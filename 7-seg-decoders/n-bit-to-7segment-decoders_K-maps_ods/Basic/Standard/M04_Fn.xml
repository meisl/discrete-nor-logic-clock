<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M04_Fn" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit

Type TFn
	which		As Variant
	arity 		As Integer
	partialArgs As Variant
End Type

Type TFnObjs
	id 		As Object
	fstArg 	As Object
	sndArg 	As Object
	swap 	As Object
	compose As Object
	ite		As Object
	asc		As Object
	add		As Object
	inRange	As Object
End Type


Sub Main
	test_Fn()
End Sub

Function newFn(name As String, arity As Integer)
	Dim result As New TFn
	result.which = name
	result.arity = arity
	newFn = result
End Function

Function mkPartialApp(fn As Object, arg As Variant)
	Dim result As New TFn
	If isPartialApp(fn) Then
		result.which = fn.which
		result.partialArgs = cons(arg, partialArgs(fn))
	Else
		result.which = fn
		result.partialArgs = cons(arg, nil)
	End If
	result.arity = arity(fn) - 1
	mkPartialApp = result
End Function

Function Fn
	Static result As Object
	If isNull(result) Then
		Set result = New TFnObjs
		result.id      	= lookupFn(&quot;id&quot;)
		result.fstArg  	= lookupFn(&quot;fstArg&quot;)
		result.sndArg  	= lookupFn(&quot;sndArg&quot;)
		result.swap    	= lookupFn(&quot;swap&quot;)
		result.compose 	= lookupFn(&quot;compose&quot;)
		result.ite 		= lookupFn(&quot;ite&quot;)
		result.asc 		= lookupFn(&quot;asc&quot;)
		result.add 		= lookupFn(&quot;add&quot;)
		result.inRange	= lookupFn(&quot;inRange&quot;)
	End If
	Fn = result
End Function

Function TFn_toString(ByVal f)
	Dim result As String, r As Integer, n As String, h As Variant, t As Object, k As Integer
	f = asFn(f)
	r = arity(f)
	n = getFnName(f)
	k = 0
	If isPartialApp(f) Then
		t = reverse(partialArgs(f))
		If n = &quot;compose&quot; Then
			If r = 1 Then
				result = &quot;\a&quot; &amp; k &amp; &quot;.&quot; &amp; TFn_toString(car(t)) &amp; &quot; (&quot; &amp; TFn_toString(cadr(t)) &amp; &quot; a&quot; &amp; k &amp; &quot;)&quot;
				
				k = k + 1
			Else &apos; r = 2
			
			End If
		Else
			result = &quot;(&quot; &amp; n &amp; &quot;_&quot; &amp; r
			While Not(isNil(t))
				h = car(t)
				t = cdr(t)
				If (isFn(h)) Then
					result = result &amp; &quot; &quot; &amp; TFn_toString(h)
				Else
					result = result &amp; &quot; &quot; &amp; toString(h)
				End If
			Wend
			result = result &amp; &quot;)&quot;
		End If
	Else
		n = car(f)
		result = n &amp; &quot;_&quot; &amp; r
	End If
	TFn_toString = result
End Function

Function fnObjs()
	Static result As Object
	If IsNull(result) Then
		result = toList(Array(_
			newFn(&quot;isString&quot;,		1), _
			newFn(&quot;toString&quot;,		1), _
			newFn(&quot;id&quot;,				1), _
			newFn(&quot;fstArg&quot;,			2), _
			newFn(&quot;sndArg&quot;,			2), _
			newFn(&quot;swap&quot;,			3), _
			newFn(&quot;compose&quot;,			3), _
			newFn(&quot;ite&quot;,				4), _
			newFn(&quot;add&quot;,				2), _
			newFn(&quot;mul&quot;,				2), _
			newFn(&quot;inRange&quot;,			3), _
			newFn(&quot;equ&quot;,				2), _
			newFn(&quot;concat&quot;,			2), _
			newFn(&quot;asc&quot;,				1), _
			newFn(&quot;chr&quot;,				1), _
			newFn(&quot;readHex&quot;,			1), _
			_
			newFn(&quot;existsF&quot;,			1), _
			newFn(&quot;arityF&quot;, 			1), _
			newFn(&quot;applyToList&quot;,		2), _
			_
			newFn(&quot;TList_toString&quot;,	1), _
			newFn(&quot;TList_equ&quot;,		2), _
			newFn(&quot;isNil&quot;,			1), _
			newFn(&quot;cons&quot;,			2), _
			newFn(&quot;car&quot;,				1), _
			newFn(&quot;cdr&quot;,				1), _
			newFn(&quot;cadr&quot;,			1), _
			newFn(&quot;caddr&quot;,			1), _
			newFn(&quot;foldl&quot;,			3), _
			newFn(&quot;foldr&quot;,			3), _
			newFn(&quot;foldl1&quot;,			2), _
			newFn(&quot;foldr1&quot;,			2), _
			newFn(&quot;map&quot;,				2), _
			newFn(&quot;filter&quot;,			2), _
			newFn(&quot;adjoin&quot;,			2), _
			newFn(&quot;flatten&quot;,			1), _
			newFn(&quot;reverse&quot;,			1), _
			_
			newFn(&quot;mkParser&quot;,		2)_
		))
	End If
	fnObjs = result
End Function

Function lookupFn(name As String) As Variant
	Dim result As Variant
	Dim fs As Object
	fs = fnObjs
	While Not(isNil(fs))
		If (getFnName(car(fs)) = name) Then
			result = car(fs)
			fs = nil
		Else
			fs = cdr(fs)
		End If
	Wend
	lookupFn = result
End Function

Function existsF(fName As String) As Boolean
	existsF = Not(isEmpty(lookupFn(fName)))
End Function

Function arityF(fName As String) As Integer
	If Not(existsF(fName)) Then
		arityF = -1
	Else
		arityF = arity(lookupFn(fName))
	End If
End Function

Function arity(fn As Object) As Integer
	arity = fn.arity
End Function

Function isFn(ByVal fn As Variant) As Boolean
	If isObject(fn) Then
		On Local Error Goto isFn_returnsFalse
		fn.which
		fn.arity
		fn.partialArgs
		isFn = True
		Exit Function
	End If
isFn_returnsFalse:
	isFn = False
End Function

Function asFn(fn As Variant, Optional ByVal msg As String)
	Dim f As Variant
	If isString(fn) Then
		f = lookupFn(fn)
		If isEmpty(f) Then
			If isMissing(msg) Then : msg = &quot;&quot; : Else : msg = msg &amp; chr(13) : End If
			croak(msg &amp; &quot;unknown function: &quot; &amp; toString(fn))
		End If
	Else
		f = fn
	End If
	If Not(isFn(f)) Then
		If isMissing(msg) Then : msg = &quot;&quot; : Else : msg = msg &amp; chr(13) : End If
		croak(msg &amp; &quot;not a valid function: &quot; &amp; toString(f))
	End If
	asFn = f
End Function

Function isPartialApp(fn As Object) As Boolean
	isPartialApp = Not(isEmpty(fn.partialArgs))
End Function

Function partialArgs(fn As Object)	&apos; ATTENTION: stored in reverse order!
	Dim result As Object
	If isPartialApp(fn) Then
		result = fn.partialArgs
	Else
		result = nil
	End If
	partialArgs = result
End Function

Function getFnName(f As Object)
	If isPartialApp(f) Then
		getFnName = getFnName(f.which)
	Else
		getFnName = f.which
	End If
End Function

Function apply1(ByVal fn As Variant, ByVal arg As Variant)
	Dim result As Variant, r As Integer
	fn = asFn(fn)	&apos; makes sure it really is a function
	r = arity(fn)
	If r &lt; 1 Then
		croak(&quot;apply1: cannot apply &quot; &amp; chr(13) &amp; &quot;  &quot; &amp; toString(fn) &amp; chr(13) &amp; &quot;arity=&quot; &amp; r)
	ElseIf r = 1 Then
		result = applyLast(fn, arg)
	Else
		result = mkPartialApp(fn, arg)
	End If
	apply1 = result
End Function

Function applyLast(fn As Object, arg As Variant)
	Dim result As Variant
	Dim reverseArgs As Object
	If isPartialApp(fn) Then
		reverseArgs = partialArgs(fn)
		fn = fn.which
	Else
		reverseArgs = nil
	End If
	Select Case getFnName(fn)
		Case &quot;id&quot;: 		result = arg
		Case &quot;fstArg&quot;:	result = car(reverseArgs)
		Case &quot;sndArg&quot;:	result = arg
		Case &quot;swap&quot;:	result = apply1( apply1(cadr(reverseArgs), arg), car(reverseArgs) )
		Case &quot;compose&quot;:	result = apply1( cadr(reverseArgs), apply1(car(reverseArgs), arg) )
		Case &quot;ite&quot;
			&apos;cond = caddr(reverseArgs)
			&apos;thn = cadr(reverseArgs)
			&apos;els = car(reverseArgs)
			If applyLast(caddr(reverseArgs), arg) Then
				result = apply1(cadr(reverseArgs), arg)
			Else
				result = apply1(car(reverseArgs), arg)
			End if
		Case &quot;asc&quot;:		result = Asc(arg)
		Case &quot;add&quot;:		result = CLng(car(reverseArgs) + arg)
		Case &quot;inRange&quot;:	result = CBool( (cadr(reverseArgs) &lt;= arg) And (arg &lt;= car(reverseArgs)) )
		Case Else
			reverseArgs = cons(arg, reverseArgs)
			result = applyBuiltinRev(fn, reverseArgs)
	End Select
	applyLast = result
End Function

Function applyBuiltinRev(fn As Object, ByVal reverseArgs As Object)
	Dim result As Variant
	Dim r As Integer, n As Integer
	r = arity(fn)
	n = length(reverseArgs)
	If (r &lt;&gt; n) Then
		croak(&quot;applyBuiltinRev: arity = &quot; &amp; r &amp; &quot; &lt;&gt; #args = &quot; &amp; n)
	End If
	&apos; Do NOT call or apply &quot;reverse&quot;!
	Dim a(0 To n - 1)
	Dim i As Integer
	For i = n - 1 To 0 Step -1
		a(i) = car(reverseArgs)
		reverseArgs = cdr(reverseArgs)
	Next i
	Select Case getFnName(fn)
		Case &quot;arityF&quot;:			result = arityF(		a(0)				)
		Case &quot;existsF&quot;:			result = existsF(		a(0)				)
		Case &quot;applyToList&quot;:		result = applyToList(	a(0), a(1)			)
		Case &quot;id&quot;:				result = id(			a(0)				)
		Case &quot;fstArg&quot;:			result = fstArg(		a(0), a(1)			)
		Case &quot;sndArg&quot;:			result = sndArg(		a(0), a(1)			)
		Case &quot;swap&quot;:			result = swap(			a(0), a(1), a(2)	)
		Case &quot;compose&quot;:			result = compose(		a(0), a(1), a(2)	)
		Case &quot;ite&quot;:				result = ite(			a(0), a(1), a(2), a(3)	)
		Case &quot;add&quot;:				result = add(			a(0), a(1)			)
		Case &quot;mul&quot;:				result = mul(			a(0), a(1)			)
		Case &quot;inRange&quot;:			
			result = _inRange(		a(0), a(1), a(2)	)
		Case &quot;equ&quot;:				result = equ(			a(0), a(1)			)
		Case &quot;concat&quot;:			result = concat(		a(0), a(1)			)
		Case &quot;asc&quot;:				result = asc(			a(0)				)
		Case &quot;chr&quot;:				result = chr(			a(0)				)
		Case &quot;readHex&quot;:			result = readHex(		a(0)				)
		Case &quot;isString&quot;:		result = isString(		a(0)				)
		Case &quot;toString&quot;:		result = toString(		a(0)				)
		Case &quot;TList_toString&quot;:	result = TList_toString(a(0)				)
		Case &quot;TList_equ&quot;:		result = TList_equ(		a(0), a(1)			)
		Case &quot;isNil&quot;:			result = isNil(			a(0)				)
		Case &quot;cons&quot;:			result = cons(			a(0), a(1)			)
		Case &quot;snoc&quot;:			result = snoc(			a(0), a(1)			)
		Case &quot;car&quot;:				result = car(			a(0)				)
		Case &quot;cdr&quot;:				result = cdr(			a(0)				)
		Case &quot;cadr&quot;:			result = cadr(			a(0)				)
		Case &quot;caddr&quot;:			result = caddr(			a(0)				)
		Case &quot;map&quot;:				result = map(			a(0), a(1)			)
		Case &quot;foldl&quot;:			result = foldl(			a(0), a(1), a(2)	)
		Case &quot;foldr&quot;:			result = foldr(			a(0), a(1), a(2)	)
		Case &quot;foldl1&quot;:			result = foldl1(		a(0), a(1)			)
		Case &quot;foldr1&quot;:			result = foldr1(		a(0), a(1)			)
		Case &quot;filter&quot;:			result = filter(		a(0), a(1)			)
		Case &quot;adjoin&quot;:			result = adjoin(		a(0), a(1)			)
		Case &quot;flatten&quot;:			result = flatten(		a(0)				)
		Case &quot;reverse&quot;:			result = reverse(		a(0)				)
		Case &quot;mkParser&quot;:		result = mkParser(		a(0), a(1)			)
		Case Else
			croak(&quot;applyBuiltinRev: unknown function &apos;&quot; &amp; car(fn) &amp; &quot;&apos;&quot;)
	End Select	
	applyBuiltinRev = result
End Function

Function applyToList(ByVal fn As Variant, ByVal args As Object)
	Dim result As Variant
	fn = asFn(fn, &quot;applyToList: invalid 1st arg&quot;)
	If isNil(args) Then
		Dim fstr As String
		fstr = toString(fn)
		croak(&quot;applyToList: empty args list for &quot; &amp; chr(13) &amp; fstr)
	Else
		result = fn
		While Not(isNil(args))
			result = apply1(result, car(args))
			args = cdr(args)
		Wend
	End If
	applyToList = result
End Function

Function _apply(fn As Object, Optional a0, Optional a1, Optional a2, Optional a3, Optional a4)
	If isMissing(a0) Then
		_apply = fn
	ElseIf isMissing(a1) Then
		_apply = apply1(fn, a0)
	ElseIf isMissing(a2) Then
		_apply = apply1(apply1(fn, a0), a1)
	ElseIf isMissing(a3) Then
		_apply = apply1(apply1(apply1(fn, a0), a1), a2)
	ElseIf isMissing(a4) Then
		_apply = apply1(apply1(apply1(apply1(fn, a0), a1), a2), a3)
	Else
		croak(&quot;_apply/NYI: more than 4 args&quot;)
	End If
End Function

Function apply(ByVal fn As Variant, a0, Optional a1, Optional a2, Optional a3, Optional a4, Optional a5, Optional a6, Optional a7, Optional a8, Optional a9, Optional a10)
	Dim args As Object
	fn = asFn(fn, &quot;apply: invalid 1st arg&quot;)
	If isMissing(a1) Then
		apply = apply1(fn, a0)
	ElseIf isMissing(a2) Then
		apply = apply1(apply1(fn, a0), a1)
	ElseIf isMissing(a3) Then
		apply = apply1(apply1(apply1(fn, a0), a1), a2)
	Else
		args = List(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
		apply = applyToList(fn, args)
	End If
End Function

&apos;= tests ============================================================


Function blaha(ByVal xs As Object)
	xs.len = 1
	xs = nil
	blaha = xs
End Function

Function test_Fn()
	Dim i As Integer
	Dim xs As Object
	xs = List(&quot;x&quot;, &quot;y&quot;)
	assertEqual(toString(blaha(xs)), &quot;[]&quot;).x
	&apos;assertEqual(toString(xs), &quot;[&apos;x&apos;, &apos;y&apos;]&quot;).x
	assertEqual(lookupFn(&quot;non-existent&quot;), Empty).x
		
	Dim fId As Variant
	fId = lookupFn(&quot;id&quot;)
	assertEqual(isPartialApp(fId), False).x
	assertEqual(arity(fId), 1).x
	assertEqual(apply(fId, 0), id(0)).x

	Dim fCar As Variant
	fCar = lookupFn(&quot;car&quot;)
	assertEqual(isPartialApp(fCar), False).x
	assertEqual(isNil(partialArgs(fCar)), True).x
	assertEqual(arity(fCar), 1).x
	
	assertEqual( apply1(fCar, List(9)), 9 ).x
	assertEqual( apply1(fCar, List(&quot;a&quot;)), &quot;a&quot; ).x
		
	Dim fEqu As Variant
	fEqu = lookupFn(&quot;equ&quot;)
	assertEqual(isPartialApp(fEqu), False).x
	assertEqual(isNil(partialArgs(fEqu)), True).x
	assertEqual(arity(fEqu), 2).x
	assertEqual(apply(fEqu, 1, 2), False).x
	assertEqual(apply(fEqu, 1, 1), True).x
	assertEqual(apply(&quot;equ&quot;, 1, 2), False).x
	assertEqual(apply(&quot;equ&quot;, 1, 1), True).x
	
	Dim eq5 As Variant
	eq5 = apply(fEqu, 5)
	assertEqual(isPartialApp(eq5), True).x
	assertEqual(isNil(partialArgs(eq5)), False).x
	assertEqual(arity(eq5), 1).x
	
	Dim eq5_7 As Variant
	eq5_7 = apply1(eq5, 7)
	assertEqual(eq5_7, False).x

	Dim eq5_5 As Variant
	eq5_5 = apply1(eq5, 5)
	assertEqual(eq5_5, True).x

	Dim konst5 As Variant
	konst5 = apply1(lookupFn(&quot;fstArg&quot;), 5)
	assertEqual(isPartialApp(konst5), True).x
	assertEqual(arity(konst5), 1).x
	assertEqual(apply1(konst5, 7), 	5).x
	&apos; easy partial application:
	assertEqual(arity(fstArg), 2).x
	konst5 = fstArg(5)
	assertEqual(arity(konst5), 1).x
	assertEqual(apply(konst5, 7), 	5).x
	assertEqual(fstArg(5, 7), 		5).x
		
	Dim sndArg5 As Variant
	sndArg5 = apply1(lookupFn(&quot;sndArg&quot;), 5)
	assertEqual(isPartialApp(sndArg5), True).x
	assertEqual(arity(sndArg5), 1).x
	assertEqual(apply1(sndArg5, 7), 7).x
	&apos; easy partial application:
	assertEqual(arity(sndArg), 2).x
	sndArg5 = sndArg(5)
	assertEqual(arity(sndArg5), 1).x
	assertEqual(apply(sndArg5, 7), 	7).x
	assertEqual(sndArg(5, 7), 		7).x
		
	Dim fIte As Variant
	fIte = lookupFn(&quot;ite&quot;)
	assertEqual(isPartialApp(fIte), False).x
	assertEqual(arity(fIte), 4).x

	Dim iteKFalse As Variant
	iteKFalse = apply1(fIte, fstArg(False))
	assertEqual(isPartialApp(iteKFalse), True).x
	assertEqual(arity(iteKFalse), 3).x

	Dim iteKFalseK42 As Variant
	iteKFalseK42 = apply1(iteKFalse, fstArg(42))
	assertEqual(isPartialApp(iteKFalseK42), True).x
	assertEqual(arity(iteKFalseK42), 2).x
	
	Dim iteKFalseK42Id As Variant
	iteKFalseK42Id = apply1(iteKFalseK42, id)
	assertEqual(arity(iteKFalseK42Id), 1).x

	assertEqual(apply(iteKFalseK42Id, &quot;Seven&quot;), &quot;Seven&quot;).x
	Dim iteKTrueK42Id As Variant, KTrue As Variant, K42 As Variant
	iteKTrueK42Id = ite(fstArg(True), fstArg(42), fId)
	assertEqual(arity(iteKTrueK42Id), 1).x
	assertEqual(apply(iteKTrueK42Id, &quot;Seven&quot;), 42).x
&apos;	MsgBox( toString(iteFalse42Seven) )

	Dim fAsc As Variant
	fAsc = lookupFn(&quot;asc&quot;)
	assertEqual(arity(fAsc), 1).x
	assertEqual(apply(fAsc, &quot; &quot;), 		Asc(&quot; &quot;)).x
	assertEqual(apply(fAsc, Chr( 9)), 	       9).x
	assertEqual(apply(fAsc, Chr(13)), 	      13).x
	assertEqual(apply(fAsc, &quot;0&quot;), 		Asc(&quot;0&quot;)).x
	assertEqual(apply(fAsc, &quot;9&quot;), 		Asc(&quot;9&quot;)).x
	assertEqual(apply(fAsc, &quot;A&quot;), 		Asc(&quot;A&quot;)).x
	assertEqual(apply(fAsc, &quot;B&quot;), 		Asc(&quot;B&quot;)).x
	assertEqual(apply(fAsc, &quot;Z&quot;), 		Asc(&quot;Z&quot;)).x

	Dim fChr As Variant
	fChr = lookupFn(&quot;chr&quot;)
	assertEqual(arity(fChr), 1).x
	assertEqual(apply(fChr,  9), 	Chr( 9)).x
	assertEqual(apply(fChr, 13), 	Chr(13)).x
	assertEqual(apply(fChr, 32), 	Chr(32)).x
	assertEqual(apply(fChr, 48), 	Chr(48)).x
	assertEqual(apply(fChr, 65), 	Chr(65)).x
	assertEqual(apply(fChr, 66), 	Chr(66)).x
	assertEqual(apply(fChr, 90), 	Chr(90)).x


	Dim fAdd As Variant
	fAdd = lookupFn(&quot;add&quot;)
	assertEqual(arity(fAdd), 2).x
	assertEqual(apply(fAdd,  0,  0), 	add(0, 0)).x
	assertEqual(apply(fAdd,  0,  1), 	add(0, 1)).x
	assertEqual(apply(fAdd,  7, -5), 	add(7, -5)).x
	&apos; partial application
	fAdd = apply(fAdd, 65535)
	assertEqual(apply(fAdd, 65535), add(65535, 65535)).x

	Dim fMul As Variant
	fMul = lookupFn(&quot;mul&quot;)
	assertEqual(arity(fMul), 2).x
	assertEqual(apply(fMul,  0,  0), 	mul(0, 0)).x
	assertEqual(apply(fMul,  0,  1), 	mul(0, 1)).x
	assertEqual(apply(fMul,  7, -5), 	mul(7, -5)).x
	&apos; partial application
	fMul = apply(fMul, 65535)
	assertEqual(apply(fMul, 32767), mul(65535, 32767)).x

	Dim fReadhex As Variant
	fReadHex = lookupFn(&quot;readHex&quot;)
	assertEqual(arity(fReadHex), 1).x
	assertEqual(apply(fReadHex,  &quot;0&quot;),  readHex(&quot;0&quot;)).x
	assertEqual(apply(fReadHex,  &quot;1&quot;),  readHex(&quot;1&quot;)).x
	assertEqual(apply(fReadHex,  &quot;2&quot;),  readHex(&quot;2&quot;)).x
	assertEqual(apply(fReadHex,  &quot;3&quot;),  readHex(&quot;3&quot;)).x
	assertEqual(apply(fReadHex,  &quot;4&quot;),  readHex(&quot;4&quot;)).x
	assertEqual(apply(fReadHex,  &quot;5&quot;),  readHex(&quot;5&quot;)).x
	assertEqual(apply(fReadHex,  &quot;6&quot;),  readHex(&quot;6&quot;)).x
	assertEqual(apply(fReadHex,  &quot;7&quot;),  readHex(&quot;7&quot;)).x
	assertEqual(apply(fReadHex,  &quot;8&quot;),  readHex(&quot;8&quot;)).x
	assertEqual(apply(fReadHex,  &quot;9&quot;),  readHex(&quot;9&quot;)).x

	assertEqual(apply(fReadHex,  &quot;A&quot;),  readHex(&quot;A&quot;)).x
	assertEqual(apply(fReadHex,  &quot;a&quot;),  readHex(&quot;a&quot;)).x

	assertEqual(apply(fReadHex,  &quot;F&quot;),  readHex(&quot;F&quot;)).x
	assertEqual(apply(fReadHex,  &quot;f&quot;),  readHex(&quot;f&quot;)).x


	assertEqual(existsF(&quot;i do not exist&quot;), False).x
	assertEqual(existsF(&quot;existsF&quot;), True).x
	assertEqual(existsF(&quot;arityF&quot;), True).x
	assertEqual(existsF(&quot;applyToList&quot;), True).x

	assertEqual(arityF(&quot;existsF&quot;), 1).x
	assertEqual(arityF(&quot;arityF&quot;), 1).x
	assertEqual(arityF(&quot;applyToList&quot;), 2).x

	assertEqual(apply(&quot;existsF&quot;, &quot;foo&quot;),         False).x
	assertEqual(apply(&quot;existsF&quot;, &quot;existsF&quot;),      True).x
	assertEqual(apply(&quot;arityF&quot;,  &quot;foo&quot;),            -1).x
	assertEqual(apply(&quot;arityF&quot;,  &quot;existsF&quot;),         1).x
	assertEqual(apply(&quot;arityF&quot;,  &quot;arityF&quot;),          1).x
	assertEqual(apply(&quot;arityF&quot;,  &quot;applyToList&quot;),     2).x

	assertEqual(apply(&quot;toString&quot;, &quot;abcd&quot;), &quot;&apos;abcd&apos;&quot;).x

End Function

</script:module>