<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M05_Parser" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit


Type Parser
	tyname As String
	tp As String
	st As Array
End Type


Sub Main
	test_Parser()
	Stop
	Dim s As String
	Dim pHexNum As Parser, pHexLit As Parser
	Set pHexNum = mkSeq(Array(pMany(pHexDigit)), &quot;readHex&quot;)
	Set pHexLit = mkSeq(Array(pStr(&quot;0x&quot;), pHexNum), &quot;snd&quot;)
	Dim p As Parser 
	&apos;pChoice(pItem(), pReturn(&quot;bar&quot;))
	Set p = pSeq(Array(pHexLit, pMany(pWhite)), &quot;fst&quot;)
	s = &quot;FF 0x1F __Âµ 0&quot;

	MsgBox( _
		&quot;applying parser &apos;&quot; &amp; p.tp &amp; &quot;&apos; to &quot; &amp; toString(s) &amp; &quot;: &quot; &amp; chr(13) _
		&amp; toString(applyP(p, s)) _
	)

End Sub

&apos;==================================================================

Function mkParser(tp As String, st As Variant)
	Dim result As New Parser
	result.tyname = &quot;TParser&quot;
	result.tp = tp
	result.st = st
	mkParser = result
End Function

&apos; always fails on any string; failure is indicated by returning parseFailure()
Function pFail()
	Static result As New Parser
	If result.tp = &quot;&quot; Then
		result = mkParser(&quot;fail&quot;, Array())
	End If
	pFail = result
End Function

Function parseFailure()
	parseFailure = nil
End Function

Function isParseFailure(parseResult) As Boolean
	If typeOf(parseResult) &lt;&gt; typeOf(parseFailure) Then
		isParseFailure = False
	Else
		isParseFailure = equ(parseResult, parseFailure)
	End If
End Function

&apos; always succeeds by returning the provided value; without increasing pos
Function pReturn(v As Variant)
	pReturn = mkParser(&quot;return&quot;, Array(v))
End Function

&apos; fails on empty string but succeeds on all others
&apos; by returning the first character; and increasing pos by 1
Function pItem()
	Static result As New Parser
	If result.tp = &quot;&quot; Then
		result = mkParser(&quot;item&quot;, Array())
	End If
	pItem = result
End Function

&apos; succeeds on strings with the given prefix t by returning t,
&apos; and advancing pos by the length of t
Function pStr(t As String)
	If (Len(t) = 0) Then
		croak(&quot;pStr: cannot match &apos;exactly&apos; the empty string t=&apos;&apos;&quot;)
	Else
		pStr = mkParser(&quot;str&quot;, Array(t))
	End If
End Function

&apos; succeeds if either p1 succeeds (then returning p1&apos;s result and pos)
&apos; or (and only if p1 fails) if p2 succeeds, returns p2&apos;s result and pos.
&apos; fails if both, p1 and p2 fail
Function pChoice(p1 As Parser, p2 As Parser)
	pChoice = mkParser(&quot;choice&quot;, Array(p1, p2))
End Function

&apos; never fails: if p fails than pZeroOrOne(p) returns nil + same pos as result,
&apos; otherwise returns a singleton list of p&apos;s result + pos
&apos; matches at most once
Function pZeroOrOne(p As Parser)
	pZeroOrOne = mkParser(&quot;zeroOrOne&quot;, Array(p))
End Function

&apos; never fails: if p fails than pMany(p) returns nil + same pos as result,
&apos; otherwise returns a *REVERSED list* of p results + last pos
&apos; matches as many as possible
Function pManyRev(p As Parser)
	pManyRev = mkParser(&quot;manyRev&quot;, Array(p))
End Function

&apos; same as pManyRev but with the list in the order as in the parsed string
Function pMany(p As Parser)
	pMany = mkParser(&quot;many&quot;, Array(p))
End Function

&apos; same as pManyRev but fails if there is no match at all
&apos; matches as many as possible
Function pMany1Rev(p As Parser)
	pMany1Rev = mkParser(&quot;many1Rev&quot;, Array(p))
End Function

&apos; same as pMany but fails if there is no match at all
&apos; matches as many as possible
Function pMany1(p As Parser)
	pMany1 = mkParser(&quot;many1&quot;, Array(p))
End Function

&apos; pSeq - make a sequence of parsers and finally process the results (list)
&apos; fails if any of the given parsers fails
&apos; if instead all succeed, collects their results in a list 
&apos; which is then passed on the the given function. The result
&apos; of this function application is then packed up with the last
&apos; parsers pos to give the overall result
Function pSeq(ps As Array, fName As String)
	Dim f As Variant
	If isString(fName) Then
		f = lookupFn(fName)
	End If
	If isEmpty(f) Then
		croak(&quot;pSeq: unknown function &quot; &amp; toString(fName))
	Else
		pSeq = mkParser(&quot;seq&quot;, Array(ps, f))
	End If
End Function

Function mkBind(fName As String, p As Parser)
	If Not existsF(fName) Then
		croak(&quot;mkBind: unknown function &quot; &amp; toString(fName))
	Else
		mkBind = mkParser(&quot;bind&quot;, Array(p, fName))
	End If
End Function



&apos;==================================================================


Function pWhite()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = pChoice(pStr(&quot; &quot;), pStr(Chr(9))
	End If
	pWhite = result
End Function

Function pBinDigit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = pChoice(pStr(&quot;0&quot;), pStr(&quot;1&quot;))
	End If
	pBinDigit = result
End Function

Function pDecDigit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = pChoice(pBinDigit,	pStr(&quot;2&quot;))
		result = pChoice(result,	pStr(&quot;3&quot;))
		result = pChoice(result,	pStr(&quot;4&quot;))
		result = pChoice(result,	pStr(&quot;5&quot;))
		result = pChoice(result,	pStr(&quot;6&quot;))
		result = pChoice(result,	pStr(&quot;7&quot;))
		result = pChoice(result,	pStr(&quot;8&quot;))
		result = pChoice(result,	pStr(&quot;9&quot;))
	End If
	pDecDigit = result
End Function

Function pHexDigit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = pChoice(pDecDigit,	pChoice(pStr(&quot;A&quot;), pStr(&quot;a&quot;)))
		result = pChoice(result,	pChoice(pStr(&quot;B&quot;), pStr(&quot;b&quot;)))
		result = pChoice(result,	pChoice(pStr(&quot;C&quot;), pStr(&quot;c&quot;)))
		result = pChoice(result,	pChoice(pStr(&quot;D&quot;), pStr(&quot;d&quot;)))
		result = pChoice(result,	pChoice(pStr(&quot;E&quot;), pStr(&quot;e&quot;)))
		result = pChoice(result,	pChoice(pStr(&quot;F&quot;), pStr(&quot;f&quot;)))
	End If
	pHexDigit = result
End Function

Function lookupParser(pName As String) As Parser
	Dim result As Parser
	Select Case pName
		Case &quot;pWhite&quot;:		result = pWhite
		Case &quot;pBinDigit&quot;:	result = pBinDigit
		Case &quot;pDecDigit&quot;:	result = pDecDigit
		Case Else
			croak(&quot;unknown parser &quot; &amp; pName)
	End Select
	lookupParser = result
End Function

&apos;==================================================================

Function parse(pName As String, s As String)
	Dim result As String
	result = toString(applyP(lookupParser(pName), s))
	if (result = &quot;Empty&quot;) then
		MsgBox(pName &amp; &quot; on &quot; &amp; tostring(s) &amp; &quot; yielded &quot; &amp; result)
	end if
	parse = result
End Function

Function applyP(ByVal parser As Variant, s As String, Optional pos As Integer)
	Dim p As Parser
	Dim fResult As Variant
	If IsNull(parser) Or IsEmpty(parser) Then
		croak(&quot;applyP: parser p = &quot; &amp; toString(parser))
	ElseIf TypeName(parser) = &quot;Object&quot; Then
		Set p = parser
	Else
		croak(&quot;applyP: invalid arg parser - &quot; &amp; toString(parser))
	End If
	If IsMissing(pos) Then
		pos = 1
	End If

	Dim result As Variant
	Dim nxtPos As Integer
	If p.tp = &quot;return&quot; Then
		result = Array(p.st(0), pos)
	ElseIf p.tp = &quot;fail&quot; Then
		result = parseFailure
	ElseIf p.tp = &quot;item&quot; Then
		If pos &lt;= Len(s) Then
			result = Array(Mid(s, pos, 1), pos + 1)
		Else
			result = parseFailure
		End If
	ElseIf p.tp = &quot;str&quot; Then
		Dim match As String
		Dim matchLen As Integer
		match = p.st(0)
		matchLen = Len(match)
		If (Mid(s, pos, matchLen) = match) Then
			result = Array(match, pos + matchLen)
		Else
			result = parseFailure
		End If
		&apos;MsgBox(&quot;str(&quot; &amp; toString(match) &amp; &quot;), s=&quot; &amp; toString(s) &amp; &quot;, pos=&quot; &amp; toString(pos) &amp; &quot;, matchLen=&quot; &amp; toString(matchLen)_
		&apos;	&amp; chr(13) &amp; &quot;~&gt;&quot; &amp; toString(result))
	ElseIf p.tp = &quot;choice&quot; Then
		result = applyP(p.st(0), s, pos)
		If isParseFailure(result) Then
			result = applyP(p.st(1), s, pos)
		End If
	ElseIf p.tp = &quot;zeroOrOne&quot; Then
		result = applyP(p.st(0), s, pos)
		If isParseFailure(result) Then
			result = Array(nil, pos)
		Else
			result = Array(List(result(0)), result(1))
		End If
	ElseIf (p.tp = &quot;manyRev&quot;) Or (p.tp = &quot;many1Rev&quot;) Then
		Dim lst As Object
		Dim lstLen As Integer
		nxtPos = pos
		lstLen = 0
		Set lst = nil
		result = applyP(p.st(0), s, nxtPos)
		While Not(isParseFailure(result))
			nxtPos = result(1)
			Set lst = cons(result(0), lst)
			lstLen = lstLen + 1
			result = applyP(p.st(0), s, nxtPos)
		Wend
		If (p.tp = &quot;many1Rev&quot;) And isNil(lst) Then
			result = parseFailure
		Else
			result = Array(lst, nxtPos)
		End If
	ElseIf p.tp = &quot;many&quot; Then
		result = applyP(pManyRev(p.st(0)), s, pos)
		result(0) = toArray(reverse(result(0)))
	ElseIf p.tp = &quot;many1&quot; Then
		result = applyP(pMany1Rev(p.st(0)), s, pos)
		result(0) = reverse(result(0))
	ElseIf p.tp = &quot;bind&quot; Then
		result = applyP(p.st(0), s, pos)
		If Not isParseFailure(result) Then
			fResult = applyToList(p.st(1), toList(result(0)))
			result(0) = fResult
		End If
	ElseIf p.tp = &quot;seq&quot; Then
		Dim innerParsers As Variant, t As Variant
		Dim i As Integer, j As Integer, k As Integer
		innerParsers = p.st(0)
		i = LBound(innerParsers)
		k = UBound(innerParsers)
		j = 0
		nxtPos = pos
		Dim iResults(0 To k-i) As Variant
		Do
			t = applyP(innerParsers(i), s, nxtPos)
			If Not isParseFailure(t) Then
				iResults(j) = t(0)
				nxtPos = t(1)
				i = i + 1
				j = j + 1
			End If
		Loop Until (i &gt; k) Or isParseFailure(t)
		If isParseFailure(t) Then
			result = t
		Else
			fResult = applyToList(p.st(1), toList(iResults))
			&apos; ATTENTION: do not reuse t, type of result value may not match
			&apos;            and an implicit conversion might happen!
			result = Array(fResult, t(1))
		End If
		&apos;MsgBox(&quot;seq/&quot; &amp; p.st(1) &amp; &quot;: &quot; &amp; toString(result))
	Else
		result = &quot;unknown Parser &apos;&quot; &amp; p.tp &amp; &quot;&apos;&quot;
		MsgBox(&quot;Error in applyP: &quot; &amp; result)
	End If
	applyP = result
End Function


&apos;= tests ============================================================

Function test_Parser()
	Dim tm As Date
	tm = TimeValue(Time)
	test_Parser_fail()
	test_Parser_item()
	test_Parser_return()
	test_Parser_str()
	test_Parser_choice()
	test_Parser_zeroOrOne()
	test_Parser_white()
	test_Parser_binDigit()
	test_Parser_decDigit()
	test_Parser_hexDigit()
	test_Parser_manyRev()
	test_Parser_many()
	test_Parser_many1Rev()
	test_Parser_many1()

	test_Parser_seq()
	
	tm = TimeValue(Time) - tm
	MsgBox(TimeSerial(Hour(tm), Minute(tm), Second(tm)))
End Function

Function assert_parse(ByVal p As Variant, ByVal ss As Variant, ByVal expected As Variant)
	If isString(p) Then
		p = lookupParser(p)
	End If
	If Not(isString(expected)) Then
		expected = toString(expected)
	End If
	assertEqual(typeOf(p), &quot;Object/TParser&quot;).x
	Dim actual As Variant, result As Variant
	
	If isArray(ss) Then
		Dim i As Integer
		For i = LBound(ss) To UBound(ss)
			actual = applyP(p, ss(i))
			result = assertEqual(toString(actual), expected)
			If result.isFail Then 
				MsgBox(&quot;at index &quot; &amp; i &amp; &quot;: &quot; &amp; toString(ss(i)))
				Exit For
			End If
		Next i
	Else
		actual = applyP(p, ss)
		result = assertEqual(toString(actual), expected)
	End If
	assert_parse = result
End Function

Function test_Parser_fail()
	assert_parse(pFail, &quot;&quot;,		parseFailure).x
	assert_parse(pFail, &quot; &quot;,	parseFailure).x
	assert_parse(pFail, &quot;a&quot;,	parseFailure).x
	assert_parse(pFail, &quot;1&quot;,	parseFailure).x
	assert_parse(pFail, &quot;[]&quot;,	parseFailure).x
End Function

Function test_Parser_item()
	assert_parse(pItem, &quot;&quot;,			parseFailure).x
	assert_parse(pItem, &quot; &quot;,		Array(&quot; &quot;, 2)).x
	assert_parse(pItem, &quot;a&quot;,		Array(&quot;a&quot;, 2)).x
	assert_parse(pItem, &quot;1&quot;,		Array(&quot;1&quot;, 2)).x
	assert_parse(pItem, &quot;[]&quot;,		Array(&quot;[&quot;, 2)).x
	assert_parse(pItem, &quot;abcd&quot;,		Array(&quot;a&quot;, 2)).x
	assert_parse(pItem, chr(13),	Array(chr(13), 2)).x
End Function

Function test_Parser_return()
	Dim p As Parser
	Dim expected As Variant

	p = pReturn(&quot;bar&quot;)
	expected = Array(&quot;bar&quot;, 1)
	assert_parse(p, &quot;&quot;,			expected).x
	assert_parse(p, &quot; &quot;,		expected).x
	assert_parse(p, &quot;a&quot;,		expected).x
	assert_parse(p, &quot;1&quot;,		expected).x
	assert_parse(p, &quot;[]&quot;,		expected).x
	assert_parse(p, &quot;abcd&quot;,		expected).x
	assert_parse(p, chr(13),	expected).x

	p = pReturn(4711)	
	expected = Array(4711, 1)
	assert_parse(p, &quot;&quot;,			expected).x
	assert_parse(p, &quot; &quot;,		expected).x
	assert_parse(p, &quot;a&quot;,		expected).x
	assert_parse(p, &quot;1&quot;,		expected).x
	assert_parse(p, &quot;[]&quot;,		expected).x
	assert_parse(p, &quot;abcd&quot;,		expected).x
	assert_parse(p, chr(13),	expected).x
End Function

Function test_Parser_str()
	Dim p As Parser

&apos;	assertThrows(pStr, Array(&quot;&quot;)).x

	p = pStr(&quot;bar&quot;)
	assert_parse(p, &quot;&quot;,				parseFailure).x
	assert_parse(p, &quot; &quot;,			parseFailure).x
	assert_parse(p, &quot; &quot; &amp; chr(13),	parseFailure).x
	assert_parse(p, &quot;asdf&quot;,			parseFailure).x
	assert_parse(p, &quot; bar&quot;,			parseFailure).x
	assert_parse(p, &quot;b&quot;,			parseFailure).x
	assert_parse(p, &quot;ba&quot;,			parseFailure).x
	assert_parse(p, &quot;bar&quot;,			Array(&quot;bar&quot;, 4)).x
	assert_parse(p, &quot;barb&quot;,			Array(&quot;bar&quot;, 4)).x
	assert_parse(p, &quot;barba&quot;,		Array(&quot;bar&quot;, 4)).x
	assert_parse(p, &quot;barbar&quot;,		Array(&quot;bar&quot;, 4)).x

	p = pStr(chr(13))
	assert_parse(p, &quot;&quot;,				parseFailure).x
	assert_parse(p, &quot; &quot;,			parseFailure).x
	assert_parse(p, &quot; &quot; &amp; chr(13),	parseFailure).x
	assert_parse(p, &quot;asdf&quot;,			parseFailure).x
	assert_parse(p, &quot; bar&quot;,			parseFailure).x
	assert_parse(p, &quot;b&quot;,			parseFailure).x
	assert_parse(p, &quot;ba&quot;,			parseFailure).x
	assert_parse(p, &quot;bar&quot;,			parseFailure).x
	assert_parse(p, &quot;barb&quot;,			parseFailure).x
	assert_parse(p, &quot;barba&quot;,		parseFailure).x
	assert_parse(p, &quot;barbar&quot;,		parseFailure).x
	assert_parse(p, chr(13),					Array(&quot;\n&quot;, 2)).x
	assert_parse(p, chr(13) &amp; &quot;bar&quot;,			Array(&quot;\n&quot;, 2)).x
	assert_parse(p, chr(13) &amp; chr(13),			Array(&quot;\n&quot;, 2)).x
	assert_parse(p, chr(13) &amp; chr(13) &amp; &quot;bar&quot;,	Array(&quot;\n&quot;, 2)).x
End Function

Function test_Parser_choice()
	Dim p As Parser
	Dim data As Variant
	Dim expected As Variant
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	p = pChoice(pFail, pFail)
	assert_parse(p, data, parseFailure).x
	
	p = pChoice(pReturn(7), pFail)
	expected = Array(7, 1)
	assert_parse(p, data, expected).x
	
	p = pChoice(pFail, pReturn(7))
	expected = Array(7, 1)
	assert_parse(p, data, expected).x
	
	p = pChoice(pReturn(42), pReturn(7))
	expected = Array(42, 1)
	assert_parse(p, data, expected).x
	
	assert_parse(pChoice(pItem, pReturn(11)), 	&quot;&quot;, Array(11, 1)).x
	assert_parse(pChoice(pItem, pStr(&quot;x&quot;)), 	&quot;&quot;, parseFailure).x
	assert_parse(pChoice(pReturn(11), pItem), 	&quot;&quot;, Array(11, 1)).x
	assert_parse(pChoice(pStr(&quot;x&quot;), pItem), 	&quot;&quot;, parseFailure).x
	
	assert_parse(pChoice(pItem, pReturn(11)), 	&quot; &quot;, Array(&quot; &quot;, 2)).x
	assert_parse(pChoice(pItem, pStr(&quot;x&quot;)), 	&quot; &quot;, Array(&quot; &quot;, 2)).x
	assert_parse(pChoice(pReturn(11), pItem), 	&quot; &quot;, Array(11, 1)).x
	assert_parse(pChoice(pStr(&quot;x&quot;), pItem), 	&quot; &quot;, Array(&quot; &quot;, 2)).x
	
	assert_parse(pChoice(pItem, pReturn(11)), 	&quot;x&quot;, Array(&quot;x&quot;, 2)).x
	assert_parse(pChoice(pItem, pStr(&quot;x&quot;)), 	&quot;x&quot;, Array(&quot;x&quot;, 2)).x
	assert_parse(pChoice(pReturn(11), pItem), 	&quot;x&quot;, Array(11, 1)).x
	assert_parse(pChoice(pStr(&quot;x&quot;), pItem), 	&quot;x&quot;, Array(&quot;x&quot;, 2)).x
End Function


Function test_Parser_zeroOrOne()
	Dim p As Parser
	Dim data As Variant
	Dim zeroMatches As Variant, oneMatch As Variant
	zeroMatches = Array(nil, 1)
	oneMatch    = Array(List(&quot;x&quot;), 2)
		
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)

	p = pZeroOrOne(pStr(&quot;x&quot;))

	assert_parse(p, data,	zeroMatches).x
	assert_parse(p, &quot;x&quot;, 	oneMatch).x
	assert_parse(p, &quot;xx&quot;, 	oneMatch).x
	assert_parse(p, &quot;xxx&quot;, 	oneMatch).x
	assert_parse(p, &quot; x&quot;, 	zeroMatches).x
	assert_parse(p, &quot; xx&quot;, 	zeroMatches).x
	assert_parse(p, &quot; xxx&quot;,	zeroMatches).x
End Function

Function test_Parser_white()
	Dim p As Parser
	p = pWhite

	assert_parse(p, &quot;&quot;, 						parseFailure).x
	assert_parse(p, &quot; &quot;, 						Array(&quot; &quot;, 2)).x
	assert_parse(p, chr(9), 					Array(&quot;\t&quot;, 2)).x
	assert_parse(p, chr(13), 					parseFailure).x
	assert_parse(p, &quot;asdf&quot;,						parseFailure).x
	assert_parse(p, &quot; asdf&quot;, 					Array(&quot; &quot;, 2)).x
	assert_parse(p, chr(9) &amp; &quot;asdf&quot;, 			Array(&quot;\t&quot;, 2)).x
	assert_parse(p, chr(13) &amp; &quot;asdf&quot;, 			parseFailure).x
	assert_parse(p, &quot;  asdf&quot;, 					Array(&quot; &quot;, 2)).x
	assert_parse(p, chr(9) &amp; chr(9) &amp; &quot;asdf&quot;, 	Array(&quot;\t&quot;, 2)).x
	assert_parse(p, chr(13) &amp; chr(9) &amp; &quot;asdf&quot;, 	parseFailure).x
	assert_parse(p, chr(9) &amp; chr(13) &amp; &quot;asdf&quot;, 	Array(&quot;\t&quot;, 2)).x
	assert_parse(p, chr(13) &amp; chr(13) &amp; &quot;asdf&quot;, parseFailure).x
End Function

Function test_Parser_binDigit()
	Dim p As Parser
	p = pBinDigit

	assert_parse(p, &quot;&quot;, 						parseFailure).x
	assert_parse(p, &quot; &quot;, 						parseFailure).x
	assert_parse(p, &quot;sadf&quot;,						parseFailure).x
	assert_parse(p, &quot;0sadf&quot;, 					Array(&quot;0&quot;, 2)).x
	assert_parse(p, &quot;1sadf&quot;, 					Array(&quot;1&quot;, 2)).x
	assert_parse(p, &quot;2sadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;3sadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;4sadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;5sadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;6sadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;7sadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;8sadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;9sadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;Asadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;asadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;Bsadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;bsadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;Csadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;csadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;Dsadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;dsadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;Esadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;esadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;Fsadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;fsadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;Gsadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;gsadf&quot;, 					parseFailure).x
End Function

Function test_Parser_decDigit()
	Dim p As Parser
	p = pDecDigit

	assert_parse(p, &quot;&quot;, 						parseFailure).x
	assert_parse(p, &quot; &quot;, 						parseFailure).x
	assert_parse(p, &quot;sadf&quot;,						parseFailure).x
	assert_parse(p, &quot;0sadf&quot;, 					Array(&quot;0&quot;, 2)).x
	assert_parse(p, &quot;1sadf&quot;, 					Array(&quot;1&quot;, 2)).x
	assert_parse(p, &quot;2sadf&quot;, 					Array(&quot;2&quot;, 2)).x
	assert_parse(p, &quot;3sadf&quot;, 					Array(&quot;3&quot;, 2)).x
	assert_parse(p, &quot;4sadf&quot;, 					Array(&quot;4&quot;, 2)).x
	assert_parse(p, &quot;5sadf&quot;, 					Array(&quot;5&quot;, 2)).x
	assert_parse(p, &quot;6sadf&quot;, 					Array(&quot;6&quot;, 2)).x
	assert_parse(p, &quot;7sadf&quot;, 					Array(&quot;7&quot;, 2)).x
	assert_parse(p, &quot;8sadf&quot;, 					Array(&quot;8&quot;, 2)).x
	assert_parse(p, &quot;9sadf&quot;, 					Array(&quot;9&quot;, 2)).x
	assert_parse(p, &quot;Asadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;asadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;Bsadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;bsadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;Csadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;csadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;Dsadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;dsadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;Esadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;esadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;Fsadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;fsadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;Gsadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;gsadf&quot;, 					parseFailure).x
End Function

Function test_Parser_hexDigit()
	Dim p As Parser
	p = pHexDigit

	assert_parse(p, &quot;&quot;, 						parseFailure).x
	assert_parse(p, &quot; &quot;, 						parseFailure).x
	assert_parse(p, &quot;sadf&quot;,						parseFailure).x
	assert_parse(p, &quot;0sadf&quot;, 					Array(&quot;0&quot;, 2)).x
	assert_parse(p, &quot;1sadf&quot;, 					Array(&quot;1&quot;, 2)).x
	assert_parse(p, &quot;2sadf&quot;, 					Array(&quot;2&quot;, 2)).x
	assert_parse(p, &quot;3sadf&quot;, 					Array(&quot;3&quot;, 2)).x
	assert_parse(p, &quot;4sadf&quot;, 					Array(&quot;4&quot;, 2)).x
	assert_parse(p, &quot;5sadf&quot;, 					Array(&quot;5&quot;, 2)).x
	assert_parse(p, &quot;6sadf&quot;, 					Array(&quot;6&quot;, 2)).x
	assert_parse(p, &quot;7sadf&quot;, 					Array(&quot;7&quot;, 2)).x
	assert_parse(p, &quot;8sadf&quot;, 					Array(&quot;8&quot;, 2)).x
	assert_parse(p, &quot;9sadf&quot;, 					Array(&quot;9&quot;, 2)).x
	assert_parse(p, &quot;Asadf&quot;, 					Array(&quot;A&quot;, 2)).x
	assert_parse(p, &quot;asadf&quot;, 					Array(&quot;a&quot;, 2)).x
	assert_parse(p, &quot;Bsadf&quot;, 					Array(&quot;B&quot;, 2)).x
	assert_parse(p, &quot;bsadf&quot;, 					Array(&quot;b&quot;, 2)).x
	assert_parse(p, &quot;Csadf&quot;, 					Array(&quot;C&quot;, 2)).x
	assert_parse(p, &quot;csadf&quot;, 					Array(&quot;c&quot;, 2)).x
	assert_parse(p, &quot;Dsadf&quot;, 					Array(&quot;D&quot;, 2)).x
	assert_parse(p, &quot;dsadf&quot;, 					Array(&quot;d&quot;, 2)).x
	assert_parse(p, &quot;Esadf&quot;, 					Array(&quot;E&quot;, 2)).x
	assert_parse(p, &quot;esadf&quot;, 					Array(&quot;e&quot;, 2)).x
	assert_parse(p, &quot;Fsadf&quot;, 					Array(&quot;F&quot;, 2)).x
	assert_parse(p, &quot;fsadf&quot;, 					Array(&quot;f&quot;, 2)).x
	assert_parse(p, &quot;Gsadf&quot;, 					parseFailure).x
	assert_parse(p, &quot;gsadf&quot;, 					parseFailure).x
End Function


Function test_Parser_manyRev()
	Dim p As Parser
	Dim data As Variant
	Dim zeroMatches As Variant
	zeroMatches = Array(nil, 1)
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	p = pManyRev(pFail)
	assert_parse(p, data, zeroMatches).x
	
	&apos;p = pMany(pReturn(3)) - yields infite sequence of 3s, even on empty string
	
	p = pManyRev(pItem)
	assert_parse(p, &quot;&quot;, 			zeroMatches).x
	assert_parse(p, &quot; &quot;, 			Array(List(&quot; &quot;), 2)).x
	assert_parse(p, &quot; &quot; &amp; chr(13),	Array(List(&quot;\n&quot;, &quot; &quot;), 3)).x
	assert_parse(p, &quot;asdf&quot;,			Array(List(&quot;f&quot;, &quot;d&quot;, &quot;s&quot;, &quot;a&quot;), 5)).x
	
	p = pManyRev(pStr(&quot; &quot;))
	assert_parse(p, &quot;&quot;, 			zeroMatches).x
	assert_parse(p, &quot; &quot;, 			Array(List(&quot; &quot;), 2)).x
	assert_parse(p, &quot; &quot; &amp; chr(13),	Array(List(&quot; &quot;), 2)).x
	assert_parse(p, &quot;asdf&quot;,			zeroMatches).x
	assert_parse(p, &quot;  &quot;,			Array(List(&quot; &quot;, &quot; &quot;), 3)).x
	assert_parse(p, &quot;   &quot;,			Array(List(&quot; &quot;, &quot; &quot;, &quot; &quot;), 4)).x
	assert_parse(p, &quot; x &quot;,			Array(List(&quot; &quot;), 2)).x
	assert_parse(p, &quot; x  &quot;,			Array(List(&quot; &quot;), 2)).x
	assert_parse(p, &quot;  x &quot;,			Array(List(&quot; &quot;, &quot; &quot;), 3)).x
	
	p = pManyRev(pDecDigit)
	assert_parse(p, &quot;&quot;, 			zeroMatches).x
	assert_parse(p, &quot; &quot;, 			zeroMatches).x
	assert_parse(p, &quot;1&quot;, 			Array(List(&quot;1&quot;), 2)).x
	assert_parse(p, &quot;12 &quot;, 			Array(List(&quot;2&quot;, &quot;1&quot;), 3)).x
	assert_parse(p, &quot;12345&quot;, 		Array(List(&quot;5&quot;, &quot;4&quot;, &quot;3&quot;, &quot;2&quot;, &quot;1&quot;), 6)).x
End Function

Function test_Parser_many()
	Dim p As Parser
	Dim data As Variant
	Dim zeroMatches As Variant
	zeroMatches = Array(Array(), 1)
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	p = pMany(pFail)
	assert_parse(p, data, zeroMatches).x
	
	&apos;p = pMany(pReturn(3)) - yields infite sequence of 3s, even on empty string
	
	p = pMany(pItem)
	assert_parse(p, &quot;&quot;, 			zeroMatches).x
	assert_parse(p, &quot; &quot;, 			Array(Array(&quot; &quot;), 2)).x
	assert_parse(p, &quot; &quot; &amp; chr(13),	Array(Array(&quot; &quot;, &quot;\n&quot;), 3)).x
	assert_parse(p, &quot;asdf&quot;,			Array(Array(&quot;a&quot;, &quot;s&quot;, &quot;d&quot;, &quot;f&quot;), 5)).x
	
	p = pMany(pStr(&quot; &quot;))
	assert_parse(p, &quot;&quot;, 			zeroMatches).x
	assert_parse(p, &quot; &quot;, 			Array(Array(&quot; &quot;), 2)).x
	assert_parse(p, &quot; &quot; &amp; chr(13),	Array(Array(&quot; &quot;), 2)).x
	assert_parse(p, &quot;asdf&quot;,			zeroMatches).x
	assert_parse(p, &quot;  &quot;,			Array(Array(&quot; &quot;, &quot; &quot;), 3)).x
	assert_parse(p, &quot;   &quot;,			Array(Array(&quot; &quot;, &quot; &quot;, &quot; &quot;), 4)).x
	assert_parse(p, &quot; x &quot;,			Array(Array(&quot; &quot;), 2)).x
	assert_parse(p, &quot; x  &quot;,			Array(Array(&quot; &quot;), 2)).x
	assert_parse(p, &quot;  x &quot;,			Array(Array(&quot; &quot;, &quot; &quot;), 3)).x
	
	p = pMany(pDecDigit)
	assert_parse(p, &quot;&quot;, 			zeroMatches).x
	assert_parse(p, &quot; &quot;, 			zeroMatches).x
	assert_parse(p, &quot;1&quot;, 			Array(Array(&quot;1&quot;), 2)).x
	assert_parse(p, &quot;12 &quot;, 			Array(Array(&quot;1&quot;, &quot;2&quot;), 3)).x
	assert_parse(p, &quot;12345&quot;, 		Array(Array(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;), 6)).x
End Function


Function test_Parser_many1Rev()
	Dim p As Parser
	Dim data As Variant
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	p = pMany1Rev(pFail)
	assert_parse(p, data, parseFailure).x
	
	&apos;p = pMany1(pReturn(3)) - yields infite sequence of 3s, except on empty string
	
	p = pMany1Rev(pItem)
	assert_parse(p, &quot;&quot;, 			parseFailure).x
	assert_parse(p, &quot; &quot;, 			Array(List(&quot; &quot;), 2)).x
	assert_parse(p, &quot; &quot; &amp; chr(13),	Array(List(&quot;\n&quot;, &quot; &quot;), 3)).x
	assert_parse(p, &quot;asdf&quot;,			Array(List(&quot;f&quot;, &quot;d&quot;, &quot;s&quot;, &quot;a&quot;), 5)).x
	
	p = pMany1Rev(pStr(&quot; &quot;))
	assert_parse(p, &quot;&quot;, 			parseFailure).x
	assert_parse(p, &quot; &quot;, 			Array(List(&quot; &quot;), 2)).x
	assert_parse(p, &quot; &quot; &amp; chr(13),	Array(List(&quot; &quot;), 2)).x
	assert_parse(p, &quot;asdf&quot;,			parseFailure).x
	assert_parse(p, &quot;  &quot;,			Array(List(&quot; &quot;, &quot; &quot;), 3)).x
	assert_parse(p, &quot;   &quot;,			Array(List(&quot; &quot;, &quot; &quot;, &quot; &quot;), 4)).x
	assert_parse(p, &quot; x &quot;,			Array(List(&quot; &quot;), 2)).x
	assert_parse(p, &quot; x  &quot;,			Array(List(&quot; &quot;), 2)).x
	assert_parse(p, &quot;  x &quot;,			Array(List(&quot; &quot;, &quot; &quot;), 3)).x
	
	p = pMany1Rev(pDecDigit)
	assert_parse(p, &quot;&quot;, 			parseFailure).x
	assert_parse(p, &quot; &quot;, 			parseFailure).x
	assert_parse(p, &quot;1&quot;, 			Array(List(&quot;1&quot;), 2)).x
	assert_parse(p, &quot;12 &quot;, 			Array(List(&quot;2&quot;, &quot;1&quot;), 3)).x
	assert_parse(p, &quot;12345&quot;, 		Array(List(&quot;5&quot;, &quot;4&quot;, &quot;3&quot;, &quot;2&quot;, &quot;1&quot;), 6)).x
End Function

Function test_Parser_many1()
	Dim p As Parser
	Dim data As Variant
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	p = pMany1(pFail)
	assert_parse(p, data, parseFailure).x
	
	&apos;p = pMany1(pReturn(3)) - yields infite sequence of 3s, except on empty string
	
	p = pMany1(pItem)
	assert_parse(p, &quot;&quot;, 			parseFailure).x
	assert_parse(p, &quot; &quot;, 			Array(List(&quot; &quot;), 2)).x
	assert_parse(p, &quot; &quot; &amp; chr(13),	Array(List(&quot; &quot;, &quot;\n&quot;), 3)).x
	assert_parse(p, &quot;asdf&quot;,			Array(List(&quot;a&quot;, &quot;s&quot;, &quot;d&quot;, &quot;f&quot;), 5)).x
	
	p = pMany1(pStr(&quot; &quot;))
	assert_parse(p, &quot;&quot;, 			parseFailure).x
	assert_parse(p, &quot; &quot;, 			Array(List(&quot; &quot;), 2)).x
	assert_parse(p, &quot; &quot; &amp; chr(13),	Array(List(&quot; &quot;), 2)).x
	assert_parse(p, &quot;asdf&quot;,			parseFailure).x
	assert_parse(p, &quot;  &quot;,			Array(List(&quot; &quot;, &quot; &quot;), 3)).x
	assert_parse(p, &quot;   &quot;,			Array(List(&quot; &quot;, &quot; &quot;, &quot; &quot;), 4)).x
	assert_parse(p, &quot; x &quot;,			Array(List(&quot; &quot;), 2)).x
	assert_parse(p, &quot; x  &quot;,			Array(List(&quot; &quot;), 2)).x
	assert_parse(p, &quot;  x &quot;,			Array(List(&quot; &quot;, &quot; &quot;), 3)).x
	
	p = pMany1(pDecDigit)
	assert_parse(p, &quot;&quot;, 			parseFailure).x
	assert_parse(p, &quot; &quot;, 			parseFailure).x
	assert_parse(p, &quot;1&quot;, 			Array(List(&quot;1&quot;), 2)).x
	assert_parse(p, &quot;12 &quot;, 			Array(List(&quot;1&quot;, &quot;2&quot;), 3)).x
	assert_parse(p, &quot;12345&quot;, 		Array(List(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;), 6)).x
End Function

Function test_Parser_seq()
	Dim p As Parser, f As Variant
	Dim data As Variant
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	f = &quot;asc&quot;
	p = pSeq(Array(pFail), f)
	assert_parse(p, data, parseFailure).x
	
	f = &quot;asc&quot;
	p = pSeq(Array(pItem), f)
	assert_parse(p, &quot;&quot;, 	parseFailure).x
	assert_parse(p, &quot;0&quot;, 	Array(asc(&quot;0&quot;), 2)).x
	assert_parse(p, &quot;1&quot;, 	Array(asc(&quot;1&quot;), 2)).x
	assert_parse(p, &quot;A&quot;, 	Array(asc(&quot;A&quot;), 2)).x
	assert_parse(p, &quot;B&quot;, 	Array(asc(&quot;B&quot;), 2)).x
	assert_parse(p, &quot;AB&quot;,	Array(asc(&quot;A&quot;), 2)).x
	assert_parse(p, &quot;BA&quot;,	Array(asc(&quot;B&quot;), 2)).x
	
	f = &quot;concat&quot;
	p = pSeq(Array(pItem, pItem), f)
	assert_parse(p, &quot;&quot;, 	parseFailure).x
	assert_parse(p, &quot;A&quot;, 	parseFailure).x
	assert_parse(p, &quot;B&quot;, 	parseFailure).x
	assert_parse(p, &quot;AB&quot;,	Array(&quot;AB&quot;, 3)).x
	assert_parse(p, &quot;BA&quot;,	Array(&quot;BA&quot;, 3)).x
	
	p = pSeq(Array(pDecDigit, pDecDigit), f)
	assert_parse(p, &quot;&quot;, 	parseFailure).x
	assert_parse(p, &quot;A&quot;, 	parseFailure).x
	assert_parse(p, &quot;B&quot;, 	parseFailure).x
	assert_parse(p, &quot;AB&quot;,	parseFailure).x
	assert_parse(p, &quot;BA&quot;,	parseFailure).x
	assert_parse(p, &quot;0B&quot;,	parseFailure).x		&apos; *ALL* in sequence must succeed!
	assert_parse(p, &quot;1A&quot;,	parseFailure).x		&apos; *ALL* in sequence must succeed!
	assert_parse(p, &quot;01&quot;,	Array(&quot;01&quot;, 3)).x
	assert_parse(p, &quot;10&quot;,	Array(&quot;10&quot;, 3)).x
	
	f = &quot;asc&quot;
	p = pSeq(Array(pDecDigit), f)
	assert_parse(p, &quot;&quot;, 			parseFailure).x
	assert_parse(p, &quot;A&quot;, 			parseFailure).x
	assert_parse(p, &quot;B&quot;, 			parseFailure).x
	assert_parse(p, &quot;AB&quot;,			parseFailure).x
	assert_parse(p, &quot;BA&quot;,			parseFailure).x
	assert_parse(p, &quot;0&quot;, 			Array(48, 2)).x
	assert_parse(p, &quot;1&quot;, 			Array(49, 2)).x
	assert_parse(p, &quot;123456789&quot;,	Array(49, 2)).x
	
	p = pMany1(pSeq(Array(pDecDigit), f))
	assert_parse(p, &quot;&quot;, 			parseFailure).x
	assert_parse(p, &quot;A&quot;, 			parseFailure).x
	assert_parse(p, &quot;B&quot;, 			parseFailure).x
	assert_parse(p, &quot;AB&quot;,			parseFailure).x
	assert_parse(p, &quot;BA&quot;,			parseFailure).x
	assert_parse(p, &quot;0&quot;, 			Array(List(48), 2)).x
	assert_parse(p, &quot;1&quot;, 			Array(List(49), 2)).x
	assert_parse(p, &quot;123456789&quot;,	Array(List(49, 50, 51, 52, 53, 54, 55, 56, 57), 10)).x
	assert_parse(p, &quot;123456789 0&quot;,	Array(List(49, 50, 51, 52, 53, 54, 55, 56, 57), 10)).x
End Function


</script:module>