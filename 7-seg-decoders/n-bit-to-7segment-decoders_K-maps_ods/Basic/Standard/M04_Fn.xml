<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M04_Fn" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit

Const TFn_tyname = &quot;TFn&quot;
Type TFn
	tyname		As String
	str			As Variant
	which		As Variant
	arity 		As Integer
	partialArgs As Variant
	args		As Variant
End Type

Type TFnObjs
	id 			As Object
	fstArg 		As Object
	sndArg 		As Object
	swap 		As Object
	compose 	As Object
	ite			As Object
	asc			As Object
	chr			As Object
	ucase		As Object
	lcase		As Object
	add			As Object
	mul			As Object
	isString	As Object
	isEmpty		As Object
	toString	As Object
	concat		As Object
	readHex		As Object
	equ			As Object
	neq			As Object
	inRange		As Object
	
	TFn_toString	As Object
	applyToList		As Object

	isList		As Object
	isNil		As Object
	cons		As Object
	length		As Object
	car			As Object
	cdr			As Object
	cadr		As Object
	caddr		As Object
	map			As Object
	filter		As Object
	skipWhile	As Object
	skipUntil	As Object
	foldl		As Object
	foldr		As Object
	foldl1		As Object
&apos;	foldr1		As Object
	adjoin		As Object
	flatten 	As Object
	reverse 	As Object
	
	TParser_toString	As Object
	mkParser 			As Object
	pReturn				As Object
	pStr				As Object
	pBind				As Object
	pChoice				As Object
	pMany				As Object
	pMany1				As Object
	pZeroOrOne			As Object
	pZeroOrOne2			As Object
	mkTypeVar			As Object
	maybeMakeArrowType	As Object
	mkTypeCtor			As Object
	mkTupleType			As Object
	
	TASN_dot			As Object
	TASN_toString		As Object
	mkASN				As Object
	mkDtTerminal		As Object
	mkDtCClass			As Object
	mkDtNonterminal		As Object
	mkDtMult			As Object
	
	isPattern			As Object
	TPattern_toString	As Object
	matches				As Object
End Type


Sub Main
	test_Fn()
End Sub


Function Fn
	Static result As Object
	If isNull(result) Then
		Set result = New TFnObjs
		result.id      	= lookupFn(&quot;id&quot;)
		result.fstArg  	= lookupFn(&quot;fstArg&quot;)
		result.sndArg  	= lookupFn(&quot;sndArg&quot;)
		result.swap    	= lookupFn(&quot;swap&quot;)
		result.compose 	= lookupFn(&quot;compose&quot;)
		result.ite 		= lookupFn(&quot;ite&quot;)
		result.asc 		= lookupFn(&quot;asc&quot;)
		result.chr 		= lookupFn(&quot;chr&quot;)
		result.ucase	= lookupFn(&quot;ucase&quot;)
		result.lcase	= lookupFn(&quot;lcase&quot;)
		result.add 		= lookupFn(&quot;add&quot;)
		result.mul 		= lookupFn(&quot;mul&quot;)
		result.isString	= lookupFn(&quot;isString&quot;)
		result.isEmpty	= lookupFn(&quot;isEmpty&quot;)
		result.toString = lookupFn(&quot;toString&quot;)
		result.concat	= lookupFn(&quot;concat&quot;)
		result.readHex	= lookupFn(&quot;readHex&quot;)
		result.equ		= lookupFn(&quot;equ&quot;)
		result.neq		= lookupFn(&quot;neq&quot;)
		result.inRange	= lookupFn(&quot;inRange&quot;)
		
		result.TFn_toString = lookupFn(&quot;TFn_toString&quot;)
		result.applyToList 	= lookupFn(&quot;applyToList&quot;)

		result.isList	= lookupFn(&quot;isList&quot;)
		result.isNil	= lookupFn(&quot;isNil&quot;)
		result.cons		= lookupFn(&quot;cons&quot;)
		result.length	= lookupFn(&quot;length&quot;)
		result.car 		= lookupFn(&quot;car&quot;)
		result.cdr 		= lookupFn(&quot;cdr&quot;)
		result.cadr 	= lookupFn(&quot;cadr&quot;)
		result.caddr 	= lookupFn(&quot;caddr&quot;)
		result.map		= lookupFn(&quot;map&quot;)
		result.filter	= lookupFn(&quot;filter&quot;)
		result.skipWhile = lookupFn(&quot;skipWhile&quot;)
		result.skipUntil = lookupFn(&quot;skipUntil&quot;)
		result.foldl	= lookupFn(&quot;foldl&quot;)
		result.foldr	= lookupFn(&quot;foldr&quot;)
		result.foldl1	= lookupFn(&quot;foldl1&quot;)
&apos;		result.foldr1	= lookupFn(&quot;foldr1&quot;)
		result.adjoin	= lookupFn(&quot;adjoin&quot;)
		result.flatten	= lookupFn(&quot;flatten&quot;)
		result.reverse	= lookupFn(&quot;reverse&quot;)

		result.TParser_toString = lookupFn(&quot;TParser_toString&quot;)
		result.mkParser	= lookupFn(&quot;mkParser&quot;)
		result.pReturn	= lookupFn(&quot;pReturn&quot;)
		result.pStr		= lookupFn(&quot;pStr&quot;)
		result.pBind	= lookupFn(&quot;pBind&quot;)
		result.pChoice	= lookupFn(&quot;pChoice&quot;)
		result.pMany		= lookupFn(&quot;pMany&quot;)
		result.pMany1		= lookupFn(&quot;pMany1&quot;)
		result.pZeroOrOne	= lookupFn(&quot;pZeroOrOne&quot;)
		result.pZeroOrOne2	= lookupFn(&quot;pZeroOrOne2&quot;)
		result.mkTypeVar		  = lookupFn(&quot;mkTypeVar&quot;)
		result.maybeMakeArrowType = lookupFn(&quot;maybeMakeArrowType&quot;)
		result.mkTypeCtor		  = lookupFn(&quot;mkTypeCtor&quot;)
		result.mkTupleType		  = lookupFn(&quot;mkTupleType&quot;)

		result.TASN_dot 		= lookupFn(&quot;TASN_dot&quot;)
		result.TASN_toString 	= lookupFn(&quot;TASN_toString&quot;)
		result.mkASN			= lookupFn(&quot;mkASN&quot;)
		result.mkDtTerminal		= lookupFn(&quot;mkDtTerminal&quot;)
		result.mkDtCClass		= lookupFn(&quot;mkDtCClass&quot;)
		result.mkDtNonterminal  = lookupFn(&quot;mkDtNonterminal&quot;)
		result.mkDtMult  		= lookupFn(&quot;mkDtMult&quot;)
		
		result.isPattern			= lookupFn(&quot;isPattern&quot;)
		result.TPattern_toString	= lookupFn(&quot;TPattern_toString&quot;)
		result.matches				= lookupFn(&quot;matches&quot;)
	End If
	Fn = result
End Function

Function newFn(name As String, arity As Integer, Optional typ)
	Dim result As New TFn
	result.tyname = TFn_tyname
	result.which = name
	result.arity = arity
	If Not(isMissing(typ)) Then
		result.str = name &amp; &quot; :: &quot; &amp; typ
	Else
		result.str = name
	End If
	newFn = result
End Function

Function mkPartialApp(fn As Object, arg As Variant)
	Dim result As New TFn
	result.tyname = TFn_tyname
	Dim baseArity As Integer, newArity As Integer
	Dim args As Variant
	If isPartialApp(fn) Then
		Dim innerArity As Integer, argPos As Integer
		Dim innerArgs As Variant
		result.which = fn.which
		innerArity = fn.arity
		baseArity = fn.which.arity
		newArity = innerArity - 1
		argPos = baseArity - newArity - 1
		ReDim args(0 To baseArity - 2)
		args(argPos) = arg
		innerArgs = fn.args
		Do
			argPos = argPos - 1
			args(argPos) = innerArgs(argPos)
		Loop Until argPos = 0
		result.args = args
		result.partialArgs = cons(arg, partialArgs(fn))
	Else
		result.which = fn
		baseArity = fn.arity
		newArity = baseArity - 1
		ReDim args(0 To baseArity - 2)
		args(0) = arg
		result.args = args
		result.partialArgs = cons(arg, nil)
	End If
	result.arity = newArity
	mkPartialApp = result
End Function

Function TFn_toString(ByVal f)
	Dim result As String, r As Integer, n As String, h As Variant, t As Object, k As Integer
	f = asFn(f)
	r = arity(f)
	n = getFnName(f)
	k = 0
	If isPartialApp(f) Then
		t = reverse(partialArgs(f))
		If n = &quot;compose&quot; Then
			If r = 1 Then
				&apos;result = &quot;\a&quot; &amp; k &amp; &quot;.&quot; &amp; TFn_toString(car(t)) &amp; &quot; (&quot; &amp; TFn_toString(cadr(t)) &amp; &quot; a&quot; &amp; k &amp; &quot;)&quot;
				&apos;k = k + 1
				result = TFn_toString(car(t)) &amp; &quot; Â° &quot; &amp; TFn_toString(cadr(t))
				&apos;result = &quot;(&quot; &amp; result &amp; &quot;)&quot;
			Else &apos; r = 2
				result = n &amp; TFn_toString(car(t))
				result = &quot;(&quot; &amp; result &amp; &quot;)&quot;
				&apos;croak(&quot;TFn_toString/NYI: compose partially applied to just 1 arg&quot;)
			End If
		ElseIf (n = &quot;swap&quot;) And (r = 1) Then
			Dim g As Object, x As Object
			g = car(t)
			x = cadr(t)
			If getFnName(g) = &quot;cons&quot; Then
				If isNil(x) Then
					result =  &quot;\a&quot; &amp; k &amp; &quot;.[a&quot; &amp; k &amp; &quot;]&quot;
					k = k + 1
				Else
					result =  &quot;\a&quot; &amp; k &amp; &quot;.cons a&quot; &amp; k &amp; &quot; &quot; &amp; toString(x)
					k = k + 1
				EndIf
			Else
				result =  &quot;\a&quot; &amp; k &amp; &quot;.&quot; &amp; TFn_toString(g) &amp; &quot; a&quot; &amp; k &amp; &quot; &quot; &amp; toString(x)
				k = k + 1
			End If
		Else
			result = &quot;(&quot; &amp; n &apos;&amp; &quot;_&quot; &amp; r
			While Not(isNil(t))
				h = car(t)
				t = cdr(t)
				If (isFn(h)) Then
					result = result &amp; &quot; &quot; &amp; TFn_toString(h)
				Else
					result = result &amp; &quot; &quot; &amp; toString(h)
				End If
			Wend
			result = result &amp; &quot;)&quot;
		End If
	Else
		result = n &apos;&amp; &quot;_&quot; &amp; r
	End If
	TFn_toString = result
End Function

Function fnObjs()
	Static result As Object
	If IsNull(result) Then
		result = toList(Array(_
			newFn(&quot;isString&quot;,		1, &quot;Any -&gt; Bool&quot;), _
			newFn(&quot;isEmpty&quot;,		1, &quot;Any -&gt; Bool&quot;), _
			newFn(&quot;toString&quot;,		1, &quot;Any -&gt; Str&quot;), _
			newFn(&quot;id&quot;,				1, &quot;a -&gt; a&quot;), _
			newFn(&quot;fstArg&quot;,			2, &quot;a -&gt; b -&gt; a&quot;), _
			newFn(&quot;sndArg&quot;,			1, &quot;a -&gt; b -&gt; b&quot;), _
			newFn(&quot;swap&quot;,			3, &quot;(b -&gt; a -&gt; c) -&gt; a -&gt; b -&gt; c&quot;), _
			newFn(&quot;compose&quot;,		3, &quot;(b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c&quot;), _
			newFn(&quot;ite&quot;,			4, &quot;(a -&gt; Bool) -&gt; (a -&gt; b) -&gt; (a -&gt; b) -&gt; a -&gt; b&quot;), _
			newFn(&quot;add&quot;,			2, &quot;Long -&gt; Long -&gt; Long&quot;), _
			newFn(&quot;mul&quot;,			2, &quot;Long -&gt; Long -&gt; Long&quot;), _
			newFn(&quot;inRange&quot;,		3, &quot;Long -&gt; Long -&gt; Long -&gt; Bool&quot;), _
			newFn(&quot;equ&quot;,			2, &quot;a -&gt; a -&gt; Bool&quot;), _
			newFn(&quot;neq&quot;,			2, &quot;a -&gt; a -&gt; Bool&quot;), _
			newFn(&quot;concat&quot;,			2, &quot;Str -&gt; Str -&gt; Str&quot;), _
			newFn(&quot;asc&quot;,			1, &quot;Char -&gt; Int&quot;), _
			newFn(&quot;chr&quot;,			1, &quot;Int -&gt; Char&quot;), _
			newFn(&quot;ucase&quot;,			1, &quot;Str -&gt; Str&quot;), _
			newFn(&quot;lcase&quot;,			1, &quot;Str -&gt; Str&quot;), _
			newFn(&quot;readHex&quot;,		1, &quot;Str -&gt; Long&quot;), _
			_
			newFn(&quot;TFn_toString&quot;,	1, &quot;(a -&gt; b) -&gt; Str&quot;), _
			newFn(&quot;applyToList&quot;,	2), _
			newFn(&quot;existsF&quot;,		1), _
			newFn(&quot;arityF&quot;, 		1), _
			_
			newFn(&quot;TList_toString&quot;,	1), _
			newFn(&quot;TList_equ&quot;,		2), _
			newFn(&quot;isList&quot;,			1, &quot;Any -&gt; Bool&quot;), _
			newFn(&quot;isNil&quot;,			1, &quot;[a] -&gt; Bool&quot;), _
			newFn(&quot;cons&quot;,			2, &quot;a -&gt; [a] -&gt; [a]&quot;), _
			newFn(&quot;length&quot;,			1), _
			newFn(&quot;car&quot;,			1), _
			newFn(&quot;cdr&quot;,			1), _
			newFn(&quot;cadr&quot;,			1), _
			newFn(&quot;caddr&quot;,			1), _
			newFn(&quot;map&quot;,			2, &quot;(a -&gt; b) -&gt; [a] -&gt; [b]&quot;), _
			newFn(&quot;filter&quot;,			2, &quot;(a -&gt; Bool) -&gt; [a] -&gt; [a]&quot;), _
			newFn(&quot;skipWhile&quot;,		2, &quot;(a -&gt; Bool) -&gt; [a] -&gt; [a]&quot;), _
			newFn(&quot;skipUntil&quot;,		2, &quot;(a -&gt; Bool) -&gt; [a] -&gt; [a]&quot;), _
			newFn(&quot;foldl&quot;,			3), _
			newFn(&quot;foldr&quot;,			3), _
			newFn(&quot;foldl1&quot;,			2), _
			newFn(&quot;foldr1&quot;,			2), _
			newFn(&quot;adjoin&quot;,			2), _
			newFn(&quot;flatten&quot;,		1, &quot;List List a -&gt; List a&quot;), _
			newFn(&quot;reverse&quot;,		1, &quot;List a -&gt; List a&quot;), _
			_
			newFn(&quot;TParser_toString&quot;,	1, &quot;Parser a -&gt; Str&quot;), _
			newFn(&quot;mkParser&quot;,			2, &quot;Str -&gt; Any -&gt; Parser a&quot;), _
			newFn(&quot;pReturn&quot;,			1, &quot;a -&gt; Parser a&quot;), _
			newFn(&quot;pStr&quot;,				1, &quot;Str -&gt; Parser Str&quot;), _
			newFn(&quot;pBind&quot;,				2, &quot;Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b&quot;), _
			newFn(&quot;pChoice&quot;,			2, &quot;Parser a -&gt; Parser a -&gt; Parser a&quot;), _
			newFn(&quot;pMany&quot;,				1, &quot;Parser a -&gt; Parser [a]&quot;), _
			newFn(&quot;pMany1&quot;,				1, &quot;Parser a -&gt; Parser [a]&quot;), _
			newFn(&quot;pZeroOrOne&quot;,			1, &quot;Parser a -&gt; Parser (Maybe a)&quot;), _
			newFn(&quot;pZeroOrOne2&quot;,		2, &quot;Parser a -&gt; a -&gt; Parser a&quot;), _
			newFn(&quot;mkTypeVar&quot;,			1, &quot;Char -&gt; Str&quot;), _
			newFn(&quot;maybeMakeArrowType&quot;,	2, &quot;Typ -&gt; Maybe Typ -&gt; Typ&quot;), _
			newFn(&quot;mkTypeCtor&quot;,			2, &quot;Str -&gt; [Typ] -&gt; Typ&quot;), _
			newFn(&quot;mkTupleType&quot;,		2, &quot;Typ -&gt; [Typ] -&gt; Typ&quot;), _
			_
			newFn(&quot;TASN_dot&quot;,			2, &quot;Str -&gt; ASN -&gt; Any&quot;), _
			newFn(&quot;TASN_toString&quot;,		1, &quot;ASN -&gt; Str&quot;), _
			newFn(&quot;mkASN&quot;,				3, &quot;Any -&gt; a -&gt; [b] -&gt; ASN&quot;), _
			newFn(&quot;mkDtTerminal&quot;,		1, &quot;Str -&gt; ASN&quot;), _
			newFn(&quot;mkDtCClass&quot;,			2, &quot;Str -&gt; Str -&gt; ASN&quot;), _
			newFn(&quot;mkDtNonterminal&quot;,	2, &quot;Str -&gt; [ASN] -&gt; ASN&quot;), _
			newFn(&quot;mkDtMult&quot;,			2, &quot;Str -&gt; [ASN] -&gt; ASN&quot;), _
			_
			newFn(&quot;isPattern&quot;,			1, &quot;Any -&gt; Bool&quot;), _
			newFn(&quot;TPattern_toString&quot;,	1, &quot;Pattern a -&gt; Str&quot;), _
			newFn(&quot;matches&quot;,			3, &quot;Pattern a -&gt; Maybe Env -&gt; a -&gt; Maybe Env&quot;) _
	))
	End If
	fnObjs = result
End Function

Function lookupFn(name As String) As Variant
	Dim result As Variant
	Dim fs As Object
	fs = fnObjs
	While Not(isNil(fs))
		If (getFnName(car(fs)) = name) Then
			result = car(fs)
			fs = nil
		Else
			fs = cdr(fs)
		End If
	Wend
	lookupFn = result
End Function

Function existsF(fName As String) As Boolean
	existsF = Not(isEmpty(lookupFn(fName)))
End Function

Function arityF(fName As String) As Integer
	If Not(existsF(fName)) Then
		arityF = -1
	Else
		arityF = arity(lookupFn(fName))
	End If
End Function

Function arity(fn As Object) As Integer
	arity = fn.arity
End Function

Function getFnTypeStr(f As Object) As String
	Dim fName As String
	fName = getFnName(f)
	getFnTypeStr = Mid(f.str, Len(fName &amp; &quot; :: &quot;) + 1)
End Function

Function isFn(ByVal fn As Variant) As Boolean
	If isObject(fn) Then
		Dim oFn As Object
		Set oFn = fn
		On Local Error Goto isFn_returnsFalse
		oFn.which
		oFn.arity
		oFn.partialArgs
		isFn = True
		Exit Function
	End If
isFn_returnsFalse:
	isFn = False
End Function

Function asFn(fn As Variant, Optional ByVal msg As String)
	Dim f As Variant
	If isString(fn) Then
		f = lookupFn(fn)
		If isEmpty(f) Then
			If isMissing(msg) Then : msg = &quot;&quot; : Else : msg = msg &amp; CR : End If
			croak(msg &amp; &quot;unknown function: &quot; &amp; toString(fn))
		End If
	Else
		f = fn
	End If
	If Not(isFn(f)) Then
		If isMissing(msg) Then : msg = &quot;&quot; : Else : msg = msg &amp; CR : End If
		croak(msg &amp; &quot;not a valid function: &quot; &amp; toString(f))
	End If
	asFn = f
End Function

Function isPartialApp(fn As Object) As Boolean
	isPartialApp = Not(isEmpty(fn.partialArgs))
End Function

Function partialArgs(fn As Object)	&apos; ATTENTION: stored in reverse order!
	Dim result As Object
	If isPartialApp(fn) Then
		result = fn.partialArgs
	Else
		result = nil
	End If
	partialArgs = result
End Function

Function getFnName(f As Object)
	If isPartialApp(f) Then
		getFnName = getFnName(f.which)
	Else
		getFnName = f.which
	End If
End Function

Function apply1(ByVal fn As Variant, ByVal arg As Variant)
	Dim result As Variant, r As Integer
	fn = asFn(fn)	&apos; makes sure it really is a function
	r = arity(fn)
	If r = 1 Then
		result = applyLast(fn, arg)
	Else
		result = mkPartialApp(fn, arg)
	End If
	apply1 = result
End Function

Function applyLast(fn As Object, arg As Variant)
	Dim result As Variant
	Dim reverseArgs As Object
	Dim baseArity As Integer
	Dim args As Variant
	Dim name As String
	If isPartialApp(fn) Then
		reverseArgs = partialArgs(fn)
		args = fn.args
		fn = fn.which
	Else
		reverseArgs = nil
	End If
	baseArity = fn.arity
	name = fn.which
	Dim a0 As Variant, a1 As Variant, a2 As Variant, a3 As Variant
	On baseArity(fn) Goto applyLast_of_one, applyLast_of_two, applyLast_of_three, applyLast_of_four
	Goto applyLast_of_fiveOrMore
applyLast_of_one:
	a0 = arg
	Select Case name
		Case &quot;id&quot;: 			result = a0
		Case &quot;sndArg&quot;:		result = sndArg(	a0)
		Case &quot;asc&quot;:			result = Asc(		a0)
		Case &quot;chr&quot;:			result = Chr(		a0)
		Case &quot;ucase&quot;:		result = UCase(		a0)
		Case &quot;lcase&quot;:		result = LCase(		a0)
		Case &quot;isString&quot;:	result = isString(	a0)
		Case &quot;isEmpty&quot;:		result = isEmpty(	a0)
		Case &quot;toString&quot;:	result = toString(	a0)
		Case &quot;readHex&quot;:		result = readHex(	a0)
		Case &quot;isList&quot;:		result = isList(	a0)
		Case &quot;isNil&quot;:		result = isNil(		a0)
		Case &quot;length&quot;:		result = length(	a0)
		Case &quot;car&quot;:			result = car(		a0)
		Case &quot;cdr&quot;:			result = cdr(		a0)
		Case &quot;cadr&quot;:		result = cadr(		a0)
		Case &quot;caddr&quot;:		result = caddr(		a0)
		Case &quot;flatten&quot;:		result = flatten(	a0)
		Case &quot;reverse&quot;: 	result = reverse(	a0)
		Case &quot;toArray&quot;: 	result = toArray(	a0)
		Case &quot;pStr&quot;: 		result = pStr(		a0)
		Case &quot;pReturn&quot;:		result = pReturn(	a0)
		Case &quot;pMany&quot;:		result = pMany(		a0)
		Case &quot;pMany1&quot;:		result = pMany1(	a0)
		Case &quot;pZeroOrOne&quot;:	result = pZeroOrOne(a0)
		Case &quot;mkTypeVar&quot;:	result = mkTypeVar(	a0)
		Case &quot;TFn_toString&quot;:		result = TFn_toString(		a0)
		Case &quot;TList_toString&quot;:		result = TList_toString(	a0)
		Case &quot;TParser_toString&quot;:	result = TParser_toString(	a0)
		Case &quot;TASN_toString&quot;:		result = TASN_toString(		a0)
		Case &quot;mkDtTerminal&quot;:		result = mkDtTerminal(		a0)
		Case &quot;isPattern&quot;:	result = isPattern(	a0)
		Case &quot;TPattern_toString&quot;:	result = TPattern_toString(	a0)
		Case Else
			Goto applyLast_doTheCall
	End Select
	applyLast = result
	Exit Function
applyLast_of_two:
	a0 = car(reverseArgs) &apos;fn.args(0)
	a1 = arg
	Select Case name
		Case &quot;fstArg&quot;:		result = a0
		Case &quot;add&quot;:			result = CLng(a0 + a1)
		Case &quot;mul&quot;:			result = CLng(a0 * a1)
		Case &quot;concat&quot;:		result = a0 &amp; a1
		Case &quot;equ&quot;:			result = equ(			a0, a1)
		Case &quot;neq&quot;:			result = Not(equ(		a0, a1))
		Case &quot;applyToList&quot;:	result = applyToList(	a0, a1)
		Case &quot;cons&quot;:		result = cons(			a0, a1)
		Case &quot;map&quot;:			result = map(			a0, a1)
		Case &quot;filter&quot;:		result = filter(		a0, a1)
		Case &quot;skipWhile&quot;:	result = skipWhile(		a0, a1)
		Case &quot;skipUntil&quot;:	result = skipUntil(		a0, a1)
		Case &quot;foldl1&quot;:		result = foldl1(		a0, a1)
&apos;		Case &quot;foldr1&quot;:		result = foldr1(		a0, a1)
		Case &quot;adjoin&quot;:		result = adjoin(		a0, a1)
		Case &quot;mkParser&quot;:	result = mkParser(		a0, a1)
		Case &quot;pBind&quot;:		result = pBind(			a0, a1)
		Case &quot;pChoice&quot;:		result = pChoice(		a0, a1)
		Case &quot;pZeroOrOne2&quot;:	result = pZeroOrOne2(	a0, a1)
		Case &quot;maybeMakeArrowType&quot;: result = maybeMakeArrowType(a0, a1)
		Case &quot;mkTypeCtor&quot;:	result = mkTypeCtor(	a0, a1)
		Case &quot;mkTupleType&quot;:	result = mkTupleType(	a0, a1)
		Case &quot;TASN_dot&quot;:	result = TASN_dot(		a0, a1)
		Case &quot;mkDtCClass&quot;:	result = mkDtCClass(	a0, a1)
		Case &quot;mkDtNonterminal&quot;:	result = mkDtNonterminal(	a0, a1)
		Case &quot;mkDtMult&quot;:		result = mkDtMult(	a0, a1)
		Case Else
			Goto applyLast_doTheCall
	End Select
	applyLast = result
	Exit Function
applyLast_of_three:
	a0 = cadr(reverseArgs) &apos;fn.args(0)
	a1 = car(reverseArgs) &apos;fn.args(1)
	a2 = arg
	Select Case name
		Case &quot;swap&quot;:		result = apply(a0, a2, a1)
		Case &quot;compose&quot;:		result = _compose(a0, a1, a2)	&apos;	apply(a0, apply(a1, a2))	&apos;
		Case &quot;inRange&quot;:		result = CBool( (a0 &lt;= a2) And (a2 &lt;= a1) )
		Case &quot;foldl&quot;:		result = foldl(		a0, a1, a2)
		Case &quot;foldr&quot;:		result = foldr(		a0, a1, a2)
		Case &quot;mkASN&quot;:		result = mkASN(		a0, a1, a2)
		Case &quot;matches&quot;:		result = matches(	a0, a1, a2)
		Case Else
			Goto applyLast_doTheCall
	End Select
	applyLast = result
	Exit Function
applyLast_of_four:
	a0 = caddr(reverseArgs) &apos;fn.args(0)
	a1 = cadr(reverseArgs) &apos;fn.args(1)
	a2 = car(reverseArgs) &apos;fn.args(2)
	a3 = arg
	Select Case name
		Case &quot;ite&quot;
			If applyLast(a0, a3) Then
				result = apply1(a1, a3)
			Else
				result = apply1(a2, a3)
			End if
		Case Else
			Goto applyLast_doTheCall
	End Select
	applyLast = result
	Exit Function
applyLast_of_fiveOrMore:
	croak(&quot;NYI: applyLast_fiveOrMore&quot;)
applyLast_doTheCall:
	reverseArgs = cons(arg, reverseArgs)
	result = applyBuiltinRev(fn, reverseArgs)
	applyLast = result
End Function

Function applyBuiltinRev(fn As Object, ByVal reverseArgs As Object)
	Dim result As Variant
	Dim r As Integer, n As Integer
	r = arity(fn)
	n = length(reverseArgs)
	If (r &lt;&gt; n) Then
		croak(&quot;applyBuiltinRev: arity = &quot; &amp; r &amp; &quot; &lt;&gt; #args = &quot; &amp; n)
	End If
	&apos; Do NOT call or apply &quot;reverse&quot;!
	Dim a(0 To n - 1)
	Dim i As Integer
	For i = n - 1 To 0 Step -1
		a(i) = car(reverseArgs)
		reverseArgs = cdr(reverseArgs)
	Next i
	Select Case getFnName(fn)
		Case &quot;arityF&quot;:				result = arityF(			a(0)				)
		Case &quot;existsF&quot;:				result = existsF(			a(0)				)
		Case &quot;TList_equ&quot;:			result = TList_equ(			a(0), a(1)			)
		Case Else
			croak(&quot;applyBuiltinRev: unknown function &apos;&quot; &amp; getFnName(fn) &amp; &quot;&apos;&quot;)
	End Select	
	applyBuiltinRev = result
End Function

Function applyToList(Optional ByVal f As Variant, Optional ByVal args As Object)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.applyToList : End If
	Dim result As Variant
	If isMissing(args) Then
		If isMissing(f) Then
			result = oFn
		Else
			f = asFn(f, &quot;applyToList: invalid 1st arg&quot;)
			result = apply1(oFn, f)
		End If
	ElseIf isNil(args) Then
		Dim fstr As String
		fstr = toString(f)
		croak(&quot;applyToList: empty args list for &quot; &amp; CR &amp; fstr)
	Else
		&apos; applyToList = foldl apply1 f args
		f = asFn(f, &quot;applyToList: invalid 1st arg&quot;)
		result = f
		While Not(isNil(args))
			result = apply1(result, car(args))
			args = cdr(args)
		Wend
	End If
	applyToList = result
End Function

Function _apply(fn As Object, Optional a0, Optional a1, Optional a2, Optional a3, Optional a4)
	If isMissing(a0) Then
		_apply = fn
	ElseIf isMissing(a1) Then
		_apply = apply1(fn, a0)
	ElseIf isMissing(a2) Then
		_apply = apply1(apply1(fn, a0), a1)
	ElseIf isMissing(a3) Then
		_apply = apply1(apply1(apply1(fn, a0), a1), a2)
	ElseIf isMissing(a4) Then
		_apply = apply1(apply1(apply1(apply1(fn, a0), a1), a2), a3)
	Else
		croak(&quot;_apply/NYI: more than 4 args&quot;)
	End If
End Function

Function apply(ByVal fn As Variant, a0, Optional a1, Optional a2, Optional a3, Optional a4, Optional a5, Optional a6, Optional a7, Optional a8, Optional a9, Optional a10)
	Dim args As Object
	If Not(isFn(fn)) Then
&apos;		croak(&quot;apply: invalid 1st arg:&quot; &amp; CR &amp; toString(fn))
	End If
	fn = asFn(fn, &quot;apply: invalid 1st arg&quot;)
	If isMissing(a1) Then
		If arity(fn) = 1 Then
			apply = applyLast(fn, a0)
		Else
			apply = apply1(fn, a0)
		End If
	ElseIf isMissing(a2) Then
		apply = apply1(apply1(fn, a0), a1)
	ElseIf isMissing(a3) Then
		apply = apply1(apply1(apply1(fn, a0), a1), a2)
	Else
		args = List(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
		apply = applyToList(fn, args)
	End If
End Function

&apos;= tests ============================================================

Function test_Fn()
	Dim i As Integer
		
	Dim fId As Variant
	fId = Fn.id
	assertEqual(isPartialApp(fId), False).x
	assertEqual(arity(fId), 1).x
	assertEqual(apply(fId, 0), id(0)).x
	
	Dim temp As Object
	temp = fId &apos; do not access fields on fId directly...!
	assertEqual(temp.tyname &lt;&gt; &quot;&quot;, True).x
	

	Dim fCar As Variant
	fCar = Fn.car
	assertEqual(isPartialApp(fCar), False).x
	assertEqual(isNil(partialArgs(fCar)), True).x
	assertEqual(arity(fCar), 1).x
	
	assertEqual( apply1(fCar, List(9)), 9 ).x
	assertEqual( apply1(fCar, List(&quot;a&quot;)), &quot;a&quot; ).x
		
	Dim fEqu As Variant
	fEqu = Fn.equ
	assertEqual(isPartialApp(fEqu), False).x
	assertEqual(isNil(partialArgs(fEqu)), True).x
	assertEqual(arity(fEqu), 2).x
	assertEqual(apply(fEqu, 1, 2), False).x
	assertEqual(apply(fEqu, 1, 1), True).x
	
	Dim eq5 As Variant
	eq5 = apply(fEqu, 5)
	assertEqual(isPartialApp(eq5), True).x
	assertEqual(isNil(partialArgs(eq5)), False).x
	assertEqual(arity(eq5), 1).x
	
	&apos; partially applied fns also have a proper .tyname:
	&apos; Note typeOf is the BASIC type, not the actual fn type
	assertEqual(typeOf(eq5), typeOf(fId)).x
	
	Dim eq5_7 As Variant
	eq5_7 = apply1(eq5, 7)
	assertEqual(eq5_7, False).x

	Dim eq5_5 As Variant
	eq5_5 = apply1(eq5, 5)
	assertEqual(eq5_5, True).x

	Dim konst5 As Variant
	konst5 = apply1(Fn.fstArg, 5)
	assertEqual(isPartialApp(konst5), True).x
	assertEqual(arity(konst5), 1).x
	assertEqual(apply1(konst5, 7), 	5).x
	&apos; easy partial application:
	assertEqual(arity(fstArg), 2).x
	konst5 = fstArg(5)
	assertEqual(arity(konst5), 1).x
	assertEqual(apply(konst5, 7), 	5).x
	assertEqual(fstArg(5, 7), 		5).x
		
	Dim sndArg5 As Variant
	sndArg5 = apply1(Fn.sndArg, 5)
	
	assertEqual(arity(sndArg5), 1).x
	assertEqual(apply1(sndArg5, 7), 7).x
	
	&apos; easy partial application:
	sndArg5 = sndArg(5)
	assertEqual(arity(sndArg5), 1).x
	assertEqual(apply(sndArg5, 7), 	7).x
	assertEqual(sndArg(5, 7), 		7).x
		
	Dim fIte As Variant
	fIte = Fn.ite
	assertEqual(isPartialApp(fIte), False).x
	assertEqual(arity(fIte), 4).x

	Dim iteKFalse As Variant
	iteKFalse = apply1(fIte, fstArg(False))
	assertEqual(isPartialApp(iteKFalse), True).x
	assertEqual(arity(iteKFalse), 3).x

	Dim iteKFalseK42 As Variant
	iteKFalseK42 = apply1(iteKFalse, fstArg(42))
	assertEqual(isPartialApp(iteKFalseK42), True).x
	assertEqual(arity(iteKFalseK42), 2).x
	
	Dim iteKFalseK42Id As Variant
	iteKFalseK42Id = apply1(iteKFalseK42, id)
	assertEqual(arity(iteKFalseK42Id), 1).x

	assertEqual(apply(iteKFalseK42Id, &quot;Seven&quot;), &quot;Seven&quot;).x
	Dim iteKTrueK42Id As Variant, KTrue As Variant, K42 As Variant
	iteKTrueK42Id = ite(fstArg(True), fstArg(42), fId)
	assertEqual(arity(iteKTrueK42Id), 1).x
	assertEqual(apply(iteKTrueK42Id, &quot;Seven&quot;), 42).x
&apos;	MsgBox( toString(iteFalse42Seven) )

	Dim fAsc As Variant
	fAsc = Fn.asc
	assertEqual(arity(fAsc), 1).x
	assertEqual(apply(fAsc, &quot; &quot;), 		Asc(&quot; &quot;)).x
	assertEqual(apply(fAsc, TAB), 	       9).x
	assertEqual(apply(fAsc, CR), 	      13).x
	assertEqual(apply(fAsc, &quot;0&quot;), 		Asc(&quot;0&quot;)).x
	assertEqual(apply(fAsc, &quot;9&quot;), 		Asc(&quot;9&quot;)).x
	assertEqual(apply(fAsc, &quot;A&quot;), 		Asc(&quot;A&quot;)).x
	assertEqual(apply(fAsc, &quot;B&quot;), 		Asc(&quot;B&quot;)).x
	assertEqual(apply(fAsc, &quot;Z&quot;), 		Asc(&quot;Z&quot;)).x

	Dim fChr As Variant
	fChr = Fn.chr
	assertEqual(arity(fChr), 1).x
	assertEqual(apply(fChr,  9), 	TAB).x
	assertEqual(apply(fChr, 13), 	CR).x
	assertEqual(apply(fChr, 32), 	Chr(32)).x
	assertEqual(apply(fChr, 48), 	Chr(48)).x
	assertEqual(apply(fChr, 65), 	Chr(65)).x
	assertEqual(apply(fChr, 66), 	Chr(66)).x
	assertEqual(apply(fChr, 90), 	Chr(90)).x


	Dim fAdd As Variant
	fAdd = Fn.add
	assertEqual(arity(fAdd), 2).x
	assertEqual(apply(fAdd,  0,  0), 	add(0, 0)).x
	assertEqual(apply(fAdd,  0,  1), 	add(0, 1)).x
	assertEqual(apply(fAdd,  7, -5), 	add(7, -5)).x
	&apos; partial application
	fAdd = apply(fAdd, 65535)
	assertEqual(apply(fAdd, 65535), add(65535, 65535)).x

	Dim fMul As Variant
	fMul = Fn.mul
	assertEqual(arity(fMul), 2).x
	assertEqual(apply(fMul,  0,  0), 	mul(0, 0)).x
	assertEqual(apply(fMul,  0,  1), 	mul(0, 1)).x
	assertEqual(apply(fMul,  7, -5), 	mul(7, -5)).x
	&apos; partial application
	fMul = apply(fMul, 65535)
	assertEqual(apply(fMul, 32767), mul(65535, 32767)).x

	Dim fReadhex As Variant
	fReadHex = Fn.readHex
	assertEqual(arity(fReadHex), 1).x
	assertEqual(apply(fReadHex,  &quot;0&quot;),  readHex(&quot;0&quot;)).x
	assertEqual(apply(fReadHex,  &quot;1&quot;),  readHex(&quot;1&quot;)).x
	assertEqual(apply(fReadHex,  &quot;2&quot;),  readHex(&quot;2&quot;)).x
	assertEqual(apply(fReadHex,  &quot;3&quot;),  readHex(&quot;3&quot;)).x
	assertEqual(apply(fReadHex,  &quot;4&quot;),  readHex(&quot;4&quot;)).x
	assertEqual(apply(fReadHex,  &quot;5&quot;),  readHex(&quot;5&quot;)).x
	assertEqual(apply(fReadHex,  &quot;6&quot;),  readHex(&quot;6&quot;)).x
	assertEqual(apply(fReadHex,  &quot;7&quot;),  readHex(&quot;7&quot;)).x
	assertEqual(apply(fReadHex,  &quot;8&quot;),  readHex(&quot;8&quot;)).x
	assertEqual(apply(fReadHex,  &quot;9&quot;),  readHex(&quot;9&quot;)).x

	assertEqual(apply(fReadHex,  &quot;A&quot;),  readHex(&quot;A&quot;)).x
	assertEqual(apply(fReadHex,  &quot;a&quot;),  readHex(&quot;a&quot;)).x

	assertEqual(apply(fReadHex,  &quot;F&quot;),  readHex(&quot;F&quot;)).x
	assertEqual(apply(fReadHex,  &quot;f&quot;),  readHex(&quot;f&quot;)).x


	assertEqual(arityF(&quot;arityF&quot;), 1).x
	assertEqual(arityF(&quot;applyToList&quot;), 2).x

	assertEqual(apply(&quot;arityF&quot;,  &quot;foo&quot;),            -1).x
	assertEqual(apply(&quot;arityF&quot;,  &quot;arityF&quot;),          1).x
	assertEqual(apply(&quot;arityF&quot;,  &quot;applyToList&quot;),     2).x

	assertEqual(apply(&quot;toString&quot;, &quot;abcd&quot;), &quot;&apos;abcd&apos;&quot;).x
End Function

</script:module>