<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M09_Pattern" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit

&apos; data Pattern = Any
&apos;              | Const TNative
&apos;              | Var Str
&apos;              | Data TDataCtor [Pattern]

Sub Main
	TPattern
	[test_Pattern======================================]()
End Sub


Function TPattern()
	Static out As Object
	If isNull(out) Then
		Dim tcPat
		tcPat = _mkDataTypeCtor(&quot;Pattern&quot;, 0)
		out = tcPat
		Dim cAny, cVar, cConst, cData
		cAny   = mkDataCtor(tcPat, &quot;Any&quot;,	nil)
		cVar   = mkDataCtor(tcPat, &quot;Var&quot;,	List(Tp.Native_String))
		cConst = mkDataCtor(tcPat, &quot;Const&quot;,	List(Tp.Native_Variant))
		cData  = mkDataCtor(tcPat, &quot;Data&quot;,	List(TDataCtor, TList(tcPat)))
	End If
	TPattern = out
End Function

Function Pattern_Any()
	Static out As Object : If isNull(out) Then
		out = singletonVal(findDataCtor(TPattern, &quot;Any&quot;))
		out.str = TPattern_toString(out)
	End If
	Pattern_Any = out
End Function

Function patAny()
	Static out As Object : If isNull(out) Then
		out = singletonVal(findDataCtor(TPattern, &quot;Any&quot;))
		out.str = TPattern_toString(out)
	End If
	patAny = out
End Function

Function Pattern_Var(Optional nm)
	Static c As Object : If isNull(c) Then
		c = findDataCtor(TPattern, &quot;Var&quot;)
	End If
	Dim out
	If isMissing(nm) Then
		out = applyDC(c)
	Else
		out = applyDC(c, nm)
		out.str = TPattern_toString(out)
	End If
	Pattern_Var = out
End Function

Function patVar(Optional nm)
	Static c As Object : If isNull(c) Then
		c = findDataCtor(TPattern, &quot;Var&quot;)
	End If
	Dim out
	If isMissing(nm) Then
		out = applyDC(c)
	Else
		out = applyDC(c, nm)
		out.str = TPattern_toString(out)
	End If
	patVar = out
End Function

Function Pattern_Var_name(Optional x)
	Static c As Object : If isNull(c) Then
		c = findDataCtor(TPattern, &quot;Var&quot;)
	End If
	Pattern_Var_name = _destructure(c, 0, x)
End Function

Function Pattern_Const(Optional val)
	Static c As Object : If isNull(c) Then
		c = findDataCtor(TPattern, &quot;Const&quot;)
	End If
	Dim out
	If isMissing(val) Then
		out = applyDC(c)
	Else
		out = applyDC(c, val)
		out.str = TPattern_toString(out)
	End If
	Pattern_Const = out
End Function

Function patConst(Optional val)
	Static c As Object : If isNull(c) Then
		c = findDataCtor(TPattern, &quot;Const&quot;)
	End If
	Dim out
	If isMissing(val) Then
		out = applyDC(c)
	Else
		out = applyDC(c, val)
		out.str = TPattern_toString(out)
	End If
	patConst = out
End Function

Function Pattern_Const_value(Optional x)
	Static c As Object : If isNull(c) Then
		c = findDataCtor(TPattern, &quot;Const&quot;)
	End If
	Pattern_Const_value = _destructure(c, 0, x)
End Function

Function Pattern_Data(Optional dc, Optional argPatterns)
	Static oFn As Object, tcPat As Object, cDat As Object
	If isNull(oFn) Then
		oFn = Fn.Pattern_Data
		tcPat = TPattern
		cDat = findDataCtor(tcPat, &quot;Data&quot;)
	End If
	Dim out
	If isMissing(dc) Then
		out = oFn
	ElseIf isMissing(argPatterns) Then
		out = apply(oFn, dc)
	Else
		out = applyDC(cDat, dc, argPatterns)
		&apos; still have to make sure argPatterns isa [Pattern]
		Dim aps As Object : aps = argPatterns
		Dim ats As Object : ats = argTypes(dc)
		If length(aps) &lt;&gt; length(ats) Then
			Goto Pattern_Data_2nd_arg_wrong_count
		End If
		Dim ap As Variant	&apos; might be whatever
		Dim at As Object	&apos; should be a Type
		Dim i As Integer
		Do Until(isNil(aps))
			ap = car(aps) : aps = cdr(aps)
			at = car(ats) : ats = cdr(ats)
			If hasType(ap, tcPat) Then
				&apos; TODO: check if it is compatible with at
			Else
				Goto Pattern_Data_2nd_arg_type_error
			End If
			i = i + 1
		Loop
		out.str = TPattern_toString(out)
	End If
	Pattern_Data = out
	Exit Function
Pattern_Data_2nd_arg_type_error:
	Dim msg As String
	On Local Error Goto Pattern_Data_2nd_arg_type_error_skipToString
	msg = &quot;:&quot; &amp; NL &amp; toString(ap)
Pattern_Data_2nd_arg_type_error_skipToString:
	msg = &quot;invalid 2nd arg: expected a [TPattern]&quot; _
		&amp; NL &amp; &quot;but there&apos;s a &quot; &amp; typeStr(ap) _
		&amp; &quot; at index &quot; &amp; i _
		&amp; msg
	On Local Error Goto 0 &apos; disable error handler
	croak(msg)
Pattern_Data_2nd_arg_wrong_count:
	On Local Error Goto 0 &apos; disable error handler
	croak(&quot;invalid 2nd arg: &quot; &amp; nameOf(dc) _
		&amp; &quot; needs &quot; &amp; length(argTypes(dc)) &amp; &quot; args&quot; _
		&amp; NL &amp; &quot;but we got &quot; &amp; length(argPatterns) &amp; &quot; patterns&quot; _
	)
End Function

Function Pattern_Data_ctor(Optional x)
	Static c As Object : If isNull(c) Then
		c = findDataCtor(TPattern, &quot;Data&quot;)
	End If
	Pattern_Data_ctor = _destructure(c, 0, x)
End Function

Function Pattern_Data_args(Optional x)
	Static c As Object : If isNull(c) Then
		c = findDataCtor(TPattern, &quot;Data&quot;)
	End If
	Pattern_Data_args = _destructure(c, 1, x)
End Function

Function singletonPat(v)
	singletonPat = Pattern_Data(_ctor(v), nil)
End Function

Function isPattern(Optional x)
	Static oFn As Object, tcPat As Object
	If isNull(oFn) Then
		oFn = Fn.isPattern
		tcPat = TPattern
	End If
	Dim out
	If isMissing(x) Then : out = oFn
	Else				 : out = hasType(x, tcPat)
	End If
	isPattern = out
End Function

Function patNil()
	Static out As Object : If isNull(out) Then 
		out = singletonPat(nil)
	End If
	patNil = out
End Function

Function patCons(hd, tl)
	Static cCons As Object : If isNull(cCons) Then
		cCons = Tp.List_Cons
	End If
	patCons = Pattern_Data(cCons, List(hd, tl))
End Function

Function patList( _
	Optional a0, _
	Optional a1, _
	Optional a2, _
	Optional a3, _
	Optional a4, _
	Optional a5, _
	Optional a6, _
	Optional a7, _
	Optional a8, _
	Optional a9, _
	Optional a10 _
)
	Dim out
	out = patNil
	If isMissing(a0 ) Then : Goto patList_0  : End If
	If isMissing(a1 ) Then : Goto patList_1  : End If
	If isMissing(a2 ) Then : Goto patList_2  : End If
	If isMissing(a3 ) Then : Goto patList_3  : End If
	If isMissing(a4 ) Then : Goto patList_4  : End If
	If isMissing(a5 ) Then : Goto patList_5  : End If
	If isMissing(a6 ) Then : Goto patList_6  : End If
	If isMissing(a7 ) Then : Goto patList_7  : End If
	If isMissing(a8 ) Then : Goto patList_8  : End If
	If isMissing(a9 ) Then : Goto patList_9  : End If
	If isMissing(a10) Then : Goto patList_10 : Else
		croak(&quot;only 10 args supported - got 11&quot;)
	End If
patList_10: out = patCons(a9, out)
patList_9:  out = patCons(a8, out)
patList_8:  out = patCons(a7, out)
patList_7:  out = patCons(a6, out)
patList_6:  out = patCons(a5, out)
patList_5:  out = patCons(a4, out)
patList_4:  out = patCons(a3, out)
patList_3:  out = patCons(a2, out)
patList_2:  out = patCons(a1, out)
patList_1:  out = patCons(a0, out)
patList_0:
	patList = out
End Function


Function TPattern_toString( _
	p As Object, _
	Optional needParens As Boolean _
)
	Dim out
	out = TPattern_toSrc(p, False)
	out = &quot;Pattern(&quot; &amp; out &amp; &quot;)&quot;
	TPattern_toString = out
End Function

Function TPattern_toSrc( _
	p As Object, _
	Optional needParens As Boolean _
)
	Static cAny		As Object
	Static idAny	As Integer
	Static idVar	As Integer
	Static idConst	As Integer
	Static idData	As Integer
	If isNull(cAny) Then
		cAny = findDataCtor(TPattern, &quot;Any&quot;)
		idAny   = _id(cAny)
		idVar   = _id(findDataCtor(TPattern, &quot;Var&quot;))
		idConst = _id(findDataCtor(TPattern, &quot;Const&quot;))
		idData  = _id(findDataCtor(TPattern, &quot;Data&quot;))
	End If
	If isMissing(needParens) Then
		needParens = False
	End If
	Dim out As String
	Dim idcP As Long
	On Local Error Goto TPattern_toSrc_error
	idcP = _id(_ctor(p))
	On Local Error Goto 0
	Select Case idcP
		Case idAny
			out = &quot;_&quot;
		Case idVar
			out = Pattern_Var_name(p)
		Case idConst
			Dim v : v = Pattern_Const_value(p)
			If isEmpty(v) Then
				out = &quot;()&quot;
			Else
				out = toString(v)
			End If
		Case idData
			Dim c  : c  = Pattern_Data_ctor(p)
			Dim ps : ps = Pattern_Data_args(p)
			If DataValue_same(c, Tp.List_Nil) Then
				out = &quot;[]&quot;
			ElseIf DataValue_same(c, Tp.List_Cons) Then
				Dim pHd As Object : pHd = car(ps)
				Dim pTl As Object : pTl = cadr(ps)
				Dim sTl As String : sTl = TPattern_toSrc(pTl, True)
				If sTl = &quot;[]&quot; Then
					out = &quot;[&quot; &amp; TPattern_toSrc(pHd, False) &amp; &quot;]&quot;
				ElseIf startsWith(sTl, &quot;[&quot;) Then
					out = TPattern_toSrc(pHd, False)
					out = &quot;[&quot; &amp; out &amp; &quot;, &quot; &amp; Mid(sTl, 2)
				Else
					out = TPattern_toSrc(pHd, True) _
						&amp; &quot;:&quot; _
						&amp; sTl
					If needParens Then
						out = &quot;(&quot; &amp; out &amp; &quot;)&quot;
					End If
				End If
			Else
				Dim q As Object
				out = nameOf(c)
				If Not(isNil(ps)) Then
					Do Until isNil(ps)
						q = car(ps)
						ps = cdr(ps)
						out = out &amp; &quot; &quot; &amp; TPattern_toSrc(q, True)
					Loop
					If needParens Then
						out = &quot;(&quot; &amp; out &amp; &quot;)&quot;
					End If
				End If
			End If
		Case Else
TPattern_toSrc_error:
			On Local Error Goto 0 &apos; disable error handler
			croak(&quot;TPattern_toSrc: bad pattern &quot; &amp; typeStr(p))
	End Select
	TPattern_toSrc = out
End Function

Function match( _
	Optional ByRef p As Object, _
	Optional ByRef e As Variant, _
	Optional ByVal x As Variant _
)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.match : End If
	Dim out As Variant
	If isMissing(p) Then
		out = oFn
	Else
		If Not(hasType(p, TPattern)) Then
			croak(&quot;match: not a pattern: &quot; &amp; typeStr(p))
		ElseIf isMissing(e) Then 	: out = apply(oFn, p)
		ElseIf isEmpty(e) Or isEnv(e) Then
			If isMissing(x) Then	: out = apply(oFn, p, e)
			ElseIf isEmpty(e) Then	: out = Empty
			Else
				out = _match(p, e, x)
			End If
		Else
			croak(&quot;match: bad environment: &quot; &amp; typeStr(e))
		End If
	End If
	match = out
End Function

Function _match( _
	ByVal p As Object, _
	ByVal e As Variant, _
	ByVal x As Variant _
)
	Static pAny       As Object		&apos; the &quot;Any&quot; pattern (singleton value)
	Static id_pAny    As Integer	&apos; id of pAny
	Static cpAny      As Object		&apos; ctor of pAny (singleton data ctor)
	Static id_cpAny   As Integer	&apos; id of cpAny
	Static id_cpVar   As Integer	&apos; id of the &quot;Var&quot; pattern ctor
	Static id_cpConst As Integer	&apos; id of the &quot;Const&quot; pattern ctor
	Static pNil       As Object		&apos; pattern that matches [] (a Data pattern)
	Static id_pNil    As Integer	&apos; id of pNil
	Static vNil       As Object		&apos; the singleton value []
	Static id_vNil    As Integer	&apos; id of vNil
	Static cNil       As Object		&apos; the singleton data ctor Nil
	Static tcList     As Object		&apos; typeCtor of cNil
	Static cpData     As Object		&apos; the &quot;Data&quot; pattern ctor (= ctor of pNil)
	Static id_cpData  As Integer	&apos; id of the &quot;Data&quot; pattern ctor
	If isNull(pAny) Then
		&apos; Let&apos;s avoid mentioning the actual name strings of the ctors!
		pAny	   = patAny
		id_pAny    = _id(pAny)
		cpAny 	   = _ctor(pAny)
		id_cpAny   = _id(cpAny)
		id_cpVar   = _id(_ctor(patVar(&quot;x&quot;)))
		id_cpConst = _id(_ctor(patConst(42)))
		pNil       = patNil
		id_pNil    = _id(pNil)
		vNil       = nil
		id_vNil    = _id(vNil)
		cNil       = _ctor(vNil)
		tcList     = typeCtorOf(cNil)
		assert_same(tcList, TList).x
		cpData     = _ctor(pNil)
		&apos;assert_same(cpData, findDataCtor(TPattern, &quot;Data&quot;)).x
		id_cpData  = _id(cpData)
	End If
	Dim out
	Dim v     As Variant	&apos; value of Const pattern
	Dim nm    As String	&apos; name of Var pattern
	Dim cx    As Object	&apos; ctor of x (if p isa Data)
	Dim pCtor As Object	&apos; ctor field of p if p isa Data : Data DataCtor ...
	Dim pArgs As Object	&apos; args field of p if p isa Data : Data ... [TPattern]
	Dim msg   As String	&apos; on errors
	
	&apos; special-case on singleton patterns:
	Select Case _id(p)
		Case id_pAny:	out = e
		Case id_pNil
			pCtor = cNil &apos; make sure error handler makes right msg
			On Local Error Goto _match_type_error
			If _id(x) = id_vNil Then
				out = e
			Else
				&apos; is it at least a List?
				cx = _ctor(x)
				Goto _match_require_same_datatype
			End If
		Case Else
				
			Select Case _id(_ctor(p))
				Case id_cpConst
					v = Pattern_Const_value(p)
_match_equ_test:			
					If equ(x, v) Then
						out = e
					Else
						out = Empty
					End If
				Case id_cpVar
					nm = Pattern_Var_name(p)
					v = lookup(nm, e)
					If isEmpty(v) Then
						&apos; TODO: what if var was bound to value Empty?!
						If isEmpty(x) Then
							Goto _match_cannot_bind_var_to_Empty
						End If
						out = extend(e, nm, x)
					Else
						&apos; tail-call:
						&apos;out = _matches(patConst(v), e, x)
						Goto _match_equ_test
					End If
				Case id_cpData
					pCtor = Pattern_Data_ctor(p)
					On Local Error Goto _match_type_error
					cx = _ctor(x)
					On Local Error Goto 0 &apos; disable error handler
					If DataValue_same(cx, pCtor) Then
						pArgs = Pattern_Data_args(p)
						out = _matchArgs(pArgs, e, x)
					Else
						Goto _match_require_same_datatype
					End If
				Case Else
					Goto _match_bad_pattern
			End Select

	End Select

_match_done:
	_match = out
	Exit Function

_match_bad_pattern:
	On Local Error Goto 0 &apos; disable error handler
	msg = &quot;match: bad pattern &quot; &amp; typeStr(p)
	If hasType(p, TPattern) Then
		msg = msg &amp; NL &amp; &quot;NYI?: &quot; &amp; ctorName(p)
	End If
	croak(msg)

_match_cannot_bind_var_to_Empty:
	On Local Error Goto 0 &apos; disable error handler
	msg = &quot;match: trying to bind var &quot; &amp; nm _
		&amp; &quot; to value Empty!&quot;
	croak(msg)

_match_require_same_datatype:
	If DataValue_same(typeCtorOf(cx), typeCtorOf(pCtor)) Then
	&apos; types are fine, just doesn&apos;t match
		out = Empty
		Goto _match_done
	End If
	Goto _match_type_error
				
_match_type_error:
	On Local Error Goto 0 &apos; disable error handler
	&apos;On Local Error Goto _match_fuck		
	msg = &quot;match: type error&quot; _
		&amp; &quot; - expected Data/&quot; &amp; typeCtorName(pCtor) _
		&amp; &quot;, not a &quot; &amp; typeStr(x)
	On Local Error Goto 0 &apos; disable error handler
	croak(msg)

End Function

Function _matchArgs( _
	ByVal ps As Object, _
	ByVal e  As Variant, _
	ByVal x  As Object _
)
	Dim i As Integer, p As Object, f As Variant
	Do Until(isNil(ps))
		p = car(ps)
		f = field(i, x)
		e = _match(p, e, f)
		If isEmpty(e) Then
			Exit Do
		End If
		i = i + 1
		ps = cdr(ps)
	Loop
	_matchArgs = e
End Function


Function [test_Pattern======================================]()
	test_Pattern_TPattern()
	test_Pattern_Any()
	test_Pattern_Var()
	test_Pattern_Const()
	test_Pattern_Data()
	
	test_Pattern_singletonPat()
	test_Pattern_patNil()
	&apos;test_Pattern_patCons()
	test_Pattern_patList()

	test_Pattern_isPattern()
	test_Pattern_toSrc_Any()
	test_Pattern_toSrc_Var()
	test_Pattern_toSrc_Const()
	test_Pattern_toSrc_lists()
	test_Pattern_toSrc_patterns()
	
	test_Pattern_toString()
	
	test_Pattern_match()
	test_Pattern_matches_Any()
	test_Pattern_matches_Const()
	test_Pattern_matches_Var()
	test_Pattern_matches_List()
	test_Pattern_matches_Pattern()
	
	&apos;test_Pattern_matches_ASN()
End Function

Function test_Pattern_TPattern()
	Dim tc : tc = TPattern
	Dim dcs
	assert_hasCtor(tc, Tp.DataTypeCtor).x
	dcs = dataCtors(tc)
	assertEqual(isList(dcs), True).x
	assertEqual(isNil(dcs), False).x
End Function

Function test_Pattern_Any()
	Dim cAny : cAny = findDataCtor(TPattern, &quot;Any&quot;)
	Dim vAny : vAny = patAny()
	assert_hasCtor(vAny, cAny).x
	&apos; returns the same value again:
	assert_same(patAny(), vAny).x
End Function

Function test_Pattern_Var()
	Dim cVar : cVar = findDataCtor(TPattern, &quot;Var&quot;)
	Dim vVar : vVar = patVar(&quot;foo&quot;)
	assert_hasCtor(vVar, cVar).x
	&apos; destructure:
	assertEqual(Pattern_Var_name(vVar), &quot;foo&quot;).x
	
	assertEqual(isFn(patVar()), True).x
	&apos;assertThrows(patVar, Array(1)).x	&apos; TODO: typecheck in applyDC
End Function

Function test_Pattern_Const()
	Dim cConst : cConst = findDataCtor(TPattern, &quot;Const&quot;)
	Dim vConst : vConst = patConst(42)
	assert_hasCtor(vConst, cConst).x
	&apos; destructure:
	assertEqual(Pattern_Const_value(vConst), 42).x

	assertEqual(Pattern_Const_value(patConst(Nothing)), Nothing).x
	assertEqual(Pattern_Const_value(patConst(Empty)), 	 Empty).x
	assertEqual(Pattern_Const_value(patConst(&quot;qmbl&quot;)),  &quot;qmbl&quot;).x
	
	assertEqual(isFn(patConst()), True).x
End Function

Function test_Pattern_Data()
	Dim cDat : cDat = findDataCtor(TPattern, &quot;Data&quot;)
	Dim cNil : cNil = Tp.List_Nil
	Dim vNil : vNil = nil
	Dim pNil : pNil = Pattern_Data(cNil, vNil)
	assert_hasCtor(pNil, cDat).x
	&apos; destructure:
	assert_same(Pattern_Data_ctor(pNil), cNil).x
	assert_same(Pattern_Data_args(pNil), vNil).x
	
	Dim c, args, p
	c = Tp.List_Cons
	args = List(patConst(1), pNil)
	p = Pattern_Data(c, args)
	assert_hasCtor(p, cDat).x
	&apos; destructure:
	assert_same(Pattern_Data_ctor(p), c).x
	assert_same(Pattern_Data_args(p), args).x
	
	&apos; expects a data ctor as 1st arg
	assertThrows(Pattern_Data, Array(TList, args)).x
	assertThrows(Pattern_Data, Array(vNil,  args)).x
	assertThrows(Pattern_Data, Array(&quot;foo&quot;, args)).x
	
	&apos; expects a List as 2nd arg
	assertThrows(Pattern_Data, Array(c, &quot;foo&quot;)).x
	
	&apos; expects a List of *Patterns* as 2nd arg
	assertThrows(Pattern_Data, Array(c, List(1, pNil))).x
	
	&apos; Pattern list must be same length as data ctor&apos;s argTypes
	assertThrows(Pattern_Data, Array(c, List(pNil))).x

	&apos; Patterns must be compatible with data ctor&apos;s argTypes:
	&apos;NYI: assertThrows(Pattern_Data, Array(c, List(pNil, pNil))).x
End Function

Function test_Pattern_singletonPat()
	Dim cNil  : cNil  = _ctor(nil)
	Dim cData : cData = _ctor(Pattern_Data(cNil, nil))
	Dim p
	p = singletonPat(nil)
	assert_hasCtor(p, cData).x
	assert_same(Pattern_data_ctor(p), cNil).x
	assert_same(Pattern_data_args(p), nil).x
End Function

Function test_Pattern_patNil()
	Dim cNil  : cNil  = Tp.List_Nil
	Dim cData : cData = _ctor(Pattern_Data(cNil, nil))
	Dim p
	p = patNil
	assert_hasCtor(p, cData).x
	assert_same(Pattern_data_ctor(p), cNil).x
	assert_same(Pattern_data_args(p), nil).x
	&apos; returns the same value again:
	assert_same(patNil, p).x
End Function

Function test_Pattern_patList()
	Dim cNil  : cNil  = Tp.List_Nil
	Dim cCons : cCons = Tp.List_Cons
	Dim cData : cData = _ctor(Pattern_Data(cNil, nil))
	Dim pAny  : pAny  = patAny
	Dim pNil  : pNil  = patNil
	Dim p, args
	p = patList()
	assert_hasCtor(p, cData).x
	assert_same(Pattern_data_ctor(p), cNil).x
	assert_same(Pattern_data_args(p), nil).x
	&apos; for empty list (pattern): returns the same value again:
	assert_same(patList(), p).x
	
	p = patList(pAny)
	assert_hasCtor(p, cData).x
	assert_same(Pattern_data_ctor(p), cCons).x
	args = Pattern_data_args(p)
	assertEqual(length(args), 2).x
	assert_same(car(args), pAny).x
	assert_same(cadr(args), pNil).x
	assert_same(cddr(args), nil).x
	
	Dim p1 : p1 = patConst(1)
	p = patList(pAny, p1)
	assert_hasCtor(p, cData).x
	assert_same(Pattern_data_ctor(p), cCons).x
	args = Pattern_data_args(p)
	assertEqual(length(args), 2).x
	assert_same(car(args), pAny).x
	p = cadr(args)
	assert_hasCtor(p, cData).x
	assert_same(Pattern_data_ctor(p), cCons).x
	args = Pattern_data_args(p)
	assertEqual(length(args), 2).x
	assert_same(car(args), p1).x
	p = cadr(args)
	assert_hasCtor(p, cData).x
	assert_same(p, pNil).x
	
	Dim pVar : pVar = patVar(&quot;x&quot;)
	p = patList(pAny, p1, pVar)
	assert_hasCtor(p, cData).x
	assert_same(Pattern_data_ctor(p), cCons).x
	args = Pattern_data_args(p)
	assertEqual(length(args), 2).x
	assert_same(car(args), pAny).x
	p = cadr(args)
	assert_hasCtor(p, cData).x
	assert_same(Pattern_data_ctor(p), cCons).x
	args = Pattern_data_args(p)
	assertEqual(length(args), 2).x
	assert_same(car(args), p1).x
	p = cadr(args)
	assert_hasCtor(p, cData).x
	assert_same(Pattern_data_ctor(p), cCons).x
	args = Pattern_data_args(p)
	assertEqual(length(args), 2).x
	assert_same(car(args), pVar).x
	p = cadr(args)
	assert_hasCtor(p, cData).x
	assert_same(p, pNil).x
End Function


Function test_Pattern_isPattern()
	assertEqual(isPattern(patAny),		True).x
	
	assertEqual(isPattern(patConst(Empty)), 	True).x
	assertEqual(isPattern(patConst(Nothing)), 	True).x
	assertEqual(isPattern(patConst(&quot;&quot;)), 		True).x
	assertEqual(isPattern(patConst(&quot;a&quot;)),		True).x
	
	assertEqual(isPattern(patVar(&quot;a&quot;)),		True).x
	assertEqual(isPattern(patVar(&quot;b&quot;)),		True).x

	assertEqual(isPattern(patNil),	True).x
	&apos;assert_hasType(patNil,	TPattern).x

	assertEqual(isPattern(Pattern_Data( _
		Tp.List_Cons, List(patAny, patAny))),	True).x

	assertEqual(isPattern(Empty),		False).x
	assertEqual(isPattern(Nothing),		False).x
	assertEqual(isPattern(True),		False).x
	assertEqual(isPattern(False),		False).x
	assertEqual(isPattern(&quot;&quot;),			False).x
	assertEqual(isPattern(&quot;foo&quot;),		False).x
	assertEqual(isPattern(0),			False).x
	assertEqual(isPattern(1),			False).x
	assertEqual(isPattern(4711),		False).x
	assertEqual(isPattern(CLng(4711)),	False).x
	assertEqual(isPattern(3.1415),		False).x
	
	Dim f As Object
	f = isPattern	&apos; &quot;partial&quot; application
	assertEqual(arity(f),				1).x
	
	assertEqual(apply(f, Empty),		False).x
	assertEqual(apply(f, Nothing),		False).x
	assertEqual(apply(f, True),			False).x
	assertEqual(apply(f, False),		False).x
	assertEqual(apply(f, &quot;&quot;),			False).x
	assertEqual(apply(f, &quot;foo&quot;),		False).x
	assertEqual(apply(f, 0),			False).x
	assertEqual(apply(f, 1),			False).x
	assertEqual(apply(f, 4711),			False).x
	assertEqual(apply(f, CLng(4711)),	False).x
	assertEqual(apply(f, 3.1415),		False).x
End Function

Function test_Pattern_toSrc_Any()
	Dim p : p = patAny
	assertEqual(TPattern_toSrc(p), &quot;_&quot;).x
End Function

Function test_Pattern_toSrc_Var()
	Dim p
	p = patVar(&quot;x&quot;)
	assertEqual(TPattern_toSrc(p), &quot;x&quot;).x
	p = patVar(&quot;y&quot;)
	assertEqual(TPattern_toSrc(p), &quot;y&quot;).x
	p = patVar(&quot;foo&quot;)
	assertEqual(TPattern_toSrc(p), &quot;foo&quot;).x
	&apos; TODO: patVar(&quot;_&quot;) ?! &lt;--------------------------
	assertEqual(TPattern_toSrc(patVar(&quot;_&quot;)), &quot;_&quot;).x
End Function

Function test_Pattern_toSrc_Const()
	Dim p As Object

	assertEqual(TPattern_toSrc(patConst(Empty)),		&quot;()&quot;			 ).x
	assertEqual(TPattern_toSrc(patConst(Nothing)),	toString(Nothing)).x
	assertEqual(TPattern_toSrc(patConst(True)),		toString(True)	 ).x
	assertEqual(TPattern_toSrc(patConst(False)),		toString(False)	 ).x
	assertEqual(TPattern_toSrc(patConst(&quot;&quot;)),			toString(&quot;&quot;)	 ).x
	assertEqual(TPattern_toSrc(patConst(&quot;a&quot;)),		toString(&quot;a&quot;)	 ).x
	assertEqual(TPattern_toSrc(patConst(&quot;foo&quot;)),		toString(&quot;foo&quot;)	 ).x
	assertEqual(TPattern_toSrc(patConst(CR)),			toString(CR)	 ).x
	assertEqual(TPattern_toSrc(patConst(LF)),			toString(LF)	 ).x
	assertEqual(TPattern_toSrc(patConst(TAB)),		toString(TAB)	 ).x
	assertEqual(TPattern_toSrc(patConst(    0)),		toString(0)		 ).x
	assertEqual(TPattern_toSrc(patConst(    1)),		toString(1)		 ).x
	assertEqual(TPattern_toSrc(patConst(    2)),		toString(2)		 ).x
	assertEqual(TPattern_toSrc(patConst( 4711)),		toString(4711)	 ).x
	assertEqual(TPattern_toSrc(patConst(3.1415)),		toString(3.1415) ).x
	assertEqual(TPattern_toSrc(patConst(CLng(42))),	toString(CLng(42))).x
	assertEqual(TPattern_toSrc(patConst(CLng(42))),	toString(42)	 ).x
End Function

Function test_Pattern_toSrc_lists()
	Dim pAny As Object : pAny = patAny
	Dim pNil As Object : pNil = patNil
	Dim varX As Object : varX = patVar(&quot;x&quot;)
	Dim varY As Object : varY = patVar(&quot;y&quot;)

	Dim p As Object

	p = pAny
	assertEqual(TPattern_toSrc(p),	&quot;_&quot;).x
	p = pNil
	assertEqual(TPattern_toSrc(p),	&quot;[]&quot;).x
	p = patList(pAny)
	assertEqual(TPattern_toSrc(p),	&quot;[_]&quot;).x
	p = patCons(pAny, pAny)
	assertEqual(TPattern_toSrc(p),	&quot;_:_&quot;).x
	p = patCons(pAny, patList(pAny))
	assertEqual(TPattern_toSrc(p),	&quot;[_, _]&quot;).x
	p = patCons(varX, pAny)
	assertEqual(TPattern_toSrc(p),	&quot;x:_&quot;).x
	p = patCons(varY, patCons(varX, pAny))
	assertEqual(TPattern_toSrc(p),	&quot;y:(x:_)&quot;).x
	p = patCons(varX, patNil)
	assertEqual(TPattern_toSrc(p),	&quot;[x]&quot;).x
	p = patList(varX, pAny)
	assertEqual(TPattern_toSrc(p),	&quot;[x, _]&quot;).x
	p = patCons(varX, pAny)
	assertEqual(TPattern_toSrc(p),	&quot;x:_&quot;).x
	p = patList(varX)
	assertEqual(TPattern_toSrc(p),	&quot;[x]&quot;).x
	p = patCons(varY, patList(varX, pAny))
	assertEqual(TPattern_toSrc(p),	&quot;[y, x, _]&quot;).x
	p = patList(varY, varX, pAny)
	assertEqual(TPattern_toSrc(p),	&quot;[y, x, _]&quot;).x
	p = patList(varY, pNil, pAny)
	assertEqual(TPattern_toSrc(p),	&quot;[y, [], _]&quot;).x
	p = patList(varY, patList(varX), pAny)
	assertEqual(TPattern_toSrc(p),	&quot;[y, [x], _]&quot;).x
	p = patList(varY, patCons(varX, pAny), pAny)
	assertEqual(TPattern_toSrc(p),	&quot;[y, x:_, _]&quot;).x
	p = patList(varY, patList(varX, pAny), pAny)
	assertEqual(TPattern_toSrc(p),	&quot;[y, [x, _], _]&quot;).x
	p = patList(varY, patList(patCons(varX, pAny)), pAny)
	assertEqual(TPattern_toSrc(p),	&quot;[y, [x:_], _]&quot;).x
	p = patList(varY, patList(varY, patCons(varX, pAny)), pAny)
	assertEqual(TPattern_toSrc(p),	&quot;[y, [y, x:_], _]&quot;).x
	p = patList(patCons(varY, pAny), patList(varY, patCons(varX, pAny)), pAny)
	assertEqual(TPattern_toSrc(p),	&quot;[y:_, [y, x:_], _]&quot;).x

End Function

Function test_Pattern_toSrc_patterns()
	Dim cAny   : cAny = _ctor(patAny)
	Dim cVar   : cVar = _ctor(patVar(&quot;x&quot;))
	Dim cConst : cConst = findDataCtor(TPattern, &quot;Const&quot;)
	Dim cData  : cData = findDataCtor(TPattern, &quot;Data&quot;)
	Dim p As Object
	
	&apos; patterns that match a pattern (patterns for a pattern)
	p = Pattern_Data(cAny, nil)
	assertEqual(TPattern_toSrc(p), &quot;Any&quot;).x
	
	p = Pattern_Data(cVar, List(patConst(&quot;x&quot;)))
	assertEqual(TPattern_toSrc(p), &quot;Var &apos;x&apos;&quot;).x
	p = Pattern_Data(cVar, List(patVar(&quot;x&quot;)))
	assertEqual(TPattern_toSrc(p), &quot;Var x&quot;).x
	
	&apos; pattern that matches a list of two Var patterns having the same varname:
	p = patList(p, p)
	assertEqual(TPattern_toSrc(p), &quot;[Var x, Var x]&quot;).x

	&apos; pattern that matches a Const pattern
	p = Pattern_Data(cConst, List(patConst(42)))
	assertEqual(TPattern_toSrc(p), &quot;Const 42&quot;).x

	&apos; pattern that matches a Data pattern
	p = Pattern_Data(cData, List(patVar(&quot;ctor&quot;), patVar(&quot;args&quot;))
	assertEqual(TPattern_toSrc(p), &quot;Data ctor args&quot;).x

	&apos; pattern to match a particular data ctor (as opposed to a value *of* that ctor)
	Dim cDataCtor : cDataCtor = Tp.DataCtor
	Dim cNil      : cNil = Tp.List_Nil
	p = Pattern_Data(cDataCtor, List( _
		patConst(nameOf(cNil)), _
		patVar(&quot;argTypes&quot;), _
		patVar(&quot;typeCtor&quot;) _
	))
	assertEqual(TPattern_toSrc(p), &quot;DataCtor &apos;Nil&apos; argTypes typeCtor&quot;).x

	&apos; pattern that matches a pattern that matches the empty list
	p = Pattern_Data(cData, List(p, patAny))
	assertEqual(TPattern_toSrc(p), _
		&quot;Data (DataCtor &apos;Nil&apos; argTypes typeCtor) _&quot;).x
End Function

Function test_Pattern_toString()
	Dim cAny   : cAny = _ctor(patAny)
	Dim cVar   : cVar = _ctor(patVar(&quot;x&quot;))
	Dim cConst : cConst = findDataCtor(TPattern, &quot;Const&quot;)
	Dim cData  : cData = findDataCtor(TPattern, &quot;Data&quot;)
	Dim p As Object
	
	p = patAny
	assertEqual(TPattern_toString(p), &quot;Pattern(&quot; &amp; TPattern_toSrc(p) &amp; &quot;)&quot;).x
	
	p = patConst(&quot;&quot;)
	assertEqual(TPattern_toString(p), &quot;Pattern(&quot; &amp; TPattern_toSrc(p) &amp; &quot;)&quot;).x
	p = patConst(42)
	assertEqual(TPattern_toString(p), &quot;Pattern(&quot; &amp; TPattern_toSrc(p) &amp; &quot;)&quot;).x
	
	p = patVar(&quot;x&quot;)
	assertEqual(TPattern_toString(p), &quot;Pattern(&quot; &amp; TPattern_toSrc(p) &amp; &quot;)&quot;).x
	p = patVar(&quot;y&quot;)
	assertEqual(TPattern_toString(p), &quot;Pattern(&quot; &amp; TPattern_toSrc(p) &amp; &quot;)&quot;).x
	
	
	p = Pattern_Data(cVar, List(patConst(&quot;x&quot;)))
	assertEqual(TPattern_toString(p), &quot;Pattern(&quot; &amp; TPattern_toSrc(p) &amp; &quot;)&quot;).x
	p = Pattern_Data(cVar, List(patVar(&quot;x&quot;)))
	assertEqual(TPattern_toString(p), &quot;Pattern(&quot; &amp; TPattern_toSrc(p) &amp; &quot;)&quot;).x
End Function


Function assert_matches(p As Object, env As Variant, ByVal vs As Variant)
	assert_matches = _match_assertions(p, env, vs, envEmpty) &apos; TODO: expect particular env
End Function

Function refute_matches(p As Object, env As Variant, ByVal vs As Variant)
	refute_matches = _match_assertions(p, env, vs, Empty)
End Function

Function _match_assertions(p As Object, env As Variant, ByVal vs As Variant, expected As Variant)
	If Not(isPattern(p)) Then
		croak(IIf(isEmpty(expected), &quot;refute&quot;, &quot;assert&quot;) &amp; &quot;_matches: invalid pattern &quot; &amp; toString(p))
	End If
	Dim testResult As Object
	Dim val As Variant, i As Integer, gotArray As Boolean
	gotArray = isArray(vs)
	If Not(gotArray) Then
		vs = Array(vs)
	End If
	For i = LBound(vs) To UBound(vs)
		testResult = _single_match_assertion(p, env, vs(i), expected, gotArray, i)
		If testResult.isFail Then
			Goto _match_assertions_end
		End If
	Next i
_match_assertions_end:
	_match_assertions = testResult
End Function

Function _single_match_assertion( _
	p As Object, _
	env As Variant, _
	val As Variant, _
	expected As Variant, _
	gotArray As Boolean, _
	i As Integer _
)
	Dim matchResult As Variant, testResult As Object
	matchResult = match(p, env, val)
	If isEmpty(matchResult) = isEmpty(expected) Then &apos; don&apos;t use assertEqual in order to avoid stupid MsgBox
		testResult = assertEqual(True, True) &apos; inc assertionCount
	Else
		Dim msg As String, valStr As String, pStr As String, eStr As String, mStr As String
		valStr = toString(val)
		pStr = toString(p)
		If isEmpty(env) Then : eStr = &quot;Empty (None)&quot;
		Else : eStr = Env_toString(env) : End If
		If isEmpty(matchResult) Then : mStr = &quot;Empty (None)&quot;
		Else : mStr = Env_toString(matchResult) : End If
		msg = &quot;pattern&quot; _
			&amp; NL &amp; &quot;  &quot; &amp; pStr _
			&amp; NL &amp; &quot;under env&quot; _
			&amp; NL &amp; &quot;  &quot; &amp; eStr _
			&amp; NL &amp; NL &amp; &quot;expected &quot; &amp; IIf(isEmpty(expected), &quot;NOT &quot;, &quot;&quot;) _
			&amp; &quot;to match value&quot; _
			&amp; NL &amp; &quot;of type &quot; &amp; typeStr(val) &amp; &quot;:&quot; _
			&amp; NL &amp; &quot;  &quot; &amp; valStr _
			&amp; NL &amp; NL &amp; &quot;but returned env&quot; _
			&amp; NL &amp; mStr
		If gotArray Then
			msg = &quot;at index &quot; &amp; i &amp; &quot;: &quot; _
				&amp; NL &amp; msg
		End If
		testResult = mkFail(matchResult, expected, msg)
	End If
	_single_match_assertion = testResult
End Function

Function test_Pattern_match()
	Dim f
	f = match
	assertEqual(arity(f), 3).x
	assertThrows(f, Array(Empty, Empty, Empty)).x
	
	f = match(patAny)
	assertEqual(arity(f), 2).x
	apply(f, Empty, Empty) &apos; should not throw
	apply(f, envEmpty, Empty) &apos; should not throw
	assertThrows(f, Array(Nothing, Empty)).x
	assertThrows(f, Array(&quot;foo&quot;, Empty)).x
	&apos; throws if given some fn as env:
	assertThrows(f, Array(f, Empty)).x
	
End Function

Function test_Pattern_matches_Any()
	Dim p As Object, f As Object, e As Variant
	f = match
	assertEqual(arity(f), 3).x

	p = patAny

	&apos; under env = Empty (None) it does not match anything:
	e = Empty
	refute_matches(p, e, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
	)).x
	refute_matches(p, e, Array( _
		nil, List(nil), List(1, 2, 3) _
	)).x
		
	e = envEmpty
	assert_matches(p, e, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
End Function

Function test_Pattern_matches_Const()
	Dim p As Object, f As Object, e As Variant
	p = patConst(Empty)

	&apos; under env = Empty (None) it does not match anything:
	e = Empty
	refute_matches(p, e, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	e = envEmpty
	assert_matches(p, e, Empty).x
	f = match(p, e)
	assert_toString_equals(apply(f, Empty), envEmpty).x
	refute_matches(p, e, Array( _
		       Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
		
	p = patConst(Nothing)
	&apos; under env = Empty (None) it does not match anything:
	e = Empty
	refute_matches(p, Empty, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	e = envEmpty
	assert_matches(p, e, Nothing).x
	
	&apos; TODO: decide what match should do if it wouldn&apos;t type-check
	&apos;refute_matches(p, e, Empty			).x
	&apos;refute_matches(p, e, nil			).x
	&apos;refute_matches(p, e, List(nil)		).x
	&apos;refute_matches(p, e, List(1, 2, 3)	).x
	&apos;refute_matches(p, e, Array( _
	&apos;	Empty, _
	&apos;	nil, List(nil), List(1, 2, 3) _
	&apos;)).x
	
	f = match(p, e)
	assertThrows(f, Array(      True)).x
	assertThrows(f, Array(     False)).x
	assertThrows(f, Array(         0)).x
	assertThrows(f, Array(         1)).x
	assertThrows(f, Array(         2)).x
	assertThrows(f, Array(      4711)).x
	assertThrows(f, Array(CLng(4711))).x
	assertThrows(f, Array(    3.1415)).x

	
	p = patConst(&quot;&quot;)
	&apos; under env = Empty (None) it does not match anything:
	e = Empty
	refute_matches(p, e, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	e = envEmpty
	assert_matches(p, e, &quot;&quot;).x
	refute_matches(p, e, Array( Empty, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot; )).x
	f = match(p, e)
	assertThrows(f, Array(   Nothing)).x
	assertThrows(f, Array(      True)).x
	assertThrows(f, Array(     False)).x
	assertThrows(f, Array(         0)).x
	assertThrows(f, Array(         1)).x
	assertThrows(f, Array(         2)).x
	assertThrows(f, Array(      4711)).x
	assertThrows(f, Array(CLng(4711))).x
	assertThrows(f, Array(    3.1415)).x	

		
	p = patConst(CInt(0))
	&apos; under env = Empty (None) it does not match anything:
	e = Empty
	refute_matches(p, e, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	e = envEmpty
	assert_matches(p, e, 0).x
	refute_matches(p, e, Array( _
		Empty, _
		1, 2, 3, -1, -2, -3, 4711 _
	)
	f = match(p, e)
	assertThrows(f, Array(   Nothing)).x
	assertThrows(f, Array(      True)).x
	assertThrows(f, Array(     False)).x
	assertThrows(f, Array(  CByte(0))).x
	assertThrows(f, Array(   CLng(0))).x
	assertThrows(f, Array(   CSng(0))).x
	assertThrows(f, Array(   CDbl(0))).x
	assertThrows(f, Array(       &quot;0&quot;)).x
	assertThrows(f, Array(CLng(4711))).x
	assertThrows(f, Array(    3.1415)).x	

End Function	
	
Function test_Pattern_matches_Var()
	Dim p As Object, f As Object, e As Variant
	
	p = patVar(&quot;a&quot;)
	&apos; under env = Empty (None) it does not match anything:
	e = Empty
	refute_matches(p, e, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x

	e = envEmpty
	assert_matches(p, e, Array( _
		       Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	&apos; the value Empty poses a problem:
	assertThrows(match, Array(p, e, Empty)).x
	
	&apos; bind the var &quot;a&quot; to the value &quot;foo&quot;:
	e = match(p, envEmpty, &quot;foo&quot;)
	&apos; under this env var-pattern &quot;a&quot; matches only &quot;foo&quot;:
	assert_matches(p, e, 		&quot;foo&quot;).x
	refute_matches(p, e, 		&quot;bar&quot;).x
	&apos; but under an env where &quot;a&quot; isn&apos;t bound it still matches anything
	e = extend(envEmpty, &quot;b&quot;, &quot;foo&quot;)
	assert_matches(p, e, &quot;foo&quot;).x
	assert_matches(p, e, &quot;bar&quot;).x
	
	&apos; again, bind the var &quot;a&quot; to the value &quot;foo&quot; (a String):
	e = match(p, envEmpty, &quot;foo&quot;)
	f = match(p, e)
	&apos; so these yield type errors:
	assertThrows(f, Array(   Nothing)).x
	assertThrows(f, Array(      True)).x
	assertThrows(f, Array(     False)).x
	assertThrows(f, Array(         0)).x
	assertThrows(f, Array(         1)).x
	assertThrows(f, Array(         2)).x
	assertThrows(f, Array(      4711)).x
	assertThrows(f, Array(CLng(4711))).x
	assertThrows(f, Array(    3.1415)).x	
End Function	
	
Function test_Pattern_matches_List()
	Dim p As Object, f As Object, e As Variant
	f = match
	e = envEmpty
	
	&apos; pattern of the empty list
	p = patNil
	assert_matches(p, e, nil).x
	refute_matches(p, e, List(nil)).x
	f = match(p, e)
	&apos; throws if x isn&apos;t a List:
	assertThrows(f, Array(&quot;foo&quot;))
	&apos; Pattern_Any is a Pattern, NOT a List!
	assertThrows(f, Array(patAny))
	
	&apos; pattern of a non-empty list
	Dim varX  : varX  = patVar(&quot;x&quot;)
	Dim varXs : varXs = patVar(&quot;xs&quot;)
	Dim v
	p = patCons(varX, varXs)
	refute_matches(p, e, nil).x
	v = List(nil)
	match(p, e, v)
	assert_matches(p, e, List(nil)				).x
	assert_matches(p, e, List(nil, nil)			).x
	assert_matches(p, e, List(1)				).x
	assert_matches(p, e, List(1, 2, 3)			).x
	assert_matches(p, e, List(&quot;a&quot;)				).x
	assert_matches(p, e, List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)	).x
	
	&apos; pattern of a list where hd = tl (so hd must be a list, too)
	p = patCons(varX, varX)	&apos; Note: same arg twice!
	refute_matches(p, e, nil					).x
	assert_matches(p, e, List(nil)				).x
	refute_matches(p, e, List(nil, nil)			).x
	assert_matches(p, e, List(List(nil), nil)	).x
	assert_matches(p, e, List(List(1), 1)		).x
	refute_matches(p, e, List(List(1), 2)		).x
	assert_matches(p, e, List(List(1, 2), 1, 2)	).x
	&apos;refute_matches(p, e, List(1)				).x	&apos; does not type-check (x:1 matched against a list)
	&apos;refute_matches(p, e, List(1, 2, 3)			).x &apos; -&quot;-
	&apos;assert_matches(p, e, List(&quot;a&quot;)				).x &apos; -&quot;-
	&apos;refute_matches(p, e, List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)	).x &apos; -&quot;-
	&apos;refute_matches(p, e, List(List(1), List(1))	).x &apos; does not type-check
	
	&apos; pattern of a singleton list
	p = patCons(varX, patNil)
	refute_matches(p, e, nil).x
	assert_matches(p, e, List(nil)				).x
	refute_matches(p, e, List(nil, nil)			).x
	assert_matches(p, e, List(1)				).x
	refute_matches(p, e, List(1, 2, 3)			).x
	assert_matches(p, e, List(&quot;a&quot;)				).x
	refute_matches(p, e, List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)	).x
	
	&apos; pattern of a list with first two elems equal
	p = patCons(varX, patCons(varX, patAny))
	refute_matches(p, e, nil).x
	refute_matches(p, e, List(nil)				).x
	assert_matches(p, e, List(nil, nil)			).x
	refute_matches(p, e, List(1)				).x
	assert_matches(p, e, List(1, 1)				).x
	refute_matches(p, e, List(1, 2)				).x
	assert_matches(p, e, List(1, 1, 3)			).x
	refute_matches(p, e, List(1, 2, 3)			).x
	assert_matches(p, e, List(1, 1, 2, 3)		).x
End Function	
	
Function test_Pattern_matches_Pattern()
	Dim p As Object, f As Object, e As Variant, eOut As Variant
	Dim pAny      : pAny      = patAny
	Dim cpAny     : cpAny     = _ctor(pAny)
	Dim pVarX     : pVarX     = patVar(&quot;x&quot;)
	Dim pVarY     : pVarY     = patVar(&quot;y&quot;)
	Dim cpVar     : cpVar     = _ctor(pVarX)
	Dim pConst42  : pConst42  = patConst(42)
	Dim pConstFoo : pConstFoo = patConst(&quot;Foo&quot;)
	Dim cpConst   : cpConst   = _ctor(pConst42)
	Dim pNil      : pNil      = patNil
	Dim cpNil     : cpNil     = _ctor(pNil)
	Dim vNil      : vNil      = nil
	Dim cNil      : cNil	  = _ctor(vNil)
	Dim cCons     : cCons     = Tp.List_Cons
	Dim cDataCtor : cDataCtor = Tp.DataCtor
	
	e = envEmpty
	
	p = Pattern_Data(cpAny, nil)
	Dim cpData : cpData = _ctor(p)
	
	assert_matches(p, e, pAny		).x
	refute_matches(p, e, pVarX		).x
	refute_matches(p, e, pVarY		).x
	refute_matches(p, e, pConst42	).x
	refute_matches(p, e, pConstFoo	).x
	refute_matches(p, e, p			).x &apos; p isa Pattern_Data
	refute_matches(p, e, pNil		).x &apos; pNil isa Pattern_Data
	
	p = Pattern_Data(cpVar, List(pVarX))
	refute_matches(p, e, pAny		).x
	assert_matches(p, e, pVarX		).x
	assert_matches(p, e, pVarY		).x
	refute_matches(p, e, pConst42	).x
	refute_matches(p, e, pConstFoo	).x
	refute_matches(p, e, p			).x &apos; p isa Pattern_Data
	refute_matches(p, e, pNil		).x &apos; pNil isa Pattern_Data
	
	p = Pattern_Data(cpConst, List(pVarX))
	refute_matches(p, e, pAny		).x
	refute_matches(p, e, pVarX		).x
	refute_matches(p, e, pVarY		).x
	assert_matches(p, e, pConst42	).x
	assert_matches(p, e, pConstFoo	).x
	refute_matches(p, e, p			).x &apos; p isa Pattern_Data
	refute_matches(p, e, pNil		).x &apos; pNil isa Pattern_Data
	
	&apos; match any Data pattern
		&apos; Data x y -&gt; ...
	p = Pattern_Data(cpData, List(pVarX, pVarY))
	refute_matches(p, e, pAny		).x
	refute_matches(p, e, pVarX		).x
	refute_matches(p, e, pVarY		).x
	refute_matches(p, e, pConst42	).x
	refute_matches(p, e, pConstFoo	).x
	assert_matches(p, e, p			).x &apos; p isa Pattern_Data
	eOut = match(p, e, p)
	assert_same(lookup(&quot;x&quot;, eOut), Pattern_Data_ctor(p)).x
	assert_same(lookup(&quot;y&quot;, eOut), Pattern_Data_args(p)).x
	
	
	assert_matches(p, e, pNil		).x &apos; pNil isa Pattern_Data
	eOut = match(p, e, pNil)
	assert_same(lookup(&quot;x&quot;, eOut), Pattern_Data_ctor(pNil)).x
	assert_same(lookup(&quot;y&quot;, eOut), Pattern_Data_args(pNil)).x
	
	&apos; match a Data pattern for singletons
	&apos; Data x [] -&gt; ...
	p = Pattern_Data(cpData, List(pVarX, pNil))
	refute_matches(p, e, pAny		).x
	refute_matches(p, e, pVarX		).x
	refute_matches(p, e, pVarY		).x
	refute_matches(p, e, pConst42	).x
	refute_matches(p, e, pConstFoo	).x
	&apos; p isa Pattern_Data but it has non-nil argPatterns:
	refute_matches(p, e, p			).x
	&apos; pNil isa Pattern_Data with nil argPatterns:
	assert_matches(p, e, pNil		).x
	&apos; pNil = Pattern_Data(cNil, nil)
	assert_matches(p, e, Pattern_Data(cNil, vNil)	).x
	eOut = match(p, e, pNil)
	assert_same(lookup(&quot;x&quot;, eOut), Pattern_Data_ctor(pNil)).x
	&apos; cpAny is a singleton data ctor, too
	assert_matches(p, e, Pattern_Data(cpAny, vNil)	).x
	eOut = match(p, e, Pattern_Data(cpAny, vNil))
	assert_same(lookup(&quot;x&quot;, eOut), cpAny).x

	&apos; match the singleton data ctor for the empty list nil
	&apos; (by its name and the fact that it&apos;s a singleton data ctor)
	&apos; DataCtor &quot;Nil&quot; [] _ -&gt; ...
	p = Pattern_Data(cDataCtor, List( _
		patConst(nameOf(cNil)), _
		pNil, _
		pAny _
	))
	&apos;refute_matches(p, e, pAny		).x	&apos; does not type-check
	&apos;refute_matches(p, e, pVarX		).x	&apos; does not type-check
	&apos;refute_matches(p, e, pVarY		).x	&apos; does not type-check
	&apos;refute_matches(p, e, pConst42	).x	&apos; does not type-check
	&apos;refute_matches(p, e, pConstFoo	).x	&apos; does not type-check
	&apos;refute_matches(p, e, p			).x	&apos; does not type-check
	&apos;refute_matches(p, e, pNil		).x	&apos; does not type-check
	refute_matches(p, e, cpAny		).x
	refute_matches(p, e, cpVar		).x
	refute_matches(p, e, cpConst	).x
	refute_matches(p, e, cpData		).x
	refute_matches(p, e, cCons		).x
	assert_matches(p, e, cNil		).x
	
	&apos; match a Data pattern that matches the empty list nil
	Dim pNilCtor : pNilCtor = p
	&apos; Data (DataCtor &quot;Nil&quot; [] _) _
	p = Pattern_Data(cpData, List(pNilCtor, pAny))
	assertEqual(TPattern_toSrc(p), &quot;Data (DataCtor &apos;Nil&apos; [] _) _&quot;).x
	refute_matches(p, e, pAny		).x
	refute_matches(p, e, pVarX		).x
	refute_matches(p, e, pVarY		).x
	refute_matches(p, e, pConst42	).x
	refute_matches(p, e, pConstFoo	).x
	refute_matches(p, e, p			).x
	assert_matches(p, e, pNil		).x
	&apos; pNil = Pattern_Data(cNil, nil)
	assert_matches(p, e, Pattern_Data(cNil, nil)	).x
	
End Function
	
Function test_Pattern_matches_ASN()
	Dim p As Object, f As Object, e As Object, v As Object
	Dim act As Variant
	Dim x As Object, w As Object
	f = matches
	e = envEmpty

	v = mkDtTerminal(&quot;Foo&quot;)
	p = patASN(patAny, patAny, patList_nil)
	assert_matches(p, e, v).x
	p = patASN(patVal(Empty), patVar(&quot;val&quot;), patList_nil)
	assert_matches(p, e, v).x
	e = matches(p, e, v)
	assertEqual(lookup(&quot;val&quot;, e), &quot;Foo&quot;).x
	

	&apos;ASN &quot;Alt&quot;  () [x]        -&gt; x
	p = patASN(patVal(&quot;Alt&quot;), patVal(Empty), patList_cons(patVar(&quot;x&quot;), patList_nil))
	v = mkDtNonterminal(&quot;Con&quot;, List(mkDtNonterminal(&quot;Atom&quot;, List(mkASN(&quot;Terminal&quot;, &quot;foo&quot;, nil)))))
	e = envEmpty
	refute_matches(p, e, v).x
	v = mkDtNonterminal(&quot;Alt&quot;, List(v))
	assert_matches(p, e, v).x
	e = matches(p, e, v)
	assertEqual(isASN(lookup(&quot;x&quot;, e)), True).x
	assert_toString_equals(lookup(&quot;x&quot;, e), asnChild(v, 0)).x
	
	&apos;ASN lbl    () [ASN () val []] -&gt; ASN lbl v []
	&apos;inner one first:
	p = patASN(patVal(Empty), patVar(&quot;val&quot;), patList_nil)
	p = patASN(patVar(&quot;lbl&quot;), patVal(Empty), patList_cons(p, patList_nil))
	v = mkDtNonTerminal(&quot;Foo&quot;, List(mkDtTerminal(&quot;bar&quot;)))
	e = envEmpty
	assert_matches(p, e, v).x
	e = matches(p, e, v)
	assertEqual(lookup(&quot;lbl&quot;, e), &quot;Foo&quot;).x
	assertEqual(lookup(&quot;val&quot;, e), &quot;bar&quot;).x
	
	w = xpApp( _
			xpApp( _
				xpApp( _
					xpBuiltin(mkASN), _
					xpVar(&quot;lbl&quot;) _
				), _
				xpVar(&quot;val&quot;) _
			), xpVal(nil) _
		)
	w = evalX(w, e)
	&apos;show(v)
	&apos;show(w)
	assert_toString_equals(w, mkASN(&quot;Foo&quot;, &quot;bar&quot;, nil)).x
		
	&apos;ASN &quot;Con&quot;  () [x]        -&gt; x
	&apos;ASN &quot;Atom&quot; () [x]        -&gt; x
	
End Function	


</script:module>