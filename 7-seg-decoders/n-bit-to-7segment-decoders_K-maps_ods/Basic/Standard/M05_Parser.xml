<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M05_Parser" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit

Const TParser_tyname = &quot;TParser&quot;

Type Parser
	tyname As String
	id As Integer
	tp As String
	st As Variant
	st0 As Variant
	st1 As Variant
	st2 As Variant
	st3 As Variant
	st4 As Variant
	str As String
	typ As String
End Type

Public applyP_callCount 			As Integer
Public _applyP_callCount(0 To 1) 	As Integer
Public applyP_return 				As Integer
Public applyP_fail 					As Integer
Public applyP_item 					As Integer
Public applyP_bind 					As Integer
Public applyP_bind_K_x 				As Integer
Public applyP_bind_K_return 		As Integer
Public applyP_bind_B_f_g 			As Integer
Public applyP_bind_B_return_g 		As Integer
Public applyP_bind_other 			As Integer
Public applyP_choice 				As Integer
Public applyP_zeroOrOne 			As Integer
Public applyP_many1 				As Integer
Public applyP_str 					As Integer
Public applyP_seq 					As Integer
Public applyP_skip 					As Integer
Public applyP_sat 					As Integer
Public applyP_end 					As Integer
Public applyP_ind 					As Integer

Sub Main
	test_Parser()
	Stop
	Dim s As String
	Set pHexLit = pSeq(Array(pStr(&quot;0x&quot;), pHexNum), &quot;sndArg&quot;)
	Dim p As Parser 
	&apos;pChoice(pItem(), pReturn(&quot;bar&quot;))
	Set p = pSeq(Array(pHexLit, pMany(pWhite)), &quot;fstArg&quot;)
	s = &quot;FF 0x1F __µ 0&quot;

	MsgBox( _
		&quot;applying parser &apos;&quot; &amp; p.tp &amp; &quot;&apos; to &quot; &amp; toString(s) &amp; &quot;: &quot; &amp; CR _
		&amp; toString(applyP(p, s)) _
	)
End Sub

&apos;==================================================================

Function isParser(x As Variant)
	isParser = (typeOf(x) = typeOf(pFail))
End Function


&apos; TODO: TParser_toString: seriously work out where to put parens and where not
Function TParser_toString(Optional ByVal p As Variant)
	Dim result As Variant
	If isMissing(p) Then
		result = Fn.TParser_toString
	Else
		If isString(p) Then
			p = lookupParser(p)
		End If
		Dim rules As Object, seen As Object
		rules = nil
		seen = nil
		result = _TParser_toString(p, 0, &quot;&quot;, False, rules, seen)
		If Not(isNil(rules)) Then
			Dim newLine As String
			newLine = NL
			result = result &amp; &quot; where&quot; &amp; NL _
				   &amp; Join(toArray(rules), NL)
		End If
		While Not(isNil(seen))
			car(seen).st2 = False
			seen = cdr(seen)
		Wend
	End If
	TParser_toString = result
End Function

Function _TParser_toString( _
	ByVal p As Object, _
	ByRef k As Integer, _
	ByVal indent As String, _
	ByVal isNewLines As Boolean, _
	ByRef rules As Object, _
	ByRef seen As Object _
)
	Dim result As String, f As Object
	Dim q As Object
	If p.str &lt;&gt; &quot;&quot; Then
		result = p.str
	ElseIf isPMany(p) Then
		&apos; it has shape (many1 q)?
		q = p.st0.st0
		If (q.tp = &quot;choice&quot;) Or (q.tp = &quot;bind&quot;) Then
			result = &quot;(&quot; &amp; _TParser_toString( _
						q, k, indent &amp; &quot; &quot;, False, rules, seen) _
				   &amp; &quot;)&quot;
		Else
			result = _TParser_toString( _
						q, k, indent, False, rules, seen)
		End If
		result = result &amp; &quot;*&quot;
	ElseIf isPZeroOrOne(p) Then
		q = p.st0
		If (q.tp = &quot;choice&quot;) Or (q.tp = &quot;bind&quot;) Then
			result = &quot;(&quot; &amp; _TParser_toString( _
						q, k, indent &amp; &quot; &quot;, False, rules, seen) _
				   &amp; &quot;)&quot;
		Else
			result = _TParser_toString( _
						q, k, indent, False, rules, seen)
		End If
		result = result &amp; &quot;?&quot;
	Else : Select Case p.tp
		Case &quot;ind&quot;
			Dim name As String
			name = getPIndName(p)
			If p.st2 Then &apos; seen it before
				result = name
			ElseIf isNull(p.st0) Then &apos; yet uninitialized indirection
				result = &quot;(ind &quot; &amp; p.st1 &amp; &quot; Nothing)&quot;	&apos; p.st1 &apos; contains a name like Rule_123
			Else &apos; initialized but not seen before
				p.st2 = True	&apos; set the &quot;visited&quot;-mark
				seen = cons(p, seen)
				result = name &amp; &quot; ::= &quot;
				&apos; In the new rule, start over fresh indent and var counter
				indent = Space(Len(result))
				Dim j As Integer
				j = 0
				result = result &amp; _TParser_toString( _
					p.st0, j, indent, True, rules, seen)
				rules = cons(result, rules)
				result = name	&apos; just return the name
			End If
		Case &quot;sat&quot;
			result = &quot;(sat &quot;
			If isPartialApp(p.st) Then
				result = result &amp; &quot;(&quot; &amp; TFn_toString(p.st) &amp; &quot;)&quot;
			Else
				result = result &amp; getFnName(p.st)
			End If
			result = result &amp; &quot;)&quot;
		Case &quot;fail&quot;:		result = &quot;fail&quot;
		Case &quot;return&quot;:		result = &quot;(return &quot; &amp; toString(p.st) &amp; &quot;)&quot;
		Case &quot;item&quot;: 		result = &quot;item&quot;
		Case &quot;str&quot;:			result = &quot;(str &quot; &amp; toString(p.st(0)) &amp; &quot;)&quot;
		Case &quot;strXXX&quot;:			result = toString(p.st(0))
		Case &quot;skip&quot;
			result = &quot;(skip &quot; &amp; _TParser_toString( _
						p.st, k, indent, False, rules, seen) _
				   &amp; &quot;)&quot;
		Case &quot;many1&quot;
			If (p.st.tp) = &quot;choice&quot; Or (p.st.tp = &quot;bind&quot;) Then
				result = &quot;(&quot; &amp; _TParser_toString( _
							p.st, k, indent &amp; &quot; &quot;, False, rules, seen) _
					   &amp; &quot;)&quot;
			Else
				result = _TParser_toString( _
					p.st, k, indent, False, rules, seen)
			End If
			result = result &amp; &quot;+&quot;
		Case &quot;choice&quot;
			Dim altL As Object, altR As Object
			altL = p.st0
			altR = p.st1
			Dim altLStr As String, altRStr As String
			If isNewLines Then
				altLStr = _TParser_toString( _
							altL, k, indent, isNewLines, rules, seen)
				altRStr = _TParser_toString( _
							altR, k, indent, isNewLines, rules, seen)	
				result = altLStr _
					   &amp; NL _
					   &amp; space(len(indent) - 2) _
					   &amp; &quot;| &quot; _
					   &amp; altRStr
			Else
				altLStr = _TParser_toString( _
							altL, k, indent, isNewLines, rules, seen)
				altRStr = _TParser_toString( _
							altR, k, indent, isNewLines, rules, seen)
				If altL.tp = &quot;bind&quot; Then
					altLStr = &quot;(&quot; &amp; altLStr &amp; &quot;)&quot;
				End If
				If altR.tp = &quot;bind&quot; Then
					altRStr = &quot;(&quot; &amp; altRStr &amp; &quot;)&quot;
				End If
				result = altLStr _
					   &amp; &quot; | &quot; _
					   &amp; altRStr
			End If
		Case &quot;bind&quot;
			q = p.st(0)
			f = p.st(1)
			result = _TParser_toString(q, k, indent, False, rules, seen) _
				   &amp; &quot; &gt;&gt;= &quot;
			If isKsomething(f) Then
				q = car(partialArgs(f)) &apos; peel off the K
				If isKreturn(f) Then
					Dim v As Variant			
					v = q.st &apos; peel off the pReturn
					result = result &amp; &quot;\_.return &quot; &amp; toString(v)
				Else
					result = result &amp; &quot;\_.&quot; &amp; _TParser_toString( _
						q, k, indent, False, rules, seen)
				End If
			Else
				If isBreturn(f) Then
					f = car(partialArgs(f)) &apos; get out B&apos;s 2nd arg (they&apos;re in reverse!)
					result = result &amp; &quot;return ° &quot;
				End If
				result = result &amp; TFn_toString(f)
				result = &quot;(&quot; &amp; result &amp; &quot;)&quot;
			End If
		Case &quot;seq&quot;
			Dim ps As Variant, i As Integer
			Dim fName As String, args As Object, argsStr As String
			ps = p.st(0)
			f  = p.st(1)
			fName = getFnName(f)
			args = nil
			result = &quot;(do &quot;
			Dim addIndent As String, newLine As String, innerIndent As String
			addIndent = Space(Len(result))
			newLine = NL &amp; indent
			innerIndent = indent &amp; addIndent &amp; Space(Len(&quot;aX &lt;- &quot;))
			For i = LBound(ps) To UBound(ps)
				If isPSkip(ps(i)) Then
					If ps(i).st.tp = &quot;choice&quot; Then
						isNewLines = True
					Else
						isNewLines = False
					End If
					result = result _
						   &amp; &quot; _ &lt;- &quot; _
						   &amp; _TParser_toString( _
						   	ps(i).st, k, innerIndent, isNewLines, rules, seen)
				Else
					If ps(i).tp = &quot;choice&quot; Then
						isNewLines = True
					Else
						isNewLines = False
					End If
					result = result &amp; &quot;a&quot; &amp; k
					args = cons(&quot;a&quot; &amp; k, args)
					k = k + 1
					result = result _
						   &amp; &quot; &lt;- &quot; _
						   &amp; _TParser_toString( _
						   	ps(i), k, innerIndent, isNewLines, rules, seen)
				End If
				result = result &amp; newLine
				If i &lt; UBound(ps) Then
					result = result &amp; addIndent
				End If
			Next i
			result = result &amp; &quot; return&quot;
			If isApplyToListSomething(f) Then
				argsStr = &quot; &quot; &amp; Join(toArray(reverse(args)), &quot; &quot;)
				If isApplyToListId(f) Then
					result = result &amp; argsStr
				Else
					result = result _
						   &amp; &quot; (&quot; _
						   &amp; TFn_toString(car(partialArgs(f))) &amp; argsStr _
						   &amp; &quot;)&quot;
				End If
			Else
				argsStr = &quot; [&quot; &amp; Join(toArray(reverse(args)), &quot;, &quot;) &amp; &quot;]&quot;
				If fName = getFnName(Fn.id) Then
					result = result &amp; argsStr
				Else
					result = result &amp; &quot; (&quot; &amp; TFn_toString(f) &amp; argsStr &amp; &quot;)&quot;
				End If
			End If
			result = result &amp; newLine &amp; &quot;)&quot;
		Case Else
			croak(&quot;TParser_toString/NYI: .tp = &quot; &amp; toString(p.tp))
	End Select : End If
	_TParser_toString = result
End Function

Function mkParser(Optional tp As String, Optional st As Variant)
	Static oFn As Object
	Static instId As Long
	Dim result As Object
	If isMissing(st) Then
		If isNull(oFn) Then : Set oFn = Fn.mkParser : End If
		If isMissing(tp) Then
			result = oFn
		Else
			result = apply1(oFn, tp)
		End If
	Else
		Set result = New Parser
		result.tyname = TParser_tyname
		result.id = instId
		instId = instId + 1
		result.tp = tp
		result.st = st
	End If
	mkParser = result
End Function

Function parseFailure()
	parseFailure = Empty
End Function

Function isParseFailure(parseResult) As Boolean
	isParseFailure = isEmpty(parseResult)
&apos;	If typeOf(parseResult) &lt;&gt; typeOf(parseFailure) Then
&apos;		isParseFailure = False
&apos;	Else
&apos;		isParseFailure = equ(parseResult, parseFailure)
&apos;	End If
End Function

&apos; always fails on any string; failure is indicated by returning parseFailure()
Function pFail()
	Static result As Object
	If isNull(result) Then : result = mkParser(&quot;fail&quot;, Nothing) : End If
	pFail = result
End Function

&apos; always succeeds by returning the provided value; without increasing pos
Function pReturn(Optional v As Variant)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.pReturn : End If
	Static returnEmpty As Object : If isNull(returnEmpty) Then
		returnEmpty = mkParser(&quot;return&quot;, Empty)
		returnEmpty.st0 = Empty
	End If
	Dim out As Variant
	If isMissing(v) Then
		out = oFn
	ElseIf isEmpty(v) Then
		out = returnEmpty
	Else
		out = mkParser(&quot;return&quot;, v)
		out.st0 = v
	End If
	pReturn = out
End Function

&apos; monadic bind, aka &quot;&gt;&gt;=&quot;
&apos; for the Parser type that is the fn of type Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b
&apos; which applies the Parser p and if that succeeds feeds its result to the fn f
&apos; to give the overall result Parser b that f returns
Function pBind(Optional ByVal p As Parser, Optional ByVal f As Object)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.pBind : End If
	Dim result As Variant
	If isMissing(f) Then
		If isMissing(p) Then
			result = oFn
		Else
			&apos; TODO: pBind: check if p is proper Parser
			result = apply(oFn, p)
		End If
	Else
	&apos; In general: (q &gt;&gt;= return ° g) &gt;&gt;= f
	&apos;            = q &gt;&gt;= f ° g
	&apos;        and: (K v) ° g
	&apos;            = K v
	&apos;        and: f ° (K v)
	&apos;            = K (f v)
		Dim q As Object, g As Object, v As Object	
		If p.tp = &quot;fail&quot; Then &apos;   fail &gt;&gt;= f
			pBind = p         &apos; = fail        
			Exit Function
		ElseIf p.tp = &quot;return&quot; Then &apos;  (return v) &gt;&gt;= f
			pBind = apply(f, p.st0) &apos; = (f v)
			Exit Function
		ElseIf p.tp = &quot;bind&quot; Then
			If p.st2 = 3 Then &apos;  (q &gt;&gt;= return ° g) &gt;&gt;= f
							  &apos; = q &gt;&gt;= f ° g
				f = compose(f, p.st3) &apos; the g has been stored in p.st3
				p = p.st0
			ElseIf p.st2 = 2 Then
				&apos;  (q &gt;&gt;= K (return v)) &gt;&gt;= f
				&apos; = q &gt;&gt;= K (f v)
				f = fstArg(apply(f, p.st3)) &apos; the v has been stored in p.st3
				p = p.st0
			ElseIf p.st2 = 1 Then
				&apos;  (q &gt;&gt;= K r) &gt;&gt;= f  [where r is a Parser]
				&apos; = q &gt;&gt;= K (r &gt;&gt;= f)
				f = fstArg(pBind(p.st3, f)) &apos; the r has been stored in p.st3
				p = p.st0
			Else &apos; p has general shape q &gt;&gt;= g
				q = p.st0
				g = p.st1
				croak(&quot;NYI: p = pBind (q &gt;&gt;= g) f; p.st2: &quot; &amp; p.st2 _
					&amp; NL &amp; NL &amp; &quot;q: &quot; &amp; toString(q) _
					&amp; NL &amp; NL &amp; &quot;g: &quot; &amp; toString(g) _
					&amp; NL &amp; NL &amp; &quot;f: &quot; &amp; toString(f) _
				)
			End If
		End If

		bindStats(p, f)
		&apos; TODO: pBind: check if f is proper function
		result = mkParser(&quot;bind&quot;, Array(p, f))
		result.st0 = p
		result.st1 = f
		&apos; Classify this bind s.t. we can optimize in subsequent
		&apos; binds and also specialize in _applyP:
		If isKsomething(f) Then
			v = car(partialArgs(f)) &apos; peel off K	
			If isKreturn(f) Then
				result.st2 = 2
				result.st3 = v.st &apos; peel off pReturn
			Else
				result.st2 = 1
				result.st3 = v	&apos; the subsequent parser
			End If
		ElseIf isBreturn(f) Then
			g = car(partialArgs(f))		&apos; get out B&apos;s 2nd arg (they&apos;re in reverse!)
			result.st2 = 3
			result.st3 = g	&apos; g produces the overall result value of the bind
		Else
			result.st2 = 0
		End If
	End If
	pBind = result
End Function

Function isKsomething(f As Object) As Boolean
	isKsomething = (getFnName(f) = getFnName(Fn.fstArg)) And (arity(f) = 1)
End Function

Function isKreturn(f As Object) As Boolean
	Dim result As Boolean
	result = False
	If isKsomething(f) Then
		Dim v As Object
		v = car(partialArgs(f))
		If v.tp = &quot;return&quot; Then
			result = True
		End If
	End If
	isKreturn = result
End Function

Function isKEmpty(f As Object) As Boolean
	Dim result As Boolean
	result = False
	If isKsomething(f) Then
		Dim a0 As Variant
		a0 = car(partialArgs(f))
		result = isEmpty(a0)
	End If
	isKEmpty = result
End Function

Function isBsomething(f As Object) As Boolean
	isBsomething = (getFnName(f) = getFnName(Fn.compose)) And (arity(f) = 1)
End Function

Function isBreturn(f As Object) As Boolean
	Dim result As Boolean
	result = False
	If isBsomething(f) Then
		Dim v As Object
		v = cadr(partialArgs(f)) &apos; they&apos;re in reverse!
		result = (getFnName(v) = getFnName(Fn.pReturn))
	End If
	isBreturn = result
End Function

Function isApplyToListSomething(f As Object) As Boolean
	isApplyToListSomething = (getFnName(f) = getFnName(Fn.applyToList)) _
		And (arity(f) = 1)
End Function

Function isApplyToListId(f As Object) As Boolean
	Dim result As Boolean
	result = False
	If isApplyToListSomething(f) Then
		Dim g As Object
		g = car(partialArgs(f))
		result = (getFnName(g) = getFnName(Fn.id))
	End If
	isApplyToListId = result
End Function

Function bindFns(Optional f As Object)
	Static fns As Object : If isNull(fns) Then : fns = nil : End If
	If isMissing(f) Then
		Dim x As Object, xs As Object, out As Object, xStr As String
		xs = fns
		out = nil
		While Not(isNil(xs))
			x = car(xs)
			If isKsomething(x) Then
				x = car(partialArgs(x))
				If (x.tp &lt;&gt; &quot;ind&quot;) Then
					xStr = &quot;K &quot; &amp; TParser_toString(x)
				Else
					If isNull(x.st) Then
						xStr = &quot;K P???&quot; &amp; x.id
					Else
						xStr = &quot;K P&quot; &amp; x.st.id
					End If
				End If
			&apos;ElseIf isBsomething(x) Then
			&apos;	Dim g As Object, h As Object
			&apos;	g = cadr(partialArgs(x)) &apos; they&apos;re in reverse order!
			&apos;	h = car(partialArgs(x))
			&apos;	xStr = &quot;B (&quot; &amp; getFnName(g) &amp; &quot;...) (&quot; &amp; getFnName(h) &amp; &quot;...)&quot;
			Else
				xStr = TFn_toString(x)
			End If
			out = cons(xStr, out)
			xs = cdr(xs)
		Wend
		bindFns = out
	Else
		fns = cons(f, fns)
		bindFns = fns
	End If
End Function

Function bindStats(p As Parser, f As Object)
	&apos;If isKsomething(f) Then
		bindFns(f)
	&apos;End If
End Function

&apos; fails on empty string but succeeds on all others
&apos; by returning the first character; and increasing pos by 1
Function pItem()
	Static result As Object
	If isNull(result) Then : result = mkParser(&quot;item&quot;, Nothing) : End If
	pItem = result
End Function

&apos; succeeds on empty string (by returning Empty) but fails on all others
Function pEnd()
	Static result As Object
	If isNull(result) Then : result = mkParser(&quot;end&quot;, Empty) : End If
	pEnd = result
End Function

Function pSat(predicate As Object)
	Dim result As Object
&apos;	result = pBind( pItem, ite(predicate, pReturn, fstArg(pFail)) )
	result = mkParser(&quot;sat&quot;, predicate)
	result.st0 = predicate
	pSat = result
End Function

&apos; pattern-matches p against &quot;q &gt;&gt;= K (return Empty)&quot; where q any parser
Function isPSkip(p As Parser)
	Dim result As Boolean : result = False
	If p.tp = &quot;skip&quot; Then
		result = True
	&apos;ElseIf p.tp = &quot;bind&quot; Then
	&apos;	Dim f As Object
	&apos;	f = p.st(1)
	&apos;	If (getFnName(f) = getFnName(Fn.fstArg)) And (arity(f) = 1) Then
	&apos;		Dim innerP As Object
	&apos;		innerP = car(partialArgs(f))
	&apos;		result = (innerP.tp = &quot;return&quot;) And isEmpty(innerP.st)
	&apos;	End If
	End If
	isPSkip = result
End Function

Function pSkip(p As Object)
	Dim result As Variant
	Select Case p.tp
		Case &quot;fail&quot;:	result = p
		Case &quot;return&quot;:	result = pReturn(Empty)
		Case Else
			If isPSkip(p) Then
				result = p
			Else
				&apos;result = pBind(p, fstArg(pReturn(Empty)))
				result = mkParser(&quot;skip&quot;, p)
				result.st0 = p
			End If
	End Select
	pSkip = result
End Function

&apos; succeeds on strings with the given prefix t by returning t,
&apos; and advancing pos by the length of t
Function pStr(Optional t As String)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.pStr : End If
	If isMissing(t) Then
		pStr = oFn
	Else
		If (Len(t) = 0) Then
			croak(&quot;pStr: cannot match &apos;exactly&apos; the empty string t=&apos;&apos;&quot;)
		Else
			pStr = mkParser(&quot;str&quot;, Array(t, Len(t)))
		End If	
	End If
End Function

&apos; succeeds if either p1 succeeds (then returning p1&apos;s result and pos)
&apos; or (and only if p1 fails) if p2 succeeds, returns p2&apos;s result and pos.
&apos; fails if both, p1 and p2 fail
Function pChoice(Optional p1 As Parser, Optional p2 As Parser)
	Static oFn As Object :	If isNull(oFn) Then : oFn = Fn.pChoice : End If
	Dim result As Object
	If isMissing(p1) Then
		result = oFn
	ElseIf isMissing(p2) Then
		result = apply(oFn, p1)
	Else
		&apos;If p2.tp = &quot;return&quot; Then
		&apos;	&apos;msgBox(&quot;choice ... &quot; &amp; toString(p2) _
		&apos;	&apos;	&amp; NL &amp; NL &amp; toString(p1))
		&apos;	pChoice = pZeroOrOne2(p2.st, p1)
		&apos;	Exit Function
		&apos;End If
	
		&apos; TODO: @pChoice: strip out always failing parsers
		&apos; TODO: @pChoice: if p1 always succeeds strip out p2
		&apos; linearize choice of choice:
		If (p1.tp = &quot;choice&quot;) Then &apos; if left-hand-side is a choice...
			&apos;...then push its right alternative over to *our* right:
			result = pChoice(p1.st0, pChoice(p1.st1, p2))
		Else
			If (p1.tp = &quot;ind&quot;) Then
				If isNull(p1.st) Then
					&apos;msgbox(&quot;pChoice: &quot; &amp; toString(mkParser(&quot;choice&quot;, Array(p1, p2)))
				ElseIf (p1.st.tp = &quot;choice&quot;) Then
					&apos;msgbox(&quot;pChoice!: lhs ind to choice: &quot; &amp; toString(p1))
				End If
			End If
			result = mkParser(&quot;choice&quot;, Array(p1, p2))
			result.st0 = p1
			result.st1 = p2
			&apos; we use .st2 to count the total nr of alternatives:
			If p2.tp = &quot;choice&quot; Then
				result.st2 = p2.st2 + 1
			Else
				result.st2 = 2
			End If
		End If
	End If
	pChoice = result
End Function

Function isPZeroOrOne(p As Parser)
	Dim result As Boolean : result = False
	If p.tp = &quot;zeroOrOne&quot; Then
		result = True
	End If
	isPZeroOrOne = result
End Function

&apos; Equivalent to pChoice(p, pReturn(v))
&apos; never fails: if p fails then pZeroOrOne2(p) returns a constant value
&apos; + same pos as result, otherwise returns whatever p returns as result (+ pos)
&apos; matches at most once
Function pZeroOrOne2(Optional v As Variant, Optional p As Parser)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.pZeroOrOne2 : End If
	Dim result As Variant
	If isMissing(v) Then
		result = oFn
	ElseIf isMissing(p) Then
		result = apply(oFn, v)
	Else
		If isPZeroOrOne(p) Then
			result = pZeroOrOne2(v, p.st0)
		Else
			result = mkParser(&quot;zeroOrOne&quot;, Array(p, v))
			result.st0 = p
			result.st1 = v
		End If
	End If
	pZeroOrOne2 = result
End Function

&apos; same as pZeroOrOne2(Empty, p)
Function pZeroOrOne(Optional p As Parser)
	Dim result As Variant
	If isMissing(p) Then
		result = pZeroOrOne2(Empty)
	Else
		result = pZeroOrOne2(Empty, p)
	End If
	pZeroOrOne = result
End Function

Function isPMany1(p As Parser) As Boolean
	isPMany1 = (p.tp = &quot;many1&quot;)
End Function

Function isPMany(p As Parser) As Boolean
	Dim result As Boolean
	result = False
	If isPZeroOrOne(p) Then
		result = isPMany1(p.st0)
	End If
	isPMany = result
End Function

&apos; pMany: equivalent to pZeroOrOne2(nil, pMany1(p))
&apos; pMany never fails: if p fails then pMany(p) returns nil + same pos as result,
&apos; otherwise returns a list of p results (in the order as in the parsed string) + last pos
&apos; matches as many as possible
Function pMany(Optional p As Parser)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.pMany : End If
	Dim result As Variant
	If isMissing(p) Then
		result = oFn
		&apos; result = compose(swap(pChoice, pReturn(nil)), pMany1)
	Else
		&apos; Note: direct impl might give a little more perf (not worth it)
		result = pZeroOrOne2(nil, pMany1(p))
	End If
	pMany = result
End Function

&apos; pMany1: same as pMany except that it fails if there is no match at all
&apos; matches as many as possible
Function pMany1(Optional p As Parser)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.pMany1 : End If
	Dim result As Variant
	If isMissing(p) Then
		result = oFn
	Else
		result = mkParser(&quot;many1&quot;, p)
		result.st0 = p	
	End If
	pMany1 = result
End Function

&apos; pSeq: make a sequence of parsers, collect their results in a list 
&apos; and finally process that list by passing it to the given function
&apos; fails if any of the given parsers fails
&apos; if instead all succeed, collects their results in a list 
&apos; which is then passed on the the given function. The result
&apos; of this function application is then packed up with the last
&apos; parsers pos to give the overall result
Function pSeq(ps As Array, ByVal f As Variant)
	&apos;TODO: pSeq: check if ps is proper Array of Parsers
	f = asFn(f, &quot;pSeq: invalid 2nd arg &quot; &amp; toString(f))
	pSeq = pSeqL(ps, applyToList(f))
End Function

Function pSeqL(ps As Array, ByVal f As Variant)
	&apos;TODO: pSeqL: check if ps is proper Array of Parsers
	f = asFn(f, &quot;pSeqL: invalid 2nd arg &quot; &amp; toString(f))
	pSeqL = mkParser(&quot;seq&quot;, Array(ps, f))
End Function

&apos; pInd: for building recursive parsers; returns a dummy Parser instance
&apos; which serves as an indirection to another Parser. This pointer later 
&apos; has to set calling fixIndirection with the dummy and the actual instance
Function pInd(ByVal name As String)
	Static n As Integer
	Dim result As Variant
	If name = &quot;&quot; Then
		name = &quot;Rule&quot;
	End If
	result = mkParser(&quot;ind&quot;, Nothing)
	result.st0 = Nothing
	n = n + 1
	result.st1 = name &amp; &quot;_&quot; &amp; n
	result.st2 = False
	pInd = result
End Function

Function getPIndName(p As Parser)
	Dim result As Variant
	If p.tp &lt;&gt; &quot;ind&quot; Then
		croak(&quot;getPIndName: need .tp = &apos;ind&apos; - got &quot; &amp; p.tp)
	End If
	result = Mid(p.st1, 1, InStr(p.st1, &quot;_&quot;) - 1)
	getPIndName = result
End Function

Function fixIndirection(dummy As Parser, target As Parser)
	If dummy.tp &lt;&gt; &quot;ind&quot; Then
		croak(&quot;fixIndirection: invalid dummy - tp = &quot; &amp; dummy.tp
	End If
	If Not(isNull(dummy.st)) Then
		croak(&quot;fixIndirection: cannot set target &quot; &amp; target.id &amp; &quot; - already points to &quot; &amp; dummy.st.id)
	End If
	dummy.st = target
	dummy.st0 = target
	fixIndirection = dummy
End Function


&apos;==================================================================

Function escapeCClass(ByVal c As String)
	Dim out As Variant
	If (Len(c) &lt;&gt; 1) Then
		croak(&quot;escapeCClass: invalid char &quot; &amp; toString(c))
	End If
	If (c = CR) Or (c = LF) Or (c = TAB) Then
		c = toString(c)
		out = Mid(c, 2, Len(c) - 2) &apos; strip off surrounding quotes
	ElseIf (c = &quot;[&quot;) Or (c = &quot;-&quot;) Or (c = &quot;]&quot;) OR (c = &quot;\&quot;) Then
		out = &quot;\&quot; &amp; c
	Else
		out = c
	End If	
	escapeCClass = out
End Function

Function pRange( _
	ByVal lo As String, _
	ByVal hi As String _
)
	Dim out As Object
	out = pSat(compose(inRange(Asc(lo), Asc(hi)), Fn.asc))
	
	out.str = &quot;[&quot; &amp; escapeCClass(lo) &amp; &quot;-&quot; &amp; escapeCClass(hi) &amp; &quot;]&quot;
	pRange = out
End Function

&apos; TODO: optimize pCClass
Function pCClass(ByVal cs As Object)
	Static esc As Object : If isNull(esc) Then 
		esc = List(&quot;\&quot;, &quot;[&quot;, &quot;-&quot;, &quot;]&quot;)
	End If
	assertEqual(isList(cs), True).x
	Dim out As Object
	Dim f As Object
	f = compose(swap(skipUntil, cs), equ)
	out = pSat(ite(compose(isNil, f), _
				fstArg(False), _
				fstArg(True) _
	))
	&apos;out.str = foldl(concat, &quot;[&quot;, map(escapeCClass, cs)) &amp; &quot;]&quot;
	Dim s As String, c As String
	s = &quot;&quot;
	Do Until(isNil(cs))
		c = car(cs)
		s = s &amp; escapeCClass(c)
		cs = cdr(cs)
	Loop
	out.str = &quot;[&quot; &amp; s &amp; &quot;]&quot;
	pCClass = out
End Function

Function pWhite()
	Static result As Object
	If isNull(result) Then
		result = pChoice(pStr(&quot; &quot;), pStr(TAB)
		result.str = &quot;[ \t]&quot;
		result.typ = &quot;Parser Char&quot;
		result = fixIndirection(pInd(&quot;ws&quot;), result)
	End If
	pWhite = result
End Function

Function pAlphaLower()
	Static result As Object
	If isNull(result) Then : result = pRange(&quot;a&quot;, &quot;z&quot;) : End If
	pAlphaLower = result
End Function

Function pAlphaUpper()
	Static result As Object
	If isNull(result) Then : result = pRange(&quot;A&quot; ,&quot;Z&quot;) : End If
	pAlphaUpper = result
End Function

Function pBinDigit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = pChoice(_
			pBind(pStr(&quot;0&quot;), fstArg(pReturn(0))), _
			pBind(pStr(&quot;1&quot;), fstArg(pReturn(1)))_
		)
		&apos;&apos;not paying off (yet):
&apos;		result = pBind(pItem, compose(ite(inRange(Asc(&quot;0&quot;), Asc(&quot;1&quot;)), compose(pReturn, add(-Asc(&quot;0&quot;))), fstArg(pFail)), Fn.asc)
		result = pSeq(Array(pRange(&quot;0&quot;, &quot;1&quot;)), _
			compose(add(-Asc(&quot;0&quot;)), Fn.Asc))
		
		result = fixIndirection(pInd(&quot;BinDigit&quot;), result)
	End If
	pBinDigit = result
End Function

Function pDecDigit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = pInd(&quot;DecDigit&quot;)
		result = fixIndirection(result, foldl1(pChoice, _
			List(pBinDigit, _
				 pBind(pStr(&quot;2&quot;), fstArg(pReturn(2))), _
				 pBind(pStr(&quot;3&quot;), fstArg(pReturn(3))), _
				 pBind(pStr(&quot;4&quot;), fstArg(pReturn(4))), _
				 pBind(pStr(&quot;5&quot;), fstArg(pReturn(5))), _
				 pBind(pStr(&quot;6&quot;), fstArg(pReturn(6))), _
				 pBind(pStr(&quot;7&quot;), fstArg(pReturn(7))), _
				 pBind(pStr(&quot;8&quot;), fstArg(pReturn(8))), _
				 pBind(pStr(&quot;9&quot;), fstArg(pReturn(9))) _
		)   )
		pDecDigit = result
		Exit Function

		&apos;&apos;this is in fact paying off:
		Dim f as Object
		&apos;Set f = compose(add(-Asc(&quot;0&quot;)), Fn.asc)
		&apos;MsgBox(TFn_toString(f))
		f = ite(inRange(Asc(&quot;0&quot;), Asc(&quot;9&quot;)), compose(pReturn, add(-Asc(&quot;0&quot;))), fstArg(pFail))
		f = compose(f, Fn.Asc)
		result = pBind(pItem, f)
	End If
	pDecDigit = result
End Function

Function pHexDigit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = pInd(&quot;HexDigit&quot;)
&apos;		result = pChoice(pDecDigit,	pBind(pChoice(pStr(&quot;A&quot;), pStr(&quot;a&quot;)), fstArg(pReturn(10))) )
&apos;		result = pChoice(result,	pBind(pChoice(pStr(&quot;B&quot;), pStr(&quot;b&quot;)), fstArg(pReturn(11))) )
&apos;		result = pChoice(result,	pBind(pChoice(pStr(&quot;C&quot;), pStr(&quot;c&quot;)), fstArg(pReturn(12))) )
&apos;		result = pChoice(result,	pBind(pChoice(pStr(&quot;D&quot;), pStr(&quot;d&quot;)), fstArg(pReturn(13))) )
&apos;		result = pChoice(result,	pBind(pChoice(pStr(&quot;E&quot;), pStr(&quot;e&quot;)), fstArg(pReturn(14))) )
&apos;		result = pChoice(result,	pBind(pChoice(pStr(&quot;F&quot;), pStr(&quot;f&quot;)), fstArg(pReturn(15))) )
		&apos;pHexDigit = result
		&apos;Exit Function

		&apos;&apos;not really paying off (yet):
		Dim retZero As Object, retUpperA As Object, retLowerA As Object, Kfail As Object
		Set retZero   = compose(pReturn, add(  -Asc(&quot;0&quot;)))
		Set retUpperA = compose(pReturn, add(10-Asc(&quot;A&quot;)))
		Set retLowerA = compose(pReturn, add(10-Asc(&quot;a&quot;)))
		Set Kfail = fstArg(pFail)
		result = fixIndirection(result, pBind(pItem, compose( _
			ite( inRange(Asc(&quot;0&quot;), Asc(&quot;9&quot;)), _
				retZero, _
				ite(inRange(Asc(&quot;A&quot;), Asc(&quot;F&quot;)), _
					retUpperA, _
					ite(inRange(Asc(&quot;a&quot;), Asc(&quot;f&quot;)), _
						retLowerA, _
						fstArg(pFail) _
					) _
				) _
			), Fn.asc) _
		)

	End If
	pHexDigit = result
End Function

Function pHexNum()
	Static result As Object
	If isNull(result) Then
		result = fixIndirection(pInd(&quot;HexNum&quot;), _
			pSeq(Array( _
					pMany1(pHexDigit) _
				), foldl1(compose(add, mul(16))) _
			) _
		)
	End If
	pHexNum = result
End Function

Function pHexLit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = fixIndirection(pInd(&quot;HexLit&quot;), _
			pSeq(Array( _
				pSkip(pStr(&quot;0x&quot;)), _
				pHexNum _
			), id) _
		)
	End If
	pHexLit = result
End Function

&apos; Type expressions: base types (atomic/built-in types), arrow types (fns), and n-ary Type constructors
&apos; Grammar for type expressions:
&apos;   TypeExpr ::= ws* N ws* (&quot;-&gt;&quot; TypeExpr)?		; &quot;ws&quot; means whitespace, &quot;*&quot; means many and &quot;?&quot; zeroOrOne
&apos;          N ::= BaseType			; need extra rule &quot;N&quot; for &quot;-&gt;&quot; to bind most strongly
&apos;              | TypeVar
&apos;              | TypeCtor (ws+ N)*	; &quot;+&quot; means many1
&apos;              | &quot;(&quot; TypeExpr &quot;)&quot;
&apos;   BaseType ::= &quot;Bool&quot; | &quot;Str&quot; | &quot;Int&quot; | &quot;Long&quot; | ...
&apos;    TypeVar ::= [a-z]
&apos;   TypeCtor ::= &quot;List&quot; | &quot;Maybe&quot; | ...
&apos; This makes the binary (infix) type constructor &quot;-&gt;&quot; right-associative
&apos; and also make it bind more weakly than any other type constructor 
&apos; &quot;TypeCtor&quot;.
&apos; For example: &quot;Parser a -&gt; b&quot; = &quot;(Parser a) -&gt; b&quot;; NOT &quot;Parser (a -&gt; b)&quot;
&apos; Now, this grammar is tricky to implement because it contains both,
&apos; - simple recursion (TypeExpr in TypeExpr and N in N)
&apos; - mutual recursion (N in TypeExpr and TypeExpr in N)
Function pTypeExpr()
	Static result As Object
	If isNull(result) Then
		Dim pRight As Object
		Dim pS As Object
		Dim pListType As Object
		Dim pParenS As Object
		Dim pTypeArg As Object
		Dim pCtor As Object
		Dim pN As Object
		Dim recDummy As Object
		
		pS = pInd(&quot;TypeExpr&quot;)
		pN = pInd(&quot;NonArrow&quot;)

		&apos; Right ::= &quot;-&gt;&quot; S
		&apos; pRight = do _ &lt;- (str &quot;-&gt;&quot;)
		&apos;             s &lt;- S
		&apos;          return s
		&apos;pRight = pSeq(Array(pSkip(pStr(&quot;-&gt;&quot;)), pS), id)
		pRight = pBind(pStr(&quot;-&gt;&quot;), fstArg(pS))
		
		&apos; S ::= ws* N ws* ((str &quot;-&gt;&quot;) S)?
		&apos; pS = do   _ &lt;- many white
		&apos;		   in &lt;- S
		&apos;           _ &lt;- many white
		&apos;         out &lt;- zeroOrOne pRight
		&apos;      return (if (empty? out) in else (mkArrowType in out))
		pS = fixIndirection(pS, pSeq(Array( _
				pSkip(pMany(pWhite)), _
				pN, _
				pSkip(pMany(pWhite)), _
				pZeroOrOne(pRight) _
			), Fn.maybeMakeArrowType _
		))
		
		&apos; ListType ::= &quot;[&quot; S &quot;]&quot;
		pListType = fixIndirection(pInd(&quot;ListType&quot;), pSeq(Array( _
				pSkip(pStr(&quot;[&quot;)), _
				pSeq(Array(pS, pReturn(nil)), cons), _
				pSkip(pStr(&quot;]&quot;)) _
			), mkTypeCtor(&quot;List&quot;) _
		))

		&apos; ParenS ::= &quot;(&quot; S? &quot;)&quot;
		&apos; ParenS ::= &quot;(&quot; (S (&quot;,&quot; S)*)? &quot;)&quot; &apos; with tuple types
		Dim pTyUnitSuffix As Object, pTySingleSuffix As Object, pTyTupleSuffix As Object
		pTyUnitSuffix = fixIndirection(pInd(&quot;TyUnitSuffix&quot;), pBind( _
			pStr(&quot;)&quot;), fstArg(pReturn(mkTypeCtor(&quot;Unit&quot;, nil))) _
		))
		pTySingleSuffix = fixIndirection(pInd(&quot;TySingleSuffix&quot;), pSeq(Array( _
				pS, _
				pSkip(pStr(&quot;)&quot;)) _
			), id _
		))
		pTyTupleSuffix = fixIndirection(pInd(&quot;TyTupleSuffix&quot;), pSeq(Array( _
				pS, _
				pMany1(pSeq(Array( _
						pSkip(pStr(&quot;,&quot;)), _
						pS _
					), id _
				)), _
				pSkip(pStr(&quot;)&quot;)) _
			), Fn.mkTupleType _
		))
		
		pParenS = pInd(&quot;ParensTyEx&quot;)
		pParenS = fixIndirection(pParenS, pSeq(Array( _
				pSkip(pStr(&quot;(&quot;)), _
				foldl1(pChoice, List( _
					pTyUnitSuffix, _
					pTySingleSuffix, _
					pTyTupleSuffix) _
				) _
			), id _
		))
				
		&apos; TypeArg ::= ws+ N
		&apos;pTypeArg = pSeq(Array(pSkip(pMany1(pWhite)), pN), id)
		pTypeArg = pBind(pMany1(pWhite), fstArg(pN))
		&apos; don&apos;t need to skip the pMany1(pWhite) - done by optimization
		
		&apos; Ctor ::= TypeCtor pTypeArg*
		pCtor = pSeq(Array( _
						pTypeCtor, _
						pMany(pTypeArg) _
					), Fn.mkTypeCtor _
				)
		
		&apos; N ::= BaseType | TypeVar | ListType | ParenS | Ctor
		pN = fixIndirection( pN, _
			foldl1(pChoice, List(pBaseType, pTypeVar, pListType, pParenS, pCtor)) _
		)
			
		result = pS
		&apos;MsgBox(toString(result))
		&apos;Stop
	End If
	pTypeExpr = result
End Function

Function pBaseType()
	Static out As Object
	If isNull(out) Then
		out = pInd(&quot;BaseType&quot;)
		out = fixIndirection(out, foldl1(pChoice, _
				map(pStr, List(&quot;Any&quot;, &quot;Bool&quot;, &quot;Char&quot;, &quot;Str&quot;, &quot;Int&quot;, &quot;Long&quot;)) _
		)
		&apos;msgbox(toString(out))
	End If
	pBaseType = out
End Function

Function pTypeVar()
	Static out As Object
	If isNull(out) Then
		out = pInd(&quot;TypeVar&quot;)
		out = fixIndirection(out, pBind(pAlphaLower, compose(pReturn, mkTypeVar)))
	&apos;	out = fixIndirection(out, pSeq(Array(pAlphaLower), mkTypeVar))
	End If
	pTypeVar = out
End Function

Function pTypeCtor()
	Static result As Object
	If isNull(result) Then
&apos;		result = foldl1( pChoice, _
&apos;						 map(pStr, List(&quot;List&quot;, &quot;Maybe&quot;, &quot;Parser&quot;)) )

		&apos; \a bs.foldl concat a bs
		result = pSeq(Array( _
						pAlphaUpper, _
						pMany1(pAlphaLower) _
					 ), _
					 foldl(concat) _
		)
	End If
	pTypeCtor = result
End Function

Function mkTypeVar(Optional ByVal name As String)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.mkTypeVar : End If
	If isMissing(name) Then
		mkTypeVar = oFn
	Else
		mkTypeVar = &quot;&apos;&quot; &amp; name
	End If
End Function

Function mkArrowType(tIn, tOut)
	mkArrowType = &quot;(-&gt; &quot; &amp; tIn &amp; &quot; &quot; &amp; tOut &amp; &quot;)&quot;
End Function

Function maybeMakeArrowType(i, o)
	If isEmpty(o) Then
		maybeMakeArrowType = i
	Else
		maybeMakeArrowType = mkArrowType(i, o)
	End If
End Function

Function mkTypeCtor(Optional ctorName As String, Optional typeArgs As Object)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.mkTypeCtor : End If
	Dim result As Variant
	If isMissing(typeArgs) Then
		If isMissing(ctorName) Then
			result = oFn
		Else
			result = apply(oFn, ctorName)
		End If
	Else
		result = &quot;(&quot; &amp; ctorName
		If isNil(typeArgs) Then
			result = result &amp; &quot; [])&quot;
		Else
			Dim toStr As Object
			&apos;  \acc a.concat acc (concat &quot;, &quot; a)
			&apos;= \acc a.(swap concat) (concat &quot;, &quot; a) acc
			&apos;= swap \a acc.(swap concat) (concat &quot;, &quot; a) acc
			&apos;= swap \a.(swap concat) (concat &quot;, &quot; a)
			&apos;= swap ((swap concat) ° (concat &quot;, &quot;))
			toStr = swap(compose(swap(concat) , concat(&quot;, &quot;)))
			result = result &amp; &quot; [&quot; &amp; foldl1(toStr, typeArgs) &amp; &quot;])&quot;
		End If
	End If
	mkTypeCtor = result
End Function

Function mkTupleType(Optional x As Variant, Optional xs As Variant)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.mkTupleType : End If
	Dim result As Variant
	If isMissing(xs) Then
		If isMissing(x) Then
			result = oFn
		Else
			result = apply(oFn, x)
		End If
	Else
		result = &quot;(Tuple&quot; &amp; (length(xs) + 1)
		Dim ts As Object
		ts = map(Fn.toString, cons(x, xs))
		Dim listJoin As Object
		&apos;  \acc a.concat acc (concat &quot;, &quot; a)
		&apos;= \acc a.(swap concat) (concat &quot;, &quot; a) acc
		&apos;= swap \a acc.(swap concat) (concat &quot;, &quot; a) acc
		&apos;= swap \a.(swap concat) (concat &quot;, &quot; a)
		&apos;= swap ((swap concat) ° (concat &quot;, &quot;))
		listJoin = swap(compose(swap(concat) , concat(&quot;, &quot;)))
		result = result &amp; &quot; [&quot; &amp; foldl1(listJoin, ts) &amp; &quot;])&quot;
	End If
	mkTupleType = result
End Function


&apos; =============================================================================

Function lookupParser(pName As String) As Parser
	Dim result As Parser
	Select Case pName
		Case &quot;pWhite&quot;:		result = pWhite
		Case &quot;pBinDigit&quot;:	result = pBinDigit
		Case &quot;pDecDigit&quot;:	result = pDecDigit
		Case &quot;pHexDigit&quot;:	result = pHexDigit
		Case &quot;pHexNum&quot;:		result = pHexNum
		Case &quot;pHexLit&quot;:		result = pHexLit
		Case &quot;pTypeExpr&quot;:	result = pTypeExpr
		Case &quot;pLogic_dt&quot;:	result = pLogic_dt
		Case Else
			croak(&quot;unknown parser &quot; &amp; pName)
	End Select
	lookupParser = result
End Function

Function parse(pName As String, s As String)
	Dim result As String
	result = toString(applyP(lookupParser(pName), s))
	if (result = &quot;Empty&quot;) then
		MsgBox(pName &amp; &quot; on &quot; &amp; tostring(s) &amp; &quot; yielded &quot; &amp; result)
	end if
	parse = result
End Function

Function applyP(ByVal parser As Variant, s As String, Optional pos As Integer)
	applyP_callCount = applyP_callCount + 1
	Dim p As Parser
	If IsNull(parser) Or IsEmpty(parser) Then
		croak(&quot;applyP: invalid arg parser - &quot; &amp; toString(parser))
	ElseIf TypeName(parser) = &quot;Object&quot; Then
		Set p = parser
	Else
		croak(&quot;applyP: invalid arg parser - &quot; &amp; toString(parser))
	End If
	If IsMissing(pos) Then
		pos = 1
	End If
	Dim endPos As Integer, parseResult As Variant
	parseResult = _applyP(p, s, pos, endPos, False)
	If endPos &lt; 0 Then &apos; indicates failure
		applyP = parseFailure
	Else &apos; package up result and endPos for the outside world			
		applyP = Array(parseResult, endPos)
	End If
End Function

Function _applyP( _
	ByVal p As Parser, _
	ByRef s As String, _
	ByVal pos As Integer, _
	ByRef endPos As Integer, _
	ByVal isUnderSkip As Boolean _
) As Variant
	_applyP_callCount(0) = _applyP_callCount(0) + 1
	If isUnderSkip Then : _applyP_callCount(1) = _applyP_callCount(1) + 1 : End If
	Dim result As Variant
	Dim i As Integer
	Dim innerParser As Parser
	Dim innerParsers As Variant
	Dim lst As Object
	&apos;_applyP = Empty
	
_applyP_begin:
	_applyP_stats(p, s, pos, endPos, isUnderSkip)
	Select Case p.tp
		Case &quot;str&quot;
			Dim match As String
			Dim matchLen As Integer
			match = p.st(0)
			matchLen = p.st(1)
			If (Mid(s, pos, matchLen) &lt;&gt; match) Then
				Goto _applyP_parseFailure
			End If
			endPos = pos + matchLen
			If Not(isUnderSkip) Then
				result = match
			End If
		Case &quot;zeroOrOne&quot;
			result = _applyP(p.st0, s, pos, endPos, isUnderSkip)
			If endPos &lt; 0 Then
				endPos = pos
				If isUnderSkip Then
					result = Empty
				Else
					result = p.st1
				End If
			End If
		Case &quot;choice&quot;	&apos; tail-recursive (in the 2nd alternative)
_applyP_choiceL:
			result = _applyP(p.st0, s, pos, endPos, isUnderSkip)
			If endPos &lt; 0 Then
				&apos;result = _applyP(p.st1, s, pos, endPos, isUnderSkip)
				If p.st2 &gt; 2 Then	&apos; p.st2 = total nr alternatives
					p = p.st1	&apos; 2nd alternative is a choice again
					Goto _applyP_choiceL
				Else	&apos; 2nd alt is NOT a choice
					p = p.st1
					Goto _applyP_begin
				End If
			End If
		Case &quot;item&quot;
			If pos &gt; Len(s) Then
				Goto _applyP_parseFailure
			End If
			endPos = pos + 1
			If Not(isUnderSkip) Then
				result = Mid(s, pos, 1)
			End If
		Case &quot;return&quot;
			endPos = pos
			If isUnderSkip Then
				result = Empty
			Else
				result = p.st
			End If
		Case &quot;bind&quot;	&apos; tail-recursive
			On p.st2 Goto _applyP_bind_K, _applyP_bind_K_return, _applyP_bind_B_return
_applyP_bind_general:			
			&apos;ATTENTION: when applying the parser (bind&apos;s 1st arg)
			&apos;           we MUST NOT propagate down isUnderSkip
			&apos;           because the fn (bind&apos;s 2nd arg) might need it
			result = _applyP(p.st0, s, pos, endPos, False)
			If endPos &lt; 0 Then : Exit Function : End If
			&apos;HOWEVER: when applying the parser *produced* by the fn
			&apos;         we *must* do this under the isUnderSkip:
			&apos;result = _applyP(apply1(p.st1, result), s, endPos, endPos, isUnderSkip)
			pos = endPos
			p = apply1(p.st1, result)
			If isUnderSkip Then : result = Empty : End If
			Goto _applyP_begin
_applyP_bind_K:
			&apos; We know that the function (bind&apos;s 2nd arg) ignores
			&apos; the parsers result value, so we can savely apply it 
			&apos; &quot;under-skip&quot;, and ignore the result value:
			_applyP(p.st0, s, pos, endPos, True)
			If endPos &lt; 0 Then : Exit Function : End If
			&apos; Since at construction we peeled off the K, we have the
			&apos; subsequent parser stored directly in .st3:
			pos = endPos
			p = p.st3
			If isUnderSkip Then : result = Empty : End If
			Goto _applyP_begin
_applyP_bind_K_return:
			&apos; We know that the function (bind&apos;s 2nd arg) will always
			&apos; produce a constant pReturn(x), so we can savely apply 
			&apos; the parser (bind&apos;s 1st arg) &quot;under-skip&quot;, 
			&apos; and ignore the result value:
			_applyP(p.st0, s, pos, endPos, True)
			If endPos &lt; 0 Then : Exit Function : End If
			&apos; Since at construction we peeled off the K and the pReturn,
			&apos; we have the result value stored directly in .st3:
			If isUnderSkip Then 
				result = Empty 
			Else
				result = p.st3
			End If
			&apos; and we&apos;re finished in this call (still have to set _applyP)
			Goto _applyP_parseSuccess
_applyP_bind_B_return:
			&apos; We know that the function (bind&apos;s 2nd arg) will always
			&apos; produce a pReturn(x), where x is produced by an inner 
			&apos; function (which we have stored in .st3)
			&apos; Therefore we can directly apply this function to the 
			&apos; parser&apos;s result (bind&apos;s 1st arg) in order to get the 
			&apos; overall result value.
			&apos; However, we need not apply this function at all if we&apos;re
			&apos; &quot;under-skip&quot;, so in that case the parser can be applied
			&apos; &quot;under-skip&quot; as well:
			If isUnderSkip Then
				_applyP(p.st0, s, pos, endPos, True)
				&apos; result not needed, endPos set by inner parser
				Exit Function
			Else
				result = _applyP(p.st0, s, pos, endPos, False)
			End If
			If endPos &lt; 0 Then : Exit Function : End If
			&apos; Since at construction we peeled off the B and the pReturn,
			&apos; we have the inner function stored directly in .st3:
			result = apply1(p.st3, result)
			&apos; and we&apos;re finished in this call (still have to set _applyP)
			Goto _applyP_parseSuccess
		Case &quot;seq&quot;
			innerParsers = p.st(0)
			If isUnderSkip Then
				For i = LBound(innerParsers) To UBound(innerParsers)
					_applyP(innerParsers(i), s, pos, endPos, True)
					If endPos &lt; 0 Then : Exit Function : End If
					pos = endPos
				Next
				result = Empty		
			Else
				lst = nil
				For i = LBound(innerParsers) To UBound(innerParsers)
					innerParser = innerParsers(i)
					result = _applyP(innerParser, s, pos, endPos, False)
					If endPos &lt; 0 Then : Exit Function : End If
					pos = endPos
					&apos; TODO: precalculate isPSkip check in pSeq
					If Not(isPSkip(innerParser)) Then
						lst = cons(result, lst)
					End If
				Next
				result = apply(p.st(1), reverse(lst))
			End If
		Case &quot;skip&quot;	&apos; tail-recursive
			p = p.st0
			isUnderSkip = True
			Goto _applyP_begin
			&apos;result = _applyP(p.st0, s, pos, endPos, True)
			&apos;If endPos &gt; 0 Then
			&apos;	assertEqual(result, Empty).x
			&apos;End If
		Case &quot;sat&quot;
			If pos &gt; Len(s) Then
				Goto _applyP_parseFailure
			End If
			result = Mid(s, pos, 1)
			If Not(apply(p.st0, result)) Then
				Goto _applyP_parseFailure
			End If
			endPos = pos + 1
			If isUnderSkip Then
				result = Empty
			End If
		Case &quot;many1&quot;
			innerParser = p.st
			If isUnderSkip Then
				_applyP(innerParser, s, pos, endPos, True)
				If endPos &lt; 0 Then : Exit Function : End If
				Do
					pos = endPos
					_applyP(innerParser, s, pos, endPos, True)
				Loop Until (endPos &lt; 0)
				endPos = pos
			Else
				Set lst = nil
				result = _applyP(innerParser, s, pos, endPos, False)
				If endPos &lt; 0 Then : Exit Function : End If
				Do
					Set lst = cons(result, lst)
					pos = endPos
					result = _applyP(innerParser, s, pos, endPos, False)
				Loop Until (endPos &lt; 0)
				endPos = pos
				result = reverse(lst)
			End If
		Case &quot;fail&quot;
			Goto _applyP_parseFailure
		Case &quot;ind&quot;	&apos; tail-recursive
			p = p.st0
			Goto _applyP_begin
&apos;			result = _applyP(p.st, s, pos, endPos, isUnderSkip)
		Case &quot;end&quot;
			If pos &lt;= Len(s) Then
				Goto _applyP_parseFailure
			End If
			endPos = pos
		Case Else
			result = &quot;unknown Parser &apos;&quot; &amp; p.tp &amp; &quot;&apos;&quot;
			MsgBox(&quot;Error in applyP: &quot; &amp; result)
	End Select
_applyP_parseSuccess:
	assertEqual(endPos &gt; 0, True).x
	If isUnderSkip Then
		If Not(isEmpty(result)) Then
			MsgBox(&quot;isUnderSkip=True, so...&quot; &amp; NL _
				&amp; NL &amp; toString(p) _
				&amp; NL &amp; &quot;...should have yielded Empty but yielded &quot; _
					 &amp; toString(result) _
				&amp; NL &amp; &quot;(pos = &quot; &amp; pos &amp; &quot;; endPos = &quot; &amp; endPos &amp; &quot;)&quot;_
				&amp; NL &amp; &quot;Mid(s, pos) = &quot; &amp; toString(Mid(s, pos)) _
			)
		End If
		assertEqual(result, Empty).x
	End If
	_applyP = result
	Exit Function
_applyP_parseFailure:
	_applyP = Empty	&apos; needed to ensure that under skip really *always* Empty is returned
	endPos = -1
End Function

Function _applyP_stats( _
	ByVal p As Parser, _
	ByRef s As String, _
	ByVal pos As Integer, _
	ByRef endPos As Integer, _
	ByVal isUnderSkip As Boolean _
)	
	Select Case p.tp
		Case &quot;str&quot;
			applyP_str = applyP_str + 1
		Case &quot;choice&quot;	&apos; tail-recursive
			applyP_choice = applyP_choice + 1
		Case &quot;item&quot;
			applyP_item = applyP_item + 1 
		Case &quot;return&quot;
			&apos;Dim tmp As Variant
			&apos;tmp = assertFails(&quot;assertThrows&quot;, Array(&quot;assertEqual&quot;, Array(p.st, p.st0)))
			&apos;If Not(tmp.isFail) Then
			&apos;	show(p)
			&apos;End If
			applyP_return = applyP_return + 1
		Case &quot;bind&quot;	&apos; tail-recursive
			applyP_bind = applyP_bind + 1
			If isKsomething(p.st1) Then
				applyP_bind_K_x = applyP_bind_K_x + 1
				If isKreturn(p.st1) Then
					applyP_bind_K_return = applyP_bind_K_return + 1
					assertEqual(p.st2, 2).x
				Else
					assertEqual(p.st2, 1).x
				End If
			ElseIf isBsomething(p.st1) Then
				applyP_bind_B_f_g = applyP_bind_B_f_g + 1
				If isBreturn(p.st1) Then
					applyP_bind_B_return_g = applyP_bind_B_return_g + 1
					assertEqual(p.st2, 3).x
				End If
			Else
				applyP_bind_other = applyP_bind_other + 1
				assertEqual(p.st2, 0).x
			End If
		Case &quot;seq&quot;
			applyP_seq = applyP_seq + 1
		Case &quot;skip&quot;	&apos; tail-recursive
			assertEqual(isParser(p.st(0)), True).x
			assertEqual(isParser(p.st0),   True).x
			assertEqual(p.st0.id, p.st(0).id).x
			applyP_skip = applyP_skip + 1
		Case &quot;sat&quot;
			assertEqual(isFn(p.st),  True).x
			assertEqual(isFn(p.st0), True).x
			assertEqual(arity(p.st0), arity(p.st)).x
			assertEqual(getFnName(p.st0), getFnName(p.st)).x
			applyP_sat = applyP_sat + 1
		Case &quot;zeroOrOne&quot;
			applyP_zeroOrOne = applyP_zeroOrOne + 1
		Case &quot;many1&quot;
			applyP_many1 = applyP_many1 + 1
		Case &quot;fail&quot;
			applyP_fail = applyP_fail + 1
		Case &quot;ind&quot;	&apos; tail-recursive
			applyP_ind = applyP_ind + 1
			If isNull(p.st0) Then
				assertEqual(p.st(0), p.st0).x
			Else
				assertEqual(isParser(p.st(0)), True).x
				assertEqual(isParser(p.st0),   True).x
				assertEqual(p.st0.id, p.st(0).id).x
			End If
		Case &quot;end&quot;
			applyP_end = applyP_end + 1
	End Select
End Function

&apos;= tests ======================================================================

Function [-----------------------------]()
End Function

Function test_Parser(Optional what)
&apos;	what = &quot;primitives&quot;
	Dim failure As String
	failure = toString(parseFailure)
	
	Dim result As Variant

	Dim tm As Double, aCount As Integer, aPerSec As Double
	aCount = assertionCount
	tm = GetSystemTicks
	
	If isMissing(what) Or (what = &quot;all&quot;) Or (what = &quot;primitives&quot;) Then
		test_Parser_fail()
		test_Parser_return()
		test_Parser_item()
		test_Parser_end()
		test_Parser_str()
		test_Parser_choice()
		test_Parser_bind()
		test_Parser_bind_simplify()
		test_Parser_sat()
		test_Parser_skip()
	End If
	If isMissing(what) Or (what = &quot;all&quot;) Or (what = &quot;multiplicity&quot;) Then
		test_Parser_zeroOrOne()
		test_Parser_skip_zeroOrOne()
		test_Parser_many()
		test_Parser_many1()
	End If
	If isMissing(what) Or (what = &quot;all&quot;) Or (what = &quot;basic&quot;) Then
		test_Parser_range()
		test_Parser_cclass()
		test_Parser_white()
		test_Parser_seq()
		test_Parser_alphaLower()
		test_Parser_alphaUpper()
	End If
	If isMissing(what) Or (what = &quot;all&quot;) Or (what = &quot;special&quot;) Then
		test_Parser_indirect()
		test_Parser_toString()
	End If
	If isMissing(what) Or (what = &quot;all&quot;) Or (what = &quot;numbers&quot;) Then
		test_Parser_binDigit()
		test_Parser_decDigit()
		test_Parser_hexDigit()
		test_Parser_hexNum()
		test_Parser_hexLit()
	End If	
	If isMissing(what) Or (what = &quot;all&quot;) Or (what = &quot;types&quot;) Then
		test_Parser_baseType()
		test_Parser_TypeVar()
		test_Parser_TypeCtor()
		test_Parser_TypeExpr()
	End If
	
end_of_Parser_tests:	
	aCount = assertionCount - aCount
	tm = CLng(10 * (GetSystemTicks() - tm) / ticksPerSec) / 10
	If tm = 0 Then : tm = 1 : End If &apos; avoid divide-by-zero
	If isMissing(what) Then
		aPerSec =  CLng(10 * aCount / tm) / 10
		Dim summary As String
		summary = tm &amp; &quot; sec for &quot; &amp; aCount &amp; &quot; assertions, &quot;_
		&amp; CR &amp; &quot;that&apos;s ~&quot; &amp; aPerSec &amp; &quot; assertions/sec&quot;
		MsgBox(summary)
		result = summary
		MsgBox(parserStats)
	Else
		result = Join(Array(&quot;test_Parser(&quot; &amp; what &amp; &quot;):&quot;, tm, aCount), &quot; &quot;)
	End If
	test_Parser = result
End Function


Function parserStats()
	Dim msg As String
	msg = pReturn(GetSystemTicks()).id &amp; &quot; Parser instances&quot; _
			&amp; NL &amp; &quot;applyP_callCount: &quot; &amp; applyP_callCount _
			&amp; NL &amp; &quot;_applyP_callCount: &quot; _
					&amp; toString(toList(_applyP_callCount)) _
					&amp; &quot; / &quot; &amp; toString(List(&quot;ttl&quot;, &quot;underSkip&quot;)) _
			&amp; NL &amp; &quot;applyP_str: &quot; &amp; applyP_str _
			&amp; NL &amp; &quot;applyP_choice: &quot; &amp; applyP_choice _
			&amp; NL &amp; &quot;applyP_item: &quot; &amp; applyP_item _
			&amp; NL &amp; &quot;applyP_end: &quot; &amp; applyP_end _
			&amp; NL &amp; &quot;applyP_bind: &quot; &amp; applyP_bind _
			&amp; NL &amp; &quot;  (applyP_bind_K_x: &quot; &amp; applyP_bind_K_x &amp; &quot;)&quot; _
			&amp; NL &amp; &quot;    (applyP_bind_K_return: &quot; &amp; applyP_bind_K_return &amp; &quot;)&quot; _
			&amp; NL &amp; &quot;  (applyP_bind_B_f_g: &quot; &amp; applyP_bind_B_f_g &amp; &quot;)&quot; _
			&amp; NL &amp; &quot;    (applyP_bind_B_return_g: &quot; &amp; applyP_bind_B_return_g &amp; &quot;)&quot; _
			&amp; NL &amp; &quot;  (applyP_bind_other: &quot; &amp; applyP_bind_other &amp; &quot;)&quot; _
			&amp; NL &amp; &quot;applyP_return: &quot; &amp; applyP_return _
			&amp; NL &amp; &quot;applyP_seq: &quot; &amp; applyP_seq _
			&amp; NL &amp; &quot;applyP_skip: &quot; &amp; applyP_skip _
			&amp; NL &amp; &quot;applyP_sat: &quot; &amp; applyP_sat _
			&amp; NL &amp; &quot;applyP_zeroOrOne: &quot; &amp; applyP_zeroOrOne _
			&amp; NL &amp; &quot;applyP_many1: &quot; &amp; applyP_many1 _
			&amp; NL &amp; &quot;applyP_fail: &quot; &amp; applyP_fail _
			&amp; NL &amp; &quot;applyP_ind: &quot; &amp; applyP_ind _
			&amp; NL &amp; length(bindFns) &amp; &quot; bindFns: &quot; _
			     &amp; &quot;[&quot; &amp; NL &amp; &quot;  &quot; _
			     &amp; Join(toArray(bindFns), &quot;,&quot; &amp; NL &amp; &quot;  &quot;) _
			     &amp; NL &amp; &quot;]&quot;
	parserStats = msg
End Function

&apos;= test helpers ===============================================================

Function refute_parses(p As Parser, ByVal ss As Variant)
	Static refute_parses_pass As Object
	If isNull(refute_parses_pass) Then
		refute_parses_pass = assertEqual(parseFailure, parseFailure)
	End If
	Dim actual As Variant, testResult As Variant
	Dim actualS As String, expectedS As String
	If isArray(ss) Then
		Dim i As Integer
		For i = LBound(ss) To UBound(ss)
			actual = applyP(p, ss(i), 1)
			assertionCount = assertionCount + 1
			If Not(isParseFailure(actual)) Then
				Goto refute_parses_failed
			End If
		Next i
	Else
		actual = applyP(p, ss, 1)
		assertionCount = assertionCount + 1
		If Not(isParseFailure(actual)) Then
			Goto refute_parses_failed
		End If
	End If
	refute_parses = refute_parses_pass
	Exit Function
refute_parses_failed:
	actualS = toString(actual)
	expectedS = toString(parseFailure)
	testResult = assertEqual(actualS, expectedS)
	If isArray(ss) Then
		MsgBox(&quot;at index &quot; &amp; i &amp; &quot;: &quot; &amp; toString(ss(i)))
	End If
	refute_parses = testResult
End Function

Function assert_parses(p As Parser, ByVal ss As Variant, expVal As Variant, expPos As Integer)
	assertEqual(isParser(p), True).x
	Dim actual As Variant, expected As Variant
	Dim msg As String
	Dim actVal As Variant
	Dim actPos As Integer
	Dim actTyp As String, expTyp As String
	Dim actStr As String, expStr As String
	Dim gotArray As Boolean
	gotArray = isArray(ss)
	If Not(gotArray) Then
		ss = Array(ss)
	End If
	Dim i As Integer
	For i = LBound(ss) To UBound(ss)
		actual = applyP(p, ss(i), 1)
		actVal = actual(0)
		actPos = actual(1)
		actTyp = typeOf(actVal)
		expTyp = typeOf(expVal)
		actStr = toString(actVal)
		expStr = toString(expVal)
		
		If isObject(expVal) Then
			If assertEqual(actPos, expPos).isFail _
			Or assertEqual(actTyp, expTyp).isFail _
			Or assertEqual(actStr, expStr).isFail _
			Then : Goto assert_parses_failed : End If
		Else
			If assertEqual(actPos, expPos).isFail _
			Or assertEqual(actVal, expVal).isFail _
			Then : Goto assert_parses_failed : End If
		End If
	Next i
	assert_parses = mkPass()
	Exit Function
assert_parses_failed:
	actual   = List(actPos, actTyp, actStr)
	expected = List(expPos, expTyp, expStr)
	msg = &quot;actual &quot; _
		&amp; NL &amp; NL &amp; &quot;  &quot; &amp; toString(actual) _
		&amp; NL &amp; NL &amp; &quot;expected to equal:&quot; _
		&amp; NL &amp; NL &amp; &quot;  &quot; &amp; toString(expected)
	If gotArray Then
		msg = &quot;at index &quot; &amp; i &amp; &quot;: &quot; &amp; toString(ss(i)) _
			&amp; NL &amp; msg
	End If
	assert_parses = mkFail(actual, expected, msg)
End Function

&apos;= actual tests ===============================================================

Function test_Parser_fail()
	refute_parses(pFail, Array( _
		&quot;&quot;,	&quot; &quot;, &quot;   &quot;, CR, TAB, &quot;a&quot;, &quot;1&quot;, &quot;[]&quot;, &quot;asdf&quot; _
	)).x
End Function

Function test_Parser_return()
	Dim p As Variant
	Dim expected As Variant
	
	p = pReturn
	assertEqual(isFn(p), True).x
	assertEqual(arity(p),  1).x

	p = pReturn(&quot;bar&quot;)
	assert_parses(p, &quot;&quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot; &quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot;a&quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot;1&quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot;[]&quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot;abcd&quot;,	&quot;bar&quot;, 1).x
	assert_parses(p, CR,	&quot;bar&quot;, 1).x

	p = pReturn(4711)	
	assert_parses(p, &quot;&quot;,		4711, 1).x
	assert_parses(p, &quot; &quot;,		4711, 1).x
	assert_parses(p, &quot;a&quot;,		4711, 1).x
	assert_parses(p, &quot;1&quot;,		4711, 1).x
	assert_parses(p, &quot;[]&quot;,		4711, 1).x
	assert_parses(p, &quot;abcd&quot;,	4711, 1).x
	assert_parses(p, CR,	4711, 1).x
End Function

Function test_Parser_item()
	Dim p As Parser
	Set p = pItem

	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;,		&quot; &quot;, 2).x
	assert_parses(p, &quot;a&quot;,		&quot;a&quot;, 2).x
	assert_parses(p, &quot;1&quot;,		&quot;1&quot;, 2).x
	assert_parses(p, &quot;[]&quot;,		&quot;[&quot;, 2).x
	assert_parses(p, &quot;abcd&quot;,	&quot;a&quot;, 2).x
	assert_parses(p, CR,	CR, 2).x
	assert_parses(p, TAB,	TAB, 2).x
End Function

Function test_Parser_end()
	Dim p As Object
	
	p = pEnd
	assert_parses(p, &quot;&quot;, Empty, 1).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;5&quot;).x
End Function

Function test_Parser_str()
	Dim p As Object
	
	p = pStr
	assertEqual(isFn(p), True).x
	assertEqual(arity(p),  1).x
	
&apos;	assertThrows(pStr, Array(&quot;&quot;)).x

	p = pStr(&quot;bar&quot;)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot; &quot; &amp; CR).x
	refute_parses(p, &quot;asdf&quot;).x
	refute_parses(p, &quot; bar&quot;).x
	refute_parses(p, &quot;b&quot;).x
	refute_parses(p, &quot;ba&quot;).x
	assert_parses(p, &quot;bar&quot;,		&quot;bar&quot;, 4).x
	assert_parses(p, &quot;barb&quot;,	&quot;bar&quot;, 4).x
	assert_parses(p, &quot;barba&quot;,	&quot;bar&quot;, 4).x
	assert_parses(p, &quot;barbar&quot;,	&quot;bar&quot;, 4).x

	p = pStr(CR)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot; &quot; &amp; CR).x
	refute_parses(p, &quot;asdf&quot;).x
	refute_parses(p, &quot; bar&quot;).x
	refute_parses(p, &quot;b&quot;).x
	refute_parses(p, &quot;ba&quot;).x
	refute_parses(p, &quot;bar&quot;).x
	refute_parses(p, &quot;barb&quot;).x
	refute_parses(p, &quot;barba&quot;).x
	refute_parses(p, &quot;barbar&quot;).x
	assert_parses(p, CR,				CR, 2).x
	assert_parses(p, CR &amp; &quot;bar&quot;,		CR, 2).x
	assert_parses(p, CR &amp; CR,			CR, 2).x
	assert_parses(p, CR &amp; CR &amp; &quot;bar&quot;,	CR, 2).x
End Function

Function test_Parser_choice()
	Dim p As Object
	Dim data As Variant

	p = pChoice
	assertEqual(isFn(p), True).x
	assertEqual(arity(p),  2).x
	p = apply(p, pItem)
	assertEqual(isFn(p), True).x
	assertEqual(arity(p),  1).x
	p = apply(p, pReturn(7))
		
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; CR, &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, CR, CR &amp; &quot;bar&quot;, CR &amp; CR,_
		CR &amp; CR &amp; &quot;bar&quot;_
	)
	p = pChoice(pFail, pFail)
	refute_parses(p, data).x
	
	p = pChoice(pReturn(7), pFail)
	assert_parses(p, data, 7, 1).x
	
	p = pChoice(pFail, pReturn(7))
	assert_parses(p, data, 7, 1).x
	
	p = pChoice(pReturn(42), pReturn(7))
	assert_parses(p, data, 42, 1).x
	
	assert_parses(pChoice(pItem, pReturn(11)), 	&quot;&quot;, 11, 1	).x
	refute_parses(pChoice(pItem, pStr(&quot;x&quot;)),	&quot;&quot;).x
	assert_parses(pChoice(pReturn(11), pItem), 	&quot;&quot;, 11, 1	).x
	refute_parses(pChoice(pStr(&quot;x&quot;), pItem),	&quot;&quot;).x
	
	assert_parses(pChoice(pItem, pReturn(11)), 	&quot; &quot;, &quot; &quot;, 2	).x
	assert_parses(pChoice(pItem, pStr(&quot;x&quot;)), 	&quot; &quot;, &quot; &quot;, 2	).x
	assert_parses(pChoice(pReturn(11), pItem), 	&quot; &quot;, 11, 1	).x
	assert_parses(pChoice(pStr(&quot;x&quot;), pItem), 	&quot; &quot;, &quot; &quot;, 2	).x
	
	assert_parses(pChoice(pItem, pReturn(11)), 	&quot;x&quot;, &quot;x&quot;, 2	).x
	assert_parses(pChoice(pItem, pStr(&quot;x&quot;)), 	&quot;x&quot;, &quot;x&quot;, 2	).x
	assert_parses(pChoice(pReturn(11), pItem), 	&quot;x&quot;, 11, 1	).x
	assert_parses(pChoice(pStr(&quot;x&quot;), pItem), 	&quot;x&quot;, &quot;x&quot;, 2	).x
End Function

Function test_Parser_bind()
	Dim p As Object
	
	p = pBind
	assertEqual(isFn(p), True).x
	assertEqual(arity(p),   2).x
	
	p = pBind(pItem)
	assertEqual(isFn(p), True).x
	assertEqual(arity(p),   1).x
	
	p = apply(p, fstArg(pStr(&quot;y&quot;)))
	assert_parses(p, &quot;xy&quot;, &quot;y&quot;, 3).x
	refute_parses(p, &quot;xx&quot;).x
	refute_parses(p, &quot;yx&quot;).x
	assert_parses(p, &quot; yabcd&quot;, &quot;y&quot;, 3).x
	
&apos;	p = item &gt;&gt;= return ° (concat &quot;FOO&quot;)
	p = pBind(pItem, compose(pReturn, concat(&quot;FOO&quot;)))
	assert_parses(p, &quot;xy&quot;,		&quot;FOOx&quot;, 2).x
	assert_parses(p, &quot;xx&quot;,		&quot;FOOx&quot;, 2).x
	assert_parses(p, &quot;yx&quot;,		&quot;FOOy&quot;, 2).x
	assert_parses(p, &quot; yabcd&quot;,	&quot;FOO &quot;, 2).x
	
&apos;	p = item &gt;&gt;= \x.if (=? &quot;y&quot; x) then (return x) else fail 
&apos;     = item &gt;&gt;= \x.ite (=? &quot;y&quot;) return (K fail)
	p = pBind( pItem, ite(equ(&quot;y&quot;), pReturn, fstArg(pFail)) )
	refute_parses(p, &quot;xy&quot;).x
	refute_parses(p, &quot;xx&quot;).x
	assert_parses(p, &quot;yx&quot;,		&quot;y&quot;, 2).x
	assert_parses(p, &quot;yy&quot;,		&quot;y&quot;, 2).x
	refute_parses(p, &quot; yabcd&quot;).x	

	&apos; under-skip-status MUST NOT be passed down into the parser (bind&apos;s 1st arg)
	&apos; because the function (bind&apos;s 2nd arg) might need the parser&apos;s
	&apos; result in order to decide what other parser to produce:
&apos;	p = (skip ( item &gt;&gt;= \x.if (=? &quot;y&quot; x) then (return x) else fail ))
&apos;     = (skip ( item &gt;&gt;= \x.ite (=? &quot;y&quot;) return (K fail) ))
	p = pSkip(pBind( pItem, ite(equ(&quot;y&quot;), pReturn, fstArg(pFail)) ))
	refute_parses(p, &quot;xy&quot;).x
	refute_parses(p, &quot;xx&quot;).x
	assert_parses(p, &quot;yx&quot;,		Empty, 2).x	&apos; succeeds but skips result
	assert_parses(p, &quot;yy&quot;,		Empty, 2).x	&apos; succeeds but skips result
	refute_parses(p, &quot; yabcd&quot;).x
End Function

Function test_Parser_bind_simplify()
	Dim p As Object, q As Object, r As Object, x As Object
	Dim f As Object, g As Object, h As Object, i As Object
	Dim v As Variant
	
	&apos; pBind( pFail, ...)
	&apos;===================
	&apos; p = fail &gt;&gt;= f
	&apos;   = fail
	q = pFail
	f = fstArg(pStr(&quot;x&quot;))
	p = pBind(q, f)
	refute_parses(p, Array(&quot;&quot;, &quot;x&quot;, &quot;xx&quot;)).x
	&apos; So it&apos;s behaving like pFail. But is pBind actually doing the simplification?
	assert_toString_equals(p, pFail).x
	
	&apos; pBind( (pReturn v), ...)
	&apos;=========================
	&apos; p = (return v) &gt;&gt;= f
	&apos;   = (f v)
	v = &quot;foobar&quot;
	q = pReturn(v)
	assert_parses(q, &quot;&quot;, v, 1).x
	f = pStr
	p = pBind(q, f) &apos; long-winded way of building pStr(&quot;foobar&quot;)
	refute_parses(p, Array(&quot;&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;fooBAR&quot;, &quot;FOObar&quot;)).x
	assert_parses(p, v, v, Len(v) + 1).x
	x = apply(f, v)
	refute_parses(x, Array(&quot;&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;fooBAR&quot;, &quot;FOObar&quot;)).x
	assert_parses(x, v, v, Len(v) + 1).x
	&apos; assert that pBind does the simplification:
	assert_toString_equals(p, x).x


	&apos; pBind( (pBind ...), ...)
	&apos;=========================
	
	&apos; p = (q &gt;&gt;= return ° g) &gt;&gt;= f
	&apos;-----------------------------
	&apos;   = q &gt;&gt;= f ° g
	q = pStr(&quot;foo&quot;)
	g = concat(&quot;bar&quot;)
	r = pBind(q, compose(pReturn, g))	&apos; r = (str &quot;bar&quot;) &gt;&gt;= (return ° (concat &quot;bar&quot;))
	f = pStr
	p = pBind(r, f) &apos;  p = ((str &quot;bar&quot;) &gt;&gt;= (return ° (concat &quot;bar&quot;)) ) &gt;&gt;= pStr
	&apos;...which matches &quot;foo&quot; then &quot;barfoo&quot; and returns the latter
	refute_parses(p, Array(&quot;foo&quot;, &quot;foobar&quot;, &quot;foofoobar&quot;, &quot;foobarbar&quot;)).x
	assert_parses(p, &quot;foobarfoo&quot;, &quot;barfoo&quot;, 10).x
	&apos; But this can be simplified to p = (str &quot;bar&quot;) &gt;&gt;= pStr ° (concat &quot;bar&quot;)
	&apos; In general: ((q &gt;&gt;= return ° g) &gt;&gt;= f) = (q &gt;&gt;= f ° g)
	p = pBind(q, compose(f, g))
	refute_parses(p, Array(&quot;foo&quot;, &quot;foobar&quot;, &quot;foofoobar&quot;, &quot;foobarbar&quot;)).x
	assert_parses(p, &quot;foobarfoo&quot;, &quot;barfoo&quot;, 10).x
	&apos; assert that pBind actually does this simplification:
	assert_toString_equals(pBind(r, f), pBind(q, compose(f, g))).x
	
	&apos; p = (q &gt;&gt;= return ° g) &gt;&gt;= f  where f = (K r)
	&apos;----------------------------------------------
	&apos;   = q &gt;&gt;= (K r) ° g
	&apos;   = q &gt;&gt;= (K r)
	&apos;   = q &gt;&gt;= f
	q = pStr(&quot;foo&quot;)
	g = concat(&quot;bar&quot;)
	r = pStr(&quot;qmbl&quot;)
	f = fstArg(r)
	p = pBind( pBind(q, compose(pReturn, g)), f )
	refute_parses(p, Array(&quot;foo&quot;, &quot;foobar&quot;, &quot;foobarqmbl&quot;)).x
	assert_parses(p, &quot;fooqmbl&quot;, &quot;qmbl&quot;, 8).x
	&apos; simplified: q &gt;&gt;= f
	refute_parses(pBind(q, f), Array(&quot;foo&quot;, &quot;foobar&quot;, &quot;foobarqmbl&quot;)).x
	assert_parses(pBind(q, f), &quot;fooqmbl&quot;, &quot;qmbl&quot;, 8).x
	&apos; pBind actually does simplify it:
	assert_toString_equals(p, pBind(q, f)).x
	
	&apos; p = (q &gt;&gt;= return ° g) &gt;&gt;= f  where f = h ° i
	&apos;----------------------------------------------
	&apos;   = q &gt;&gt;= (h ° i) ° g
	&apos;   = q &gt;&gt;= h ° (i ° g)
	q = pStr(&quot;foo&quot;)
	g = concat(&quot;bar&quot;)
	h = pStr
	i = Fn.UCase &apos; turns a string into all upper-case
	f = compose(h, i)
	r = pBind(q, compose(pReturn, g))
	p = pBind(r, f) &apos; p = (str &quot;foo&quot;) &gt;&gt;= return ° (concat &quot;bar&quot;)) &gt;&gt;= (pStr ° ucase)
	&apos; p matches &quot;foo&quot;, then &quot;BARFOO&quot; and returns the latter
	&apos;show(p)
	refute_parses(p, Array(&quot;foo&quot;, &quot;foobar&quot;, &quot;foobarfoo&quot;, &quot;fooBARfoo&quot;, &quot;FOOBARfoo&quot;)).x
	assert_parses(p, &quot;fooBARFOO&quot;, &quot;BARFOO&quot;, 10).x
	&apos; simplified: x = q &gt;&gt;= h ° (i ° g)
	x = pBind(q, compose(h, compose(i, g)))
	refute_parses(x, Array(&quot;foo&quot;, &quot;foobar&quot;, &quot;foobarfoo&quot;, &quot;fooBARfoo&quot;, &quot;FOOBARfoo&quot;)).x
	assert_parses(x, &quot;fooBARFOO&quot;, &quot;BARFOO&quot;, 10).x
	&apos; pBind actually does simplify it:
	assert_toString_equals(p, x).x
	&apos; Note: fn composition is associative, ie (h ° i) ° g = h ° (i ° g)
	&apos;       So semantically they&apos;re the same. However, from an implementation
	&apos;       point of view - in pBind - we would like it to be represented as
	&apos;       right-associative (as on rhs of the equality), so we can easily
	&apos;       spot pReturn ° (...)

	 
	&apos; p = (q &gt;&gt;= K r) &gt;&gt;= f
	&apos;----------------------
	&apos;   = q &gt;&gt;= K (r &gt;&gt;= f)
	q = pStr(&quot;foo&quot;)
	r = pStr(&quot;bar&quot;)
	f = compose(pStr, Fn.ucase)
	p = pBind( pBind(q, fstArg(r)), f )
	refute_parses(p, &quot;&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;foobarbar&quot;, &quot;fooBARbar&quot;, &quot;fooBARBAR&quot;).x
	assert_parses(p, &quot;foobarBAR&quot;, &quot;BAR&quot;, 10).x
	x = pBind(q, fstArg(pBind(r, f)))	
	refute_parses(x, &quot;&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;foobarbar&quot;, &quot;fooBARbar&quot;, &quot;fooBARBAR&quot;).x
	assert_parses(x, &quot;foobarBAR&quot;, &quot;BAR&quot;, 10).x
	&apos; assert that pBind actually does the simplification:
	assert_toString_equals(p, x).x
	
	
	&apos; p = (q &gt;&gt;= K (return v)) &gt;&gt;= f
	&apos;-------------------------------
	&apos;   = q &gt;&gt;= K (f v)
	&apos; This is a special of the above and should be covered
	&apos; by it plus the (return v) &gt;&gt;= f  ~&gt;  (f v) simplification
	q = pStr(&quot;foo&quot;)
	v = &quot;bar&quot;
	f = compose(pStr, Fn.ucase)
	r = pBind(q, fstArg(pReturn(v)))
	p = pBind(r, f)
	refute_parses(p, &quot;&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;foobar&quot;).x
	assert_parses(p, &quot;fooBAR&quot;, &quot;BAR&quot;, 7).x
	x = pBind(q, fstArg(apply(f, v)))
	refute_parses(x, &quot;&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;foobar&quot;).x
	assert_parses(x, &quot;fooBAR&quot;, &quot;BAR&quot;, 7).x
	&apos; assert that pBind actually does the simplification:
	assert_toString_equals(p, x).x

End Function

Function test_Parser_sat()
	Dim p As Parser, actual As Variant
	Set p = pSat(apply(Fn.equ, &quot;a&quot;)
	
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	assert_parses(p, &quot;a&quot;,		&quot;a&quot;, 2).x
	assert_parses(p, &quot;aa&quot;,		&quot;a&quot;, 2).x
	refute_parses(p, &quot;1&quot;).x
	refute_parses(p, &quot;[]&quot;).x
	assert_parses(p, &quot;abcd&quot;,	&quot;a&quot;, 2).x
	refute_parses(p, CR).x
	refute_parses(p, TAB).x
End Function

Function test_Parser_skip()
	Dim p As Parser, actual As Variant
	Set p = pSkip(pItem)
	refute_parses(p, &quot;&quot;).x
	applyP(p, &quot; &quot;)
	assert_parses(p, &quot; &quot;,		Empty, 2).x
	assert_parses(p, &quot;a&quot;,		Empty, 2).x
	assert_parses(p, &quot;1&quot;,		Empty, 2).x
	assert_parses(p, &quot;[]&quot;,		Empty, 2).x
	assert_parses(p, &quot;abcd&quot;,	Empty, 2).x
	assert_parses(p, CR,   Empty, 2).x
	assert_parses(p, TAB,	Empty, 2).x
	
	&apos; skip fail = fail
	Set p = pSkip(pFail)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;1&quot;).x
	refute_parses(p, &quot;[]&quot;).x
	refute_parses(p, &quot;abcd&quot;).x
	refute_parses(p, CR).x
	refute_parses(p, TAB).x
		
	Set p = pSkip(pBind(pItem, fstArg(pItem)))
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;1&quot;).x
	assert_parses(p, &quot;[]&quot;,				Empty, 3).x
	assert_parses(p, &quot;abcd&quot;,			Empty, 3).x
	refute_parses(p, CR).x
	refute_parses(p, TAB).x
	assert_parses(p, CR &amp; CR,	Empty, 3).x
	assert_parses(p, TAB &amp; TAB,	Empty, 3).x

	&apos; skip (return x) = return Empty
	Set p = pSkip(pReturn(&quot;foo&quot;))
	assert_parses(p, &quot;&quot;,		Empty, 1).x
	assert_parses(p, &quot; &quot;,		Empty, 1).x
	assert_parses(p, &quot;a&quot;,		Empty, 1).x
	assert_parses(p, &quot;1&quot;,		Empty, 1).x
	assert_parses(p, &quot;[]&quot;,		Empty, 1).x
	assert_parses(p, &quot;abcd&quot;,	Empty, 1).x
	assert_parses(p, CR,   Empty, 1).x
	assert_parses(p, TAB,	Empty, 1).x

	&apos; skip (skip x) = skip x
	Set p = pSkip(pSkip(pItem))
&apos;	msgbox(toString(p))
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;,		Empty, 2).x
	assert_parses(p, &quot;a&quot;,		Empty, 2).x
	assert_parses(p, &quot;1&quot;,		Empty, 2).x
	assert_parses(p, &quot;[]&quot;,		Empty, 2).x
	assert_parses(p, &quot;abcd&quot;,	Empty, 2).x
	assert_parses(p, CR,   Empty, 2).x
	assert_parses(p, TAB,	Empty, 2).x

	Set p = pSkip(pStr(&quot;foo&quot;))
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;1&quot;).x
	refute_parses(p, &quot;[]&quot;).x
	refute_parses(p, &quot;abcd&quot;).x
	refute_parses(p, CR).x
	refute_parses(p, TAB).x
	
	assert_parses(p, &quot;foo&quot;,				Empty, 4).x
	assert_parses(p, &quot;foo &quot;,			Empty, 4).x
	assert_parses(p, &quot;fooa&quot;,			Empty, 4).x
	assert_parses(p, &quot;foo1&quot;,			Empty, 4).x
	assert_parses(p, &quot;foo[]&quot;,			Empty, 4).x
	assert_parses(p, &quot;fooabcd&quot;,			Empty, 4).x
	assert_parses(p, &quot;foo&quot; &amp; CR,   Empty, 4).x
	assert_parses(p, &quot;foo&quot; &amp; TAB,	Empty, 4).x
	
	Set p = pSkip(pSeq(Array(pStr(&quot;f&quot;), pStr(&quot;oo&quot;)), concat)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;1&quot;).x
	refute_parses(p, &quot;[]&quot;).x
	refute_parses(p, &quot;abcd&quot;).x
	refute_parses(p, CR).x
	refute_parses(p, TAB).x
	
	assert_parses(p, &quot;foo&quot;,				Empty, 4).x
	assert_parses(p, &quot;foo &quot;,			Empty, 4).x
	assert_parses(p, &quot;fooa&quot;,			Empty, 4).x
	assert_parses(p, &quot;foo1&quot;,			Empty, 4).x
	assert_parses(p, &quot;foo[]&quot;,			Empty, 4).x
	assert_parses(p, &quot;fooabcd&quot;,			Empty, 4).x
	assert_parses(p, &quot;foo&quot; &amp; CR,   Empty, 4).x
	assert_parses(p, &quot;foo&quot; &amp; TAB,	Empty, 4).x
	
	Set p = pSkip(pZeroOrOne(pItem))
	assert_parses(p, &quot;&quot;,		Empty, 1).x
	assert_parses(p, &quot; &quot;,		Empty, 2).x
	assert_parses(p, &quot;a&quot;,		Empty, 2).x
	assert_parses(p, &quot;1&quot;,		Empty, 2).x
	assert_parses(p, &quot;[]&quot;,		Empty, 2).x &apos; reads at most one
	assert_parses(p, &quot;abcd&quot;,	Empty, 2).x
	assert_parses(p, CR,   Empty, 2).x
	assert_parses(p, TAB,	Empty, 2).x
	
	Set p = pSkip(pMany(pItem))
&apos;	msgbox(toString(p))
	assert_parses(p, &quot;&quot;,		Empty, 1).x
	assert_parses(p, &quot; &quot;,		Empty, 2).x
	assert_parses(p, &quot;a&quot;,		Empty, 2).x
	assert_parses(p, &quot;1&quot;,		Empty, 2).x
	assert_parses(p, &quot;[]&quot;,		Empty, 3).x
	assert_parses(p, &quot;abcd&quot;,	Empty, 5).x
	assert_parses(p, CR,   Empty, 2).x
	assert_parses(p, TAB,	Empty, 2).x	
	
	Set p = pSkip(pMany1(pItem))
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;,		Empty, 2).x
	assert_parses(p, &quot;a&quot;,		Empty, 2).x
	assert_parses(p, &quot;1&quot;,		Empty, 2).x
	assert_parses(p, &quot;[]&quot;,		Empty, 3).x
	assert_parses(p, &quot;abcd&quot;,	Empty, 5).x
	assert_parses(p, CR,   Empty, 2).x
	assert_parses(p, TAB,	Empty, 2).x	

	Set p = pSkip(pMany(pWhite))
	assert_parses(p, &quot;&quot;,		Empty, 1).x
	assert_parses(p, &quot; &quot;,		Empty, 2).x
	assert_parses(p, &quot;  &quot;,		Empty, 3).x
	assert_parses(p, &quot;a&quot;,		Empty, 1).x
	assert_parses(p, &quot;1&quot;,		Empty, 1).x
	assert_parses(p, &quot; a&quot;,		Empty, 2).x
	assert_parses(p, &quot;  1&quot;,		Empty, 3).x
	assert_parses(p, &quot;[]&quot;,		Empty, 1).x
	assert_parses(p, &quot;abcd&quot;,	Empty, 1).x
	assert_parses(p, &quot;   d&quot;,	Empty, 4).x
	assert_parses(p, CR,   Empty, 1).x
	assert_parses(p, TAB,	Empty, 2).x	
	
	Set p = pBind(pSkip(pMany(pWhite)), fstArg(pStr(&quot;xx&quot;))
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;x&quot;).x
	assert_parses(p, &quot;xx&quot;,		&quot;xx&quot;,  3).x
	assert_parses(p, &quot;xxx&quot;,		&quot;xx&quot;,  3).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot; x&quot;).x
	assert_parses(p, &quot; xx&quot;,		&quot;xx&quot;,  4).x
	assert_parses(p, &quot; xxx&quot;,	&quot;xx&quot;,  4).x
	refute_parses(p, &quot;  &quot;).x
	refute_parses(p, &quot;  x&quot;).x
	assert_parses(p, &quot;  xx&quot;,	&quot;xx&quot;,  5).x
	assert_parses(p, &quot;  xxx&quot;,	&quot;xx&quot;,  5).x
	refute_parses(p, TAB).x
	refute_parses(p, TAB &amp; &quot;  &quot;).x
	refute_parses(p, TAB &amp; &quot;  x&quot;).x
	assert_parses(p, TAB &amp; &quot;  xx&quot;,	&quot;xx&quot;,  6).x
	assert_parses(p, TAB &amp; &quot;  xxx&quot;,	&quot;xx&quot;,  6).x
	
	Dim mkList1 As Object, mkList2 As Object, expected As Object
	Set mkList1 = swap(cons, nil) &apos; \y.cons y nil
	Set mkList2 = swap(compose(swap(cons), mkList1)) &apos; \x y.cons x (cons y nil))
	Set expected = apply(mkList2, &quot;foo&quot;, &quot;bar&quot;)
	assertEqual(toString(expected), &quot;[&apos;foo&apos;, &apos;bar&apos;]&quot;).x
	Set p = pSeq(Array(pSkip(pMany(pWhite)), _
					   pStr(&quot;foo&quot;), _
					   pSkip(pMany(pWhite)), _
					   pStr(&quot;bar&quot;), _
					   pSkip(pMany(pWhite)) _
				 ), mkList2 _
	)
	assert_parses(p, &quot;foobar&quot;, 		expected,  7).x
	assert_parses(p, &quot;   foobar&quot;, 	expected, 10).x
	assert_parses(p, &quot;foobar   &quot;, 	expected, 10).x
	assert_parses(p, &quot;foo   bar&quot;, 	expected, 10).x
	assert_parses(p, &quot; foo  bar&quot;, 	expected, 10).x
	assert_parses(p, &quot;foo  bar &quot;, 	expected, 10).x
	assert_parses(p, &quot; foo bar &quot;, 	expected, 10).x
End Function

Function test_Parser_indirect()
	Dim p As Parser, q As Parser, r As Parser
	r = pInd(&quot;Something&quot;)
	&apos;Note: most of the parsers we create here don&apos;t actually make sense
	&apos;      the important thing for testing is their structure
	
	assertEqual(getPIndName(r), &quot;Something&quot;).x
	
	p = pInd(&quot;&quot;) : q = pInd(&quot;&quot;)
	assertEqual(p.id = q.id, False).x
	
	p = pInd(&quot;&quot;) : q = pReturn(&quot;foo&quot;)
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	
	p = pInd(&quot;&quot;) : q = pFail
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	
	p = pInd(&quot;&quot;) : q = pItem
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	
	p = pInd(&quot;&quot;) : q = pStr(&quot;bar&quot;)
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	
	p = pInd(&quot;&quot;) : q = pSat(compose(inRange(5, 7), Fn.asc))
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	
	p = pInd(&quot;&quot;) : q = pSkip(pItem)
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	
	p = pInd(&quot;&quot;) : q = pSkip(pStr(&quot;foo&quot;))
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	
	p = pInd(&quot;&quot;) : q = pSkip(p)
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	
	p = pInd(&quot;&quot;) : q = pChoice(pStr(&quot;foo&quot;), p)
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	Dim altsP As Object, altsQ As Object
	altsP = p.st.st : altsQ = q.st
	Dim alt1P As Object, alt1Q As Object
	alt1P = altsP(0) : alt1Q = altsQ(0)
	assertEqual(alt1P.tp, alt1Q.tp).x
	assertEqual(alt1P.id, alt1Q.id).x
	assertEqual(alt1P.st, alt1Q.st).x

	Dim alt2P As Object, alt2Q As Object
	alt2P = altsP(1) : alt2Q = altsQ(1)
	assertEqual(alt2P.tp, alt2Q.tp).x
	assertEqual(alt2P.id, alt2Q.id).x
	assertEqual(alt2P.tp, p.tp).x &apos; there is the recursion!
	assertEqual(alt2P.id, p.id).x &apos; there is the recursion!


	p = pInd(&quot;&quot;) : q = pZeroOrOne(p)
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x

	p = pInd(&quot;&quot;) : q = pMany1(p)
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x

	p = pInd(&quot;&quot;) : q = pMany(p)
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x

	p = pInd(&quot;&quot;) : q = pChoice( pStr(&quot;x&quot;), pSeq(Array(pSkip(pStr(&quot;(&quot;)), p, pSkip(pStr(&quot;)&quot;))), id) )
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;()&quot;).x
	refute_parses(p, &quot;(x&quot;).x
	assert_parses(p, &quot;x))&quot;, 		&quot;x&quot;,  2).x
	refute_parses(p, &quot;(())&quot;).x
	refute_parses(p, &quot;((x)&quot;).x
	assert_parses(p, &quot;(x))&quot;,		&quot;x&quot;,  4).x
	assert_parses(p, &quot;x&quot;, 			&quot;x&quot;,  2).x
	assert_parses(p, &quot;(x)&quot;, 		&quot;x&quot;,  4).x
	assert_parses(p, &quot;((x))&quot;, 		&quot;x&quot;,  6).x
	assert_parses(p, &quot;(((x)))&quot;, 	&quot;x&quot;,  8).x
	assert_parses(p, &quot;((((x))))&quot;, 	&quot;x&quot;, 10).x
	assert_parses(p, &quot;(((((x)))))&quot;,	&quot;x&quot;, 12).x
	
			
	&apos;TODO: test_Parser_ind: fixIndirection .. bind
	
End Function

Function test_Parser_zeroOrOne()
	Dim p As Parser
	Dim data As Variant
	Dim zeroMatches As Variant, oneMatch As Variant
	zeroMatches = Empty
	oneMatch    = &quot;x&quot;
		
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; CR, &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, CR, CR &amp; &quot;bar&quot;, CR &amp; CR,_
		CR &amp; CR &amp; &quot;bar&quot;_
	)

	p = pZeroOrOne(pStr(&quot;x&quot;))
	assert_parses(p, data,	zeroMatches, 1).x
	assert_parses(p, &quot;x&quot;, 	oneMatch, 2).x
	assert_parses(p, &quot;xx&quot;, 	oneMatch, 2).x
	assert_parses(p, &quot;xxx&quot;, oneMatch, 2).x
	assert_parses(p, &quot; x&quot;, 	zeroMatches, 1).x
	assert_parses(p, &quot; xx&quot;, zeroMatches, 1).x
	assert_parses(p, &quot; xxx&quot;,zeroMatches, 1).x
	
	&apos; double p?? is the same as p?:
	p = pZeroOrOne(pZeroOrOne(pStr(&quot;x&quot;)))
	assert_parses(p, data,	zeroMatches, 1).x
	assert_parses(p, &quot;x&quot;, 	oneMatch, 2).x
	assert_parses(p, &quot;xx&quot;, 	oneMatch, 2).x
	assert_parses(p, &quot;xxx&quot;, oneMatch, 2).x
	assert_parses(p, &quot; x&quot;, 	zeroMatches, 1).x
	assert_parses(p, &quot; xx&quot;, zeroMatches, 1).x
	assert_parses(p, &quot; xxx&quot;,zeroMatches, 1).x
	
	&apos; (skip p)? always yields Empty, but pos may or may not be advanced:
	p = pZeroOrOne(pSkip(pStr(&quot;x&quot;)))
	assert_parses(p, data,	Empty, 1).x
	assert_parses(p, &quot;x&quot;, 	Empty, 2).x
	assert_parses(p, &quot;xx&quot;, 	Empty, 2).x
	assert_parses(p, &quot;xxx&quot;, Empty, 2).x
	assert_parses(p, &quot; x&quot;, 	Empty, 1).x
	assert_parses(p, &quot; xx&quot;, Empty, 1).x
	assert_parses(p, &quot; xxx&quot;,Empty, 1).x
	
	&apos; (skip p?) always yields Empty, but pos may or may not be advanced.
	&apos; So: (skip p?) = (skip p)?
	p = pSkip(pZeroOrOne(pStr(&quot;x&quot;)))
	assert_parses(p, data,	Empty, 1).x
	assert_parses(p, &quot;x&quot;, 	Empty, 2).x
	assert_parses(p, &quot;xx&quot;, 	Empty, 2).x
	assert_parses(p, &quot;xxx&quot;, Empty, 2).x
	assert_parses(p, &quot; x&quot;, 	Empty, 1).x
	assert_parses(p, &quot; xx&quot;, Empty, 1).x
	assert_parses(p, &quot; xxx&quot;,Empty, 1).x
End Function

Function test_Parser_skip_zeroOrOne()
	Dim p As Parser
	Dim data As Variant
			
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; CR, &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, CR, CR &amp; &quot;bar&quot;, CR &amp; CR,_
		CR &amp; CR &amp; &quot;bar&quot;_
	)

	p = pSkip(pZeroOrOne(pStr(&quot;x&quot;)))
	assert_parses(p, data,	Empty, 1).x
	assert_parses(p, &quot;x&quot;, 	Empty, 2).x
	assert_parses(p, &quot;xx&quot;, 	Empty, 2).x
	assert_parses(p, &quot;xxx&quot;, Empty, 2).x
	assert_parses(p, &quot; x&quot;, 	Empty, 1).x
	assert_parses(p, &quot; xx&quot;, Empty, 1).x
	assert_parses(p, &quot; xxx&quot;,Empty, 1).x
	
	&apos;TODO: is that what we want?: pZeroOrOne (pSkip p) = pSkip (pZeroOrOne p)  ...?
	p = pZeroOrOne(pSkip(pStr(&quot;x&quot;)))
	assert_parses(p, data,	Empty, 1).x
	assert_parses(p, &quot;x&quot;, 	Empty, 2).x
	assert_parses(p, &quot;xx&quot;, 	Empty, 2).x
	assert_parses(p, &quot;xxx&quot;, Empty, 2).x
	assert_parses(p, &quot; x&quot;, 	Empty, 1).x
	assert_parses(p, &quot; xx&quot;, Empty, 1).x
	assert_parses(p, &quot; xxx&quot;,Empty, 1).x
End Function

Function test_Parser_white()
	Dim p As Parser
	p = pWhite

	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;, 					&quot; &quot;, 2	).x
	assert_parses(p, TAB, 					TAB, 2	).x
	refute_parses(p, CR).x
	refute_parses(p, &quot;asdf&quot;).x
	assert_parses(p, &quot; asdf&quot;, 				&quot; &quot;, 2).x
	assert_parses(p, TAB &amp; &quot;asdf&quot;, 			TAB, 2).x
	refute_parses(p, CR &amp; &quot;asdf&quot;).x
	assert_parses(p, &quot;  asdf&quot;, 				&quot; &quot;, 2).x
	assert_parses(p, TAB &amp; TAB &amp; &quot;asdf&quot;, 	TAB, 2).x
	refute_parses(p, CR &amp; TAB &amp; &quot;asdf&quot;).x
	assert_parses(p, TAB &amp; CR &amp; &quot;asdf&quot;, 	TAB, 2).x
	refute_parses(p, CR &amp; CR &amp; &quot;asdf&quot;).x
End Function

Function test_Parser_range()
	Dim p As Parser, i As Integer
	
	p = pRange(&quot;A&quot;, &quot;Z&quot;)
	For i = 1 To Asc(&quot;A&quot;) - 1
		refute_parses(p, Chr(i)).x
	Next i
	For i = Asc(&quot;A&quot;) To Asc(&quot;Z&quot;)
		assert_parses(p, Chr(i), Chr(i), 2).x
	Next i
	For i = Asc(&quot;Z&quot;) + 1 To 255
		refute_parses(p, Chr(i)).x
	Next i
	assertEqual(toString(p), &quot;[A-Z]&quot;).x
	
	p = pRange(TAB, CR)
	For i = 1 To Asc(TAB) - 1
		refute_parses(p, Chr(i)).x
	Next i
	For i = Asc(TAB) To Asc(CR)
		assert_parses(p, Chr(i), Chr(i), 2).x
	Next i
	For i = Asc(CR) + 1 To 255
		refute_parses(p, Chr(i)).x
	Next i
	assertEqual(toString(p), &quot;[\t-\r]&quot;).x	
	
	p = pRange(LF, &quot;-&quot;)
	For i = 1 To Asc(LF) - 1
		refute_parses(p, Chr(i)).x
	Next i
	For i = Asc(LF) To Asc(&quot;-&quot;)
		assert_parses(p, Chr(i), Chr(i), 2).x
	Next i
	For i = Asc(&quot;-&quot;) + 1 To 255
		refute_parses(p, Chr(i)).x
	Next i
	assertEqual(toString(p), &quot;[\n-\-]&quot;).x	
	
	p = pRange(DQ, &quot;-&quot;)
	For i = 1 To Asc(DQ) - 1
		refute_parses(p, Chr(i)).x
	Next i
	For i = Asc(DQ) To Asc(&quot;-&quot;)
		assert_parses(p, Chr(i), Chr(i), 2).x
	Next i
	For i = Asc(&quot;-&quot;) + 1 To 255
		refute_parses(p, Chr(i)).x
	Next i
	&apos; Note: DQ should not be escaped
	assertEqual(toString(p), &quot;[&quot; &amp; DQ &amp; &quot;-\-]&quot;).x	
	
	p = pRange(&quot;[&quot;, &quot;]&quot;)
	For i = 1 To Asc(&quot;[&quot;) - 1
		refute_parses(p, Chr(i)).x
	Next i
	For i = Asc(&quot;[&quot;) To Asc(&quot;]&quot;)
		assert_parses(p, Chr(i), Chr(i), 2).x
	Next i
	For i = Asc(&quot;]&quot;) + 1 To 255
		refute_parses(p, Chr(i)).x
	Next i
	assertEqual(toString(p), &quot;[\[-\]]&quot;).x	
End Function

Function test_Parser_cclass()
	Dim p As Parser, i As Integer
	p = pCClass(List(&quot; &quot;, TAB)
	
	refute_parses(p, Array( _
		&quot;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;=&quot;, &quot;.&quot;, &quot;|&quot;, &quot;-&quot;, &quot;_&quot;, &quot;\&quot;, &quot;/&quot;, _
		&quot;(&quot;, &quot;)&quot;, &quot;[&quot;, &quot;]&quot;, &quot;{&quot;, &quot;}&quot;, DQ, _
		     CR, LF,     _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, _
		&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,   &quot;q&quot;,        &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, _
		&quot;A&quot;, &quot;B&quot;, &quot;C&quot;,        &quot;R&quot;,   &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, _
		_dq(&quot;\&quot;), _dq(&quot;\-&quot;), _dq(&quot;\[&quot;), _dq(&quot;\]&quot;), _
		_dq(CR), _dq(LF) _
	)).x
	
	assert_parses(p, &quot; &quot; &amp; TAB,	&quot; &quot;, 2).x
	assert_parses(p, TAB &amp; &quot; &quot;, TAB, 2).x
	assertEqual(toString(p), &quot;[ \t]&quot;).x

	p = pCClass(List(&quot;[&quot;, &quot;-&quot;, &quot;]&quot;, CR, LF, DQ, &quot;\&quot;)
	
	refute_parses(p, Array( _
		&quot;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;=&quot;, &quot;.&quot;, &quot;|&quot;,      &quot;_&quot;,      &quot;/&quot;, _
		&quot;(&quot;, &quot;)&quot;,          &quot;{&quot;, &quot;}&quot;,     _
		&quot; &quot;,         TAB, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, _
		&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,   &quot;q&quot;,        &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, _
		&quot;A&quot;, &quot;B&quot;, &quot;C&quot;,        &quot;R&quot;,   &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot; _
	)).x
	
	assert_parses(p, &quot;[&quot;,	&quot;[&quot;, 2).x
	assert_parses(p, &quot;-&quot;,	&quot;-&quot;, 2).x
	assert_parses(p, &quot;]&quot;,	&quot;]&quot;, 2).x
	assert_parses(p, CR,	CR,	 2).x
	assert_parses(p, LF,	LF,  2).x
	assert_parses(p, DQ,	DQ,  2).x
	assert_parses(p, &quot;\&quot;,	&quot;\&quot;, 2).x
	&apos; Note: DQ should not be escaped
	assertEqual(toString(p), &quot;[\[\-\]\r\n&quot; &amp; DQ &amp; &quot;\\]&quot;).x
End Function

Function test_Parser_alphaLower()
	Dim p As Parser
	p = pAlphaLower

	refute_parses(p, Array(&quot; &quot;, TAB, CR, &quot;_&quot;, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, _
		&quot;+&quot;, &quot;-&quot;, &quot;-&gt;&quot;, &quot;*&quot;, &quot;?&quot;, &quot;#&quot;,_
		&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, _
		&quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, _
		&quot;&quot;)).x
	assert_parses(p, &quot;asdf&quot;, &quot;a&quot;, 2).x
	assert_parses(p, &quot;a&quot;, &quot;a&quot;, 2).x
	assert_parses(p, &quot;b&quot;, &quot;b&quot;, 2).x
	assert_parses(p, &quot;c&quot;, &quot;c&quot;, 2).x
	assert_parses(p, &quot;d&quot;, &quot;d&quot;, 2).x
	assert_parses(p, &quot;e&quot;, &quot;e&quot;, 2).x
	assert_parses(p, &quot;f&quot;, &quot;f&quot;, 2).x
	assert_parses(p, &quot;g&quot;, &quot;g&quot;, 2).x
	assert_parses(p, &quot;h&quot;, &quot;h&quot;, 2).x
	assert_parses(p, &quot;i&quot;, &quot;i&quot;, 2).x
	assert_parses(p, &quot;j&quot;, &quot;j&quot;, 2).x
	assert_parses(p, &quot;k&quot;, &quot;k&quot;, 2).x
	assert_parses(p, &quot;l&quot;, &quot;l&quot;, 2).x
	assert_parses(p, &quot;m&quot;, &quot;m&quot;, 2).x
	assert_parses(p, &quot;n&quot;, &quot;n&quot;, 2).x
	assert_parses(p, &quot;o&quot;, &quot;o&quot;, 2).x
	assert_parses(p, &quot;p&quot;, &quot;p&quot;, 2).x
	assert_parses(p, &quot;q&quot;, &quot;q&quot;, 2).x
	assert_parses(p, &quot;r&quot;, &quot;r&quot;, 2).x
	assert_parses(p, &quot;s&quot;, &quot;s&quot;, 2).x
	assert_parses(p, &quot;t&quot;, &quot;t&quot;, 2).x
	assert_parses(p, &quot;u&quot;, &quot;u&quot;, 2).x
	assert_parses(p, &quot;v&quot;, &quot;v&quot;, 2).x
	assert_parses(p, &quot;w&quot;, &quot;w&quot;, 2).x
	assert_parses(p, &quot;x&quot;, &quot;x&quot;, 2).x
	assert_parses(p, &quot;y&quot;, &quot;y&quot;, 2).x
	assert_parses(p, &quot;z&quot;, &quot;z&quot;, 2).x
End Function

Function test_Parser_alphaUpper()
	Dim p As Parser
	p = pAlphaUpper

	refute_parses(p, Array(&quot; &quot;, TAB, CR, &quot;_&quot;, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, _
		&quot;+&quot;, &quot;-&quot;, &quot;-&gt;&quot;, &quot;*&quot;, &quot;?&quot;, &quot;#&quot;,_
		&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, _
		&quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, _
		&quot;&quot;)).x
	assert_parses(p, &quot;ASDF&quot;, &quot;A&quot;, 2).x
	assert_parses(p, &quot;A&quot;, &quot;A&quot;, 2).x
	assert_parses(p, &quot;B&quot;, &quot;B&quot;, 2).x
	assert_parses(p, &quot;C&quot;, &quot;C&quot;, 2).x
	assert_parses(p, &quot;D&quot;, &quot;D&quot;, 2).x
	assert_parses(p, &quot;E&quot;, &quot;E&quot;, 2).x
	assert_parses(p, &quot;F&quot;, &quot;F&quot;, 2).x
	assert_parses(p, &quot;G&quot;, &quot;G&quot;, 2).x
	assert_parses(p, &quot;H&quot;, &quot;H&quot;, 2).x
	assert_parses(p, &quot;I&quot;, &quot;I&quot;, 2).x
	assert_parses(p, &quot;J&quot;, &quot;J&quot;, 2).x
	assert_parses(p, &quot;K&quot;, &quot;K&quot;, 2).x
	assert_parses(p, &quot;L&quot;, &quot;L&quot;, 2).x
	assert_parses(p, &quot;M&quot;, &quot;M&quot;, 2).x
	assert_parses(p, &quot;N&quot;, &quot;N&quot;, 2).x
	assert_parses(p, &quot;O&quot;, &quot;O&quot;, 2).x
	assert_parses(p, &quot;P&quot;, &quot;P&quot;, 2).x
	assert_parses(p, &quot;Q&quot;, &quot;Q&quot;, 2).x
	assert_parses(p, &quot;R&quot;, &quot;R&quot;, 2).x
	assert_parses(p, &quot;S&quot;, &quot;S&quot;, 2).x
	assert_parses(p, &quot;T&quot;, &quot;T&quot;, 2).x
	assert_parses(p, &quot;U&quot;, &quot;U&quot;, 2).x
	assert_parses(p, &quot;V&quot;, &quot;V&quot;, 2).x
	assert_parses(p, &quot;W&quot;, &quot;W&quot;, 2).x
	assert_parses(p, &quot;X&quot;, &quot;X&quot;, 2).x
	assert_parses(p, &quot;Y&quot;, &quot;Y&quot;, 2).x
	assert_parses(p, &quot;Z&quot;, &quot;Z&quot;, 2).x
End Function

Function test_Parser_baseType()
	Dim p As Parser
	p = pBaseType

	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;asdf&quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;b&quot;).x
	refute_parses(p, &quot;c&quot;).x
	
	assert_parses(p, &quot;Bool -&gt; Bool&quot;, &quot;Bool&quot;, 5).x
	assert_parses(p, &quot;Bool&quot;, &quot;Bool&quot;, 5).x
	refute_parses(p, &quot;bool&quot;).x

	assert_parses(p, &quot;Str&quot;, &quot;Str&quot;, 4).x
	refute_parses(p, &quot;str&quot;).x

	assert_parses(p, &quot;Int&quot;, &quot;Int&quot;, 4).x
	refute_parses(p, &quot;int&quot;).x

	assert_parses(p, &quot;Long&quot;, &quot;Long&quot;, 5).x
	refute_parses(p, &quot;long&quot;).x
End Function

Function test_Parser_TypeVar()
	Dim p As Parser
	p = pTypeVar

	refute_parses(p, Array(&quot; &quot;, TAB, CR, &quot;_&quot;, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, _
		&quot;+&quot;, &quot;-&quot;, &quot;-&gt;&quot;, &quot;*&quot;, &quot;?&quot;, &quot;#&quot;,_
		&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, _
		&quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, _
		&quot;&quot;)).x
	assert_parses(p, &quot;asdf&quot;, &quot;&apos;a&quot;, 2).x
	assert_parses(p, &quot;a&quot;, &quot;&apos;a&quot;, 2).x
	assert_parses(p, &quot;b&quot;, &quot;&apos;b&quot;, 2).x
	assert_parses(p, &quot;c&quot;, &quot;&apos;c&quot;, 2).x
	assert_parses(p, &quot;d&quot;, &quot;&apos;d&quot;, 2).x
	assert_parses(p, &quot;e&quot;, &quot;&apos;e&quot;, 2).x
	assert_parses(p, &quot;f&quot;, &quot;&apos;f&quot;, 2).x
	assert_parses(p, &quot;g&quot;, &quot;&apos;g&quot;, 2).x
	assert_parses(p, &quot;h&quot;, &quot;&apos;h&quot;, 2).x
	assert_parses(p, &quot;i&quot;, &quot;&apos;i&quot;, 2).x
	assert_parses(p, &quot;j&quot;, &quot;&apos;j&quot;, 2).x
	assert_parses(p, &quot;k&quot;, &quot;&apos;k&quot;, 2).x
	assert_parses(p, &quot;l&quot;, &quot;&apos;l&quot;, 2).x
	assert_parses(p, &quot;m&quot;, &quot;&apos;m&quot;, 2).x
	assert_parses(p, &quot;n&quot;, &quot;&apos;n&quot;, 2).x
	assert_parses(p, &quot;o&quot;, &quot;&apos;o&quot;, 2).x
	assert_parses(p, &quot;p&quot;, &quot;&apos;p&quot;, 2).x
	assert_parses(p, &quot;q&quot;, &quot;&apos;q&quot;, 2).x
	assert_parses(p, &quot;r&quot;, &quot;&apos;r&quot;, 2).x
	assert_parses(p, &quot;s&quot;, &quot;&apos;s&quot;, 2).x
	assert_parses(p, &quot;t&quot;, &quot;&apos;t&quot;, 2).x
	assert_parses(p, &quot;u&quot;, &quot;&apos;u&quot;, 2).x
	assert_parses(p, &quot;v&quot;, &quot;&apos;v&quot;, 2).x
	assert_parses(p, &quot;w&quot;, &quot;&apos;w&quot;, 2).x
	assert_parses(p, &quot;x&quot;, &quot;&apos;x&quot;, 2).x
	assert_parses(p, &quot;y&quot;, &quot;&apos;y&quot;, 2).x
	assert_parses(p, &quot;z&quot;, &quot;&apos;z&quot;, 2).x
End Function

Function test_Parser_TypeCtor()
	Dim p As Parser
	p = pTypeCtor

	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;asdf&quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;b&quot;).x
	refute_parses(p, &quot;c&quot;).x
	
	assert_parses(p, &quot;List&quot;, &quot;List&quot;, 5).x
	assert_parses(p, &quot;Maybe&quot;, &quot;Maybe&quot;, 6).x

	&apos; any capitalized String with more than 2 chars does
	assert_parses(p, &quot;Bool&quot;, &quot;Bool&quot;, 5).x &apos; 
	refute_parses(p, &quot;bool&quot;).x

	assert_parses(p, &quot;Str&quot;, &quot;Str&quot;, 4).x
	refute_parses(p, &quot;str&quot;).x

	assert_parses(p, &quot;Int&quot;, &quot;Int&quot;, 4).x
	refute_parses(p, &quot;int&quot;).x

	assert_parses(p, &quot;Long&quot;, &quot;Long&quot;, 5).x
	refute_parses(p, &quot;long&quot;).x

	assert_parses(p, &quot;Avalidtypector&quot;, &quot;Avalidtypector&quot;, 15).x
	assert_parses(p, &quot;NotAValidTypeCtor&quot;, &quot;Not&quot;, 4).x
End Function

Function test_Parser_TypeExpr()
	Dim p As Parser
	p = pTypeExpr
	
	assert_parses(p, &quot;Bool&quot;, 			&quot;Bool&quot;, 5).x
	assert_parses(p, &quot;Int&quot;,	 			&quot;Int&quot;, 4).x
	assert_parses(p, &quot;Int-&gt;Int&quot;,	 	&quot;(-&gt; Int Int)&quot;, 9).x
	assert_parses(p, &quot;Int-&gt;Str-&gt;Bool&quot;,	&quot;(-&gt; Int (-&gt; Str Bool))&quot;, 15).x
	assert_parses(p, &quot;a-&gt;b-&gt;c&quot;,	 		&quot;(-&gt; &apos;a (-&gt; &apos;b &apos;c))&quot;, 8).x
	assert_parses(p, &quot;(a-&gt;b)-&gt;c&quot;,	 	&quot;(-&gt; (-&gt; &apos;a &apos;b) &apos;c)&quot;, 10).x
	assert_parses(p, &quot;(a-&gt;b)-&gt;(c)&quot;,	 	&quot;(-&gt; (-&gt; &apos;a &apos;b) &apos;c)&quot;, 12).x
	assert_parses(p, &quot;List&quot;,	 		&quot;(List [])&quot;, 5).x
	assert_parses(p, &quot;List a&quot;,	 		&quot;(List [&apos;a])&quot;, 7).x
	assert_parses(p, &quot;List a b&quot;,	 	&quot;(List [&apos;a, &apos;b])&quot;, 9).x
	assert_parses(p, &quot;List Int&quot;,	 	&quot;(List [Int])&quot;, 9).x
	assert_parses(p, &quot;List a-&gt;b&quot;,	 	&quot;(-&gt; (List [&apos;a]) &apos;b)&quot;, 10).x
	assert_parses(p, &quot;List (a-&gt;b)&quot;,	 	&quot;(List [(-&gt; &apos;a &apos;b)])&quot;, 12).x
	assert_parses(p, &quot;List Maybe a&quot;,	&quot;(List [(Maybe [&apos;a])])&quot;, 13).x
	assert_parses(p, &quot;List Maybe a b&quot;,	&quot;(List [(Maybe [&apos;a, &apos;b])])&quot;, 15).x
	assert_parses(p, &quot;List (Maybe a) b&quot;,&quot;(List [(Maybe [&apos;a]), &apos;b])&quot;, 17).x
	
	refute_parses(p, &quot;-&gt;a&quot;).x
	&apos;refute_parses(p, &quot;a-&gt;&quot;).x	&apos; parses the a as a TypeVar, then stops

	&apos; skips over trailing whitespace:
	assert_parses(p, &quot;Bool   &quot;, 				&quot;Bool&quot;, 8).x
	assert_parses(p, &quot;Int    &quot;,	 				&quot;Int&quot;,  8).x
	assert_parses(p, &quot;Int -&gt; Int            &quot;,	&quot;(-&gt; Int Int)&quot;, 23).x
	assert_parses(p, &quot;Int  -&gt; Str -&gt;   Bool &quot;,	&quot;(-&gt; Int (-&gt; Str Bool))&quot;, 23).x

	&apos; skips over leading whitespace:
	assert_parses(p, &quot; Bool  &quot;, 				&quot;Bool&quot;, 8).x
	assert_parses(p, &quot; Int   &quot;,	 				&quot;Int&quot;,  8).x
	assert_parses(p, &quot; Int -&gt; Int           &quot;,	&quot;(-&gt; Int Int)&quot;, 23).x
	assert_parses(p, &quot; Int  -&gt; Str -&gt;  Bool &quot;,	&quot;(-&gt; Int (-&gt; Str Bool))&quot;, 23).x

	&apos; fn type variations:
	assert_parses(p, &quot;((a) -&gt; ((b)))&quot;, &quot;(-&gt; &apos;a &apos;b)&quot;, 15).x
	assert_parses(p, &quot; a -&gt; (b -&gt; c)&quot;, &quot;(-&gt; &apos;a (-&gt; &apos;b &apos;c))&quot;, 15).x
	assert_parses(p, &quot; a -&gt;  b -&gt; c &quot;, &quot;(-&gt; &apos;a (-&gt; &apos;b &apos;c))&quot;, 15).x
	assert_parses(p, &quot;(a -&gt; b) -&gt; c &quot;, &quot;(-&gt; (-&gt; &apos;a &apos;b) &apos;c)&quot;, 15).x
	assert_parses(p, &quot;(a -&gt; (b)-&gt; c)&quot;, &quot;(-&gt; &apos;a (-&gt; &apos;b &apos;c))&quot;, 15).x

	&apos; some real types:
	&apos; type of fn isNil:
	assert_parses(p, &quot;[a] -&gt; Bool&quot;, &quot;(-&gt; (List [&apos;a]) Bool)&quot;, 12).x
	&apos; type of fn flatten:
	assert_parses(p, &quot;[[a]] -&gt; [a]&quot;, &quot;(-&gt; (List [(List [&apos;a])]) (List [&apos;a]))&quot;, 13).x
	&apos; type of fn compose:
	assert_parses(p, &quot;(b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c&quot;, _
					 &quot;(-&gt; (-&gt; &apos;b &apos;c) (-&gt; (-&gt; &apos;a &apos;b) (-&gt; &apos;a &apos;c)))&quot;, 31).x
	&apos; type of pBind:
	assert_parses(p, &quot;Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b&quot;, _
					 &quot;(-&gt; (Parser [&apos;a]) (-&gt; (-&gt; &apos;a (Parser [&apos;b])) (Parser [&apos;b])))&quot;, 40).x			

	&apos; [] (List) type variations:
	refute_parses(p, &quot;[]&quot;).x
	refute_parses(p, &quot;[a b]&quot;).x
	refute_parses(p, &quot;[a, b]&quot;).x
	assert_parses(p, &quot;[a]&quot;, 	&quot;(List [&apos;a])&quot;, 4).x
	assert_parses(p, &quot;([(a)])&quot;, &quot;(List [&apos;a])&quot;, 8).x
	assert_parses(p, &quot;([[a]])&quot;, &quot;(List [(List [&apos;a])])&quot;, 8).x
	assert_parses(p, &quot;[[(a)]]&quot;, &quot;(List [(List [&apos;a])])&quot;, 8).x
	assert_parses(p, &quot;[[[a]]]&quot;, &quot;(List [(List [(List [&apos;a])])])&quot;, 8).x
	assert_parses(p, &quot;[a-&gt;b]&quot;,  &quot;(List [(-&gt; &apos;a &apos;b)])&quot;, 7).x
	
	&apos;isNil:
	assert_parses(p, &quot;[a] -&gt; Bool&quot;, &quot;(-&gt; (List [&apos;a]) Bool)&quot;, 12).x
	&apos;cons:
	assert_parses(p, &quot;a -&gt; [a] -&gt; [a]&quot;, &quot;(-&gt; &apos;a (-&gt; (List [&apos;a]) (List [&apos;a])))&quot;, 16).x
	
	&apos; (,) tuple type variations:
	assert_parses(p, &quot;()&quot;, 		&quot;(Unit [])&quot;, 3).x
	refute_parses(p, &quot;( )&quot;).x
	assert_parses(p, &quot;(())&quot;, 	&quot;(Unit [])&quot;, 5).x
	assert_parses(p, &quot;[()]&quot;, 	&quot;(List [(Unit [])])&quot;, 5).x
	refute_parses(p, &quot;([])&quot;).x
	
	refute_parses(p, &quot;,&quot;).x
	refute_parses(p, &quot;(,)&quot;).x
	refute_parses(p, &quot;(a,)&quot;).x
	refute_parses(p, &quot;(,b)&quot;).x
	&apos; TODO: double toString on the inner types since we don&apos;t yet represent types as proper objects
	assert_parses(p, &quot;(a,b)&quot;, &quot;(Tuple2 [&apos;&apos;a&apos;, &apos;&apos;b&apos;])&quot;, 6).x
	assert_parses(p, &quot;(a ,b, c)&quot;, &quot;(Tuple3 [&apos;&apos;a&apos;, &apos;&apos;b&apos;, &apos;&apos;c&apos;])&quot;, 10).x
	assert_parses(p, &quot;((a,b),c)&quot;, &quot;(Tuple2 [&apos;(Tuple2 [&apos;&apos;a&apos;, &apos;&apos;b&apos;])&apos;, &apos;&apos;c&apos;])&quot;, 10).x
	 
	Dim fns As Object, f As Object, fName As String, typStr As String
	fns = Fn._instances
	While Not(isNil(fns))
		f = car(fns)
		typStr = getFnTypeStr(f)
		If typStr &lt;&gt; &quot;&quot; Then
			fName = getFnName(f)
&apos;			assert_parses(p, typStr, fName &amp; &quot; :: asdf&quot;, Len(typStr) + 1).x
		End If
		fns = cdr(fns)
	Wend
End Function

Function test_Parser_binDigit()
	Dim p As Parser
	p = pBinDigit

	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;sadf&quot;).x
	assert_parses(p, &quot;0sadf&quot;,	0, 2).x
	assert_parses(p, &quot;1sadf&quot;,	1, 2).x
	refute_parses(p, &quot;2sadf&quot;).x
	refute_parses(p, &quot;3sadf&quot;).x
	refute_parses(p, &quot;4sadf&quot;).x
	refute_parses(p, &quot;5sadf&quot;).x
	refute_parses(p, &quot;6sadf&quot;).x
	refute_parses(p, &quot;7sadf&quot;).x
	refute_parses(p, &quot;8sadf&quot;).x
	refute_parses(p, &quot;9sadf&quot;).x
	refute_parses(p, &quot;Asadf&quot;).x
	refute_parses(p, &quot;asadf&quot;).x
	refute_parses(p, &quot;Bsadf&quot;).x
	refute_parses(p, &quot;bsadf&quot;).x
	refute_parses(p, &quot;Csadf&quot;).x
	refute_parses(p, &quot;csadf&quot;).x
	refute_parses(p, &quot;Dsadf&quot;).x
	refute_parses(p, &quot;dsadf&quot;).x
	refute_parses(p, &quot;Esadf&quot;).x
	refute_parses(p, &quot;esadf&quot;).x
	refute_parses(p, &quot;Fsadf&quot;).x
	refute_parses(p, &quot;fsadf&quot;).x
	refute_parses(p, &quot;Gsadf&quot;).x
	refute_parses(p, &quot;gsadf&quot;).x
End Function

Function test_Parser_decDigit()
	Dim p As Parser
	p = pDecDigit

	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;sadf&quot;).x
	assert_parses(p, &quot;0sadf&quot;,	0, 2).x
	assert_parses(p, &quot;1sadf&quot;,	1, 2).x
	assert_parses(p, &quot;2sadf&quot;,	2, 2).x
	assert_parses(p, &quot;3sadf&quot;,	3, 2).x
	assert_parses(p, &quot;4sadf&quot;,	4, 2).x
	assert_parses(p, &quot;5sadf&quot;,	5, 2).x
	assert_parses(p, &quot;6sadf&quot;,	6, 2).x
	assert_parses(p, &quot;7sadf&quot;,	7, 2).x
	assert_parses(p, &quot;8sadf&quot;,	8, 2).x
	assert_parses(p, &quot;9sadf&quot;,	9, 2).x
	refute_parses(p, &quot;Asadf&quot;).x
	refute_parses(p, &quot;asadf&quot;).x
	refute_parses(p, &quot;Bsadf&quot;).x
	refute_parses(p, &quot;bsadf&quot;).x
	refute_parses(p, &quot;Csadf&quot;).x
	refute_parses(p, &quot;csadf&quot;).x
	refute_parses(p, &quot;Dsadf&quot;).x
	refute_parses(p, &quot;dsadf&quot;).x
	refute_parses(p, &quot;Esadf&quot;).x
	refute_parses(p, &quot;esadf&quot;).x
	refute_parses(p, &quot;Fsadf&quot;).x
	refute_parses(p, &quot;fsadf&quot;).x
	refute_parses(p, &quot;Gsadf&quot;).x
	refute_parses(p, &quot;gsadf&quot;).x
End Function

Function test_Parser_hexDigit()
	Dim p As Parser
	p = pHexDigit

	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;sadf&quot;).x
	assert_parses(p, &quot;0sadf&quot;,	 0, 2).x
	assert_parses(p, &quot;1sadf&quot;,	 1, 2).x
	assert_parses(p, &quot;2sadf&quot;,	 2, 2).x
	assert_parses(p, &quot;3sadf&quot;,	 3, 2).x
	assert_parses(p, &quot;4sadf&quot;,	 4, 2).x
	assert_parses(p, &quot;5sadf&quot;,	 5, 2).x
	assert_parses(p, &quot;6sadf&quot;,	 6, 2).x
	assert_parses(p, &quot;7sadf&quot;,	 7, 2).x
	assert_parses(p, &quot;8sadf&quot;,	 8, 2).x
	assert_parses(p, &quot;9sadf&quot;,	 9, 2).x
	assert_parses(p, &quot;Asadf&quot;,	10, 2).x
	assert_parses(p, &quot;asadf&quot;,	10, 2).x
	assert_parses(p, &quot;Bsadf&quot;,	11, 2).x
	assert_parses(p, &quot;bsadf&quot;,	11, 2).x
	assert_parses(p, &quot;Csadf&quot;,	12, 2).x
	assert_parses(p, &quot;csadf&quot;,	12, 2).x
	assert_parses(p, &quot;Dsadf&quot;,	13, 2).x
	assert_parses(p, &quot;dsadf&quot;,	13, 2).x
	assert_parses(p, &quot;Esadf&quot;,	14, 2).x
	assert_parses(p, &quot;esadf&quot;,	14, 2).x
	assert_parses(p, &quot;Fsadf&quot;,	15, 2).x
	assert_parses(p, &quot;fsadf&quot;,	15, 2).x
	refute_parses(p, &quot;Gsadf&quot;).x
	refute_parses(p, &quot;gsadf&quot;).x
End Function

Function test_Parser_many()
	Dim p As Parser
	Dim data As Variant
	Dim zeroMatches As Variant
	zeroMatches = nil
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; CR, &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, CR, CR &amp; &quot;bar&quot;, CR &amp; CR,_
		CR &amp; CR &amp; &quot;bar&quot;_
	)
	p = pMany(pFail)
	assert_parses(p, data, zeroMatches, 1).x
	
	&apos;p = pMany(pReturn(3)) - yields infite sequence of 3s, even on empty string
	
	p = pMany(pItem)
	assert_parses(p, &quot;&quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; CR,		List(&quot; &quot;, CR), 3).x
	assert_parses(p, &quot; &quot; &amp; LF,		List(&quot; &quot;, LF), 3).x
	assert_parses(p, &quot;asdf&quot;,		List(&quot;a&quot;, &quot;s&quot;, &quot;d&quot;, &quot;f&quot;), 5).x
	
	p = pMany(pStr(&quot; &quot;))
	assert_parses(p, &quot;&quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; CR,		List(&quot; &quot;), 2).x
	assert_parses(p, &quot;asdf&quot;,		zeroMatches, 1).x
	assert_parses(p, &quot;  &quot;,			List(&quot; &quot;, &quot; &quot;), 3).x
	assert_parses(p, &quot;   &quot;,			List(&quot; &quot;, &quot; &quot;, &quot; &quot;), 4).x
	assert_parses(p, &quot; x &quot;,			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; x  &quot;,		List(&quot; &quot;), 2).x
	assert_parses(p, &quot;  x &quot;,		List(&quot; &quot;, &quot; &quot;), 3).x
	
	p = pMany(pDecDigit)
	assert_parses(p, &quot;&quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot; &quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot;1&quot;, 			List(1), 2).x
	assert_parses(p, &quot;10 &quot;, 		List(1, 0), 3).x
	assert_parses(p, &quot;102345&quot;, 		List(1, 0, 2, 3, 4, 5), 7).x
End Function

Function test_Parser_many1()
	Dim p As Parser
	Dim data As Variant
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; CR, &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, CR, CR &amp; &quot;bar&quot;, CR &amp; CR,_
		CR &amp; CR &amp; &quot;bar&quot;_
	)
	p = pMany1(pFail)
	refute_parses(p, data).x
	
	&apos;p = pMany1(pReturn(3)) - yields infite sequence of 3s, except on empty string
	
	p = pMany1(pItem)
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; CR,		List(&quot; &quot;, CR), 3).x
	assert_parses(p, &quot; &quot; &amp; LF,		List(&quot; &quot;, LF), 3).x
	assert_parses(p, &quot;asdf&quot;,		List(&quot;a&quot;, &quot;s&quot;, &quot;d&quot;, &quot;f&quot;), 5).x
	
	p = pMany1(pStr(&quot; &quot;))
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; CR,		List(&quot; &quot;), 2).x
	refute_parses(p, &quot;asdf&quot;).x
	assert_parses(p, &quot;  &quot;,			List(&quot; &quot;, &quot; &quot;), 3).x
	assert_parses(p, &quot;   &quot;,			List(&quot; &quot;, &quot; &quot;, &quot; &quot;), 4).x
	assert_parses(p, &quot; x &quot;,			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; x  &quot;,		List(&quot; &quot;), 2).x
	assert_parses(p, &quot;  x &quot;,		List(&quot; &quot;, &quot; &quot;), 3).x
	
	p = pMany1(pDecDigit)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	assert_parses(p, &quot;1&quot;, 			List(1), 2).x
	assert_parses(p, &quot;10 &quot;, 		List(1, 0), 3).x
	assert_parses(p, &quot;102345&quot;, 		List(1, 0, 2, 3, 4, 5), 7).x
	
	p = pMany1(pSeqL(Array(pStr(&quot; &quot;)), id))
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;, 			List(List(&quot; &quot;)), 2).x
	assert_parses(p, &quot; &quot; &amp; CR,	List(List(&quot; &quot;)), 2).x
	refute_parses(p, &quot;asdf&quot;).x
	assert_parses(p, &quot;  &quot;,			List(List(&quot; &quot;), List(&quot; &quot;)), 3).x
	assert_parses(p, &quot;   &quot;,			List(List(&quot; &quot;), List(&quot; &quot;), List(&quot; &quot;)), 4).x
	assert_parses(p, &quot; x &quot;,			List(List(&quot; &quot;)), 2).x
	assert_parses(p, &quot; x  &quot;,		List(List(&quot; &quot;)), 2).x
	assert_parses(p, &quot;  x &quot;,		List(List(&quot; &quot;), List(&quot; &quot;)), 3).x

End Function

Function test_Parser_seq()
	Dim p As Parser, f As Variant
	Dim data As Variant
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; CR, &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, CR, CR &amp; &quot;bar&quot;, CR &amp; CR,_
		CR &amp; CR &amp; &quot;bar&quot;_
	)
	f = Fn.asc
	p = pSeq(Array(pFail), f)
	refute_parses(p, data).x
	
	f = Fn.asc
	p = pSeq(Array(pItem), f)
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot;0&quot;, 	asc(&quot;0&quot;), 2).x
	assert_parses(p, &quot;1&quot;, 	asc(&quot;1&quot;), 2).x
	assert_parses(p, &quot;A&quot;, 	asc(&quot;A&quot;), 2).x
	assert_parses(p, &quot;B&quot;, 	asc(&quot;B&quot;), 2).x
	assert_parses(p, &quot;AB&quot;,	asc(&quot;A&quot;), 2).x
	assert_parses(p, &quot;BA&quot;,	asc(&quot;B&quot;), 2).x
	
	f = Fn.concat
	p = pSeq(Array(pItem, pItem), f)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;A&quot;).x
	refute_parses(p, &quot;B&quot;).x
	assert_parses(p, &quot;AB&quot;,	&quot;AB&quot;, 3).x
	assert_parses(p, &quot;BA&quot;,	&quot;BA&quot;, 3).x
	
	p = pSeq(Array(pDecDigit, pDecDigit), f)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;A&quot;).x
	refute_parses(p, &quot;B&quot;).x
	refute_parses(p, &quot;AB&quot;).x
	refute_parses(p, &quot;BA&quot;).x
	refute_parses(p, &quot;0B&quot;).x		&apos; *ALL* in sequence must succeed!
	refute_parses(p, &quot;1A&quot;).x		&apos; *ALL* in sequence must succeed!
	assert_parses(p, &quot;01&quot;,	&quot;01&quot;, 3).x
	assert_parses(p, &quot;10&quot;,	&quot;10&quot;, 3).x
	
	f = Fn.asc
	p = pSeq(Array(pDecDigit), f)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;A&quot;).x
	refute_parses(p, &quot;B&quot;).x
	refute_parses(p, &quot;AB&quot;).x
	refute_parses(p, &quot;BA&quot;).x
	assert_parses(p, &quot;0&quot;, 			48, 2).x
	assert_parses(p, &quot;1&quot;, 			49, 2).x
	assert_parses(p, &quot;123456789&quot;,	49, 2).x
	
	p = pMany1(pSeq(Array(pDecDigit), f))
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;A&quot;).x
	refute_parses(p, &quot;B&quot;).x
	refute_parses(p, &quot;AB&quot;).x
	refute_parses(p, &quot;BA&quot;).x
	assert_parses(p, &quot;0&quot;, 			List(48), 2).x
	assert_parses(p, &quot;1&quot;, 			List(49), 2).x
	assert_parses(p, &quot;123456789&quot;,	List(49, 50, 51, 52, 53, 54, 55, 56, 57), 10).x
	assert_parses(p, &quot;123456789 0&quot;,	List(49, 50, 51, 52, 53, 54, 55, 56, 57), 10).x
End Function

Function assert_toStr(p As Object, expected As String)
	Dim testResult As Variant
	testResult = assertEqual(TParser_toString(p), expected)
	If testResult.isFail Then
		assert_toStr = testResult
		Exit Function
	End If
	&apos; try polymorphic dispatch:
	testResult = assertEqual(toString(p), expected)
	assert_toStr = testResult
End Function

Function test_Parser_toString()
	Dim f As Object, p As Object, q As Object, k As Integer
	f = TParser_toString
	assertEqual(isFn(f), True).x
	assertEqual(arity(f),   1).x
	assertEqual(apply(f, pFail), &quot;fail&quot;).x

	&apos; pSeqL(..., id)
	p = pSeqL(Array(pItem), id)
	assert_toStr(p, &quot;(do a0 &lt;- item&quot; &amp; NL _
				  &amp; &quot; return [a0]&quot; &amp; NL _
				  &amp; &quot;)&quot;).x
	p = pSeqL(Array(pItem, pItem), id)
	assert_toStr(p, &quot;(do a0 &lt;- item&quot; &amp; NL _
				  &amp; &quot;    a1 &lt;- item&quot; &amp; NL _
				  &amp; &quot; return [a0, a1]&quot; &amp; NL _
				  &amp; &quot;)&quot;).x
	p = pSeqL(Array(pItem, pStr(&quot;x&quot;), pItem), id)
	assert_toStr(p, &quot;(do a0 &lt;- item&quot; &amp; NL _
				  &amp; &quot;    a1 &lt;- (str &apos;x&apos;)&quot; &amp; NL _
				  &amp; &quot;    a2 &lt;- item&quot; &amp; NL _
				  &amp; &quot; return [a0, a1, a2]&quot; &amp; NL _
				  &amp; &quot;)&quot;).x
	p = pSeqL(Array(pItem, pSkip(pStr(&quot;x&quot;)), pItem), id)
	assert_toStr(p, &quot;(do a0 &lt;- item&quot; &amp; NL _
				  &amp; &quot;     _ &lt;- (str &apos;x&apos;)&quot; &amp; NL _
				  &amp; &quot;    a1 &lt;- item&quot; &amp; NL _
				  &amp; &quot; return [a0, a1]&quot; &amp; NL _
				  &amp; &quot;)&quot;).x

	&apos; pSeqL(..., reverse)
	p = pSeqL(Array(pItem), reverse)
	assert_toStr(p, &quot;(do a0 &lt;- item&quot; &amp; NL _
				  &amp; &quot; return (reverse [a0])&quot; &amp; NL _
				  &amp; &quot;)&quot;).x
	p = pSeqL(Array(pItem, pStr(&quot;x&quot;), pItem), reverse)
	assert_toStr(p, &quot;(do a0 &lt;- item&quot; &amp; NL _
				  &amp; &quot;    a1 &lt;- (str &apos;x&apos;)&quot; &amp; NL _
				  &amp; &quot;    a2 &lt;- item&quot; &amp; NL _
				  &amp; &quot; return (reverse [a0, a1, a2])&quot; &amp; NL _
				  &amp; &quot;)&quot;).x
	p = pSeqL(Array(pItem, pSkip(pStr(&quot;x&quot;)), pItem), reverse)
	assert_toStr(p, &quot;(do a0 &lt;- item&quot; &amp; NL _
				  &amp; &quot;     _ &lt;- (str &apos;x&apos;)&quot; &amp; NL _
				  &amp; &quot;    a1 &lt;- item&quot; &amp; NL _
				  &amp; &quot; return (reverse [a0, a1])&quot; &amp; NL _
				  &amp; &quot;)&quot;).x

	&apos; pSeq(..., id) &apos; NOT pSeqL!
	p = pSeq(Array(pItem), id)
	assert_toStr(p, &quot;(do a0 &lt;- item&quot; &amp; NL _
				  &amp; &quot; return a0&quot; &amp; NL _
				  &amp; &quot;)&quot;).x
	p = pSeq(Array(pItem, pSkip(pItem)), id)
	assert_toStr(p, &quot;(do a0 &lt;- item&quot; &amp; NL _
				  &amp; &quot;     _ &lt;- item&quot; &amp; NL _
				  &amp; &quot; return a0&quot; &amp; NL _
				  &amp; &quot;)&quot;).x
	p = pSeq(Array(pSkip(pItem), pItem), id)
	assert_toStr(p, &quot;(do  _ &lt;- item&quot; &amp; NL _
				  &amp; &quot;    a0 &lt;- item&quot; &amp; NL _
				  &amp; &quot; return a0&quot; &amp; NL _
				  &amp; &quot;)&quot;).x
	
	assert_toStr(pFail, 							&quot;fail&quot;).x
	assert_toStr(pReturn(7), 						&quot;(return 7)&quot;).x
	assert_toStr(pReturn(&quot;seven&quot;),					&quot;(return &apos;seven&apos;)&quot;).x
	assert_toStr(pItem,								&quot;item&quot;).x
	assert_toStr(pStr(&quot;a&quot;),							&quot;(str &apos;a&apos;)&quot;).x
	assert_toStr(pSkip(pItem), 						&quot;(skip item)&quot;).x
	assert_toStr(pSkip(pStr(&quot;a&quot;)),					&quot;(skip (str &apos;a&apos;))&quot;).x
	assert_toStr(pChoice(pStr(&quot;a&quot;), pStr(&quot;b&quot;)),		&quot;(str &apos;a&apos;) | (str &apos;b&apos;)&quot;).x
	assert_toStr(pChoice(pStr(&quot;b&quot;), pStr(&quot;a&quot;)),		&quot;(str &apos;b&apos;) | (str &apos;a&apos;)&quot;).x
	assert_toStr(pChoice(pChoice(pStr(&quot;a&quot;), pStr(&quot;b&quot;)),	pStr(&quot;c&quot;)), _
		&quot;(str &apos;a&apos;) | (str &apos;b&apos;) | (str &apos;c&apos;)&quot;).x
	assert_toStr(pChoice(pStr(&quot;a&quot;), pChoice(pStr(&quot;b&quot;), pStr(&quot;c&quot;))), _
		&quot;(str &apos;a&apos;) | (str &apos;b&apos;) | (str &apos;c&apos;)&quot;).x
	assert_toStr(pZeroOrOne(pStr(&quot;a&quot;)),				&quot;(str &apos;a&apos;)?&quot;).x
	&apos; double p?? is the same as p?:
	assert_toStr(pZeroOrOne(pZeroOrOne(pStr(&quot;a&quot;))),	&quot;(str &apos;a&apos;)?&quot;).x

	assert_toStr(pMany1(pItem),						&quot;item+&quot;).x
	assert_toStr(pSkip(pMany1(pItem)),				&quot;(skip item+)&quot;).x
&apos;	assert_toStr(pMany1(pWhite),					toString(pWhite) &amp; &quot;+&quot;).x
&apos;	assert_toStr(pSkip(pMany1(pWhite)),				&quot;(skip (&quot; &amp; toString(pWhite) &amp; &quot;)+)&quot;).x

	assert_toStr(pMany(pItem),						&quot;item*&quot;).x
	assert_toStr(pSkip(pMany(pItem)),				&quot;(skip item*)&quot;).x


	&apos; Q ::= (do  x &lt;- (str &quot;x&quot;)
	&apos;           xs &lt;- P
	&apos;        return (cons x xs))
	&apos;     | (do  y &lt;- (str &quot;y&quot;)
	&apos;           ys &lt;- P
	&apos;        return (cons y ys))
	&apos; P ::= Q
	&apos; P MUST NOT be visited twice when traversing Q!
	p = pInd(&quot;P&quot;)
	q = fixIndirection(pInd(&quot;Q&quot;), pChoice( _
		pSeq(Array(pStr(&quot;x&quot;), p), cons), _
		pSeq(Array(pStr(&quot;y&quot;), p), cons) _
	))
	p = fixIndirection(p, q)
	k = InStr(1, TParser_toString(p), &quot;P ::= Q&quot;)
	assertEqual(k &gt;= 1, True).x	&apos; it does appear once
	k = InStr(k + 1, TParser_toString(p), &quot;P ::= Q&quot;)
	assertEqual(k &gt;= 1, False).x &apos; but only once
	
	&apos;MsgBox(toString(pTypeExpr))

	p = pInd(&quot;&quot;)
	assert_toStr(p,	&quot;(ind &quot; &amp; p.st1 &amp; &quot; Nothing)&quot;).x
	q = pItem
	p = fixIndirection(p, q)
	k = InStr(TParser_toString(p), _
		getPIndName(p) &amp; &quot; ::= &quot; &amp; TParser_toString(q))
	assertEqual(k &gt;= 1, True).x

	p = pInd(&quot;&quot;)
	p = fixIndirection(p, pChoice(pStr(&quot;x&quot;), pSeq(Array(pSkip(pStr(&quot;(&quot;)), p, pSkip(pStr(&quot;)&quot;))), id))
&apos;	assert_toStr(p,	&quot;(str &apos;x&apos;) +++ ?????? )&quot;).x
	

End Function

Function test_Parser_hexNum()
	Dim p As Parser
	Dim data As Variant
	p = pHexNum

	refute_parses(p, &quot;&quot;).x
		
	data = Array(&quot; &quot;, &quot; &quot; &amp; CR, &quot;qasdf&quot;, &quot; bar&quot;, &quot;qb&quot;, &quot;qba&quot;, &quot;qbar&quot;, &quot;qbarb&quot;,_
		&quot;qbarba&quot;, &quot;qbarbar&quot;, CR, CR &amp; &quot;qbar&quot;, CR &amp; CR,_
		CR &amp; CR &amp; &quot;bar&quot;_
	)
	refute_parses(p, data).x

	assert_parses(p, &quot;0&quot;,	 0, 2).x
	assert_parses(p, &quot;1&quot;,	 1, 2).x
	assert_parses(p, &quot;2&quot;,	 2, 2).x
	assert_parses(p, &quot;3&quot;,	 3, 2).x
	assert_parses(p, &quot;4&quot;,	 4, 2).x
	assert_parses(p, &quot;5&quot;,	 5, 2).x
	assert_parses(p, &quot;6&quot;,	 6, 2).x
	assert_parses(p, &quot;7&quot;,	 7, 2).x
	assert_parses(p, &quot;8&quot;,	 8, 2).x
	assert_parses(p, &quot;9&quot;,	 9, 2).x

	assert_parses(p, &quot;a&quot;,	10, 2).x
	assert_parses(p, &quot;b&quot;, 	11, 2).x
	assert_parses(p, &quot;c&quot;, 	12, 2).x
	assert_parses(p, &quot;d&quot;, 	13, 2).x
	assert_parses(p, &quot;e&quot;, 	14, 2).x
	assert_parses(p, &quot;f&quot;, 	15, 2).x
	assert_parses(p, &quot;A&quot;, 	10, 2).x
	assert_parses(p, &quot;B&quot;, 	11, 2).x
	assert_parses(p, &quot;C&quot;, 	12, 2).x
	assert_parses(p, &quot;D&quot;, 	13, 2).x
	assert_parses(p, &quot;E&quot;, 	14, 2).x
	assert_parses(p, &quot;F&quot;, 	15, 2).x

	assert_parses(p, &quot;FF&quot;, 		readHex(&quot;FF&quot;), 	3).x
	assert_parses(p, &quot;123&quot;, 	readHex(&quot;123&quot;), 4).x

	assert_parses(p, &quot;0FF&quot;, 	readHex(&quot;FF&quot;), 	4).x	&apos; leading 0s don&apos;t matter
	assert_parses(p, &quot;0123&quot;, 	readHex(&quot;123&quot;), 5).x	&apos; leading 0s don&apos;t matter

	assert_parses(p, &quot;00FF&quot;, 	readHex(&quot;FF&quot;), 	5).x	&apos; leading 0s don&apos;t matter
	assert_parses(p, &quot;00123&quot;, 	readHex(&quot;123&quot;), 6).x	&apos; leading 0s don&apos;t matter

	&apos; 31 bit
	assert_parses(p, &quot;CAFEBAB&quot;, readHex(&quot;CAFEBAB&quot;), 	8).x
	assert_parses(p, &quot;DEADBEE&quot;, readHex(&quot;DEADBEE&quot;), 	8).x
	assert_parses(p, &quot;CAFEBAB&quot;, readHex(&quot;cafebab&quot;), 	8).x	&apos; case doesn&apos;t matter
	assert_parses(p, &quot;dEaDbEe&quot;, readHex(&quot;DeAdBeE&quot;), 	8).x	&apos; case doesn&apos;t matter

&apos;	&apos; 32 bit
&apos;	assert_parses(p, &quot;CAFEBABE&quot;, readHex(&quot;CAFEBABE&quot;), 	9).x
&apos;	assert_parses(p, &quot;DEADBEEF&quot;, readHex(&quot;DEADBEEF&quot;), 	9).x
&apos;	assert_parses(p, &quot;CAFEBABE&quot;, readHex(&quot;cafebabe&quot;), 	9).x	&apos; case doesn&apos;t matter
&apos;	assert_parses(p, &quot;dEaDbEeF&quot;, readHex(&quot;DeAdBeEf&quot;), 	9).x	&apos; case doesn&apos;t matter
End Function

Function test_Parser_hexLit()
	Dim p As Parser
	Dim data As Variant
	p = pHexLit

	refute_parses(p, &quot;&quot;).x
		
	data = Array(&quot; &quot;, &quot; &quot; &amp; CR, &quot;qasdf&quot;, &quot; bar&quot;, &quot;qb&quot;, &quot;qba&quot;, &quot;qbar&quot;, &quot;qbarb&quot;,_
		&quot;qbarba&quot;, &quot;qbarbar&quot;, CR, CR &amp; &quot;qbar&quot;, CR &amp; CR,_
		CR &amp; CR &amp; &quot;bar&quot;,_
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;,_
		&quot;a&quot;, &quot;A&quot;, &quot;b&quot;, &quot;B&quot;, &quot;c&quot;, &quot;C&quot;, &quot;d&quot;, &quot;D&quot;, &quot;e&quot;, &quot;E&quot;, &quot;f&quot;, &quot;F&quot;,_
		&quot;0x&quot;_
	)
	refute_parses(p, data).x

	assert_parses(p, &quot;0x0&quot;, 	 0, 4).x
	assert_parses(p, &quot;0x1&quot;, 	 1, 4).x
	assert_parses(p, &quot;0x2&quot;, 	 2, 4).x
	assert_parses(p, &quot;0x3&quot;, 	 3, 4).x
	assert_parses(p, &quot;0x4&quot;, 	 4, 4).x
	assert_parses(p, &quot;0x5&quot;, 	 5, 4).x
	assert_parses(p, &quot;0x6&quot;, 	 6, 4).x
	assert_parses(p, &quot;0x7&quot;, 	 7, 4).x
	assert_parses(p, &quot;0x8&quot;, 	 8, 4).x
	assert_parses(p, &quot;0x9&quot;,		 9, 4).x

	assert_parses(p, &quot;0xa&quot;,		10, 4).x
	assert_parses(p, &quot;0xb&quot;,		11, 4).x
	assert_parses(p, &quot;0xc&quot;, 	12, 4).x
	assert_parses(p, &quot;0xd&quot;, 	13, 4).x
	assert_parses(p, &quot;0xe&quot;, 	14, 4).x
	assert_parses(p, &quot;0xf&quot;, 	15, 4).x
	assert_parses(p, &quot;0xA&quot;, 	10, 4).x
	assert_parses(p, &quot;0xB&quot;, 	11, 4).x
	assert_parses(p, &quot;0xC&quot;, 	12, 4).x
	assert_parses(p, &quot;0xD&quot;, 	13, 4).x
	assert_parses(p, &quot;0xE&quot;, 	14, 4).x
	assert_parses(p, &quot;0xF&quot;, 	15, 4).x

	assert_parses(p, &quot;0xFF&quot;, 	readHex(&quot;FF&quot;), 	5).x
	assert_parses(p, &quot;0x123&quot;, 	readHex(&quot;123&quot;), 6).x

	assert_parses(p, &quot;0x0FF&quot;, 	readHex(&quot;FF&quot;), 	6).x	&apos; leading 0s don&apos;t matter
	assert_parses(p, &quot;0x0123&quot;, 	readHex(&quot;123&quot;), 7).x	&apos; leading 0s don&apos;t matter

	assert_parses(p, &quot;0x00FF&quot;, 	readHex(&quot;FF&quot;), 	7).x	&apos; leading 0s don&apos;t matter
	assert_parses(p, &quot;0x00123&quot;, readHex(&quot;123&quot;), 8).x	&apos; leading 0s don&apos;t matter

	&apos; 31 bit
	assert_parses(p, &quot;0xCAFEBAB&quot;, readHex(&quot;CAFEBAB&quot;), 	10).x
	assert_parses(p, &quot;0xDEADBEE&quot;, readHex(&quot;DEADBEE&quot;), 	10).x
	assert_parses(p, &quot;0xCAFEBAB&quot;, readHex(&quot;cafebab&quot;), 	10).x	&apos; case doesn&apos;t matter
	assert_parses(p, &quot;0xdEaDbEe&quot;, readHex(&quot;DeAdBeE&quot;), 	10).x	&apos; case doesn&apos;t matter

&apos;	&apos; 32 bit
&apos;	assert_parses(p, &quot;0xCAFEBABE&quot;, readHex(&quot;CAFEBABE&quot;), 	11).x
&apos;	assert_parses(p, &quot;0xDEADBEEF&quot;, readHex(&quot;DEADBEEF&quot;), 	11).x
&apos;	assert_parses(p, &quot;0xCAFEBABE&quot;, readHex(&quot;cafebabe&quot;), 	11).x	&apos; case doesn&apos;t matter
&apos;	assert_parses(p, &quot;0xdEaDbEeF&quot;, readHex(&quot;DeAdBeEf&quot;), 	11).x	&apos; case doesn&apos;t matter
End Function

</script:module>