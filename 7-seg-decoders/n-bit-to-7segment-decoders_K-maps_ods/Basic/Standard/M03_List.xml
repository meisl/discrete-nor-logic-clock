<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M03_List" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit


Sub Main
	[test_List ===============]()
End Sub


&apos; --- constructors ---


&apos; --- ctor test ---


&apos; --- destructors ---

Function car(Optional xs)
	If isMissing(xs) Then : car = Fn.car : Exit Function : End If
	If isNil(xs) Then
		croak(&quot;car: nil&quot;)
	Else
		&apos;car = List_car(xs)
		car = field(0, xs)
	End If
End Function

Function cdr(Optional xs)
	If isMissing(xs) Then : cdr = Fn.cdr : Exit Function : End If
	If isNil(xs) Then
		croak(&quot;cdr: nil&quot;)
	Else
		&apos;cdr = List_cdr(xs)
		cdr = field(1, xs)
	End If
End Function

Function length(Optional ByVal xs)
	If isMissing(xs) Then : length = Fn.length : Else
		&apos;length = List_length(xs)
		Dim out As Integer
		out = 0
		Do Until isNil(xs)
			out = out + 1
			xs = cdr(xs)
		Loop
		length = out
	End If
End Function

&apos; --- type test ---

Function isList(Optional x As Variant)
	Static oFn As Object
	If isMissing(x) Then
		If isNull(oFn) Then : oFn = Fn.isList : End If
		isList = oFn
	Else
		Dim c As Object : c = ctorOf(x)
		&apos;isList = hasType(x, TList)
		isList = CBool(DataValue_same(c, Tp.List_Nil) _
					Or DataValue_same(c, Tp.List_Cons) _
		)
	End If
End Function


&apos; --- toString ---

Function TList_toString(ByVal xs)
	&apos;concat &quot;[&quot; (concat (foldl1 (\acc.(concat acc) Â° (concat &quot;, &quot;))) &quot;[&quot; (map toString xs)) &quot;]&quot;
	&apos;out = &quot;[&quot; &amp; Join(toArray(map(Fn.toString, xs)), &quot;, &quot;) &amp; &quot;]&quot;
	
	Dim out As String
	If isNil(xs) Then
		out = &quot;[]&quot;
	Else
		Dim x
		x = car(xs)
		If isList(x) Then
			out = TList_toString(x)
		Else
			out = toString(x)
		End If
		xs = cdr(xs)
		Do Until(isNil(xs))
			x = car(xs)
			xs = cdr(xs)
			If isList(x) Then
				out = out &amp; &quot;, &quot; &amp; TList_toString(x)
			Else
				out = out &amp; &quot;, &quot; &amp; toString(x)
			End If
		Loop
		out = &quot;[&quot; &amp; out &amp; &quot;]&quot;
	End If
	
	TList_toString = out
End Function

&apos; --- equality ---

Function TList_equ(xs, ys) As Boolean
	Dim out As Boolean
	out = False
	Dim n As Integer
	n = length(xs)
	
	If n = length(ys) Then
	Dim x, y
TList_equ_compare_elems:
		If n = 0 Then
			out = True
		Else
			On Local Error Goto TList_equ_end &apos; if cars are incomparable
			x = car(xs)
			y = car(ys)
			If equ(x, y) Then
				&apos; tail-call:
				&apos;out = TList_equ(cdr(xs), cdr(ys))
				xs = cdr(xs)
				ys = cdr(ys)
				n = n - 1
				Goto TList_equ_compare_elems
			End If
		End If
	End If
TList_equ_end:
	TList_equ = out
End Function


&apos; --- fns on List ---

Function cadr(xs)
	cadr = car(cdr(xs))
End Function

Function caddr(xs)
	caddr = cadr(cdr(xs))
End Function

Function map(Optional f As Variant, Optional xs As Object)
	Dim result As Variant
	If isMissing(f) Then
		result = Fn.map
	ElseIf isMissing(xs) Then
		result = apply(Fn.map, f)
	Else
		If isArray(xs) Then
			result = toArray(map(f, toList(xs)))
		ElseIf isNil(xs) Then
			result = nil
		Else
			result = cons(apply(f, car(xs)), map(f, cdr(xs)))
		End If
	End If
	map = result
End Function

Function filter( _
	Optional ByRef f As Object, _
	Optional ByVal xs As Variant _
)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.filter : End If
	Dim out As Variant
	If isMissing(f) Then
		out = oFn
	ElseIf isMissing(xs) Then
		out = apply(oFn, f)
	Else
		If IsArray(xs) Then
			xs = toList(xs)
		End If
		Dim x As Variant
		out = nil
		While Not(isNil(xs))
			x = car(xs)
			If (apply(f, x)) Then
				out = cons(x, out)
			End If
			xs = cdr(xs)
		Wend
		out = reverse(out)
	End If
	filter = out
End Function

Function skipWhile( _
	Optional ByRef f As Object, _
	Optional ByVal xs As Variant _
)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.skipWhile : End If
	Dim out As Variant
	If isMissing(f) Then
		out = oFn
	ElseIf isMissing(xs) Then
		out = apply(oFn, f)
	Else
		If IsArray(xs) Then
			xs = toList(xs)
		End If
		Dim x As Variant
		out = xs
		Do Until isNil(out)
			If apply(f, car(out)) Then
				out = cdr(out)
			Else
				Exit Do
			End If
		Loop
	End If
	skipWhile = out
End Function

Function skipUntil( _
	Optional ByRef f As Object, _
	Optional ByVal xs As Variant _
)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.skipUntil : End If
	Dim out As Variant
	If isMissing(f) Then
		out = oFn
	ElseIf isMissing(xs) Then
		out = apply(oFn, f)
	Else
		If IsArray(xs) Then
			xs = toList(xs)
		End If
		Dim x As Variant
		out = xs
		Do Until isNil(out)
			If apply(f, car(out)) Then
				Exit Do
			Else
				out = cdr(out)
			End If
		Loop
	End If
	skipUntil = out
End Function

Function foldl( _
	Optional f As Object, _
	Optional acc, _
	Optional ByVal xs _
)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.foldl : End If
	If isMissing(xs) Then
		If isMissing(acc) Then
			If isMissing(f) Then
				foldl = oFn
			Else
				foldl = apply(oFn, f)
			End If
		Else
			foldl = apply(oFn, f, acc)
		End If
	Else
		If IsArray(xs) Then
			foldl = foldl(f, acc, toList(xs))
		Else
			Dim result As Variant
			result = acc
			While Not(isNil(xs))
				result = apply(f, result, car(xs))
				xs = cdr(xs)
			Wend
			foldl = result
		End If
	End If
End Function

Function foldl1(Optional f As Object, Optional xs)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.foldl1 : End If
	If isMissing(f) Then
		foldl1 = oFn
	ElseIf isMissing(xs) Then
		foldl1 = apply(oFn, f)
	Else
		If isNil(xs) Then
			croak(&quot;foldl1 on nil&quot;)
		End If
		foldl1 = foldl(f, car(xs), cdr(xs))
	End If
End Function

Function foldr( _
	Optional f As Object, _
	Optional acc As Variant, _
	Optional xs _
)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.foldr : End If
	If isMissing(xs) Then
		If isMissing(acc) Then
			If isMissing(f) Then
				foldr = oFn
			Else
				foldr = apply(oFn, f)
			End If
		Else
			foldr = apply(oFn, f, acc)
		End If
	Else
		Dim result As Variant
		If IsNil(xs) Then
			result = acc
		ElseIf IsArray(xs) Then
			result = foldr(f, acc, toList(xs))
		Else
			result = apply(f, car(xs), foldr(f, acc, cdr(xs)))
		End If
		foldr = result
	End If
End Function

&apos; Cannot name this function &quot;append&quot;, seems to be a BASIC keyword(?)
Function adjoin(Optional xs, Optional ys)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.adjoin : End If
	If isMissing(ys) Then 
		If isMissing(xs) Then
			adjoin = oFn
		Else
			adjoin = apply(oFn, xs)
		End If
	Else
		If isList(ys) Then
			adjoin = foldr(cons, ys, xs)
		Else
			croak(&quot;adjoin: expected List as 2nd arg - got &quot; &amp; typeStr(ys) _
				&amp; NL &amp; toString(ys))
		End If
	End If
End Function

&apos; Normally this is called &quot;concat&quot; but we already have that for Strings
Function flatten(Optional xs)
	If isMissing(xs) Then
		flatten = foldl(adjoin, nil)
	Else
		flatten = foldl(adjoin, nil, xs)
	End If
End Function

Function reverse(Optional ByVal xs)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.reverse : End If
	Dim out As Variant
	If isMissing(xs) Then : out = oFn
	Else
		&apos;out = foldl(swap(cons), nil, xs)
		Dim n As Integer
		n = length(xs)
		If n &lt;= 1 Then
			out = xs
		Else
			out = nil
			Do Until (n = 0)
				out = cons(car(xs), out)
				xs = cdr(xs)
				n = n - 1
			Loop
		End If
	End If
	reverse = out
End Function

Function toArray(ByVal xs)
	Dim n As Integer
	n = length(xs) - 1
	If n = -1 Then
		toArray = emptyArray
	Else
		Dim out(0 To n)
		Dim i As Integer
		For i = 0 To n
			out(i) = car(xs)
			xs = cdr(xs)
		Next i
		toArray = out
	End If
End Function

Function List( _
	Optional a0, _
	Optional a1, _
	Optional a2, _
	Optional a3, _
	Optional a4, _
	Optional a5, _
	Optional a6, _
	Optional a7, _
	Optional a8, _
	Optional a9, _
	Optional a10 _
)
	If Not(IsMissing(a10)) Then
		croak(&quot;List(...): cannot handle more than 10 args&quot;)
	End If
	Dim out As Object : out = nil

	&apos;If Not(isMissing(a0)) Then
	&apos;	&apos; tail-call:
	&apos;	out = cons(a0, List(a1, a2, a3, a4, a5, a6, a7, a8, a9))
	&apos;End If

	If isMissing(a4) Then
		If isMissing(a2) Then
			If isMissing(a0) Then
				Goto List_end
			ElseIf isMissing(a1) Then
				Goto List_0
			Else
				Goto List_1
			End If
		ElseIf isMissing(a3) Then
			Goto List_2
		Else
			Goto List_3
		End If
	ElseIf isMissing(a7) Then
		If isMissing(a5) Then
			Goto List_4
		ElseIf isMissing(a6) Then
			Goto List_5
		Else
			Goto List_6
		End If
	ElseIf isMissing(a8) Then
		Goto List_7
	ElseIf isMissing(a9) Then
		Goto List_8
	Else
		Goto List_9
	End If
List_9:	out = cons(a9, out)
List_8:	out = cons(a8, out)
List_7:	out = cons(a7, out)
List_6:	out = cons(a6, out)
List_5:	out = cons(a5, out)
List_4:	out = cons(a4, out)
List_3:	out = cons(a3, out)
List_2:	out = cons(a2, out)
List_1:	out = cons(a1, out)
List_0:	out = cons(a0, out)
List_end:
	List = out
End Function

Function toList(a As Array)
	Dim out As Variant
	Set out = nil
	Dim i As Integer, k As Integer
	Select Case getDim(a)
		Case 1
			For i = UBound(a) To LBound(a) Step -1
				out = cons(a(i), out)
			Next i
		Case 2
			For i = UBound(a, 1) To LBound(a, 1) Step -1
				Dim inner
				inner = nil
				For k = UBound(a, 2) To LBound(a, 2) Step -1
					inner = cons(a(i, k), inner)
				Next k
				out = cons(inner, out)
			Next i
		Case Else
			croak(&quot;toList: cannot handle &quot; &amp; getDim(a) &amp; &quot;-dimensional arrays&quot;)
	End Select
	toList = out
End Function
				
&apos;= tests ============================================================

Function [test_List ===============]()
	test_List_isList()
	test_List_isNil_and_cons()
	test_List_length()
	test_List_typeStr()
	test_List_TList_toString()
	test_List_polymorphic_toString()
	test_List_List()
	test_List_car()
	test_List_cdr()
	test_List_map()
	test_List_filter()
	test_List_skipWhile()
	test_List_skipUntil()
	test_List_foldl()
	test_List_foldl1()
	test_List_foldr()
	test_List_adjoin()
	test_List_flatten()
	test_List_reverse()
	test_List_equ()
End Function

Function test_List_isList()
	assertEqual(isList(Empty), 			False).x
	assertEqual(isList(Nothing), 		False).x
	assertEqual(isList(False),			False).x
	assertEqual(isList(True),			False).x
	assertEqual(isList(&quot;&quot;), 			False).x
	assertEqual(isList(&quot;foobar&quot;), 		False).x
	assertEqual(isList(0),				False).x
	assertEqual(isList(1),				False).x
	assertEqual(isList(-1),				False).x
	assertEqual(isList(3.1415),			False).x
	assertEqual(isList(Array()),		False).x
	assertEqual(isList(Array(1)),		False).x
	assertEqual(isList(Array(1, &quot;x&quot;)),	False).x
	assertEqual(isList(Fn.id),			False).x

	assertEqual(isList(nil),			True).x
	assertEqual(isList(cons(nil, nil)),	True).x
End Function

Function test_List_isNil_and_cons()
	assertEqual(isNil(nil), True).x
&apos;	assertThrows(isNil, Array()).x		&apos; assertThrows can&apos;t test call with 0 args
	assertThrows(isNil, Array(Empty)).x
	assertThrows(isNil, Array(Nothing)).x

	assertThrows(cons, Array(42, Empty)).x
	assertThrows(cons, Array(42, Nothing)).x
	assertThrows(cons, Array(42, True)).x
	assertThrows(cons, Array(42, False)).x
	assertThrows(cons, Array(42, 87)).x
	assertThrows(cons, Array(42, &quot;&quot;)).x
	assertThrows(cons, Array(42, &quot;foo&quot;)).x
	assertThrows(cons, Array(42, Array())).x

	assertEqual(isNil(cons(nil, nil)), False).x
	assertEqual(isNil(cons(0, nil)), False).x
	assertEqual(isNil(cons(&quot;&quot;, nil)), False).x
	
	assertEqual(isFn(Fn.isNil), True).x	&apos; from Fn object
	assertEqual(isFn(isNil), 	True).x	&apos; from 0-arg call
	assertEqual(arity(isNil),	1).x

	assertEqual(isFn(Fn.cons),	True).x	&apos; from Fn object
	assertEqual(isFn(cons),		True).x	&apos; from 0-arg call
	assertEqual(arity(cons),	2).x

	assertEqual(apply(isNil, nil), True).x
		
	&apos;assertEqual(toString(isNil(Empty)), &quot;[&apos;isNil&apos;, True, 1]&quot;).x
	&apos;assertEqual(apply(isNil, Nothing), True).x
End Function

Function test_List_length()
	assertEqual(length(					nil), 	0).x
	assertEqual(length(			cons(0, nil)), 	1).x
	assertEqual(length(cons(0, 	cons(0, nil))), 2).x

	assertEqual(isFn(Fn.length), 	True).x	&apos; from Fn object
	assertEqual(isFn(length), 		True).x	&apos; from 0-arg call
	assertEqual(arity(length), 		   1).x
	
	assertEqual(apply(length,						nil), 	0).x
	assertEqual(apply(length,				cons(0, nil)), 	1).x
	assertEqual(apply(length,	cons(0, 	cons(0, nil))), 2).x
End Function

Function test_List_typeStr()
	assertEqual(typeStr(nil), &quot;Data/List&quot;).x
	
	Dim lst
	lst = cons(5, nil)
	assertEqual(typeStr(lst), &quot;Data/List&quot;).x
End Function

Function test_List_TList_toString()
	Dim a
	a = nil
	assertEqual(TList_toString(a), &quot;[]&quot;).x
	
	a = cons(5, nil)
	assertEqual(TList_toString(a), &quot;[5]&quot;).x

	a = cons(7, a)
	assertEqual(TList_toString(a), &quot;[7, 5]&quot;).x
	a = cons(&quot;a&quot;, a)
	assertEqual(TList_toString(a), &quot;[&apos;a&apos;, 7, 5]&quot;).x
	a = cons(&quot;xxx&quot;, nil)
	assertEqual(TList_toString(a), &quot;[&apos;xxx&apos;]&quot;).x

	a = cons(nil, nil)
	assertEqual(TList_toString(a), &quot;[[]]&quot;).x
	a = cons(&quot;b&quot;, a)
	assertEqual(TList_toString(a), &quot;[&apos;b&apos;, []]&quot;).x
	a = cons(cons(&quot;a&quot;, nil), a)
	assertEqual(TList_toString(a), &quot;[[&apos;a&apos;], &apos;b&apos;, []]&quot;).x
	a = cons(a, nil)
	assertEqual(TList_toString(a), &quot;[[[&apos;a&apos;], &apos;b&apos;, []]]&quot;).x
	
	assertEqual(arity(Fn.TList_toString), 1).x
End Function

Function test_List_polymorphic_toString()
	Dim a
	a = nil
	assertEqual(toString(a), &quot;[]&quot;).x
	
	a = cons(5, nil)
	assertEqual(toString(a), &quot;[5]&quot;).x

	a = cons(7, a)
	assertEqual(toString(a), &quot;[7, 5]&quot;).x
	a = cons(&quot;a&quot;, a)
	assertEqual(toString(a), &quot;[&apos;a&apos;, 7, 5]&quot;).x
	a = cons(&quot;xxx&quot;, nil)
	assertEqual(toString(a), &quot;[&apos;xxx&apos;]&quot;).x

	a = cons(nil, nil)
	assertEqual(toString(a), &quot;[[]]&quot;).x
	a = cons(&quot;b&quot;, a)
	assertEqual(toString(a), &quot;[&apos;b&apos;, []]&quot;).x
	a = cons(cons(&quot;a&quot;, nil), a)
	assertEqual(toString(a), &quot;[[&apos;a&apos;], &apos;b&apos;, []]&quot;).x
End Function

Function test_List_foo(Optional a0, Optional a1)
	test_List_foo = List(a0, a1)
End Function

Function test_List_List()
	assertEqual(toString(List()), &quot;[]&quot;).x
	assertEqual(toString(List(0)), &quot;[0]&quot;).x
	assertEqual(toString(List(0, 1)), &quot;[0, 1]&quot;).x
	assertEqual(toString(List(0, 1, 2)), &quot;[0, 1, 2]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3)), &quot;[0, 1, 2, 3]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3, 4)), &quot;[0, 1, 2, 3, 4]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3, 4, 5)), &quot;[0, 1, 2, 3, 4, 5]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3, 4, 5, 6)), &quot;[0, 1, 2, 3, 4, 5, 6]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3, 4, 5, 6, 7)), &quot;[0, 1, 2, 3, 4, 5, 6, 7]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3, 4, 5, 6, 7, 8)), &quot;[0, 1, 2, 3, 4, 5, 6, 7, 8]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)), &quot;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&quot;).x

	&apos;&apos; assertThrows requires the function to be
	&apos;&apos; recognized by module &quot;List&quot;
	&apos;assertThrows(&quot;List&quot;, Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)).x
	
	assertEqual(toString(test_List_foo(5)), &quot;[5]&quot;).x
	assertEqual(toString(test_List_foo(5, 7)), &quot;[5, 7]&quot;).x
End Function

Function test_List_car()
	assertThrows(Fn.car, Array(nil)).x
	assertEqual(car(List(1   	)), 1).x
	assertEqual(car(List(2, 1	)), 2).x
	assertEqual(car(List(3, 2, 1)), 3).x

	assertEqual(isFn(Fn.car), 	True).x	&apos; from Fn object
	assertEqual(isFn(car), 		True).x	&apos; from 0-arg call
	assertEqual(arity(car), 	   1).x

	assertEqual(apply(car, List(1   	)), 1).x
	assertEqual(apply(car, List(2, 1	)), 2).x
	assertEqual(apply(car, List(3, 2, 1	)), 3).x
End Function

Function test_List_cdr()
	assertThrows(Fn.cdr, Array(nil)).x
	assertEqual(toString(cdr(List(1   	 ))), &quot;[]&quot;).x
	assertEqual(toString(cdr(List(2, 1	 ))), &quot;[1]&quot;).x
	assertEqual(toString(cdr(List(3, 2, 1))), &quot;[2, 1]&quot;).x

	assertEqual(isFn(Fn.cdr), 	True).x	&apos; from Fn object
	assertEqual(isFn(cdr), 		True).x	&apos; from 0-arg call
	assertEqual(arity(cdr), 	   1).x

	assertEqual(toString(apply(cdr, List(1   	))), &quot;[]&quot;).x
	assertEqual(toString(apply(cdr, List(2, 1	))), &quot;[1]&quot;).x
	assertEqual(toString(apply(cdr, List(3, 2, 1))), &quot;[2, 1]&quot;).x
End Function

Function test_List_map()
	assertEqual(toString(map(Fn.toString, nil)), &quot;[]&quot;).x
	assertEqual(toString(map(Fn.toString, List(1))), &quot;[&apos;1&apos;]&quot;).x
	assertEqual(toString(map(Fn.toString, List(&quot;a&quot;))), &quot;[&apos;&apos;a&apos;&apos;]&quot;).x
	assertEqual(toString(map(Fn.toString, List(&quot;a&quot;, 42))), &quot;[&apos;&apos;a&apos;&apos;, &apos;42&apos;]&quot;).x
	assertEqual(toString(map(Fn.toString, List(nil, &quot;a&quot;, 42))), &quot;[&apos;[]&apos;, &apos;&apos;a&apos;&apos;, &apos;42&apos;]&quot;).x
	
	assertEqual(arity(Fn.map), 2).x
	assertEqual(toString(apply(Fn.map, Fn.toString, nil)), &quot;[]&quot;).x
	assertEqual(toString(apply(Fn.map, Fn.toString, List(1))), &quot;[&apos;1&apos;]&quot;).x
	assertEqual(toString(apply(Fn.map, Fn.toString, List(&quot;a&quot;))), &quot;[&apos;&apos;a&apos;&apos;]&quot;).x
	assertEqual(toString(apply(Fn.map, Fn.toString, List(&quot;a&quot;, 42))), &quot;[&apos;&apos;a&apos;&apos;, &apos;42&apos;]&quot;).x
	assertEqual(toString(apply(Fn.map, Fn.toString, List(nil, &quot;a&quot;, 42))), &quot;[&apos;[]&apos;, &apos;&apos;a&apos;&apos;, &apos;42&apos;]&quot;).x
End Function

Function test_List_filter()
	Dim p As Object
	assertEqual(arity(filter), 2).x
	
	p = isNil
	assertEqual(arity(filter(p)), 1).x

	assertEqual(toString(filter(p, nil)), 		  	&quot;[]&quot;).x
	assertEqual(toString(filter(p, List(nil))),		&quot;[[]]&quot; ).x
	assertEqual(toString(filter(p, List(nil, nil))), &quot;[[], []]&quot;).x
	assertEqual(toString(filter(p, _
		List(List(1), List(1, 0), List(nil))  )), _
		&quot;[]&quot;).x
	assertEqual(toString(filter(p, _
		List(nil, List(1), nil, List(1, 0), List(nil))  )), _
		&quot;[[], []]&quot;).x
	
	p = equ(1)
	assertEqual(arity(filter(p)), 1).x
	assertEqual(toString(filter(p, _
		List(0, 1, 1, 0, 1, 0)  )), _
		&quot;[1, 1, 1]&quot;).x
	
	&apos; it preserves order of elements
	p = inRange(2, 4)
	assertEqual(toString(filter(p, _
		List(0, 1, 2, 3, 4, 5))), &quot;[2, 3, 4]&quot;).x
End Function

Function test_List_skipWhile()
	Dim f As Object
	f = skipWhile
	assertEqual(arity(f), 2).x
	f = skipWhile(isNil)
	assertEqual(arity(f), 1).x
	
	f = compose(Fn.toString, skipWhile(isNil))

	assertEqual(apply(f, nil),				&quot;[]&quot;).x
	assertEqual(apply(f, List(nil)),		&quot;[]&quot; ).x
	assertEqual(apply(f, List(nil, nil)),	&quot;[]&quot;).x
	assertEqual(apply(f, List(List(nil), nil)),	&quot;[[[]], []]&quot;).x
	assertEqual(apply(f, _
		List(List(1), nil, List(1, 0))), _
		&quot;[[1], [], [1, 0]]&quot;).x
	assertEqual(apply(f, _
		List(nil, nil, List(1), nil, List(1, 0))), _
		&quot;[[1], [], [1, 0]]&quot;).x
	
	f = compose(Fn.toString, skipWhile(inRange(0, 2)))
	
	assertEqual(apply(f, List(0, 1, 2)), 		  &quot;[]&quot;).x
	assertEqual(apply(f, List(0, 1, 2, 3)),		  &quot;[3]&quot;).x
	assertEqual(apply(f, List(0, 1, 2, 3, 4, 5)), &quot;[3, 4, 5]&quot;).x
	assertEqual(apply(f, List(2, 0, 3, 1, 4, 5)), &quot;[3, 1, 4, 5]&quot;).x
	assertEqual(apply(f, List(5, 4, 3, 2, 1, 0)), &quot;[5, 4, 3, 2, 1, 0]&quot;).x
End Function

Function test_List_skipUntil()
	Dim f As Object
	f = skipUntil
	assertEqual(arity(f), 2).x
	f = skipUntil(isNil)
	assertEqual(arity(f), 1).x
	
	f = compose(Fn.toString, skipUntil(isNil))

	assertEqual(apply(f, nil),				&quot;[]&quot;).x
	assertEqual(apply(f, List(nil)),		&quot;[[]]&quot; ).x
	assertEqual(apply(f, List(nil, nil)),	&quot;[[], []]&quot;).x
	assertEqual(apply(f, List(List(nil), nil)),	&quot;[[]]&quot;).x
	assertEqual(apply(f, _
		List(List(1), nil, List(1, 0))), _
		&quot;[[], [1, 0]]&quot;).x
	assertEqual(apply(f, _
		List(nil, nil, List(1), nil, List(1, 0))), _
		&quot;[[], [], [1], [], [1, 0]]&quot;).x
	
	f = compose(Fn.toString, skipUntil(inRange(0, 2)))
	
	assertEqual(apply(f, List(0, 1, 2)), 		  &quot;[0, 1, 2]&quot;).x
	assertEqual(apply(f, List(0, 1, 2, 3)),		  &quot;[0, 1, 2, 3]&quot;).x
	assertEqual(apply(f, List(0, 1, 2, 3, 4, 5)), &quot;[0, 1, 2, 3, 4, 5]&quot;).x
	assertEqual(apply(f, List(2, 0, 3, 1, 4, 5)), &quot;[2, 0, 3, 1, 4, 5]&quot;).x
	assertEqual(apply(f, List(5, 4, 3, 2, 1, 0)), &quot;[2, 1, 0]&quot;).x
End Function

Function test_List_foldl() &apos;TODO: check order of args as they come in
	Dim f As Object
	f = Fn.foldl
	assertEqual(isFn(f), True).x
	assertEqual(arity(f),   3).x
	
	f = foldl(concat)
	assertEqual(isFn(f), True).x
	assertEqual(arity(f),   2).x
	
	f = foldl(concat, &quot;xxx&quot;)
	assertEqual(isFn(f), True).x
	assertEqual(arity(f),   1).x
	
	assertEqual(apply(f, nil),                      &quot;xxx&quot;).x
	assertEqual(apply(f, List(&quot;a&quot;)),			 	&quot;xxxa&quot;).x
	assertEqual(apply(f, List(&quot;a&quot;, &quot;b&quot;)),		 	&quot;xxxab&quot;).x
	assertEqual(apply(f, List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)),	 	&quot;xxxabc&quot;).x
	assertEqual(apply(f, List(&quot;d&quot;, &quot;a&quot;, &quot;c&quot;, &quot;b&quot;)),	&quot;xxxdacb&quot;).x

	assertEqual(apply(foldl, add, 1, List(4, 1, 3, 2)), 11).x
End Function

Function test_List_foldl1() &apos;TODO: check order of args as they come in
	Dim f As Object
	f = Fn.foldl1
	assertEqual(isFn(f), True).x
	assertEqual(arity(f),   2).x
	
	f = foldl1(concat)
	assertEqual(isFn(f), True).x
	assertEqual(arity(f),   1).x
	assertThrows(f, Array(nil)).x
	assertEqual(apply(f, List(&quot;a&quot;)),			 	&quot;a&quot;).x
	assertEqual(apply(f, List(&quot;a&quot;, &quot;b&quot;)),		 	&quot;ab&quot;).x
	assertEqual(apply(f, List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)),	 	&quot;abc&quot;).x
	assertEqual(apply(f, List(&quot;d&quot;, &quot;a&quot;, &quot;c&quot;, &quot;b&quot;)),	&quot;dacb&quot;).x

	assertEqual(apply(foldl1, add, List(4, 1, 3, 2)), 10).x
End Function

Function test_List_foldr() &apos;TODO: check order of args as they come in
	Dim f As Object, i As Integer, a As Variant
	f = Fn.foldr
	assertEqual(isFn(f), True).x
	assertEqual(arity(f),   3).x
	
	f = foldr(concat)
	assertEqual(isFn(f), True).x
	assertEqual(arity(f),   2).x
	
	a = Array(foldr(concat, &quot;xxx&quot;), apply(Fn.foldr, concat, &quot;xxx&quot;))
	For i = LBound(a) To UBound(a)
		f = a(i)
		assertEqual(isFn(f), True).x
		assertEqual(arity(f),   1).x
		
		assertEqual(apply(f, nil),                      &quot;xxx&quot;).x
		assertEqual(apply(f, List(&quot;a&quot;)),			 	&quot;axxx&quot;).x
		assertEqual(apply(f, List(&quot;a&quot;, &quot;b&quot;)),		 	&quot;abxxx&quot;).x
		assertEqual(apply(f, List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)),	 	&quot;abcxxx&quot;).x
		assertEqual(apply(f, List(&quot;d&quot;, &quot;a&quot;, &quot;c&quot;, &quot;b&quot;)),	&quot;dacbxxx&quot;).x
	Next i
	
	assertEqual(apply(foldr, add, 1, List(4, 1, 3, 2)), 11).x
End Function

Function test_List_adjoin()
	assertEqual(toString(adjoin(nil, nil)), &quot;[]&quot;).x
	
	assertThrows(adjoin, Array(1, nil)).x
	assertThrows(adjoin, Array(nil, 1)).x
	
	Dim lst
	Set lst = cons(1, nil)
	assertEqual(toString(adjoin(lst, nil)), &quot;[1]&quot;).x
	assertEqual(toString(adjoin(nil, lst)), &quot;[1]&quot;).x

	assertEqual(toString(adjoin(lst, lst)), &quot;[1, 1]&quot;).x
	Dim lst2
	Set lst2 = cons(2, nil)
	assertEqual(toString(adjoin(lst, lst2)), &quot;[1, 2]&quot;).x
	assertEqual(toString(adjoin(lst2, lst)), &quot;[2, 1]&quot;).x
	Set lst2 = cons(3, lst2)
	assertEqual(toString(adjoin(lst, lst2)), &quot;[1, 3, 2]&quot;).x
	assertEqual(toString(adjoin(lst2, lst)), &quot;[3, 2, 1]&quot;).x
	Set lst = cons(0, lst)
	assertEqual(toString(adjoin(lst, lst2)), &quot;[0, 1, 3, 2]&quot;).x
	assertEqual(toString(adjoin(lst2, lst)), &quot;[3, 2, 0, 1]&quot;).x
End Function

Function test_List_flatten()
	assertEqual(arity(Fn.flatten),	1).x
	assertEqual(arity(flatten),		1).x

	assertEqual(toString(flatten(nil)), &quot;[]&quot;).x
	Dim lst
	Set lst = cons(1, nil)
	assertThrows(Fn.flatten, Array(lst)).x
	Set lst = cons(lst, nil)	&apos; [[1]]
	assertEqual(toString(flatten(lst)), &quot;[1]&quot;).x
	Set lst = cons(nil, lst)	&apos; [[], [1]]
	assertEqual(toString(flatten(lst)), &quot;[1]&quot;).x
	Dim lst2
	Set lst2 = cons(&quot;a&quot;, cons(&quot;b&quot;, nil))
	Set lst = cons(lst2, lst)	&apos; [[&apos;a&apos;, &apos;b&apos;], [], [1]]
	assertEqual(toString(flatten(lst)), &quot;[&apos;a&apos;, &apos;b&apos;, 1]&quot;).x
	Set lst2 = cons(lst2, nil)
	Set lst = cons(lst2, lst)	&apos; [[[&apos;a&apos;, &apos;b&apos;]], [&apos;a&apos;, &apos;b&apos;], [], [1]]
	assertEqual(toString(flatten(lst)), &quot;[[&apos;a&apos;, &apos;b&apos;], &apos;a&apos;, &apos;b&apos;, 1]&quot;).x
End Function

Function test_List_reverse()
	assertEqual(toString(reverse(nil)), toString(nil)).x
	Dim lst
	Set lst = cons(1, nil)
	assertEqual(toString(reverse(lst)), toString(lst)).x
	Set lst = cons(2, lst)
	assertEqual(toString(reverse(lst)), &quot;[1, 2]&quot;).x
	Set lst = cons(3, lst)
	assertEqual(toString(reverse(lst)), &quot;[1, 2, 3]&quot;).x
	
	assertEqual(isFn(Fn.reverse), True).x &apos; from Fn object
	assertEqual(isFn(reverse), 	  True).x &apos; from 0-arg call
End Function

Function test_List_equ()
	assertEqual(arity(Fn.TList_equ),	2).x
	&apos;assertEqual(arity(TList_equ),		2).x
	assertEqual(apply(Fn.TList_equ, nil, nil),	True).x
	
	assertEqual(equ(nil, Empty), False).x	&apos; Empty is comparable to anything
	assertEqual(equ(Empty, nil), False).x

	&apos; we consider data types NOT to be comparable with plain Object:
	assertThrows(equ, Array(nil, Nothing)).x
	assertThrows(equ, Array(Nothing, nil)).x

	assertEqual(equ(nil,		nil),			True).x
	
	assertEqual(equ(List(1), 	nil),			False).x
	assertEqual(equ(nil, 		List(1)),		False).x
	
	assertEqual(equ(List(1), 	List(1)),		True).x
	assertEqual(equ(List(2), 	List(1)),		False).x
	assertEqual(equ(List(1), 	List(2)),		False).x
	
	&apos; ?? &quot;equ: incompatible types String and Integer&quot;
	&apos;assertThrows(equ, Array(List(&quot;1&quot;), 	List(1))).x
	assertEqual(equ(List(&quot;1&quot;), List(1)), False).x
	
	&apos; ?? &quot;equ: incompatible types Integer and String&quot;
	&apos;assertThrows(equ, Array(List(1, 2), List(1, &quot;2&quot;))).x
	assertEqual(equ(List(1, 2), List(1, &quot;2&quot;)), False).x
	
	assertEqual(equ(List(1, 2), List(1)),		False).x
	assertEqual(equ(List(1), 	List(1, 2)),	False).x
	assertEqual(equ(List(1, 2), List(1, 2)),	True).x
	assertEqual(equ(List(2, 2), List(1, 2)),	False).x
	assertEqual(equ(List(2, 1), List(1, 2)),	False).x


End Function

</script:module>