<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M01_Common" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit

Type TTest_NoTyname
End Type

Type TTest_Tyname
	tyname As String
End Type

Type TTest_Ctor
	ctor As Variant
End Type

Type TTest_Foo
	bar As Integer
End Type

Sub Main
	test_Common()
End Sub

Function CR()  : CR = Chr(13) : End Function
Function LF()  : LF = Chr(10) : End Function
Function NL()  : NL = CR &amp; LF : End Function
Function TAB() : TAB = Chr(9) : End Function
Function DQ()  : DQ = Chr(34) : End Function &apos; double quote &quot;

Function show(a As Variant, Optional b As Variant)
	If isMissing(b) Then
		MsgBox(toString(a))
	Else
		If isString(a) Then
			MsgBox(a &amp; NL &amp; NL &amp; toString(b))
		Else
			MsgBox(toString(a) &amp; NL &amp; NL &amp; toString(b))
		End If
	End If
End Function

Function typeOf(x As Variant)
	Dim out As String
	out = TypeName(x)
	If out = &quot;Object&quot; Then
		out = _typeOf(x) &apos; DONT access fields in here!
	ElseIf IsArray(x) Then
		out = &quot;Array&quot;
	End If
	typeOf = out
End Function

Function _typeOf(o As Object)
	Dim out As String
	out = &quot;Object&quot;
	On Local Error Goto _typeOf_end
	out = out &amp; &quot;/&quot; &amp; _tyname(o)
_typeOf_end:
	_typeOf = out
End Function

Function _tyname(o As Object)
	_tyname = o.tyname
End Function

Function ctorOf(Optional x As Variant)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.ctorOf : End If
	Dim out As Variant
	If isMissing(x) Then : out = oFn
	Else
		out = Empty
		If isObject(x) Then
			If Not(isNull(x)) Then
				On Local Error Goto ctorOf_end
				out = _ctor(x) &apos; DONT access fields in here!
				If Not(isFn(out)) Then
					On Local Error Goto ctorOf_error
					out.provoke_an_error
				End If
			End If
		End If
	End If
ctorOf_end:
	ctorOf = out
	Exit Function
ctorOf_error:
	croak(&quot;ctorOf: object with invalid .ctor :: &quot; &amp; typeOf(out) &amp; NL &amp; toString(out))
End Function

Function _ctor(o As Object)
	Dim out As Variant
	On Local Error Goto _ctor_end
	out = o.ctor
_ctor_end:
	_ctor = out
End Function


Function isString(Optional x As Variant)
	If isMissing(x) Then
		isString = Fn.isString
	Else
		isString = (typeOf(x) = typeOf(&quot;&quot;))
	End If
End Function

Sub croak(msg As String)
	Dim provoke As Object
	If (testLevel = 0) Then
		MsgBox(msg)
	End If
	MsgBox(provoke.AnError)
End Sub

&apos; I = \x.x
&apos;	:: a -&gt; a
Function id(Optional x As Variant)
	id = _apply(Fn.id, x)
End Function

&apos; K = \x y.x
&apos;     :: a -&gt; b -&gt; a
Function fstArg(Optional x As Variant, Optional y As Variant)
	fstArg = _apply(Fn.fstArg, x, y)
End Function

&apos; K I = (\b x.b) (\y.y) = \x.\y.y = \x y.y
&apos;     :: a -&gt; b -&gt; b
Function sndArg(Optional x As Variant, Optional y As Variant)
	Dim out As Variant
	If isMissing(x) Then
		out = Fn.sndArg
	ElseIf isMissing(y) Then
		out = Fn.id
	Else
		out = y
	End If
	sndArg = out
End Function

&apos;\f y x.f x y
&apos; :: (b -&gt; a) -&gt; a -&gt; b = (b -&gt; a) -&gt; (a -&gt; b)
Function swap(Optional f, Optional x, Optional y)
	swap = _apply(Fn.swap, f, x, y)
End Function

&apos; B = \f g x.f (g x)
&apos;   :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c  =  (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)
Function compose(Optional ByVal f, Optional ByVal g, Optional x)
	&apos;compose = _apply(Fn.compose, f, g, x)
	compose = _compose(f, g, x)
End Function

Function _compose(Optional ByVal f, Optional ByVal g, Optional x)
	Dim out As Variant
	If isMissing(f) Then
		out = Fn.compose
	Else
		Dim fName As String, h As Object, i As Object
		fName = getFnName(f)
		If isMissing(g) Then
			If fName = getFnName(Fn.id) Then
				out = f
			ElseIf fName = getFnName(Fn.fstArg) Then
				If arity(f) = 1 Then &apos; f = K v
					out = f
				Else &apos; f = K
					out = _apply(Fn.compose, f)
				End If
			ElseIf fName = getFnName(Fn.sndArg) Then
				out = Fn.sndArg
			ElseIf fName = getFnName(Fn.compose) Then
				If arity(f) = 1 Then &apos; f = B h i, so B f = B (B h i) = B h (B i)
					h = cadr(partialArgs(f)) &apos; they&apos;re backwards!
					i = car(partialArgs(f))   &apos; they&apos;re backwards!
					out = _compose(h, _compose(i))
				Else
					out = _apply(Fn.compose, f)
				End If
			Else
				out = _apply(Fn.compose, f)
			End If
		Else
			Dim gName As String
			gName = getFnName(g)
			If gName = getFnName(Fn.id) Then
				out = _apply(f, x)
			ElseIf isMissing(x) Then
				If fName = getFnName(Fn.id) Then
					out = g
				ElseIf fName = getFnName(Fn.sndArg) Then
					out = f
				ElseIf fName = getFnName(Fn.fstArg) Then
					If arity(f) = 1 Then &apos; f = K v
						out = f
					Else &apos; f = K
						out = _apply(Fn.compose, f, g)
					End If
				ElseIf fName = getFnName(Fn.compose) Then
					If arity(f) = 1 Then &apos; f = B h i, so B f g = B (B h i) g = (h ° i) ° g = h ° (i ° g)
						h = cadr(partialArgs(f)) &apos; they&apos;re backwards!
						i = car(partialArgs(f))   &apos; they&apos;re backwards!
						out = _compose(h, _compose(i, g))
					Else
						out = _apply(Fn.compose, f, g)
					End If
				Else
					out = _apply(Fn.compose, f, g)
				End If
			Else
				If fName = getFnName(Fn.id) Then
					out = _apply(g, x)
				ElseIf fName = getFnName(Fn.sndArg) Then
					out = x
				ElseIf fName = getFnName(Fn.fstArg) Then
					If arity(f) = 1 Then &apos; f = K v
						out = car(partialArgs(f))
					Else &apos; f = K
						out = apply1(f, apply1(g, x))
					End If
				ElseIf fName = getFnName(Fn.compose) Then
					If arity(f) = 1 Then &apos; f = B h i, so B f g x = B (B h i) g x = h (i (g x))
						h = cadr(partialArgs(f)) &apos; they&apos;re backwards!
						i = car(partialArgs(f))   &apos; they&apos;re backwards!
						out = apply1(h, apply1(i, apply1(g, x)))
					Else
						out = apply1(f, apply1(g, x))
					End If
				Else
					out = apply1(f, apply1(g, x))
				End If
			End If
		End If
	End If		
	_compose = out
End Function


&apos;\c t e x.if (c x) then (t x) else (e x)
&apos;   :: (a -&gt; Bool) -&gt; (a -&gt; b) -&gt; (a -&gt; b) -&gt; a -&gt; b
Function ite(Optional cond, Optional thn, Optional els, Optional x)
	ite = _apply(Fn.ite, cond, thn, els, x)
End Function

Function concat(Optional a As String, Optional b As String)
	concat = _apply(Fn.concat, a, b)
End Function

&apos; TODO: startsWith ~&gt; isPrefixOf, add isSuffixOf (&quot;endsWith&quot;)
Function startsWith(s As String, prefix As String) 
	startsWith = ((Len(prefix) &lt;= Len(s)) And (Mid(s, 1, Len(prefix)) = prefix))
End Function

Function add(Optional a As Long, Optional b As Long)
	add = _apply(Fn.add, a, b)
End Function

Function mul(Optional a As Long, Optional b As Long)
	mul = _apply(Fn.mul, a, b)
End Function

Function neq(Optional a As Variant, Optional b As Variant)
	neq = _apply(Fn.neq, a, b)
End Function

Function inRange( _
	Optional lo As Long, _
	Optional hi As Long, _
	Optional x As Long _
)
	inRange = _apply(Fn.inRange, lo, hi, x)
End Function

Function equ(Optional a As Variant, Optional b As Variant)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.equ : End If
	Dim result as Variant
	If isMissing(a) Then
		result = oFn
	ElseIf isMissing(b) Then
		result = apply(oFn, a)
	ElseIf isEmpty(a) Then
		result = isEmpty(b)
	ElseIf isEmpty(b) Then
		result = False
	Else
		Dim ta As String, tb As String, tmp As String
		ta = typeOf(a)
		tb = typeOf(b)
		If (ta &lt;&gt; tb) Then
			If (isNull(a) And startsWith(tb, ta)) Or (isNull(b) And startsWith(ta, tb)) Then
				result = False
			Else
				croak(&quot;equ: incompatible types &quot; &amp; ta &amp; &quot; and &quot; &amp; tb)
			End If
		Else &apos; ta = tb
			Select Case ta
				Case &quot;Empty&quot;:	result = True
				Case &quot;Object&quot;	&apos; Object without a .tyname field
					result = CBool(isNull(a) And isNull(b))
					If Not(result) Then
						croak(&quot;equ: cannot compare values of underspecified type &quot; &amp; ta)
					End If
				Case &quot;Object/&quot;	&apos; Object with a uninitialized .tyname field
					croak(&quot;equ: cannot compare (uninitialized) values of type &quot; &amp; ta)
				Case Else
					If isObject(a) Then	&apos;they are instances of the same custom type (with non-empty.tyname)
						&apos; ATTENTION: do NOT access .tyname directly!
						Dim fName As String
						fName = _tyname(a) &amp; &quot;_equ&quot;
						result = apply(fName, a, b)
					ElseIf isArray(a) Then
						croak(&quot;equ: NYI - comparing arrays&quot;)
					Else
						result = CBool(a = b)
					End If
			End Select
		End If
	End If
	equ = result
End Function

Function toString(ByVal v As Variant) As String
	Dim result As String
	Dim tp As String
	tp = typeOf(v)
	Select Case tp
		Case &quot;String&quot;
			Dim t As String
			t = v &amp; &quot;&quot;
			t = Join(Split(t, &quot;\&quot;), &quot;\\&quot;)
			t = Join(Split(t, DQ), 	&quot;\&quot; &amp; DQ)
			t = Join(Split(t, CR),  &quot;\r&quot;)
			t = Join(Split(t, LF),  &quot;\n&quot;)
			t = Join(Split(t, TAB), &quot;\t&quot;)
			result = &quot;&apos;&quot; &amp; t &amp; &quot;&apos;&quot;
		Case &quot;Empty&quot;
			result = tp
		Case &quot;Array&quot;
			result = Array_toString(v)
		Case &quot;Object&quot;	&apos; Object without a .tyname field
			If IsNull(v) Then
				result = &quot;Nothing&quot;
			Else
				result = tp &amp; &quot;(...)&quot;
			End If
		Case Else
			If IsObject(v) Then	&apos; Object with a .tyname field
				Dim tyName As String, toStrFnName As String, toStrFn As Variant
				&apos; ATTENTION: do NOT access .tyname directly!
				tyName = _tyName(v)
				If (tyname = &quot;&quot;) Then
					result = &quot;Object(tyname=&apos;&apos;)&quot;
				Else
					toStrFnName = tyName &amp; &quot;_toString&quot;
					&apos;We&apos;ve got an Object with .tyName, so we insist on its _toString to exist
					&apos;Note: We test for existence separately because apply/croak call toString again...
					toStrFn = lookupFn(toStrFnName)
					If isEmpty(toStrFn) Then
						&apos;croak(&quot;toString: unknown fn &apos;&quot; &amp; toStrFnName &amp; &quot;&apos;&quot;)
						result = tyName &amp; &quot;(...)&quot;
					Else
						result = apply(toStrFn, v)
					End If
				End If
			Else
				result = v &amp; &quot;&quot;
			End If
	End Select
	toString = result
End Function

Function readHex(arg As Variant) As Long
	Dim result As Long, t As String
	t = typeOf(arg)
	Select Case t
		Case &quot;Array&quot;
			result = readHex(Join(arg))
		Case &quot;String&quot;
			Dim l As Integer
			l = Len(arg)
			If l = 0 Then
				croak(&quot;readHex: got empty String&quot;)
			Else
				Dim digits As String, d As Integer, x As Long, i As Integer
				digits = arg
				result = 0
				For i = 1 To Len(digits)
					d = Asc(Mid(digits, i, 1))
					If (d &gt;= Asc(&quot;0&quot;)) And (d &lt;= Asc(&quot;9&quot;)) Then
						x = d - Asc(&quot;0&quot;)
					ElseIf (d &gt;= Asc(&quot;A&quot;)) And (d &lt;= Asc(&quot;F&quot;)) Then
						x = d - Asc(&quot;A&quot;) + 10
					ElseIf (d &gt;= Asc(&quot;a&quot;)) And (d &lt;= Asc(&quot;f&quot;)) Then
						x = d - Asc(&quot;a&quot;) + 10
					Else
						croak(&quot;readHex: invalid hex digit &apos;&quot; &amp; chr(d) &amp; &quot;&apos; in &quot; &amp; toString(arg))
					End If
&apos;On Local Error Goto readHex_blows		
					result = (result * 16) + x
				Next i
			End If
		Case Else
			croak(&quot;readHex: expected Array or String - got &quot; &amp; t &amp; &quot;:&quot; &amp; CR &amp; toString(arg))
	End Select
	readHex = result
	Exit Function
	
readHex_blows:
	MsgBox(toString(result))
	Exit Function
End Function

&apos;= tests ============================================================

Function test_Common()
	testLevel = 0
	test_isObject()
	test_passing_pointers()
	test_concat()
	test_typeOf()
	test_ctorOf()
	test_isString()
	test_toString()
	test_id()
	test_fstArg()
	test_sndArg()
	test_swap()
	test_add()
	test_mul()
	test_compose() &apos; tests use add and mul and toString
	test_inRange()
	test_equ()
	test_readHex()
End Function

Function test_isObject()
	Dim o As Object

	assertEqual(isObject(Nothing),	True).x

	assertEqual(isObject(Empty),	False).x
	assertEqual(isObject(True),		False).x
	assertEqual(isObject(False),	False).x
	assertEqual(isObject(&quot;&quot;),		False).x
	assertEqual(isObject(&quot;foobar&quot;),	False).x
	assertEqual(isObject( 0),		False).x
	assertEqual(isObject( 1),		False).x
	assertEqual(isObject(-1),		False).x
	assertEqual(isObject(3.1415),	False).x
	assertEqual(isObject(Array()),	False).x

	o = New TTest_Foo
	assertEqual(isObject(o), True).x
	o.bar = 4711
	assertEqual(isObject(o), True).x
End Function

Function test_passPtrByVal_Object(ByVal o As Object)
	o.bar = o.bar + 1
	o = Nothing
	test_passPtrByVal_Object = o
End Function

Function test_passPtrByVal_Type(ByVal o As TTest_Foo)
	o.bar = o.bar + 1
	o = Nothing
	test_passPtrByVal_Type = o
End Function

Function test_passPtrByRef_Object(ByRef o As Object)
	o.bar = o.bar + 1
	o = Nothing
	test_passPtrByRef_Object = o
End Function

Function test_passPtrByRef_Type(o As TTest_Foo)
	o.bar = o.bar + 1
	o = Nothing
	test_passPtrByRef_Type = o
End Function

Function test_passing_pointers()
	Dim o As Object
	o = New TTest_Foo
	o.bar = 7
	
	&apos; make sure fn was actually executed:
	assertEqual(test_passPtrByVal_Object(o), Nothing).x
	&apos; fn did not change the pointer o (because it was passed ByVal):
	assertEqual(isNull(o), False).x
	&apos; fn did however change the object pointed to:
	assertEqual(o.bar, 8).x
	
	&apos; Same if parameter is declared with the custom type instead of Object
	&apos; make sure fn was actually executed:
	assertEqual(test_passPtrByVal_Type(o), Nothing).x
	&apos; fn did not change the pointer o (because it was passed ByVal):
	assertEqual(isNull(o), False).x
	&apos; fn did however change the object pointed to:
	assertEqual(o.bar, 9).x

	&apos;Things change when we pass it ByRef (which is the default!)
	Dim o2 As Object
	o2 = o	&apos; keep original in different var
	&apos; call fn
	assertEqual(test_passPtrByRef_Object(o), Nothing).x
	&apos; fn did change the pointer o (because it was passed ByRef):
	assertEqual(isNull(o), True).x
	&apos; fn also did change the object pointed to:
	assertEqual(o2.bar, 10).x
	
	&apos; Same if parameter is declared with the custom type instead of Object
	o = o2 &apos; restore o
	&apos; make sure fn was actually executed:
	assertEqual(test_passPtrByRef_Type(o), Nothing).x
	&apos; fn did change the pointer o (because it was passed ByRef):
	assertEqual(isNull(o), True).x
	&apos; fn did however change the object pointed to:
	assertEqual(o2.bar, 11).x

	
	&apos; Now try with an argument declared as the custom type (instead of Object):
	&apos;--------------------------------------------------------------------------
	Dim p As New TTest_Foo
	p.bar = 7

	&apos; make sure fn was actually executed:
	assertEqual(test_passPtrByVal_Object(p), Nothing).x
	&apos; fn did not change the pointer p (because it was passed ByVal):
	assertEqual(isNull(p), False).x
	&apos; fn did however change the object pointed to:
	assertEqual(p.bar, 8).x
	
	&apos; Same if parameter is declared with the custom type instead of Object
	&apos; make sure fn was actually executed:
	assertEqual(test_passPtrByVal_Object(p), Nothing).x
	&apos; fn did not change the pointer p (because it was passed ByVal):
	assertEqual(isNull(p), False).x
	&apos; fn did however change the object pointed to:
	assertEqual(p.bar, 9).x


	&apos;Things change when we pass it ByRef (which is the default)
	Dim p2 As Object
	p2 = p	&apos; keep original in different var
	&apos; call fn
	assertEqual(test_passPtrByRef_Type(p), Nothing).x
	&apos; fn did change the pointer p (because it was passed ByRef):
	assertEqual(isNull(p), True).x
	&apos; fn also did change the object pointed to:
	assertEqual(p2.bar, 10).x
	
	&apos; Same if parameter is declared with the custom type instead of Object
	p = p2 &apos; restore p
	&apos; make sure fn was actually executed:
	assertEqual(test_passPtrByRef_Type(p), Nothing).x
	&apos; fn did change the pointer p (because it was passed ByRef):
	assertEqual(isNull(p), True).x
	&apos; fn did however change the object pointed to:
	assertEqual(p2.bar, 11).x
End Function
	
Function test_typeOf()
	assertEqual(typeOf(0), &quot;Integer&quot;).x
	assertEqual(typeOf(1), &quot;Integer&quot;).x
	assertEqual(typeOf(-42), &quot;Integer&quot;).x
	
	assertEqual(typeOf(&quot;&quot;), &quot;String&quot;).x
	assertEqual(typeOf(&quot;1&quot;), &quot;String&quot;).x
	
	assertEqual(typeOf(3.14), &quot;Double&quot;).x

	assertEqual(typeOf(Array()), &quot;Array&quot;).x

	assertEqual(typeOf(Empty), &quot;Empty&quot;).x
	assertEqual(typeOf(Nothing), &quot;Object&quot;).x

	Dim t1 As New TTest_NoTyName
	assertEqual(typeOf(t1), &quot;Object&quot;).x

	Dim t2 As New TTest_TyName
	t2.tyname = &quot;foobar&quot;
	assertEqual(typeOf(t2), &quot;Object/foobar&quot;).x
End Function
	
Function test_ctorOf()
	assertEqual(ctorOf(Nothing),	Empty).x
	assertEqual(ctorOf(Empty),		Empty).x
	assertEqual(ctorOf(True),		Empty).x
	assertEqual(ctorOf(False),		Empty).x
	assertEqual(ctorOf(&quot;&quot;),			Empty).x
	assertEqual(ctorOf(&quot;blah&quot;),		Empty).x
	assertEqual(ctorOf( 0),			Empty).x
	assertEqual(ctorOf( 1),			Empty).x
	assertEqual(ctorOf(-1),			Empty).x
	assertEqual(ctorOf(3.1415),		Empty).x
	
	Dim o As Object, act As Variant
	o = New TTest_Ctor
	o.ctor = Empty		: assertThrows(ctorOf, Array(o)).x
	o.ctor = Nothing	: assertThrows(ctorOf, Array(o)).x
	o.ctor = True		: assertThrows(ctorOf, Array(o)).x
	o.ctor = False		: assertThrows(ctorOf, Array(o)).x
	o.ctor = &quot;&quot;			: assertThrows(ctorOf, Array(o)).x
	o.ctor = &quot;foo&quot;		: assertThrows(ctorOf, Array(o)).x
	o.ctor =  0			: assertThrows(ctorOf, Array(o)).x
	o.ctor =  1			: assertThrows(ctorOf, Array(o)).x
	o.ctor = -1			: assertThrows(ctorOf, Array(o)).x
	o.ctor = 3.1415		: assertThrows(ctorOf, Array(o)).x
	o.ctor = Array()	: assertThrows(ctorOf, Array(o)).x
	
	o.ctor = New TTest_TyName
	assertThrows(ctorOf, Array(o)).x
	o.ctor.tyname = &quot;foo&quot;
	assertThrows(ctorOf, Array(o)).x
	
	o.ctor = Fn.cons
	act = ctorOf(o)
	assertEqual(isFn(act), True).x
	assertEqual(getFnName(act), getFnName(Fn.cons)).x
	assertEqual(arity(act), arity(Fn.cons)).x
End Function

Function test_concat()
	assertEqual(concat(&quot;&quot;, &quot;&quot;), &quot;&quot;).x
	assertEqual(concat(&quot;a&quot;, &quot;&quot;), &quot;a&quot;).x
	assertEqual(concat(&quot;a&quot;, &quot;b&quot;), &quot;ab&quot;).x
	assertEqual(concat(&quot;a&quot;, &quot;bc&quot;), &quot;abc&quot;).x
	assertEqual(concat(&quot;ab&quot;, &quot;c&quot;), &quot;abc&quot;).x
	
	assertEqual(arity(Fn.concat), 2).x	&apos; from Fn object
	assertEqual(arity(concat), 	  2).x	&apos; from 0-arg call

	assertEqual(apply(concat, &quot;&quot;, &quot;&quot;), &quot;&quot;).x
	assertEqual(apply(concat, &quot;a&quot;, &quot;&quot;), &quot;a&quot;).x
	assertEqual(apply(concat, &quot;a&quot;, &quot;b&quot;), &quot;ab&quot;).x
	assertEqual(apply(concat, &quot;a&quot;, &quot;bc&quot;), &quot;abc&quot;).x
	assertEqual(apply(concat, &quot;ab&quot;, &quot;c&quot;), &quot;abc&quot;).x
End Function


Function test_isString()
	assertEqual(isString(&quot;&quot;),                  True).x
	assertEqual(isString(&quot;a&quot;),                 True).x
	assertEqual(isString(&quot;foobar&quot;),            True).x
	assertEqual(isString(Nothing),            False).x
	assertEqual(isString(Empty),              False).x
	assertEqual(isString(True),               False).x
	assertEqual(isString(False),              False).x
	assertEqual(isString(0),                  False).x
	assertEqual(isString(1),                  False).x
	assertEqual(isString(3.14),               False).x
	assertEqual(isString(Array()),            False).x
	assertEqual(isString(Array(42)),          False).x
	assertEqual(isString(Array(42)),          False).x
	assertEqual(isString(&quot;0&quot;),                 True).x
	assertEqual(isString(&quot;1&quot;),                 True).x
	assertEqual(isString(&quot;3.14&quot;),              True).x
	
	assertEqual(arity(Fn.isString),	1).x &apos; from Fn object
	assertEqual(arity(isString),	1).x &apos; from 0-arg call
	
	assertEqual(apply(isString, &quot;&quot;),         True).x
	assertEqual(apply(isString, &quot;a&quot;),        True).x
	assertEqual(apply(isString, &quot;foobar&quot;),   True).x
	assertEqual(apply(isString, Nothing),   False).x
	assertEqual(apply(isString, Empty),     False).x
	assertEqual(apply(isString, True),      False).x
	assertEqual(apply(isString, False),     False).x
	assertEqual(apply(isString, 0),         False).x
	assertEqual(apply(isString, 1),         False).x
	assertEqual(apply(isString, 3.14),      False).x
	assertEqual(apply(isString, Array()),   False).x
	assertEqual(apply(isString, Array(42)), False).x
	assertEqual(apply(isString, Array(42)), False).x
	assertEqual(apply(isString, &quot;0&quot;),        True).x
	assertEqual(apply(isString, &quot;1&quot;),        True).x
	assertEqual(apply(isString, &quot;3.14&quot;),     True).x
End Function

Function test_toString()
	assertEqual(toString(&quot;&quot;),               &quot;&apos;&apos;&quot;).x
	assertEqual(toString(&quot; &quot;),              &quot;&apos; &apos;&quot;).x
	assertEqual(toString(&quot;abc&quot;),            &quot;&apos;abc&apos;&quot;).x
	assertEqual(toString(0),                &quot;0&quot;).x
	assertEqual(toString(&quot;0&quot;),              &quot;&apos;0&apos;&quot;).x
	assertEqual(toString(1),                &quot;1&quot;).x
	assertEqual(toString(&quot;1&quot;),              &quot;&apos;1&apos;&quot;).x
	assertEqual(toString(&quot; 1&quot;),             &quot;&apos; 1&apos;&quot;).x
	assertEqual(toString(&quot;01&quot;),             &quot;&apos;01&apos;&quot;).x
	assertEqual(toString(01),               &quot;1&quot;).x
	assertEqual(toString(CR),             	&quot;&apos;\r&apos;&quot;).x
	assertEqual(toString(LF),             	&quot;&apos;\n&apos;&quot;).x
	assertEqual(toString(TAB),             	&quot;&apos;\t&apos;&quot;).x
	assertEqual(toString(TAB &amp; &quot;x&quot;),       	&quot;&apos;\tx&apos;&quot;).x
	assertEqual(toString(&quot;x&quot; &amp; TAB),       	&quot;&apos;x\t&apos;&quot;).x
	assertEqual(toString(&quot;x&quot; &amp; CR),       	&quot;&apos;x\r&apos;&quot;).x
	assertEqual(toString(&quot;x&quot; &amp; LF),       	&quot;&apos;x\n&apos;&quot;).x
	assertEqual(toString(&quot;x&quot; &amp; TAB &amp; &quot;y&quot;), 	&quot;&apos;x\ty&apos;&quot;).x
	assertEqual(toString(&quot;x&quot; &amp; CR &amp; &quot;y&quot;), 	&quot;&apos;x\ry&apos;&quot;).x
	assertEqual(toString(&quot;x&quot; &amp; LF &amp; &quot;y&quot;), 	&quot;&apos;x\ny&apos;&quot;).x
	assertEqual(toString(TAB &amp; CR &amp; &quot;y&quot;), 	&quot;&apos;\t\ry&apos;&quot;).x
	assertEqual(toString(TAB &amp; LF &amp; &quot;y&quot;), 	&quot;&apos;\t\ny&apos;&quot;).x

	assertEqual(toString(&quot;\&quot;),              &quot;&apos;\\&apos;&quot;).x
	assertEqual(toString(&quot; \&quot;),             &quot;&apos; \\&apos;&quot;).x
	assertEqual(toString(&quot;\ &quot;),             &quot;&apos;\\ &apos;&quot;).x
	assertEqual(toString(&quot; \ &quot;),            &quot;&apos; \\ &apos;&quot;).x

	assertEqual(toString(DQ),               &quot;&apos;\&quot; &amp; DQ &amp; &quot;&apos;&quot;).x
	assertEqual(toString(&quot; &quot; &amp; DQ),         &quot;&apos; \&quot; &amp; DQ &amp; &quot;&apos;&quot;).x
	assertEqual(toString(DQ &amp; &quot; &quot;),			&quot;&apos;\&quot; &amp; DQ &amp; &quot; &apos;&quot;).x
	assertEqual(toString(&quot; &quot; &amp; DQ &amp; &quot; &quot;),   &quot;&apos; \&quot; &amp; DQ &amp; &quot; &apos;&quot;).x

	Dim aLong As Long
	aLong = 0
	assertEqual(toString(aLong), 	 &quot;0&quot;).x
	assertEqual(toString(aLong + 1), &quot;1&quot;).x

	assertEqual(toString(Nothing), &quot;Nothing&quot;).x
	assertEqual(toString(Empty), &quot;Empty&quot;).x

	Dim t1 As New TTest_NoTyName
	assertEqual(toString(t1), &quot;Object(...)&quot;).x

	Dim t2 As New TTest_TyName
	assertEqual(toString(t2), &quot;Object(tyname=&apos;&apos;)&quot;).x
	t2.tyname = &quot;foobar&quot;
	&apos;assertThrows(&quot;toString&quot;, Array(t2)).x
	assertEqual(toString(t2), &quot;foobar(...)&quot;).x
End Function

Function test_id()
	assertEqual(arity(Fn.id), 1).x
	assertEqual(arity(id), 1).x

	assertEqual(id(Empty), Empty).x
	assertEqual(id(Nothing), Nothing).x
	
	assertEqual(id(0), 0).x
	assertEqual(id(1), 1).x
	assertEqual(id(-2), -2).x
	assertEqual(id(&quot;a&quot;), &quot;a&quot;).x
	assertEqual(id(&quot;b&quot;), &quot;b&quot;).x
End Function

Function test_fstArg()
	assertEqual(arity(Fn.fstArg), 2).x

	assertEqual(fstArg(1, 2), 1).x
	assertEqual(fstArg(2, 1), 2).x
	assertEqual(fstArg(&quot;a&quot;, &quot;b&quot;), &quot;a&quot;).x
	assertEqual(fstArg(&quot;b&quot;, &quot;a&quot;), &quot;b&quot;).x
End Function

Function test_sndArg()
	&apos;assertEqual(arity(Fn.sndArg), 2).x	&apos; well, not so sure...

	assertEqual(sndArg(1, 2), 2).x
	assertEqual(sndArg(2, 1), 1).x
	assertEqual(sndArg(&quot;a&quot;, &quot;b&quot;), &quot;b&quot;).x
	assertEqual(sndArg(&quot;b&quot;, &quot;a&quot;), &quot;a&quot;).x
End Function

Function test_swap()
	assertEqual(arity(Fn.swap), 3).x

	assertEqual(swap(Fn.fstArg, 1, 2), 2).x
	assertEqual(swap(Fn.sndArg, 1, 2), 1).x

	assertEqual(swap(Fn.fstArg, 1, 2), 2).x
	assertEqual(swap(Fn.sndArg, 1, 2), 1).x

	Dim f As Variant &apos; test partial application
	
	f = swap
	assertEqual(arity(f), 3).x
	assertEqual(apply(f, Fn.fstArg, 1, 2), 2).x
	assertEqual(apply(f, Fn.sndArg, 1, 2), 1).x

	assertEqual(apply(f, Fn.fstArg, 1, 2), 2).x
	assertEqual(apply(f, Fn.sndArg, 1, 2), 1).x
	
	&apos; partially applied to 1 arg:
	f = swap(Fn.fstArg)
	assertEqual(arity(f), 2).x
	assertEqual(apply(f, 1, 2), 2).x
	
	f = swap(Fn.sndArg)
	assertEqual(arity(f), 2).x
	assertEqual(apply(f, 1, 2), 1).x
	
	&apos; partially applied to 2 args:
	f = swap(Fn.fstArg, 1)
	assertEqual(arity(f), 1).x
	assertEqual(apply(f, 2), 2).x
		
	f = swap(Fn.sndArg, 1)
	assertEqual(arity(f), 1).x
	assertEqual(apply(f, 2), 1).x
End Function

Function test_add()
	assertEqual(typeOf(add( 0,  0)),  &quot;Long&quot;).x
	assertEqual(add( 0,  0),  0).x
	assertEqual(add( 0,  1),  1).x
	assertEqual(add( 1,  1),  2).x
	assertEqual(add( 1,  1),  2).x
	assertEqual(add( 1, -1),  0).x
	assertEqual(add(-1, -1), -2).x
	assertEqual(add( 2,  2),  4).x
	
	assertEqual(add(42, 4711), 		42 + 4711).x
	assertEqual(add(65535, 65535), 	CLng(65535 * 2)).x	&apos; not limited to 16 bit

	Dim f As Object
	Set f = add
	assertEqual(arity(f), 2).x
	Set f = add(1)
	assertEqual(arity(f), 1).x
	assertEqual(apply(f,  0),  1).x
	assertEqual(apply(f,  1),  2).x
	assertEqual(apply(f,  2),  3).x
	assertEqual(apply(f, -2), -1).x	
End Function

Function test_mul()
	assertEqual(mul( 0,  0),  0).x
	assertEqual(mul( 0,  1),  0).x
	assertEqual(mul( 1,  1),  1).x
	assertEqual(mul( 1, -1), -1).x
	assertEqual(mul(-1, -1),  1).x
	assertEqual(mul( 2,  2),  4).x
	
	assertEqual(mul(42, 4711),		CLng(42 * 4711)).x
	assertEqual(mul(65535, 32767),  CLng(65535 * 32767)).x	&apos; not limited to 16 bit
End Function

Function assert_compose_equals(f As Object, g As Object, x As Object)
	assert_compose_equals = assertEqual(toString(compose(f, g)), toString(x))
End Function

Function assert_compApp_equals( _
	f As Object, _
	g As Object, _
	v As Variant, _
	x As Variant _
)
	assert_compApp_equals = assert_toString_equals( _
		apply(compose(f, g), v), _
		x)
End Function

Function test_compose()
	assertEqual(arity(Fn.compose),	3).x
	assertEqual(arity(compose), 	3).x

	Dim f As Variant, g As Variant, h As Variant, x As Variant
	
	f = compose
	assertEqual(isFn(f), True).x
	assertEqual(arity(f), 3).x
	
	f = compose(compose, compose)
	assertEqual(isFn(f), True).x
	assertEqual(arity(f), 1).x

	f = compose(fstArg(5), fstArg(7))
	assertEqual(isFn(f), True).x
	assertEqual(arity(f), 1).x
	assertEqual(apply(f, 42), 5).x
	
	assertEqual(compose(id, id, &quot;asdf&quot;), &quot;asdf&quot;).x

	assertThrows(&quot;compose&quot;, Array(&quot;i-dont-exist&quot;, id, 42)).x
	assertThrows(&quot;compose&quot;, Array(Nothing, 		  id, 42)).x
	assertThrows(&quot;compose&quot;, Array(Empty, 		  id, 42)).x
	assertThrows(&quot;compose&quot;, Array(4711, 		  id, 42)).x
	
	&apos;&apos;assertThrows doesn&apos;t really work with partial app
	&apos;&apos;that is because it uses applyToList, which doesn&apos;t do
	&apos;&apos;an actual call until more args come in
	&apos;assertThrows(&quot;compose&quot;, Array(Nothing, Fn.id)).x	
	&apos;assertThrows(&quot;compose&quot;, Array(&quot;i-dont-exist&quot;)).x

	assertThrows(&quot;compose&quot;, Array(id, &quot;i-dont-exist&quot;, 42)).x
	assertThrows(&quot;compose&quot;, Array(id, Nothing, 		  42)).x
	assertThrows(&quot;compose&quot;, Array(id, Empty, 		  42)).x
	assertThrows(&quot;compose&quot;, Array(id, 4711, 		  42)).x
	&apos;&apos;assertThrows doesn&apos;t really work with partial app
	&apos;assertThrows(&quot;compose&quot;, Array(id, &quot;i-dont-exist&quot;)).x

	assertThrows(&quot;compose&quot;, Array(&quot;i-dont-exist&quot;, &quot;i-dont-exist-either&quot;, 42)).x
	&apos;&apos;assertThrows doesn&apos;t really work with partial app
	&apos;assertThrows(&quot;compose&quot;, Array(&quot;i-dont-exist&quot;, &quot;i-dont-exist-either&quot;)).x

	test_compose_left_id()   &apos; not passing when delaying until 3rd arg
	test_compose_right_id()  &apos; not passing when delaying until 3rd arg
	test_compose_left_K()
	test_compose_left_K_v()  &apos; not passing when delaying until 3rd arg
	
	
	g = fstArg  &apos; again not too special: f ° K = \x.f (K x)
	&apos; so we&apos;ll do the partial app in a first step but also
	&apos; test what the result of that behaves like
	&apos;--------------------------------------------------------------
	&apos;f = fstArg    &apos; f ° g = K ° K; covered by test_compose_left_K
	&apos;f = fstArg(3) &apos; f ° g = (K 3) ° K; covered by test_compose_left_K_v
	&apos;f = add       &apos; f ° g = add ° K = \x.add (K x) - wouldn&apos;t type check
	f = sndArg     &apos; f ° g = sndArg ° K = \x.sndArg (K x)
	&apos;                      = \x.id = sndArg
	assert_toString_equals( _
		apply(compose(f, g), &quot;foo&quot;, &quot;bar&quot;), _
		&quot;bar&quot; _
	)
	&apos; stronger assertion (ie sndArg actually simplifies partial app):
	assert_compApp_equals(f, g, &quot;foo&quot;, id).x
	&apos; even stronger assertion: simplification already done in compose:
	assert_compose_equals(f, g, sndArg).x	
	
	f = add(7)
	g = mul(11)
	h = add(5)
	&apos; fn composition is both, left and right associative, 
	&apos; ie it doesn&apos;t really matter.
	&apos; Note: the following assertion might pass because 
	&apos;       of two independent reasons:
	&apos;       a) string repr: passes if parentheses are omitted there
	&apos;       b) partial app repr: passes if that is canonicalized
	assert_compose_equals(compose(f, g), h, compose(f, compose(g, h))).x 
	x = compose(compose(f, g), h)
	assertEqual(arity(x), 1).x
	assertEqual(isPartialApp(x), True).x
	&apos; We want fn composition to be represented as right-associative
	&apos; (right-leaning tree, ie. left arg is never a composition)
	assert_toString_equals(cadr(partialArgs(x)), f).x
	assert_toString_equals(car(partialArgs(x)), compose(g, h)).x
End Function	
	
Function test_compose_left_id()
	Dim f As Object, g As Object
	f = id  &apos; I ° g = \x.I (g x) = \x.g x = g
	&apos;----------------------------------------
	g = id						: assert_compose_equals(f, g, g).x
	g = fstArg					: assert_compose_equals(f, g, g).x
	g = fstArg(5)				: assert_compose_equals(f, g, g).x
	g = add						: assert_compose_equals(f, g, g).x
	g = add(7)					: assert_compose_equals(f, g, g).x
	g = mul						: assert_compose_equals(f, g, g).x
	g = mul(11)					: assert_compose_equals(f, g, g).x
	g = compose					: assert_compose_equals(f, g, g).x
	g = compose(add)			: assert_compose_equals(f, g, g).x
	g = compose(mul)			: assert_compose_equals(f, g, g).x
	g = compose(add(7), mul(11)): assert_compose_equals(f, g, g).x
	g = compose(mul(11), add(7)): assert_compose_equals(f, g, g).x
End Function

Function test_compose_right_id()
	Dim f As Object, g As Object
	g = id  &apos; f ° I = \x.f (I x) = \x.f x = f
	&apos;----------------------------------------
	f = fstArg					: assert_compose_equals(f, g, f).x
	f = fstArg(5)				: assert_compose_equals(f, g, f).x
	f = add						: assert_compose_equals(f, g, f).x
	f = add(7)					: assert_compose_equals(f, g, f).x
	f = mul						: assert_compose_equals(f, g, f).x
	f = mul(11)					: assert_compose_equals(f, g, f).x
	f = compose					: assert_compose_equals(f, g, f).x
	f = compose(add)			: assert_compose_equals(f, g, f).x
	f = compose(mul)			: assert_compose_equals(f, g, f).x
	f = compose(add(7), mul(11)): assert_compose_equals(f, g, f).x
	f = compose(mul(11), add(7)): assert_compose_equals(f, g, f).x
End Function

Function test_compose_left_K()	
	Dim f As Object, g As Object
	f = fstArg	&apos; nothing too special here: K ° g = \x.K (g x) = \x _.g x
	&apos; so we&apos;ll do the partial app in a first step but also
	&apos; test what the result of that behaves like
	&apos;----------------------------------------------------------------
	g = fstArg &apos; f ° g = K ° K, so (K ° K) x = K (K x)
	assert_compApp_equals(f, g, &quot;foo&quot;, fstArg(fstArg(&quot;foo&quot;))).x
	g = fstArg(5) &apos; so (K ° (K 5)) x = K (K 5 x) = K 5 = g
	assert_compApp_equals(f, g, &quot;foo&quot;, g).x
	g = add &apos; f ° g = K ° add, so (K ° add) x = K (add x)
	assert_compApp_equals(f, g, 5, fstArg(add(5))).x
	g = add(7) &apos; f ° g = K ° (add 7), so (K ° (add 7)) x = K (add 7 x)
	assert_compApp_equals(f, g, 5, fstArg(5 + 7)).x
	g = mul &apos; f ° g = K ° mul, so (K ° mul) x = K (mul x)
	assert_compApp_equals(f, g, 5, fstArg(mul(5))).x
	g = mul(11) &apos; f ° g = K ° (mul 11), so (K ° (mul 11)) x = K (mul 11 x)
	assert_compApp_equals(f, g, 5, fstArg(5 * 11)).x
	g = compose &apos; f ° g = K ° B, so (K ° B) h = K (B h)
	assert_compApp_equals(f, g, isString, fstArg(compose(isString))).x
	g = compose(add) &apos; f ° g = K ° (B add), 
					 &apos; so (K ° (B add)) h = K (add ° h)
	&apos; Note: we only assert *same behaviour* of
	&apos; K ° (B add)  and  \h.K (add ° h)
	assert_compApp_equals(f, g, mul, fstArg(compose(add, mul))).x
	g = compose(add(7)) &apos; f ° g = K ° (B (add 7)), 
						&apos; so (K ° (B (add 7))) h = K ((add 7) ° h)
	assert_compApp_equals(f, g, mul, fstArg(compose(add(7), mul))).x
	assert_compApp_equals(f, g, mul(11), fstArg(compose(add(7), mul(11)))).x
	g = compose(add(7), mul(11)) &apos; f ° g = K ° ((add 7) ° (mul 11)), 
	&apos; so K ° ((add 7) ° (mul 11)) x = K ((add 7) ((mul 11) x))
	&apos;                               = K (7 + (11 * x))
	assert_compApp_equals(f, g, 3, fstArg(7 + (11 * 3))).x
	g = compose(mul(11), add(7)) &apos; f ° g = K ° ((mul 11) ° (add 7)), 
	&apos; so K ° ((mul 11) ° (add 7)) x = K ((mul 11) ((add 7) x))
	&apos;                               = K (11 * (7 * x))
	assert_compApp_equals(f, g, 3, fstArg(11 * (7 + 3))).x
End Function

Function test_compose_left_K_v()
	Dim f As Object, g As Object	
	f = fstArg(5)  &apos; (K v) ° g = \x.(\_.v) (g x) = \x.v = (K v) = f
	&apos;--------------------------------------------------------------
	g = fstArg					: assert_compose_equals(f, g, f).x
	g = fstArg(3)				: assert_compose_equals(f, g, f).x
	g = add						: assert_compose_equals(f, g, f).x
	g = add(7)					: assert_compose_equals(f, g, f).x
	g = mul						: assert_compose_equals(f, g, f).x
	g = mul(11)					: assert_compose_equals(f, g, f).x
	g = compose					: assert_compose_equals(f, g, f).x
	g = compose(add)			: assert_compose_equals(f, g, f).x
	g = compose(add(7))			: assert_compose_equals(f, g, f).x
	g = compose(mul)			: assert_compose_equals(f, g, f).x
	g = compose(mul(11))		: assert_compose_equals(f, g, f).x
	g = compose(add(7), mul(11)): assert_compose_equals(f, g, f).x
	g = compose(mul(11), add(7)): assert_compose_equals(f, g, f).x
End Function


Function test_inRange()
	dim actual as Boolean
	assertEqual(inRange(48, 57, 47), False).x
	assertEqual(inRange(48, 57, 48), True).x
	assertEqual(inRange(48, 57, 55), True).x
	assertEqual(inRange(48, 57, 57), True).x
	assertEqual(inRange(48, 57, 58), False).x
End Function

Function test_equ()
	assertThrows(&quot;equ&quot;, Array(0, &quot;one&quot;)).x
	
	assertEqual(equ(0, 0), True).x
	assertEqual(equ(0, 1), False).x
	assertEqual(equ(1, 0), False).x
	
	assertEqual(equ(&quot;a&quot;, &quot;a&quot;), True).x
	assertEqual(equ(&quot;a&quot;, &quot;b&quot;), False).x
	assertEqual(equ(&quot;b&quot;, &quot;a&quot;), False).x
	assertEqual(equ(&quot;x&quot;, &quot;xx&quot;), False).x
	assertEqual(equ(&quot;xx&quot;, &quot;x&quot;), False).x
	assertEqual(equ(&quot;xx&quot;, &quot;xx&quot;), True).x
	assertEqual(equ(&quot; xx&quot;, &quot;xx&quot;), False).x
	
	assertEqual(equ(Nothing, Nothing), True).x
	
	Dim vEmpty          As Variant
	assertEqual(typeOf(vEmpty), &quot;Empty&quot;).x
	
	Dim vNothing		As Variant
	vNothing = Nothing
	assertEqual(typeOf(vNothing), &quot;Object&quot;).x
		
	Dim oNothing        As Object
	assertEqual(typeOf(oNothing), &quot;Object&quot;).x
	
	Dim oUninitTyName   As Object
	Set oUninitTyName = New TTest_Tyname
	assertEqual(typeOf(oUninitTyName), &quot;Object/&quot;).x
	
	Dim vUninitTyName As Variant
	vUninitTyName = oUninitTyName
	assertEqual(typeOf(vUninitTyName), &quot;Object/&quot;).x
	
	Dim oInitTyName     As Object
	Set oInitTyName = New TTest_Tyname
	oInitTyName.tyname = &quot;foobar&quot;
	assertEqual(typeOf(oInitTyName), &quot;Object/foobar&quot;).x

	Dim vInitTyName As Variant
	vInitTyName = oInitTyName
	assertEqual(typeOf(vInitTyName), &quot;Object/foobar&quot;).x
	
	Dim oUninitNoTyName As Object
	oUninitNoTyName = New TTest_NoTyname
	assertEqual(typeOf(oUninitNoTyName), &quot;Object&quot;).x

	Dim vUninitNoTyName As Variant
	vUninitNoTyName = oUninitNoTyName
	assertEqual(typeOf(vUninitNoTyName), &quot;Object&quot;).x
	
	&apos; Empty is comparable to anything:
	assertEqual(equ(Empty, Empty),		True).x
	assertEqual(equ(Empty, Nothing),	False).x
	assertEqual(equ(Nothing, Empty),	False).x
	assertEqual(equ(Empty, True),		False).x
	assertEqual(equ(True, Empty),		False).x
	assertEqual(equ(Empty, False),		False).x
	assertEqual(equ(False, Empty),		False).x
	assertEqual(equ(Empty, &quot;&quot;),			False).x
	assertEqual(equ(&quot;&quot;, Empty),			False).x
	assertEqual(equ(Empty, &quot;a&quot;),		False).x
	assertEqual(equ(&quot;a&quot;, Empty),		False).x
	assertEqual(equ(Empty, &quot;foo&quot;),		False).x
	assertEqual(equ(&quot;foo&quot;, Empty),		False).x
	assertEqual(equ(Empty, 0),			False).x
	assertEqual(equ(0, Empty),			False).x
	assertEqual(equ(Empty, 1),			False).x
	assertEqual(equ(1, Empty),			False).x
	assertEqual(equ(Empty, -1),			False).x
	assertEqual(equ(-1, Empty),			False).x
	assertEqual(equ(Empty, 2),			False).x
	assertEqual(equ(2, Empty),			False).x
	assertEqual(equ(Empty, -2),			False).x
	assertEqual(equ(-2, Empty),			False).x
	assertEqual(equ(Empty, 3.1415),		False).x
	assertEqual(equ(3.1415, Empty),		False).x

	assertEqual(equ(vEmpty, oNothing),		False).x
	assertEqual(equ(oNothing, vEmpty),		False).x
	assertEqual(equ(vEmpty, oUninitTyName),	False).x
	assertEqual(equ(oUninitTyName, vEmpty),	False).x
	assertEqual(equ(vEmpty, vUninitTyName),	False).x
	assertEqual(equ(vUninitTyName, vEmpty),	False).x
	assertEqual(equ(vEmpty, oUninitTyName),	False).x
	assertEqual(equ(oUninitTyName, vEmpty),	False).x
	

	assertEqual(equ(vEmpty, nil),			False).x
	assertEqual(equ(nil, vEmpty),			False).x
	assertEqual(equ(vEmpty, List(nil)),		False).x
	assertEqual(equ(List(nil), vEmpty),		False).x
	assertEqual(equ(vEmpty, List(1)),		False).x
	assertEqual(equ(List(1), vEmpty),		False).x
	assertEqual(equ(vEmpty, List(1, &quot;a&quot;)),	False).x
	assertEqual(equ(List(1, &quot;a&quot;), vEmpty),	False).x
	
	&apos;---------------
	
	assertThrows(&quot;equ&quot;, Array(vUninitTyName, oUninitTyName)).x	&apos; cannot compare uninitialized instances of type Object/

	assertThrows(&quot;equ&quot;, Array(vUninitTyName, oInitTyName)).x	&apos; missing fn &quot;foobar_equ&quot;
	
	assertThrows(&quot;equ&quot;, Array(Array(), Array())).x	&apos; NYI
	
	assertEqual(equ(Nothing,		oNothing), 		True ).x
	assertEqual(equ(oNothing,		Nothing), 		True ).x
	assertEqual(equ(Nothing,		oUninitTyName), False).x
	assertEqual(equ(oUninitTyName,	Nothing),		False).x
	assertEqual(equ(Nothing,		oInitTyName),	False).x
	assertEqual(equ(oInitTyName,	Nothing),		False).x

	assertThrows(&quot;equ&quot;, Array(vUninitNoTyName, oUninitNoTyName)).x	&apos; cannot compare values of underspecified type Object
	assertThrows(&quot;equ&quot;, Array(oUninitNoTyName, vUninitNoTyName)).x	&apos; cannot compare values of underspecified type Object

	assertThrows(&quot;equ&quot;, Array(nil, oUninitNoTyName)).x	&apos; incompatible types Object/TList and Object
End Function

Function test_readHex()
	assertEqual(arityF(&quot;readHex&quot;), 1).x
	
	assertEqual(readHex( &quot;0&quot;),    0).x
	assertEqual(readHex( &quot;1&quot;),    1).x
	assertEqual(readHex( &quot;2&quot;),    2).x
	assertEqual(readHex( &quot;3&quot;),    3).x
	assertEqual(readHex( &quot;4&quot;),    4).x
	assertEqual(readHex( &quot;5&quot;),    5).x
	assertEqual(readHex( &quot;6&quot;),    6).x
	assertEqual(readHex( &quot;7&quot;),    7).x
	assertEqual(readHex( &quot;8&quot;),    8).x
	assertEqual(readHex( &quot;9&quot;),    9).x
	assertEqual(readHex( &quot;a&quot;),   10).x
	assertEqual(readHex( &quot;A&quot;),   10).x
	assertEqual(readHex( &quot;b&quot;),   11).x
	assertEqual(readHex( &quot;B&quot;),   11).x
	assertEqual(readHex( &quot;c&quot;),   12).x
	assertEqual(readHex( &quot;C&quot;),   12).x
	assertEqual(readHex( &quot;d&quot;),   13).x
	assertEqual(readHex( &quot;D&quot;),   13).x
	assertEqual(readHex( &quot;e&quot;),   14).x
	assertEqual(readHex( &quot;E&quot;),   14).x
	assertEqual(readHex( &quot;f&quot;),   15).x
	assertEqual(readHex( &quot;F&quot;),   15).x

	assertEqual(readHex( &quot;1F&quot;),  31).x
	assertEqual(readHex( &quot;1f&quot;),  31).x
	assertEqual(readHex( &quot;ff&quot;), 255).x
	assertEqual(readHex( &quot;Ff&quot;), 255).x
	
	Dim aLong As Long
	&apos;31 bit
	aLong = 212855723
	assertEqual(typeOf(readHex( &quot;CAFEBAB&quot;)), typeOf(aLong)).x
	assertEqual(readHex( &quot;CAFEBAB&quot;), aLong).x
	aLong = 233495534
	assertEqual(readHex( &quot;deadbee&quot;), aLong).x
	
&apos;	&apos;32 bit
&apos;	assertEqual(readHex( &quot;CAFEBABE&quot;), 3405691582).x
&apos;	assertEqual(readHex( &quot;deadbeef&quot;), 3735928559).x

	assertThrows(&quot;readHex&quot;, Array(3)).x
	assertThrows(&quot;readHex&quot;, Array(&quot;&quot;)).x
	assertThrows(&quot;readHex&quot;, Array(&quot; &quot;)).x
	assertThrows(&quot;readHex&quot;, Array(&quot;g&quot;)).x
	assertThrows(&quot;readHex&quot;, Array(&quot;G&quot;)).x
	assertThrows(&quot;readHex&quot;, Array(&quot;z&quot;)).x
	assertThrows(&quot;readHex&quot;, Array(&quot;Z&quot;)).x

	assertThrows(&quot;readHex&quot;, Array(&quot;014Z&quot;)).x
End Function

</script:module>