<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M12_Type" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit
		
Type DataValue
	id		As Long
	str		As String	&apos; debugger shows that in inspector
	ctor	As Object
	fields	As Variant Array
	x		As Variant
End Type

Type Tp
	TDataTypeCtor	As Object
	DataTypeCtor	As Object
	
	TDataCtor		As Object
	DataCtor		As Object
	
	List			As Object
	List_Nil		As Object
	List_Cons		As Object
	
	TNative			As Object
	Native			As Object
	
	TType			As Object
	TType_Param		As Object
	TType_App		As Object
	
	Native_Boolean	As Object
	Native_Byte		As Object
	Native_Integer	As Object
	Native_Long		As Object
	Native_Single	As Object
	Native_Double	As Object
	Native_String	As Object
	
	Native_Empty	As Object
	Native_Object	As Object
	Native_Date		As Object
	Native_Array	As Object
	Native_Variant	As Object
End Type


Const DataCtor_name     = 0
Const DataCtor_argTypes = 1
Const DataCtor_typeCtor = 2


Const DataTypeCtor_name  	 = 0
Const DataTypeCtor_arity 	 = 1
Const DataTypeCtor_dataCtors = 2

Const Ntv_shortName = 0
Const Ntv_typeName  = 1
Const Ntv_varType   = 2

Sub Main
	[test_Type======================================]()
End Sub

Function _DataTypeCtor_name(x)
	_DataTypeCtor_name = _destructure(Tp.DataTypeCtor, 0, x)
End Function

Function _DataTypeCtor_arity(x)
	_DataTypeCtor_arity = _destructure(Tp.DataTypeCtor, 1, x)
End Function

Function _DataTypeCtor_dataCtors(x)
	_DataTypeCtor_dataCtors = _destructure(Tp.DataTypeCtor, 2, x)
End Function


Function _newDataValue(ctor As DataValue, ByRef args As Array)
	Static instanceCount As Long
	Dim out As New DataValue
	out.ctor   = ctor
	out.fields = args
	out.id	   = instanceCount
	instanceCount = instanceCount + 1
	_newDataValue = out
End Function

&apos; old stuff, to be replaced
Function _tyname(o As Object)
	_tyname = o.tyname
End Function

Function _id(o As Object)
	_id = o.id
End Function

Function _str(o As Object)
	_str = o.str
End Function

Function _ctor(o As Object)
	_ctor = o.ctor
End Function

Function _fields(o As Object)
	_fields = o.fields
End Function

Function _x(o As Object)
	_x = o.x
End Function

Function Tp() &apos; bootstrap TType and data types
	Static out As Object
	If isNull(out) Then
		out = New Tp
		
		Dim vNil, tcList, cNil
		vNil = _newDataValue(Nothing, emptyArray)
		tcList = _newDataValue(Nothing, Array(&quot;List&quot;, 1, vNil))
		out.List = tcList
		
		cNil = _newDataValue(Nothing, Array(&quot;Nil&quot;, vNil, tcList))
		cNil.x = vNil
		vNil.ctor = cNil
		out.List_Nil = cNil
		
		
		Dim tcDataCtor, cDataCtor
		tcDataCtor = _newDataValue(Nothing, Array( _
			&quot;TDataCtor&quot;, 0, vNil _
		)
		out.TDataCtor = tcDataCtor
		
		cDataCtor = _newDataValue(Nothing, Array( _
			&quot;DataCtor&quot;, vNil, tcDataCtor _
		))
		cDataCtor.ctor	= cDataCtor
		cNil.ctor		= cDataCtor
		out.DataCtor = cDataCtor
		
		Dim cCons
		cCons = _newDataValue(cDataCtor, Array( _
			&quot;Cons&quot;, vNil, tcList _
		))
		out.List_Cons = cCons
		
		out.List.str			= &quot;List&quot;
		out.List_Nil.str		= &quot;Nil :: List a0&quot;	&apos; singleton data ctor
		out.List_Nil.x.str		= &quot;[]&quot;	&apos; singleton value
		out.List_Cons.str		= &quot;Cons :: a0 -&gt; (List a0) -&gt; (List a0)&quot;


		tcList.fields(DataTypeCtor_dataCtors) = _
			_newDataValue(cCons, Array(cNil, _
			_newDataValue(cCons, Array(cCons, _
								 vNil _
		))))
		
		tcDataCtor.fields(DataTypeCtor_dataCtors) = _
			_newDataValue(cCons, Array(cDataCtor, _
								 vNil _
		))
		
		&apos; can use _mkDataCtor from now on
		
		Dim tcDataTypeCtor
		tcDataTypeCtor = _mkDataTypeCtor(&quot;TDataTypeCtor&quot;, 0)
		out.TDataTypeCtor = tcDataTypeCtor
		
		Dim cDataTypeCtor
		cDataTypeCtor = _mkDataCtor(tcDataTypeCtor, &quot;DataTypeCtor&quot;, vNil)
		tcDataTypeCtor.ctor = cDataTypeCtor
		tcDataCtor.ctor 	= cDataTypeCtor
		tcList.ctor			= cDataTypeCtor
		out.DataTypeCtor = cDataTypeCtor
		
		&apos; Now we need types to fix up the argTypes fields
		
		Dim tcNative
		tcNative =  _mkDataTypeCtor(&quot;TNative&quot;, 0)
		out.TNative = tcNative
		
		Dim cNtv &apos; data ctor of TNative for native types
				 &apos; later: its argTypes = [Native Str, Native Str, Native Int]
		cNtv = _mkDataCtor(tcNative, &quot;Native&quot;, vNil)
		out.Native = cNtv
		
		&apos; make Native instances:
		
		Dim nStr
		nStr = _newDataValue(cNtv, Array( _
			&quot;Str&quot;, TypeName(CStr(&quot;&quot;)), VarType(CStr(&quot;&quot;)) _
		)
		
		Dim nInt
		nInt = _newDataValue(cNtv, Array( _
			&quot;Int&quot;, TypeName(CInt(0)), VarType(CInt(0)) _
		)
		
		&apos; With nStr and nInt we can fix argTypes of cNtv:
		
		cNtv.fields(DataCtor_argTypes) = _
			_newDataValue(cCons, Array(nStr, _
			_newDataValue(cCons, Array(nStr, _
			_newDataValue(cCons, Array(nInt, _
								 vNil _
		))))))
		&apos; TODO: cNtv.x
		
		
		
		Dim tcType
		tcType = _mkDataTypeCtor(&quot;Type&quot;, 0)
		out.TType = tcType
				
		Dim cParam
		cParam = _mkDataCtor(tcType, &quot;Param&quot;, _
			_newDataValue(cCons, Array(nInt, _
								 vNil _
		)))
		out.TType_Param = cParam
		
		Dim cApp
		cApp = _mkDataCtor(tcType, &quot;App&quot;, _
			_newDataValue(cCons, Array(tcType, _
			_newDataValue(cCons, Array(tcType, _
								 vNil _
		)))))
		out.TType_App = cApp
		
		
		&apos; With cApp we can fix field argTypes of cons 
		&apos; so we can use list fns (can use convenience fns already)
		Dim a0 : a0 = TypeParam(0)
		cCons.fields(DataCtor_argTypes) =		_
			_newDataValue( cCons, Array(a0,	_
			_newDataValue( cCons, Array(TList(a0), _
			vNil _
		))))
		
		
		&apos; argTypes of DataTypeCtor
		cDataTypeCtor.fields(DataCtor_argTypes) = _
			List(nStr, nInt, TList(tcDataCtor))
		
		&apos; argTypes of DataCtor
		cDataCtor.fields(DataCtor_argTypes) = _
			List(nStr, TList(tcType), tcDataTypeCtor)
		
		
		out.TDataTypeCtor.str	= &quot;TDataTypeCtor&quot;
		out.DataTypeCtor.str	= &quot;DataTypeCtor :: Str -&gt; Int -&gt; (List TDataCtor) -&gt; TDataTypeCtor&quot;
		
		out.TDataCtor.str		= &quot;TDataCtor&quot;
		out.DataCtor.str		= &quot;DataCtor :: Str -&gt; (List Type) -&gt; TDataTypeCtor -&gt; TDataCtor&quot;

		out.TNative.str			= &quot;TNative&quot;
		out.Native.str			= &quot;Native&quot;

		out.TType.str			= &quot;Type&quot;
		out.TType_Param.str		= &quot;Param :: Int -&gt; Type&quot;
		out.TType_App.str		= &quot;App :: Type -&gt; Type -&gt; Type&quot;
		
		nStr.str 				= cNtv.str &amp; &quot;_Str&quot;
		nInt.str 				= cNtv.str &amp; &quot;_Int&quot;
		
		&apos; -- more BASIC types:
		out.Native_Boolean	= _mkNative(&quot;Bool&quot;,		CBool(0))
		out.Native_Byte		= _mkNative(&quot;Byte&quot;,		CByte(0))
		out.Native_Integer	= nInt		
		out.Native_Long 	= _mkNative(&quot;Long&quot;,		CLng(0))
		out.Native_Single	= _mkNative(&quot;Single&quot;,	CSng(0))
		out.Native_Double	= _mkNative(&quot;Double&quot;,	CDbl(0))
		out.Native_String 	= nStr
		out.Native_Object	= _mkNative(&quot;Obj&quot;,		Nothing)
		out.Native_Empty	= _mkNative(&quot;Empty&quot;,	Empty)
		out.Native_Array	= _mkNative(&quot;Array&quot;,	Array())
		out.Native_Date		= _mkNative(&quot;Date&quot;,		Date)
		Dim aVariant As Variant
		out.Native_Variant	= _mkNative(&quot;Variant&quot;,	aVariant)
						
	End If
	Tp = out
End Function

Function _mkNative(shortName As String, sampleValue As Variant)
	Dim out
	&apos; cannot use applyDC because it needs the native types
	If isArray(sampleValue) Then
		out = _newDataValue(Tp.Native, Array( _
			shortName, &quot;Array&quot;, VarType(sampleValue)))
	Else
		out = _newDataValue(Tp.Native, Array( _
			shortName, TypeName(sampleValue), VarType(sampleValue)))
	End If
	out.str = Tp.Native.str &amp; &quot;_&quot; &amp; shortName
	_mkNative = out
End Function

&apos; duck-type like test:
&apos; - does it have member .ctor of (BASIC) type Object?
&apos; - does it have member .fields of (BASIC) type Array?
Function isDataValue(x As Variant)
	Dim out
	out = False
	&apos; TODO: isDataValue: check isObject &amp; Not isNull first
	On Local Error Goto isDataValue_end
	If isObject(_ctor(x)) And isArray(_fields(x)) Then
		out = True
	End If
isDataValue_end:
	isDataValue = out
End Function



Function field(idx As Integer, v As DataValue)
	field = v.fields(idx)
End Function

Function fieldCount(v As DataValue)
	fieldCount = CInt(UBound(v.fields) + 1)
End Function


Function DataValue_same(a As DataValue, b As DataValue)
	DataValue_same = (a.id = b.id)
End Function


&apos;	assertEqual(VarType(Empty),		0).x
&apos;	&apos;assertEqual(VarType(?),		1).x	&apos; doc says &quot;Null&quot; (?!)
&apos;	assertEqual(VarType(CInt(0)),	2).x
&apos;	assertEqual(VarType(CLng(0)),	3).x
&apos;	assertEqual(VarType(CSng(0)),	4).x
&apos;	assertEqual(VarType(CDbl(0)),	5).x
&apos;	&apos;assertEqual(VarType(?),	6).x
&apos;	assertEqual(VarType(Date),		7).x
&apos;	assertEqual(VarType(&quot;string&quot;),	8).x
&apos;	assertEqual(VarType(Nothing),	9).x
&apos;	assertEqual(VarType(missing),	10).x
&apos;	assertEqual(VarType(True),		11).x
&apos;	&apos;assertEqual(VarType(?),		12).x	&apos; doc says &quot;Variant&quot;...
&apos;	&apos;assertEqual(VarType(Array()),	8204).x	&apos; let&apos;s treat it as random

Function typeOf(Optional x As Variant)
	Static oFn As Object &apos; init only when needed (Fn() requires List)
	Static cs As Variant, cDataCtor As Object
	&apos; ATTENTION: cByte, cInt, cLng, cSng, cDbl, cStr, cDate, cBool
	&apos;            are BASIC *keywords*! 
	Static _Byte, _Int, _Lng, _Sng, _Dbl, _Str, _Bool
	Static _Empty, _Obj, _Date, _Variant, _Array
	If isEmpty(cs) Then
		Dim cs(0 To 17)
		_Empty 	= Tp.Native_Empty	&apos; vt =  0
									&apos; vt =  1 ??? (&quot;Null&quot;)
		_Int 	= Tp.Native_Integer	&apos; vt =  2
		_Lng 	= Tp.Native_Long	&apos; vt =  3
		_Sng 	= Tp.Native_Single	&apos; vt =  4
		_Dbl 	= Tp.Native_Double	&apos; vt =  5
									&apos; vt =  6 ???
		_Date 	= Tp.Native_Date	&apos; vt =  7
		_Str 	= Tp.Native_String	&apos; vt =  8
		_Obj 	= Tp.Native_Object	&apos; vt =  9
									&apos; vt = 10 (isMissing = True)
		_Bool 	= Tp.Native_Boolean	&apos; vt = 11
		_Variant= Tp.Native_Variant	&apos; vt = 12 ??? (&quot;Variant&quot;)
		_Array 	= Tp.Native_Array	&apos; vt = &amp;H2000 + VarType(elem)
		_Byte	= Tp.Native_Byte	&apos; vt = 17
		
		cs( 0) = _Empty
		cs( 2) = _Int
		cs( 3) = _Lng
		cs( 4) = _Sng
		cs( 5) = _Dbl
		cs( 7) = _Date
		cs( 8) = _Str
		cs( 9) = _Obj
		cs(11) = _Bool
		cs(12) = _Variant
		cs(17) = _Byte
		
		cDataCtor = Tp.DataCtor
	End If
		
	Dim out As Variant, vt As Integer
	vt = VarType(x)
		
	On vt Goto _vtXX, _vtNN, _vtNN, _vtNN, _vtNN, _
			   _vtXX, _vtNN, _vtNN, _vt09, _vt10, _
			   _vtNN, _vtNN, _vtXX, _vtXX, _vtXX, _
			   _vtXX, _vtNN
	&apos; when we get here then vt = 0 or &gt;17
	If vt = 0 Then
		out = _Empty
		Goto _typeOf_end
	ElseIf isArray(x) Then
		out = _Array
		Goto _typeOf_end
	End If
_vt10: &apos; isMissing(x) = True
	If isNull(oFn) Then : oFn = Fn.typeOf :	End If
	out = oFn
	Goto _typeOf_end
_vtNN:
	out = cs(vt)
	Goto _typeOf_end
_vt09: &apos; isObject(x) = True
	out = _Obj
	On Local Error Goto _typeOf_end
	&apos; Does x have a .ctor member?
	Dim cx  : cx  = _ctor(x)  &apos; DON&apos;T dot-access members in here!
	&apos; But is it (cx) a TDataCtor?
	&apos; The field access may throw if cx ain&apos;t a TDataCtor...
	out = field(DataCtor_typeCtor, cx)
	&apos; But if it didn&apos;t we have to make sure that cx
	&apos; really was constructed by DataCtor:
	Dim ccx : ccx = _ctor(cx) &apos; .ctor of x&apos;s .ctor
	If DataValue_same(ccx, cDataCtor) Then
		Dim r As Integer, i As Integer
		r = field(DataTypeCtor_arity, out)
		&apos; TODO: typeOf - fully apply DataTypeCtor with arity &gt; 0?
		&apos;For i = 0 To r - 1
		&apos;	out = TypeApp(out, TypeParam(i))
		&apos;Next i
	Else
		out = _Obj
	End If
_typeOf_end:
	typeOf = out
	Exit Function
_vtXX: &apos; vt =1, =6, &gt;17 and not Array
	croak(&quot;typeOf: unsupported VarType = &quot; &amp; vt _
		&amp; NL &amp; &quot;TypeName: &apos;&quot; &amp; TypeName(x) &amp; &quot;&apos;&quot; _
	)
End Function


Function ctorOf(Optional x As Variant)
	Static oFn As Object &apos; init only when needed (Fn() requires List)
	Dim out : out = Empty
	If isMissing(x) Then
		out = Fn.ctorOf
	Else
		On Local Error Goto ctorOf_end
		out = _ctor(x) &apos; DON&apos;T dot-access members in here!
	End If
ctorOf_end:
	ctorOf = out
	Exit Function
End Function

Function isCtorOf(c As Object, v As Variant)
	Dim actC As Variant
	actC = ctorOf(v)
	isCtorOf = DataValue_same(actC, c)
End Function

Function ctorName(v As DataValue)
	Dim out
	out = v.ctor.fields(DataCtor_name)
	ctorName = out
End Function

Function typectorOf(c)
	&apos;require(hasType, c, TDataCtor)
	typeCtorOf = c.fields(DataCtor_typeCtor)
End Function

Function typeCtorName(c)
	&apos;require(hasType, c, TDataCtor)
	typeCtorName = field(DataTypeCtor_name, typectorOf(c))
End Function

&apos; --------------------------------------------------------------
	
Function _destructure(c As Object, i As Integer, Optional v As Variant)
	Dim out
	If isMissing(v) Then
		out = apply(Fn.destructure, c, i)
	Else
		On Local Error Goto _destructure_error
		If DataValue_same(_ctor(v), c) Then
			out = field(i, v)
		Else
_destructure_error:
			On Local Error Goto 0 &apos; disable error handler
			Dim cName : cName = field(DataCtor_name, c)
			Dim tExp : tExp = field(DataCtor_typeCtor, c)
			Dim r, k : r = field(DataTypeCtor_arity, tExp)
			For k = 0 To r - 1
				tExp = TypeApp(tExp, TypeParam(k))
			Next k
			Dim msg
			msg = &quot;destructure &quot; &amp; cName &amp; &quot; &quot; &amp; i &amp; &quot;: &quot;
			If hasType(v, tExp) Then
				&apos; wrong data ctor
				msg = msg &amp; &quot; wrong ctor &quot; &amp; ctorName(v)
			Else
				Dim tAct : tAct = typeOf(v)
				&apos; wrong type
				msg = msg &amp; &quot; expected a &quot; &amp; tExp.str &amp; &quot;, not a &quot; &amp; tAct.str
			End If
			croak(msg)
		End If
	End If
	_destructure = out
End Function







Function DataValue_genericToString(v As DataValue)
	Dim seen As String : seen = &quot;&quot;
	DataValue_genericToString = _DataValue_genericToString(v, 0, seen)
End Function

Function _DataValue_genericToString( _
	ByVal v 	 As DataValue, _
	ByVal indent As Integer, _
	ByRef seen 	 As String _
)
	Dim out
	Dim ctor   As Variant : ctor   = v.ctor
	Dim fields As Variant : fields = v.fields
	Dim cStr   As String
	Dim fStr   As String
	
	If inStr(seen, &quot; &quot; &amp; v.id) &lt;&gt; 0 Then
		out = &quot;{ id: &quot; &amp; v.id &amp; &quot; }&quot;
	Else
		seen = v.id &amp; &quot; &quot; &amp; seen 
		If isDataValue(ctor) Then
			cStr = _DataValue_genericToString(ctor, indent + 2, seen)
		Else
			cStr = toString(ctor)
		End If
		If isArray(fields) Then
			fStr = _DataValue_genericToString_Array(fields, indent, seen)
		Else
			fStr = toString(fields)
		End If
		out = &quot;{ id: &quot; &amp; v.id &amp; &quot;,&quot;			&amp; NL &amp; space(indent) _
			&amp; &quot;  ctor: &quot; &amp; cStr &amp; &quot;,&quot; 		&amp; NL &amp; space(indent) _
			&amp; &quot;  fields: &quot; &amp; fStr 			&amp; NL &amp; space(indent) _
			&amp; &quot;}&quot;
	End If
	_DataValue_genericToString = out
End Function

Function _DataValue_genericToString_Array( _
	ByVal a 	 As Array, _
	ByVal indent As Integer, _
	ByRef seen 	 As String _
)
	Dim out
	out = &quot;Array(&quot;
	If UBound(a) &lt; 0 Then
		out = out &amp; &quot;)&quot;
	Else
		out = out &amp; NL &amp; space(indent + 4)
		Dim i As Integer, w As Variant
		For i = 0 To UBound(a)
			If i &gt; 0 Then
				out = out &amp; &quot;,&quot; &amp; NL &amp; space(indent + 4)
			End If
			w = a(i)
			If isArray(w) Then
				out = out &amp; _
				_DataValue_genericToString_Array(w, indent + 2, seen)
			ElseIf isDataValue(w) Then
				out = out &amp; _
				_DataValue_genericToString(w, indent + 4, seen)
			Else
				out = out &amp; toString(w)
			End If
		Next i
		out = out &amp; NL &amp; space(indent + 2) &amp; &quot;)&quot;
	End If	
	_DataValue_genericToString_Array = out
End Function

Function _mkValueFrom_lax(ctor As DataValue, args As Array)
	Dim x As Integer, a As Integer
	a = LBound(args)
	If a &lt;&gt; 0 Then
		croak(&quot;_mkValueFrom_lax &quot; &amp; ctor.fields(DataCtor_name) &amp; &quot;:&quot; _
			&amp; NL &amp; &quot;invalid &quot; &amp; a &amp; &quot;-based args Array&quot; _
			&amp; NL &amp; &quot;expected 0-based Array&quot;)
	Else
		x = UBound(ctor.fields(DataCtor_argTypes))
		a = UBound(args)
		If a &lt;&gt; x Then
			a = a + 1 : x = x + 1
			croak(&quot;_mkValueFrom_lax &quot; &amp; ctor.fields(DataCtor_name) _
				&amp; &quot;:&quot; _
				&amp; NL &amp; &quot;expected &quot; &amp; x &amp; &quot; arg&quot; &amp; IIf(x = 1, &quot;&quot;, &quot;s&quot;) _
				&amp; &quot; but got &quot; &amp; a _
				&amp; NL &amp; toString(args))
		End If
	End If
	_mkValueFrom_lax = _newDataValue(ctor, args)
End Function

Sub _setTypeCtor(dataCtor As DataValue, dataTypeCtor As DataValue)
	&apos; TODO: check that dataCtor really is a DataCtor
	&apos; TODO: check that dataTypeCtor really is a DatatypeCtor
	dataCtor.fields(DataCtor_typeCtor) = dataTypeCtor
End Sub


&apos; --------------------------------------------------------------

&apos; --- TDataTypeCtor

Function TDataTypeCtor()
	Static out As Object : If isNull(out) Then : out = Tp.TDataTypeCtor : End If
	TDataTypeCtor = out
End Function

Function dataCtors(Optional tc)
	dataCtors = _destructure(Tp.DataTypeCtor, 2, tc)
End Function

Function findDataCtor(tc, dcName As String)
	Dim dcs As Object, dc as Object, out
	dcs = dataCtors(tc)
	Do Until isNil(dcs)
		dc = car(dcs)
		If nameOf(dc) = dcName Then
			out = dc
			Exit Do
		End If
		dcs = cdr(dcs)
	Loop
	findDataCtor = out
End Function

Function nameOf(x)
	On Local Error Goto nameOf_error
	Dim out, c : c = _ctor(x)
	If DataValue_same(c, Tp.DataCtor) Then
		out = field(DataCtor_name, x)
	ElseIf DataValue_same(c, Tp.DataTypeCtor) Then
		out = field(DataTypeCtor_name, x)
	Else
nameOf_error:
		croak(&quot;nameOf: expected DataCtor or DataTypeCtor - got &quot; _
			&amp; _str(typeOf(x)))
	End If
	nameOf = out
End Function

&apos; --- TDataCtor

Function TDataCtor()
	Static out As Object : If isNull(out) Then : out = Tp.TDataCtor : End If
	TDataCtor = out
End Function

Function argTypes(Optional dc)
	argTypes = _destructure(Tp.DataCtor, 1, dc)
End Function

Function singletonVal(Optional dc)
	Dim out
	If isMissing(dc) Then
		out = Fn.singletonVal
	ElseIf isNil(argTypes(dc)) Then
		out = _x(dc)
	Else
		croak(&quot;not a singleton data ctor: &quot; &amp; nameOf(dc) _
			&amp; NL &amp; _str(dc))
	End If
	singletonVal = out
End Function

&apos; --- List

Function TList(Optional typeArg)
	Static tc As Object : If isNull(tc) Then : tc = Tp.List : End If
	Dim out
	If isMissing(typeArg) Then
		out = tc
	Else
		out = TypeApp(tc, typeArg)
	End If
	TList = out
End Function

&apos; --- TType

Function TType()
	Static out As Object : If isNull(out) Then : out = Tp.TType : End If
	TType = out
End Function

&apos; Str -&gt; [Type] -&gt; TDataTypeCtor -&gt; TDataCtor
Function DataCtor( _
	Optional _name As String, _
	Optional argTypes As Object, _
	Optional typeCtor As Object _
)
	Static c As Object : If isNull(c) Then : c = Tp.DataCtor : End If
	Dim out
	If isMissing(_name) Then
		out = c
	Else
		out = applyDC(c, _name, argTypes, typeCtor)
	End If
	DataCtor = c
End Function

&apos; String -&gt; Integer -&gt; [TDataCtor] -&gt; TDataTypeCtor
Function DataTypeCtor( _
	Optional _name As String, _
	Optional arity As Integer, _
	Optional dataCtors As Object _
)
	Static c As Object : If isNull(c) Then : c = Tp.DataTypeCtor : End If
	Dim out
	If isMissing(_name) Then
		out = c
	Else
		out = applyDC(c, _name, arity, dataCtors)
	End If
	DataTypeCtor = out
End Function

Function TypeParam(Optional i As Integer)
	Static c As Object : If isNull(c) Then : c = Tp.TType_Param : End If
	Dim out
	If isMissing(i) Then
		out = c
	Else
		&apos;out = applyDC(c, i)
		out = _newDataValue(c, Array(i))
		out.str = &quot;a&quot; &amp; i
	End If
	TypeParam = out
End Function

Function TypeParam_index(Optional x)
	TypeParam_index = _destructure(Tp.TType_Param, 0, x)
End Function


Function TypeApp(Optional tc As Object, Optional ta As Object)
	Static cApp As Object : If isNull(cApp) Then : cApp = Tp.TType_App : End If
	Dim out
	If isMissing(tc) Then
		out = cApp
	Else
		Dim r As Integer
		&apos;out = applyDC(cApp, tc, ta)
		out = _newDataValue(cApp, Array(tc, ta))
		
		&apos; tc must be an &quot;applicable&quot; type,
		&apos; ie: a DataTypeCtor with arity &gt; 0
		&apos;     or a TypeApp with at least 1 unbound TypeParam
		If isType(tc) Then
			r = Type_arity(tc)
			If r &gt; 0 Then
				Dim tcCtor As Variant, tcStr As String
				tcCtor = _ctor(tc)
				If DataValue_same(tcCtor, DataTypeCtor) Then
					tcStr = field(DataTypeCtor_name, tc)
				ElseIf DataValue_same(tcCtor, cApp) Then
					tcStr = tc.str
				Else
					show(&quot;TypeApp/NYI: &quot;, tc).boom
				End If
			Else
				croak(&quot;TypeApp: cannot apply &quot; _
					&amp; TType_toString(tc))
			End If
		Else
			Goto TypeApp_invalid_1st_arg
		End If
				
		&apos; ta must be a &quot;complete&quot; type,
		&apos; ie: a DataTypeCtor with arity = 0
		&apos;  or a TypeApp
		&apos;  or a TypeParam
		&apos;  or a native type (Native_Str, Native_Int, ...)
		If isType(ta) Then
			r = Type_arity(ta)
			If r = 0 Then
				Dim taCtor As Object, taStr As String
				taCtor = _ctor(ta)
				If DataValue_same(taCtor, DataTypeCtor) Then
					taStr = field(DataTypeCtor_name, ta)
				ElseIf DataValue_same(taCtor, Tp.Native) Then
					taStr = field(Ntv_shortName, ta)
				ElseIf DataValue_same(taCtor, cApp) Then
					taStr = ta.str
					If Not(startsWith(taStr, &quot;[&quot;)) Then
						taStr = &quot;(&quot; &amp; taStr &amp; &quot;)&quot;
					End If
				Else
					taStr = ta.str
				End If
			Else
				croak(&quot;TypeApp: incomplete type arg: &quot; _
					&amp; TType_toString(ta))
			End If
		Else
			Goto TypeApp_invalid_2nd_arg
		End If
		
		If DataValue_same(tc, TList) Then
			out.str = &quot;[&quot; &amp; taStr &amp; &quot;]&quot;
		Else
			out.str = tcStr &amp; &quot; &quot; &amp; taStr
		End If
		
	End If
	TypeApp = out
	Exit Function
TypeApp_invalid_1st_arg:
	croak(&quot;TypeApp: cannot apply &quot; &amp; toString(tc))
TypeApp_invalid_2nd_arg:
	croak(&quot;TypeApp: invalid type arg &quot; &amp; toString(ta))
End Function

&apos; --------------------------------------------------------------

Function TypeApp_typeFn(Optional x)
	TypeApp_typeFn = _destructure(Tp.TType_App, 0, x)
End Function

Function TypeApp_typeArg(Optional x)
	TypeApp_typeArg = _destructure(Tp.TType_App, 1, x)
End Function

Function Type_arity(x)
	Dim out
	On Local Error Goto Type_arity_error
	Dim ct : ct = _ctor(x)
	If DataValue_same(ct, Tp.DataTypeCtor) Then
		out = field(DataTypeCtor_arity, x)
	ElseIf DataValue_same(ct, Tp.TType_App) Then
		out = CInt(Type_arity(TypeApp_typeFn(x)) - 1)
	ElseIf isType(x) Then
		out = 0
	Else
Type_arity_error:
		On Local Error Goto 0 &apos; disable error handler
		show(&quot;Type_arity: expected a Type, not a &quot; _
			&amp; typeStr(x)).boom
	End If
	Type_arity = out
End Function

&apos;Function isSubtypeOf(s As Object, t As Object)
&apos;	Dim out
&apos;	out = DataValue_same(s, t)
&apos;	If Not(out) Then
&apos;		If DataValue_same(t, TType) Then
&apos;			out = CBool(DataValue_same(s, TDataTypeCtor) _
&apos;					Or DataValue_same(s, TString) _
&apos;					Or DataValue_same(s, TInteger) _
&apos;			)
&apos;		End If
&apos;	End If
&apos;	isSubtypeOf = out
&apos;End Function

Function hasType(Optional v As Variant, Optional t As Object)
	Static oFn As Object, tcType As Object
	Static cDataTypeCtor As Object, cNative As Object
	Static nVariant As Object
	Static cParam As Object, cApp As Object
	Dim out As Variant
	If isMissing(t) Then
		If isNull(oFn) Then : oFn = Fn.hasType : End If
		If isMissing(v) Then	: out = oFn
		Else					: out = apply1(oFn, v)
		End If
	ElseIf isType(t) Then
		If isNull(tcType) Then
			tcType = Tp.TType
			cDataTypeCtor = Tp.DataTypeCtor
			cNative = Tp.Native
			nVariant = Tp.Native_Variant
			cParam = Tp.TType_Param
			cApp = Tp.TType_App
		End If
		If DataValue_same(t, tcType) Then
			out = isType(v)
		ElseIf isCtorOf(cParam, t) Then
			&apos; TODO: hasType - type context
			out = True
		Else
			out = False
			Dim tv As Object
			tv = typeOf(v)
			If DataValue_same(tv, t) Then
				out = True
			ElseIf isCtorOf(cNative, tv) Then
				If DataValue_same(t, nVariant) Then
					out = True
				Else
					&apos; TODO: subtype relation for native types
					out = False
				End If			
			ElseIf isCtorOf(cDataTypeCtor, tv) Then
				Dim r As Integer
				r = field(DataTypeCtor_arity, tv)
				If (r &gt; 0) And (isCtorOf(cApp, t)) Then
					out = DataValue_same(tv, TypeApp_typeFn(t))
					&apos; TODO: test type arg
				Else
					&apos; TODO: subtype relation for data types
				End If
			End If
		End If
	Else
		croak(&quot;hasType: not a type: &quot; &amp; toString(t))	
	End If	
	hasType = out
End Function

&apos;Function requireType(t As Object, v As Variant)
&apos;	Dim out
&apos;	If hasType(v, t) Then
&apos;		out = mkPass
&apos;	Else
&apos;		out = mkFail(v, t, &quot;need &quot; &amp; DataValue_toString(t) &amp; &quot; - got&quot; &amp; NL &amp; toString(v))
&apos;	End If
&apos;	requireType = out
&apos;End Function

Function applyDC(c, _
	Optional a0, _
	Optional a1, _
	Optional a2, _
	Optional a3, _
	Optional a4 _
)
	If Not(isctorOf(Tp.DataCtor, c)) Then
		croak(&quot;applyDC: not a data ctor: &quot; &amp; NL &amp; toString(c))
	End If
	Dim out As Object
	Dim cName As String : cName = field(DataCtor_name, c)
	Dim ats As Object	: ats = field(DataCtor_argTypes, c)
	Dim r As Integer	: r = length(ats)
	Dim n As Integer, i As Integer
	Dim a As Variant, t As Object
	
	If     isMissing(a0) Then :	n = 0
	ElseIf isMissing(a1) Then : n = 1
	ElseIf isMissing(a2) Then : n = 2
	ElseIf isMissing(a3) Then : n = 3
	ElseIf isMissing(a4) Then : n = 4
	Else
		croak(&quot;applyDC &quot; &amp; cName &amp; &quot;: &quot; _
			&amp; &quot; only up to 4 args supported - got 5&quot; _
		)
	End If
	If r &lt; n Then
		Goto applyDC_too_many_args
	End If
	On n Goto _tc1, _tc2, _tc3, _tc4, _tc5
	Goto _tc0
_tc5: a = a4 : t = nth(4, ats) : If Not(hasType(a, t)) Then : Goto applyDC_typeError : End If
_tc4: a = a3 : t = nth(3, ats) : If Not(hasType(a, t)) Then : Goto applyDC_typeError : End If
_tc3: a = a2 : t = nth(2, ats) : If Not(hasType(a, t)) Then : Goto applyDC_typeError : End If
_tc2: a = a1 : t = nth(1, ats) : If Not(hasType(a, t)) Then : Goto applyDC_typeError : End If
_tc1: a = a0 : t = nth(0, ats) : If Not(hasType(a, t)) Then : Goto applyDC_typeError : End If
_tc0:
	If n &lt; r Then
		Dim typeStr As String
		For i = n To r - 1
			t = nth(i, ats)
			If (t.str &lt;&gt; &quot;&quot;) Then
				typeStr = typeStr &amp; t.str &amp; &quot; -&gt; &quot;
			Else
				typeStr = typeStr &amp; _DataValue_toString_Type(t, &quot;&quot;) &amp; &quot; -&gt; &quot;
			End If
		Next i
		typeStr = typeStr &amp; typeCtorName(c)
		Dim oFn As Object
		oFn = _newFn(&quot;applyDC&quot;, r + 1, typeStr)
		Select Case n
			Case 0:	out = apply(oFn, c)
			Case 1:	out = apply(oFn, c, a0)
			Case 2:	out = apply(oFn, c, a0, a1)
			Case 3:	out = apply(oFn, c, a0, a1, a2)
			Case 4:	out = apply(oFn, c, a0, a1, a2, a3)
		End Select
	ElseIf n = r Then
		If r = 0 Then
			out = singletonVal(c)
			If isEmpty(out) Then
				croak(&quot;applyDC &quot; &amp; cName &amp; &quot;: singleton ctor &quot; _
					&amp; &quot; empty with .x&quot; _
				)
			End If
		Else
			Dim fields
			Select Case r
				Case 1:	fields = Array(a0)
				Case 2:	fields = Array(a0, a1)
				Case 3:	fields = Array(a0, a1, a2)
				Case 4:	fields = Array(a0, a1, a2, a3)
			End Select
			out = _newDataValue(c, fields)
		End If
	Else
applyDC_too_many_args:
		croak(&quot;applyDC &quot; &amp; cName &amp; &quot;: &quot; _
			&amp; &quot; cannot apply &quot; &amp; r &amp; &quot;-arg ctor to &quot; &amp; n &amp; &quot; args&quot; _
		)
	End If
	applyDC = out
	Exit Function
applyDC_typeError:
	dim foo : foo = hasType(a, t)	
	croak(&quot;applyDC &quot; &amp; cName &amp; &quot;: type error: expected &quot; _
		&amp; _DataValue_toString_Type(t) _
		&amp; &quot;, not a &quot; &amp; typeof(a).str _
	)
End Function


&apos; --------------------------------------------------------------

Function Data_toString( _
	v As DataValue, _
	Optional ByRef seen As String _
)
	Dim out As String
	Dim id_v As Long
	id_v = _id(v)
	If isMissing(seen) Then
		seen = &quot;&quot;
	End If
	If inStr(seen, &quot; &quot; &amp; id_v) &lt;&gt; 0 Then
		out = &quot;{ id: &quot; &amp; id_v &amp; &quot; }&quot;
	Else
		seen = seen &amp; &quot; &quot; &amp; id_v
		&apos; dispatch on data type:
		Dim tc
		tc = typeCtorOf(_ctor(v))
		Select Case _id(tc)
			Case _id(TDataTypeCtor)
				out = TDataTypeCtor_toString(v, seen)
			Case _id(TType)
				out = TType_toString(v, False)
			Case _id(TDataCtor)
				out = TDataCtor_toString(v)
			Case Else
				croak(&quot;Data_toString/NYI: a &quot; &amp; typeStr(v))
		End Select
	End If
	Data_toString = out
End Function

Function TDataTypeCtor_toString(v As Object, ByRef seen As String)
	Dim out
	out = &quot;(&quot; &amp; nameOf(v) &amp; &quot; &quot; &amp; Type_arity(v) &amp; &quot; [&quot;
	Dim dcs     As Object  : dcs = dataCtors(v) 
	Dim isFirst As Boolean : isFirst = True
	Do Until(isNil(dcs))
		If isFirst Then
			isFirst = False
		Else
			out = out &amp; &quot;, &quot;
		End If
		out = out &amp; &quot;´&quot; &amp; nameOf(car(dcs))
		dcs = cdr(dcs)
	Loop
	out = out &amp; &quot;])&quot;
	TDataTypeCtor_toString = out
End Function

Function TDataCtor_toString(v As Object)
	Dim out
	Dim ats As Object
	ats = argTypes(v)
	out = typeCtorName(v) &amp; &quot;.&quot; &amp; nameOf(v)
	Do Until isNil(ats)
		out = out &amp; &quot; &quot; &amp; TType_toString(car(ats), True)
		ats = cdr(ats)
	Loop
	TDataCtor_toString = out
End Function

Function TType_toString( _
	v As Object, _
	Optional needParens As Boolean _
)
	Static tcType   As Object, cParam As Object, cApp As Object
	Static tcNative As Object
	If isNull(tcType) Then
		tcType   = Tp.TType
		cParam   = Tp.TType_Param
		cApp     = Tp.TType_App
		tcNative = Tp.TNative
	End If
	If isMissing(needParens) Then
		needParens = False
	End If
	Dim out
	Dim c  As Object : c  = _ctor(v)
	Dim tc As Object : tc = typeCtorOf(c)
	
	If DataValue_same(tc, tcType) Then
		If DataValue_same(c, cParam) Then
			out = &quot;a&quot; &amp; TypeParam_index(v)
		ElseIf DataValue_same(c, cApp) Then
			out = TType_toString(TypeApp_typeFn(v), False) _
				&amp; &quot; &quot; _
				&amp; TType_toString(TypeApp_typeArg(v), True)
			If needParens Then
				out = &quot;(&quot; &amp; out &amp; &quot;)&quot;
			End If
		Else
			croak(&quot;TType_toString/NYI: TType.&quot; &amp; nameOf(c))
		End If
	ElseIf isType(v) Then
		If DataValue_same(tc, tcNative) Then
			out = field(Ntv_shortName, v)
		ElseIf DataValue_same(c, DataTypeCtor) Then
			out = nameOf(v)
		Else
			croak(&quot;TType_toString/NYI: &quot; &amp; typeStr(v))
		End If
	Else
		croak(&quot;TType_toString: not a Type: &quot; &amp; typeStr(v))
	End If

	TType_toString = out
End Function




Function DataValue_toString(v As DataValue)
	Dim seen As String
	seen = &quot;&quot;
	DataValue_toString = _DataValue_toString(v, seen)
End Function



Function _DataValue_toString(v As DataValue, ByRef seen As String)
	Dim out As String
	Dim typeStr As String, ctorStr As String
	Dim ctor As DataValue, fields As Variant
	If inStr(seen, &quot; &quot; &amp; v.id) &lt;&gt; 0 Then
		out = &quot;{ id: &quot; &amp; v.id &amp; &quot; }&quot;
	Else
		seen = seen &amp; &quot; &quot; &amp; v.id
		ctor   = v.ctor
		fields = v.fields
		typeStr = field(DataTypeCtor_name, field(DataCtor_typeCtor, ctor))
		ctorStr = field(DataCtor_name, ctor)
		out = typeStr &amp; &quot;.&quot; &amp; ctorStr
		If UBound(fields) &gt;= 0 Then
			Dim argsStr As String, i As Integer, first As Boolean
			Dim tc As DataValue
					
			If typeStr = &quot;TDataTypeCtor&quot; Then
				argsStr = toString(field(DataTypeCtor_name, v)) &amp; &quot; &quot; &amp; field(DataTypeCtor_arity, v) &amp; &quot; &quot; 
				Dim dataCtors As Variant, dc As DataValue
				dataCtors = field(DataTypeCtor_dataCtors, v)
				If isArray(dataCtors) Then
					argsStr = argsStr &amp; &quot;Array(&quot;
					For i = 0 To UBound(dataCtors)
						If i &gt; 0 Then : argsStr = argsStr &amp; &quot;, &quot; : End If
						dc = dataCtors(i)
						argsStr = argsStr &amp; field(DataCtor_name, dc)
					Next i
					argsStr = argsStr &amp; &quot;)&quot;
				ElseIf isDataValue(dataCtors) Then
					ctor = ctorOf(dataCtors)
					tc = field(DataCtor_typeCtor, ctor)
					If field(DataTypeCtor_name, tc) = &quot;List&quot; Then
						argsStr = argsStr &amp; &quot;[&quot;
						first = True
						Do Until ctorName(dataCtors) = &quot;Nil&quot;
							If first Then
								first = False
							Else
								argsStr = argsStr &amp; &quot;, &quot;
							End If
							dc = field(0, dataCtors) &apos; &quot;car&quot;
							argsStr = argsStr &amp; field(DataCtor_name, dc)
							dataCtors = field(1, dataCtors) &apos; &quot;cdr&quot;
						Loop
						argsStr = argsStr &amp; &quot;]&quot; 
					Else
						argsStr = argsStr &amp; _DataValue_toString(dataCtors, seen)
					End If
				Else
					croak(&quot;DataValue_toString/non-array, non-dataValue dataCtors: NYI&quot;)
				End If
			ElseIf typeStr = &quot;TDataCtor&quot; Then
				argsStr = toString(field(DataTypeCtor_name, v)) &amp; &quot; &quot; 
				Dim argTypes As Variant, at As Variant
				argTypes = field(DataCtor_argTypes, v)
				If isArray(argTypes) Then
					argsStr = argsStr &amp; &quot;Array(&quot;
					For i = 0 To UBound(argTypes)
						If i &gt; 0 Then : argsStr = argsStr &amp; &quot;, &quot; : End If
						at = argTypes(i)
						If isDataValue(at) Then
							argsStr = argStr &amp; _DataValue_toString_Type(at, seen)	&apos; &lt;------ type-to-string here
						Else
							argsStr = argsStr &amp; toString(at)
						End If
					Next i
					argsStr = argsStr &amp; &quot;)&quot;
				ElseIf isDataValue(argTypes) Then
					ctor = ctorOf(argTypes)
					tc = field(DataCtor_typeCtor, ctor)
					If field(DataTypeCtor_name, tc) = &quot;List&quot; Then
						argsStr = argsStr &amp; &quot;[&quot;
						first = True
						Do Until ctorName(argTypes) = &quot;Nil&quot;
							If first Then
								first = False
							Else
								argsStr = argsStr &amp; &quot;, &quot;
							End If
							at = field(0, argTypes) &apos; &quot;car&quot;
							argsStr = argsStr &amp; _DataValue_toString(at, seen)	&apos; &lt;------ type-to-string here
							argTypes = field(1, argTypes) &apos; &quot;cdr&quot;
						Loop
						argsStr = argsStr &amp; &quot;]&quot; 
					Else
						argsStr = argsStr &amp; _DataValue_toString(argTypes, seen)
					End If
				Else
					argsStr = argsStr &amp; toString(argTypes, seen)
					&apos;croak(&quot;DataValue_toString/non-array, non-dataValue argTypes: NYI&quot; &amp; NL &amp; NL &amp; toString(argTypes))
				End If
				argsStr = argsStr &amp; &quot; &quot; &amp; field(DataTypeCtor_name, field(DataCtor_typeCtor, v))
			ElseIf typeStr = &quot;Type&quot; Then
				out = _DataValue_toString_Type(v, seen)
			Else
				argsStr = _DataValue_toString_Array(fields, seen)
			End If
			out = &quot;(&quot; &amp; out &amp; &quot; &quot; &amp; argsStr &amp; &quot;)&quot;
		End If
	End If
	_DataValue_toString = out
End Function

Function _DataValue_toString_Array(a As Array, ByRef seen As String)
	Dim out As String, i As Integer, x As Variant
	out = &quot;&quot;
	For i = 0 To UBound(a)
		If i &gt; 0 Then : out = out &amp; &quot; &quot; : End If
		x = a(i)
		If isDataValue(x) Then
			out = out &amp; _DataValue_toString(x, seen)
		ElseIf isArray(x) Then
			out = out &amp; &quot;Array(&quot; &amp; _DataValue_toString_Array(x, seen) &amp; &quot;)&quot;
		Else
			out = out &amp; toString(x)
		End If
	Next i
	
	_DataValue_toString_Array = out
End Function


Function _DataValue_toString_Type(v As DataValue, ByRef seen As String)
	Dim out As String : out = &quot;&quot;
	If isDataTypeCtor(v) Then
		out = field(DataTypeCtor_name, v)
	Else
		Dim c As DataValue : c = ctorOf(v)
		If ctorName(c) = &quot;DataCtor&quot; Then
			Dim t As DataValue : t = field(DataCtor_typeCtor, c)
			If field(DataTypeCtor_name, t) = &quot;Type&quot; Then
				Dim cName As String
				cName = ctorName(v)
				out = cName
				Dim args   As Variant, a As Variant
				Dim i As Integer, n As Integer
				args = _fields(v)
				n = UBound(args)
				If n &gt;= 0 Then
					out = out &amp; &quot; &quot;
					Select Case cName
						Case &quot;Ntv&quot; &apos; Ntv Str Str Int
							out = out &amp; &quot;&apos;&quot; &amp; args(0) &amp; &quot;&apos; ...&quot;
						Case &quot;Param&quot; &apos; Param Int
							out = out &amp; args(0)
						Case &quot;App&quot;	&apos; App Type Type
							out = out &amp; field(DataTypeCtor_name, args(0)) _
								&amp; &quot; &quot; &amp; _DataValue_toString_Type(args(1), seen)
						Case Else
							croak(&quot;_DataValue_toString_Type/NYI: Type instance &quot; &amp; cName &amp; &quot; ...&quot;)
					End Select
					out = &quot;(&quot; &amp; out &amp; &quot;)&quot;
				End If
			End If
		End If
		If out = &quot;&quot; Then
			croak(&quot;_DataValue_toString_Type: invalid Type instance &quot; &amp; DataValue_toString(v))
		End If
	End If
	_DataValue_toString_Type = out
End Function


Function isDataTypeCtor(tc As DataValue)
	Dim out
	out = False
	Dim c As DataValue
	c = tc.ctor
	Dim cName As String
	cName = c.fields(DataCtor_name)
	If cName = &quot;DataTypeCtor&quot; Then
		Dim tcName As String
		tcName = c.fields(DataCtor_typeCtor).fields(DataTypeCtor_name) 
		If tcName = &quot;TDataTypeCtor&quot; Then
			out = True
		End If
	End If
	isDataTypeCtor = out
End Function

Function _mkDataCtor( _
	typeCtor As Object, _
	cName 	 As String, _
	ByVal argTypes As Object _
)
	Dim dc As Object : dc = Tp.DataCtor
	Dim nl As Object : nl = Tp.List_Nil.x
	Dim out
	out = _newDataValue(dc, Array(cName, argTypes, typeCtor))
	Dim dcs As Object
	dcs = typeCtor.fields(DataTypeCtor_dataCtors, typeCtor)
	Dim isFirst As Boolean, isSingle As Boolean
	isFirst  = DataValue_same(nl, dcs)
	isSingle = DataValue_same(nl, argTypes) &apos; singleton data ctor?
	typeCtor.fields(DataTypeCtor_dataCtors, typeCtor) _
		= _newDataValue(Tp.List_Cons, Array(out, dcs))
	Dim tcName As String
	tcName = field(DataTypeCtor_name, typeCtor)
	If Not(isFirst) Then
		typeCtor.str = typeCtor.str &amp; &quot; | &quot;
	End If
	out.str = cName
	If isSingle Then
		out.x = _newDataValue(out, emptyArray)
		out.x.str = cName
	Else
		&apos; cannot use TType_toString yet!
		out.str = out.str &amp; &quot; ...&quot;
	End If
	typeCtor.str = typeCtor.str &amp; out.str
	out.str = tcName &amp; &quot;.&quot; &amp; out.str
	_mkDataCtor = out	
End Function

Function mkDataCtor( _
	typeCtor As Object, _
	cName 	 As String, _
	ByVal argTypes As Object _
)
	Dim out
	out = _newDataValue(Tp.DataCtor, Array(cName, argTypes, typeCtor))
	Dim dcs As Object
	dcs = dataCtors(typeCtor)
	Dim isFirst As Boolean, isSingle As Boolean
	isFirst  = isNil(dcs)
	isSingle = isNil(argTypes) &apos; singleton data ctor?
	typeCtor.fields(DataTypeCtor_dataCtors, typeCtor) _
		= cons(out, dcs)
	Dim tcName As String
	tcName = nameOf(typeCtor)
	If Not(isFirst) Then
		typeCtor.str = typeCtor.str &amp; &quot; | &quot;
	End If
	out.str = cName
	If isSingle Then
		out.x = _newDataValue(out, emptyArray)
		out.x.str = cName
	Else
		&apos; can use TType_toString now:
		Do
			out.str = out.str _
				&amp; &quot; &quot; &amp; TType_toString(car(argTypes), True)
			argTypes = cdr(argTypes)
		Loop Until(isNil(argTypes))
	End If
	typeCtor.str = typeCtor.str &amp; out.str
	out.str = tcName &amp; &quot;.&quot; &amp; out.str
	mkDataCtor = out
End Function

Function _mkDataTypeCtor( _
	ByVal tcName As String, _
	ByVal arity As Integer _
)
	Dim dtc As Object : dtc = Tp.DataTypeCtor
	Dim nl	As Object : nl  = Tp.List_Nil.x
	Dim out As Object
	out = _newDataValue(dtc, Array(tcName, arity, nl))
	out.str = tcName
	Dim i As Integer, p As Object
	For i = 0 To arity - 1
		out.str = out.str &amp; &quot; a&quot; &amp; i
	Next i
	out.str = out.str &amp; &quot; = &quot;
	_mkDataTypeCtor = out
End Function

Function isType(t As Variant)
	Dim out
	out = False
	If isObject(t) Then
		On Local Error Goto isType_end
		Dim c : c = _ctor(t) &apos; DON&apos;t dot-access it!
		If DataValue_same(c, Tp.Native) Then
			out = True
		ElseIf DataValue_same(c, Tp.DataTypeCtor) Then
			out = True
		ElseIf DataValue_same(_ctor(c), Tp.DataCtor) Then
			&apos; DON&apos;t use typeCtorOf
			out = DataValue_same(field(DataCtor_typeCtor, c), Tp.TType)
		End If
	End If
isType_end:
	isType = out
End Function

&apos; --- equ ---

Function TypeCtor_equ(a As TypeCtor, b As TypeCtor)
	Dim out
	out = (a._name = b._name)
	TypeCtor_equ = out
End Function

Function DataType_equ(a As DataType, b As DataType)
	Dim out
	out = False
	If TypeCtor_equ(a.typeCtor, b.typeCtor) Then
		Dim aArgs : aArgs = a.typeArgs
		Dim bArgs : bArgs = b.typeArgs
		Dim i As Integer
		For i = 0 To UBound(aArgs)
			If Not(Type_equ(aArgs(i), bArgs(i))) Then
				Goto DataType_equ_end
			End If
		Next i
		out = True
	End If
DataType_equ_end:
	DataType_equ = out
End Function

Function DataCtor_equ(a As DataCtor, b As DataCtor)
	Dim out
	out = False
	Dim aStr
	If a._name = b._name Then
		out = TypeCtor_equ(a.typeCtor, b.typeCtor)
	End If
	DataCtor_equ = out
End Function

Function Type_equ(a As Object, b As Object)
	Dim out
	out = False
	If isType(a) And isType(b) Then
		If isDataType(a) And isDataType(b) Then
			out = DataType_equ(a, b)
		&apos;ElseIf ... &apos;TODO: Type_equ for other Types
		End If
	Else
		croak(&quot;Type_equ: cannot compare &quot; &amp; typeStr(a) _
			&amp; &quot; and &quot; &amp; typeStr(b))
	End If
	Type_equ = out
End Function









Function typeStr(x As Variant)
	Dim out As String, t As Object, ct
	t = typeOf(x)
	ct = ctorOf(t)
	If Not(isObject(ct)) Then
		ct = ctorOf(t)
		croak(&quot;typeStr: invalid ctor of type &quot; &amp; toString(t))
	ElseIf DataValue_same(ct, Tp.Native) Then
		&apos; Special case: native values have as &quot;ctors&quot;
		&apos; members of the enum TNative. They are not
		&apos; data ctors, but rather &quot;NativeTypeCtor&quot; s.
		&apos; They cannot be &quot;applied&quot; to construct values.
		&apos; They do however contain x&apos;s TypeName, VarType and short_name.
		If DataValue_same(t, Tp.Native_Object) Then &apos; x is not a DataValue
			out = _typeStr(x)
		Else
			out = field(Ntv_typeName, t)
		End If
	Else &apos; x is normal DataValue
		out = &quot;Data/&quot; &amp; field(DataTypeCtor_name, t)
	End If
	typeStr = out
End Function

Function _typeStr(o As Object)
	Dim out As String
	out = &quot;Object&quot;
	On Local Error Goto _typeStr_end
	out = out &amp; &quot;/&quot; &amp; _tyname(o)
_typeStr_end:
	_typeStr = out
End Function



Function isString(Optional x As Variant)
	If isMissing(x) Then
		isString = Fn.isString
	Else
		isString = DataValue_same(typeOf(x), Tp.Native_String)
	End If
End Function

Function isInteger(Optional x As Variant)
	Dim out As Variant
	If isMissing(x) Then : out = Fn.isInteger
	Else 				 : out = DataValue_same(typeOf(x), Tp.Native_Integer)
	End If
	isInteger = out
End Function


Function [test_Type======================================]
	test_Type_DataValue()
	test_Type_isDataValue()
	
	test_bootstrapTypes()
	test_Type_typeOf()
	test_Type_typeStr()
	test_Type_isType()
	test_Type_isObject()
	test_Type_isString()
	test_Type_isInteger()
	
	test_Type_hasType()
	
	test_Type_dot_str()
	
	test_Data_toString()
	
	test_Type_applyDC()
	test_Type_destructure()
	test_Type_dataCtors()
	&apos;test_Type_nameOf()
	test_Type_findDataCtor()
	test_Type_singletonVal()

	test_Type_Type_arity()
End Function

&apos; some dummy (BASIC) Type s used in tests
&apos; ---------------------------------------

Type TTest_NoTyname
End Type

Type TTest_Tyname
	tyname As String
End Type

Type TTest_Foo
	bar As Integer
End Type

Type TTest_Ctor
	ctor As Variant
End Type

&apos; test helpers
&apos; --------------------------------------------------


Function test_same(x As Variant, y As Variant, exp As Boolean)
	Dim out, lvl As Integer, msg As String
	If Not(isDataValue(x)) Or Not(isDataValue(y)) Then
		Goto test_same_invalid_args
	End If
	testLevel = testLevel + 1
	out = assertEqual(DataValue_same(x, y), exp)
	testLevel = testLevel - 1
	If out.isFail Then
		msg = &quot;expected .id &quot; &amp; _id(x) _
			&amp; IIf(exp, &quot;&quot;, &quot;NOT&quot;) _
			&amp; &quot; to be same as .id &quot; &amp; _id(y) &amp; &quot;:&quot; _
			&amp; NL &amp; &quot;.id &quot; &amp; _id(x) &amp; &quot;: &quot; &amp; DataValue_toString(x) _
			&amp; NL _
			&amp; NL &amp; &quot;.id &quot; &amp; _id(y) &amp; &quot;: &quot; &amp; DataValue_toString(y)
		out = mkFail(x, y, msg)
	End If
	test_same = out
	Exit Function
test_same_invalid_args:
	dim xStr : xStr = toString(x)
	dim yStr : yStr = toString(y)
	msg = IIf(exp, &quot;assert&quot;, &quot;refute&quot;) _
		&amp; &quot;_same: invalid args &quot; &amp; NL &amp; xStr _
		&amp; NL &amp; NL &amp; yStr
	&apos;croak(msg)
	test_same = mkFail(x, y, msg)
End Function

Function assert_same(act As Variant, exp As Variant)
	assert_same = test_same(act, exp, True)
End Function

Function refute_same(act As Variant, exp As Variant)
	refute_same = test_same(act, exp, False)
End Function

Function assert_hasCtor(v As Variant, c As Variant)
	If Not(isDataValue(c)) Or Not(isDataValue(c)) Then
		Goto assert_hasCtor_invalid_args
	End If
	If assert_same(ctorOf(c), DataCtor).isFail Then
		Goto assert_hasCtor_invalid_args
	End If
	assert_hasCtor = assert_same(ctorOf(v), c)
	Exit Function
assert_hasCtor_invalid_args:
	croak(&quot;assert_hasCtor: invalid args &quot; &amp; NL &amp; toString(v) _
		&amp; NL &amp; NL &amp; toString(c)
End Function

Function assert_hasTypeCtor(c As Variant, tc As Variant)
	If Not(isDataValue(c)) Or Not(isDataValue(tc)) Then
		Goto assert_hasTypeCtor_invalid_args
	End If
	If assert_same(ctorOf(c),  DataCtor    ).isFail _
	Or assert_same(ctorOf(tc), DataTypeCtor).isFail Then
		Goto assert_hasTypeCtor_invalid_args
	End If
	assert_hasTypeCtor = assert_same(field(DataCtor_typeCtor, c), tc)
	Exit Function
assert_hasTypeCtor_invalid_args:
		croak(&quot;assert_hasTypeCtor: invalid args &quot; &amp; NL &amp; toString(c) _
			&amp; NL &amp; NL &amp; toString(tc)
End Function

&apos; actual tests
&apos; ----------------------------------------------------



&apos; isObject is a BASIC function:
&apos; make sure we know exactly what it does
Function test_Type_isObject()
	Dim o As Object

	assertEqual(isObject(Nothing),	True).x

	assertEqual(isObject(Empty),	False).x
	assertEqual(isObject(True),		False).x
	assertEqual(isObject(False),	False).x
	assertEqual(isObject(&quot;&quot;),		False).x
	assertEqual(isObject(&quot;foobar&quot;),	False).x
	assertEqual(isObject( 0),		False).x
	assertEqual(isObject( 1),		False).x
	assertEqual(isObject(-1),		False).x
	assertEqual(isObject(3.1415),	False).x
	assertEqual(isObject(Array()),	False).x

	o = New TTest_Foo
	assertEqual(isObject(o), True).x
	o.bar = 4711
	assertEqual(isObject(o), True).x
End Function

&apos; isString: implemented above
Function test_Type_isString()
	assertEqual(isString(&quot;&quot;),                  True).x
	assertEqual(isString(&quot;a&quot;),                 True).x
	assertEqual(isString(&quot;foobar&quot;),            True).x
	assertEqual(isString(Nothing),            False).x
	assertEqual(isString(Empty),              False).x
	assertEqual(isString(True),               False).x
	assertEqual(isString(False),              False).x
	assertEqual(isString(0),                  False).x
	assertEqual(isString(1),                  False).x
	assertEqual(isString(3.14),               False).x
	assertEqual(isString(Array()),            False).x
	assertEqual(isString(Array(42)),          False).x
	assertEqual(isString(Array(42)),          False).x
	
	assertEqual(arity(Fn.isString),	1).x &apos; from Fn object
	assertEqual(arity(isString),	1).x &apos; from 0-arg call
	
	assertEqual(apply(isString, &quot;&quot;),         True).x
	assertEqual(apply(isString, &quot;a&quot;),        True).x
	assertEqual(apply(isString, &quot;foobar&quot;),   True).x
	assertEqual(apply(isString, Nothing),   False).x
	assertEqual(apply(isString, Empty),     False).x
	assertEqual(apply(isString, True),      False).x
	assertEqual(apply(isString, False),     False).x
	assertEqual(apply(isString, 0),         False).x
	assertEqual(apply(isString, 1),         False).x
	assertEqual(apply(isString, 3.14),      False).x
	assertEqual(apply(isString, Array()),   False).x
	assertEqual(apply(isString, Array(42)), False).x
	assertEqual(apply(isString, Array(42)), False).x
End Function

&apos; isInteger: implemented above
Function test_Type_isInteger()
	assertEqual(isInteger(&quot;&quot;),                 False).x
	assertEqual(isInteger(&quot;a&quot;),                False).x
	assertEqual(isInteger(&quot;foobar&quot;),           False).x
	assertEqual(isInteger(Nothing),            False).x
	assertEqual(isInteger(Empty),              False).x
	assertEqual(isInteger(True),               False).x
	assertEqual(isInteger(False),              False).x
	assertEqual(isInteger( 0),                  True).x
	assertEqual(isInteger( 1),                  True).x
	assertEqual(isInteger(-1),                  True).x
	assertEqual(isInteger( 32766),              True).x &apos;0x7FFE
	assertEqual(isInteger( 32767),              True).x &apos;0x7FFF
	assertEqual(isInteger( 32768),             False).x &apos;0x8000 (!)
	assertEqual(isInteger( 65534),             False).x &apos;0xFFFE
	assertEqual(isInteger( 65535),             False).x &apos;0xFFFF
	assertEqual(isInteger( 65536),             False).x &apos;0x80000
	assertEqual(isInteger(-32766),              True).x &apos;0x8002
	assertEqual(isInteger(-32767),              True).x &apos;0x8001
	assertEqual(isInteger(-32768),              True).x &apos;0x8000
	assertEqual(isInteger(-32769),             False).x &apos;0x17FFF (!)
	assertEqual(isInteger(-65534),             False).x &apos;0xFFFE
	assertEqual(isInteger(-65535),             False).x &apos;0xFFFF
	assertEqual(isInteger(-65536),             False).x &apos;0x80000
	assertEqual(isInteger(3.14),               False).x
	assertEqual(isInteger(Array()),            False).x
	assertEqual(isInteger(Array(42)),          False).x
	assertEqual(isInteger(Array(42)),          False).x
End Function

Function test_Type_isDataValue()
	&apos; positive tests below
	assertEqual(isDataValue(&quot;&quot;),                 False).x
	assertEqual(isDataValue(&quot;a&quot;),                False).x
	assertEqual(isDataValue(&quot;foobar&quot;),           False).x
	assertEqual(isDataValue(Nothing),            False).x
	assertEqual(isDataValue(Empty),              False).x
	assertEqual(isDataValue(True),               False).x
	assertEqual(isDataValue(False),              False).x
	assertEqual(isDataValue( 0),                 False).x
	assertEqual(isDataValue( 1),                 False).x
	assertEqual(isDataValue(-1),                 False).x
	assertEqual(isDataValue( 32766),             False).x &apos;0x7FFE
	assertEqual(isDataValue( 32767),             False).x &apos;0x7FFF
	assertEqual(isDataValue( 32768),             False).x &apos;0x8000 (!)
	assertEqual(isDataValue( 65534),             False).x &apos;0xFFFE
	assertEqual(isDataValue( 65535),             False).x &apos;0xFFFF
	assertEqual(isDataValue( 65536),             False).x &apos;0x80000
	assertEqual(isDataValue(-32766),             False).x &apos;0x8002
	assertEqual(isDataValue(-32767),             False).x &apos;0x8001
	assertEqual(isDataValue(-32768),             False).x &apos;0x8000
	assertEqual(isDataValue(-32769),             False).x &apos;0x17FFF (!)
	assertEqual(isDataValue(-65534),             False).x &apos;0xFFFE
	assertEqual(isDataValue(-65535),             False).x &apos;0xFFFF
	assertEqual(isDataValue(-65536),             False).x &apos;0x80000
	assertEqual(isDataValue(3.14),               False).x
	assertEqual(isDataValue(Array()),            False).x
	assertEqual(isDataValue(Array(42)),          False).x
	assertEqual(isDataValue(Array(42)),          False).x
End Function

Function test_Type_DataValue()
	Dim v, c
	v = _newDataValue(Nothing, emptyArray)
	assertEqual(v.ctor, Nothing)
	assertEqual(LBound(v.fields),  0).x
	assertEqual(UBound(v.fields), -1).x
	assertEqual(isDataValue(v), True).x

	v = _newDataValue(Nothing, Array(42))
	assertEqual(v.ctor, Nothing)
	assertEqual(UBound(v.fields), 0).x
	assertEqual(v.fields(0), 42).x 
	assertEqual(isDataValue(v), True).x

	v = _newDataValue(Nothing, Array(&quot;foo&quot;, 4711))
	assertEqual(v.ctor, Nothing)
	assertEqual(UBound(v.fields), 1).x
	assertEqual(v.fields(0), &quot;foo&quot;).x 
	assertEqual(v.fields(1), 4711).x 
	assertEqual(isDataValue(v), True).x
End Function


Function bootstrapTypes()
	Dim vNil
	&apos; The most simple DataValue is one without any fields.
	&apos; Since we don&apos;t have data ctors yet we&apos;ll leave the
	&apos; .ctor member empty.
	vNil = _newDataValue(Nothing, emptyArray)
	&apos; The function DataValue_genericToString provides a way to
	&apos; see what&apos;s inside a DataValue:
	Dim vNilStr As String
	vNilStr = DataValue_genericToString(vNil)
	assertEqual( _
		vNilStr, _
		&quot;{ id: &quot; &amp; vNil.id &amp; &quot;,&quot;	&amp; NL &amp; _
		&quot;  ctor: Nothing,&quot;			&amp; NL &amp; _
		&quot;  fields: Array()&quot;			&amp; NL &amp; _
		&quot;}&quot;							       _
	).x
	&apos; We can see that there&apos;s another member: .id, which is unique
	&apos; to the particular DataValue instance. This gives rise to a 
	&apos; notion of sameness. The function `DataValue_same` provides a
	&apos; means of testing for sameness:
	assertEqual(DataValue_same(vNil, vNil), True).x
	&apos; Even if we provide the very same values, we&apos;ll get a
	&apos; different instance:
	Dim x
	x = _newDataValue(Nothing, emptyArray)
	assertEqual(DataValue_same(x, vNil), False).x
	&apos; To make the tests more readable we&apos;ll abbreviate that to
	refute_same(x, vNil).x
	&apos; and for a positive test:
	assert_same(x,    x).x
	assert_same(vNil, vNil).x
	&apos; ...which simply means that &quot;sameness&quot; is of course
	&apos; reflexive, ie for all x, y: if x = y then x same y.
	&apos; It is - again of course - 
	&apos; symmetric, ie forall x, y: x same y iff y same x.
	assertEqual(_
		DataValue_same(vNil, x), _
		DataValue_same(x, vNil) _
	).x
	
	&apos; Now we have to fill in the .ctor member of vNil, which should
	&apos; point to vNil&apos;s data ctor.
	&apos; A data ctor has
	&apos;   - a name (a String)
	&apos;   - a list of argument types (tbd)
	&apos;   - a pointer to its datatype ctor (tbd)
	&apos; ...and we&apos;ll consider DataValue s with a .ctor member pointing
	&apos; to it as having been &quot;created&quot; from that data ctor.
	&apos; We already can provide a name, and for the particular data ctor
	&apos; of vNil - which has no fields whatsoever - we can also provide
	&apos; the list of argument types: it&apos;s just the empty list, represented
	&apos; by vNil.
	&apos; If we want to represent data ctors as DataValue as well,
	&apos; then they in turn need a .ctor member. For now we&apos;ll leave it
	&apos; empty.
	Dim cNil
	cNil = _newDataValue(Nothing, Array( _
		&quot;Nil&quot;, _
		vNil, _
		Nothing _
	)
	assertEqual(isDataValue(cNil), True).x
	&apos; The data ctor is different from the value, even if the data ctor
	&apos; takes no arguments:
	refute_same(cNil, vNil).x
	&apos; Let&apos;s make sure that cNil has an empty argument list.
	&apos; We&apos;ll use the fn `field` and constants to index into a
	&apos; DataValue&apos;s fields:
	assert_same(field(DataCtor_argTypes, cNil), vNil).x
	&apos; Fill in cNil as vNil&apos;s .ctor and see what it looks like then:
	vNil.ctor = cNil
	vNilStr = DataValue_genericToString(vNil)
	assertEqual( vNilStr, _
		&quot;{ id: &quot; &amp; vNil.id &amp; &quot;,&quot;			&amp; NL &amp; _
		&quot;  ctor: { id: &quot; &amp; cNil.id &amp; &quot;,&quot;	&amp; NL &amp; _
		&quot;    ctor: Nothing,&quot;				&amp; NL &amp; _
		&quot;    fields: Array(&quot;				&amp; NL &amp; _
		&quot;      &apos;Nil&apos;,&quot;						&amp; NL &amp; _ 
		&quot;      { id: &quot; &amp; vNil.id &amp; &quot; },&quot;	&amp; NL &amp; _ 
		&quot;      Nothing&quot;						&amp; NL &amp; _
		&quot;    )&quot;								&amp; NL &amp; _
		&quot;  },&quot;								&amp; NL &amp; _
		&quot;  fields: Array()&quot;					&amp; NL &amp; _
		&quot;}&quot;										   _
	).x
	&apos; We&apos;ve just created a circular structure:
	&apos; vNil refers to cNil via .ctor and cNil refers to vNil
	&apos; via field argTypes. DataValue_genericToString resolves
	&apos; the problem by showing only the .id member of previously
	&apos; encountered DataValue s.
	&apos; Looking at cNil (first):
	Dim cNilStr
	cNilStr = DataValue_genericToString(cNil)
	assertEqual(cNilStr, _
		&quot;{ id: &quot; &amp; cNil.id &amp; &quot;,&quot;				&amp; NL &amp; _
		&quot;  ctor: Nothing,&quot;						&amp; NL &amp; _
		&quot;  fields: Array(&quot;						&amp; NL &amp; _
		&quot;    &apos;Nil&apos;,&quot;							&amp; NL &amp; _ 
		&quot;    { id: &quot; &amp; vNil.id &amp; &quot;,&quot;			&amp; NL &amp; _ 
		&quot;      ctor: { id: &quot; &amp; cNil.id &amp; &quot; },&quot;	&amp; NL &amp; _
		&quot;      fields: Array()&quot;					&amp; NL &amp; _
		&quot;    },&quot;								&amp; NL &amp; _
		&quot;    Nothing&quot;							&amp; NL &amp; _
		&quot;  )&quot;									&amp; NL &amp; _
		&quot;}&quot;											   _
	).x

	&apos; access ctor fields:
	&apos; TODO: why not .fields ?
	Dim c
	c = ctorOf(vNil)
	assertEqual(field(DataCtor_name,     c), &quot;Nil&quot;).x
	assert_same(field(DataCtor_argTypes, c), vNil).x
	assertEqual(field(DataCtor_typeCtor, c), Nothing).x
	
	
	
	
	
	
	
	&apos; Since the ctor is itself a DataValue - what&apos;s the ctor of that ctor?
	Dim cDataCtor As DataValue
	&apos; it&apos;ll be a DataValue again, and it&apos;ll be a data ctor with
	&apos; - name: &quot;DataCtor&quot;
	&apos; - argTypes: a list of argument types
	&apos; - and as the third field typeCtor: a DataTypeCtor
	&apos; The typeCtor field will be left empty for now, but we must mention
	&apos; it in the definition of DataCtor. Therefore there are not only
	&apos; two entries in argTypes - &quot;String&quot; and &quot;List_of_TypeExpr&quot; - but three: the
	&apos; third must be &quot;TDataTypeCtor&quot;.
	Dim cName As String, argTypes As Variant
	cName    = &quot;DataCtor&quot;
	&apos; The argTypes should be types (type expressions), which we don&apos;t
	&apos; have yet.
	&apos; But types (type expressions) may also be type variables. Let&apos;s
	&apos; just use plain strings and pretend they&apos;re type vars.
	&apos; Similarly, since we don&apos;t have the List data type yet, we&apos;ll
	&apos; use a native Array instead for argTypes and pretend it were a
	&apos; List.
	argTypes = Array(&quot;String&quot;, &quot;List_of_TypeExpr&quot;, &quot;TDataTypeCtor&quot;)
	cDataCtor = _newDataValue(Nothing, Array(cName, argTypes, Nothing))
	c = cDataCtor
	assertEqual(           field(DataCtor_name,     c), cName).x
	assert_toString_equals(field(DataCtor_argTypes, c), argTypes).x
	assertEqual(           field(DataCtor_typeCtor, c), Nothing).x

	&apos; What does it look like?
	Dim cDataCtorStr As String
	cDataCtorStr = DataValue_genericToString(cDataCtor)
	&apos;msgbox(cDataCtorStr)
	assertEqual( _
		cDataCtorStr, _
		&quot;{ id: &quot; &amp; cDataCtor.id &amp; &quot;,&quot;	&amp; NL &amp; _
		&quot;  ctor: Nothing,&quot;				&amp; NL &amp; _
		&quot;  fields: Array(&quot;				&amp; NL &amp; _
		&quot;    &apos;DataCtor&apos;,&quot;				&amp; NL &amp; _ 
		&quot;    Array(&quot;					&amp; NL &amp; _
		&quot;      &apos;String&apos;,&quot;				&amp; NL &amp; _
		&quot;      &apos;List_of_TypeExpr&apos;,&quot;		&amp; NL &amp; _
		&quot;      &apos;TDataTypeCtor&apos;&quot;			&amp; NL &amp; _
		&quot;    ),&quot;						&amp; NL &amp; _
		&quot;    Nothing&quot;					&amp; NL &amp; _
		&quot;  )&quot;							&amp; NL &amp; _
		&quot;}&quot;							           _
	).x

	&apos; Let&apos;s put this in as cNil&apos;s .ctor:
	cNil.ctor = cDataCtor
	&apos; Now cNil looks like this:
	cNilStr = DataValue_genericToString(cNil)
	assertEqual( _
		cNilStr, _
		&quot;{ id: &quot; &amp; cNil.id &amp; &quot;,&quot;				&amp; NL &amp; _
		&quot;  ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot;,&quot;	&amp; NL &amp; _
		&quot;    ctor: Nothing,&quot;					&amp; NL &amp; _
		&quot;    fields: Array(&quot;					&amp; NL &amp; _
		&quot;      &apos;DataCtor&apos;,&quot;						&amp; NL &amp; _ 
		&quot;      Array(&quot;							&amp; NL &amp; _ 
		&quot;        &apos;String&apos;,&quot;						&amp; NL &amp; _ 
		&quot;        &apos;List_of_TypeExpr&apos;,&quot;			&amp; NL &amp; _ 
		&quot;        &apos;TDataTypeCtor&apos;&quot;				&amp; NL &amp; _ 
		&quot;      ),&quot;								&amp; NL &amp; _
		&quot;      Nothing&quot;							&amp; NL &amp; _
		&quot;    )&quot;									&amp; NL &amp; _
		&quot;  },&quot;									&amp; NL &amp; _
		&quot;  fields: Array(&quot;						&amp; NL &amp; _
		&quot;    &apos;Nil&apos;,&quot;							&amp; NL &amp; _
		&quot;    { id: &quot; &amp; vNil.id &amp; &quot;,&quot;			&amp; NL &amp; _
		&quot;      ctor: { id: &quot; &amp; cNil.id &amp; &quot; },&quot;	&amp; NL &amp; _
		&quot;      fields: Array()&quot;					&amp; NL &amp; _
		&quot;    },&quot;								&amp; NL &amp; _
		&quot;    Nothing&quot;							&amp; NL &amp; _
		&quot;  )&quot;									&amp; NL &amp; _
		&quot;}&quot; _
	).x
	
	
	&apos; What&apos;s the ctor of cDataCtor?
	&apos; Since again, cDataCtor is just a DataValue, it&apos;s constructor
	&apos; must be a data ctor as we have just described, ie have fields:
	&apos; - 1st a String for the name - which we don&apos;t care about
	&apos; - 2nd a three-elem list with types &quot;String&quot;, &quot;List_of_Type_Expr&quot;
	&apos;       and &quot;TDataTypeCtor&quot;
	&apos; - 3rd a a value of type &quot;TDataTypeCtor&quot; (still left empty)
	&apos; But that&apos;s just cDataCtor itself!
	cDataCtor.ctor = cDataCtor
	&apos; Also: once we worked out the typeCtor field (left empty but we
	&apos; already &quot;know&quot; it must be a value of type &quot;TDataTypeCtor&quot;)
	&apos; - it&apos;ll work just fine as the typeCtor for both cDataCtor, and
	&apos; its constructor. Proof: if it works for cDataCtor then it will
	&apos; work for cDataCtor :)
	
	&apos; But we&apos;ve created a problem with traversing the structure
	&apos; in order to create a string representation. 
	&apos; TODO: infinite regression in toString(cDataCtor) via .ctor
	&apos; In the special case at hand, DataCtor, it&apos;s enough to not
	&apos; go down the .ctor member if it&apos;s the same as the current
	&apos; instance. This is indicated by &quot;-&gt;self&quot;:
	cDataCtorStr = DataValue_genericToString(cDataCtor)
	assertEqual( _
		cDataCtorStr, _
		&quot;{ id: &quot; &amp; cDataCtor.id &amp; &quot;,&quot;			&amp; NL &amp; _
		&quot;  ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot; },&quot;	&amp; NL &amp; _
		&quot;  fields: Array(&quot;						&amp; NL &amp; _
		&quot;    &apos;DataCtor&apos;,&quot;						&amp; NL &amp; _
		&quot;    Array(&quot;							&amp; NL &amp; _
		&quot;      &apos;String&apos;,&quot;						&amp; NL &amp; _
		&quot;      &apos;List_of_TypeExpr&apos;,&quot;				&amp; NL &amp; _
		&quot;      &apos;TDataTypeCtor&apos;&quot;					&amp; NL &amp; _
		&quot;    ),&quot;								&amp; NL &amp; _
		&quot;    Nothing&quot;							&amp; NL &amp; _
		&quot;  )&quot;									&amp; NL &amp; _
		&quot;}&quot; _
	).x
	
	
	&apos; So what&apos;s the type of cDataCtor, ie what should we put in its 
	&apos; typeCtor field?
	&apos; It&apos;s the very simple data type
	&apos;   TDataCtor = DataCtor Str (List TypeExpr)
	&apos; The &quot;DataCtor&quot; on the rhs is just a data ctor as we have defined,
	&apos; and its name is &quot;DataCtor&quot;.
	&apos; On the lhs, however, it&apos;s a DataTypeCtor and there&apos;s &quot;T&quot; as a name
	&apos; prefix. We *could* have given it just the same name, but the &quot;T&quot; may
	&apos; help to reduce confusion (a little bit...).
	&apos; Now, a DataTypeCtor has
	&apos; - a name (a String)
	&apos; - an arity (an Integer), which is the nr of it&apos;s type parameters
	&apos; - zero or more DataCtors
	&apos; We can describe that by defining another data ctor - which itself,
	&apos; as we saw, has DataCtor as it&apos;s (data) constructor:
	Dim cDataTypeCtor As DataValue, arity As Integer
	cDataTypeCtor = _newDataValue(cDataCtor, Array( _
		&quot;DataTypeCtor&quot;, _
		Array(&quot;String&quot;, &quot;Integer&quot;, &quot;List_of_DataCtor&quot;), _
		Nothing _
	))
	&apos; Except for the typeCtor field - again left empty -
	&apos; what we&apos;ve just done will be bread-and-butter: create a value
	&apos; from a data ctor where the value&apos;s fields are filled with the
	&apos; argument values - provided they comply with the data ctor&apos;s
	&apos; argTypes.
	&apos; However, we cannot factor this pattern out until we&apos;ve completed
	&apos; the bootstrap.
	cDataTypeCtor = _newDataValue(cDataCtor, Array( _
		&quot;DataTypeCtor&quot;, _
		Array(&quot;String&quot;, &quot;Integer&quot;, &quot;List_of_DataCtor&quot;), _
		Nothing _
	))
	assertEqual(DataValue_same(ctorOf(cDataTypeCtor), cDataCtor), True).x

	&apos;TODO: Another repeated pattern is that of making DataValues that serve
	&apos; serve as DataCtor s:
	&apos;cTypeCtor = _mkDataCtor(&quot;DataTypeCtor&quot;, Nothing)
	&apos; This will stick in the repeated cDataCtor as .ctor member and
	&apos; Array(&quot;String&quot;, &quot;Integer&quot;, &quot;List_of_DataCtor&quot;) as argType field
	
	&apos; Let&apos;s inspect cDataTypeCtor.
	Dim cDataTypeCtorStr As String
	cDataTypeCtorStr = DataValue_genericToString(cDataTypeCtor)
	assertEqual( _
		cDataTypeCtorStr, _
		&quot;{ id: &quot; &amp; cDataTypeCtor.id &amp; &quot;,&quot;			&amp; NL &amp; _
		&quot;  ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot;,&quot;		&amp; NL &amp; _
		&quot;    ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot; },&quot;	&amp; NL &amp; _
		&quot;    fields: Array(&quot;						&amp; NL &amp; _
		&quot;      &apos;DataCtor&apos;,&quot;							&amp; NL &amp; _
		&quot;      Array(&quot;								&amp; NL &amp; _
		&quot;        &apos;String&apos;,&quot;							&amp; NL &amp; _
		&quot;        &apos;List_of_TypeExpr&apos;,&quot;				&amp; NL &amp; _
		&quot;        &apos;TDataTypeCtor&apos;&quot;					&amp; NL &amp; _
		&quot;      ),&quot;									&amp; NL &amp; _
		&quot;      Nothing&quot;								&amp; NL &amp; _
		&quot;    )&quot;										&amp; NL &amp; _
		&quot;  },&quot;										&amp; NL &amp; _
		&quot;  fields: Array(&quot;							&amp; NL &amp; _
		&quot;    &apos;DataTypeCtor&apos;,&quot;						&amp; NL &amp; _
		&quot;    Array(&quot;								&amp; NL &amp; _
		&quot;      &apos;String&apos;,&quot;							&amp; NL &amp; _
		&quot;      &apos;Integer&apos;,&quot;							&amp; NL &amp; _
		&quot;      &apos;List_of_DataCtor&apos;&quot;					&amp; NL &amp; _
		&quot;    ),&quot;									&amp; NL &amp; _
		&quot;    Nothing&quot;								&amp; NL &amp; _
		&quot;  )&quot;										&amp; NL &amp; _
		&quot;}&quot; _
	).x
	
	
	&apos; Now we&apos;ll make a value from that cDataTypeCtor, and that value
	&apos; will serve as the typeCtor for DataCtor:
	Dim tcDataCtor As DataValue
	tcDataCtor = _newDataValue(cDataTypeCtor, Array( _
		&quot;TDataCtor&quot;, _
		0, _
		Array(cDataCtor) _
	)
	&apos; Since cDataCtor is a (the only) data ctor of tcDataCtor, cDataCtor&apos;s
	&apos; &quot;typeCtor&quot; field points back to tcDataCtor. We could do this by indexing
	&apos; into the .fields member and writing it there, like so:
	&apos; cDataCtor.fields(DataCtor_typeCtor) = tcDataCtor
	&apos; But again, this pointer-fixing will occur everytime we create a new
	&apos; data type (and its constructors), so:
 	assertEqual(field(DataCtor_typeCtor, cDataCtor), Nothing).x
	&apos; was empty, now set it:
	_setTypeCtor(cDataCtor, tcDataCtor)
	&apos; now it&apos;s set:
	Dim it
	it = field(DataCtor_typeCtor, cDataCtor)
	assertEqual(DataValue_same(it, tcDataCtor), True).x
	&apos; we also have constants for accessing a DataTypeCtor&apos;s fields:	
	assertEqual( _
		field(DataTypeCtor_name, it), _
		field(DataTypeCtor_name, tcDataCtor) ).x
	assertEqual( _
		field(DataTypeCtor_arity, it), _
		field(DataTypeCtor_arity, tcDataCtor) ).x
	
	it = field(DataTypeCtor_dataCtors, tcDataCtor)
	assertEqual(isArray(it), True).x
	assertEqual(DataValue_same(it(0), cDataCtor), True).x
	
	Dim tcDatStr As String
	tcDatStr = DataValue_genericToString(tcDataCtor)
	
	&apos;msgbox(tcDatStr &amp; NL &amp; NL &amp; _
	assertEqual(tcDatStr, _
		&quot;{ id: &quot; &amp; tcDataCtor.id &amp; &quot;,&quot;				&amp; NL &amp; _
		&quot;  ctor: { id: &quot; &amp; cDataTypeCtor.id &amp; &quot;,&quot;	&amp; NL &amp; _
		&quot;    ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot;,&quot;		&amp; NL &amp; _
		&quot;      ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot; },&quot;	&amp; NL &amp; _
		&quot;      fields: Array(&quot;						&amp; NL &amp; _
		&quot;        &apos;DataCtor&apos;,&quot;						&amp; NL &amp; _
		&quot;        Array(&quot;							&amp; NL &amp; _
		&quot;          &apos;String&apos;,&quot;						&amp; NL &amp; _
		&quot;          &apos;List_of_TypeExpr&apos;,&quot;				&amp; NL &amp; _
		&quot;          &apos;TDataTypeCtor&apos;&quot;					&amp; NL &amp; _
		&quot;        ),&quot;								&amp; NL &amp; _
		&quot;        { id: &quot; &amp; tcDataCtor.id &amp; &quot; }&quot;		&amp; NL &amp; _
		&quot;      )&quot;									&amp; NL &amp; _
		&quot;    },&quot;									&amp; NL &amp; _
		&quot;    fields: Array(&quot;						&amp; NL &amp; _
		&quot;      &apos;DataTypeCtor&apos;,&quot;						&amp; NL &amp; _
		&quot;      Array(&quot;								&amp; NL &amp; _
		&quot;        &apos;String&apos;,&quot;							&amp; NL &amp; _
		&quot;        &apos;Integer&apos;,&quot;						&amp; NL &amp; _
		&quot;        &apos;List_of_DataCtor&apos;&quot;				&amp; NL &amp; _
		&quot;      ),&quot;									&amp; NL &amp; _
		&quot;      Nothing&quot;								&amp; NL &amp; _
		&quot;    )&quot;										&amp; NL &amp; _
		&quot;  },&quot;										&amp; NL &amp; _
		&quot;  fields: Array(&quot;							&amp; NL &amp; _
		&quot;    &apos;TDataCtor&apos;,&quot;							&amp; NL &amp; _
		&quot;    0,&quot;									&amp; NL &amp; _
		&quot;    Array(&quot;								&amp; NL &amp; _
		&quot;      { id: &quot; &amp; cDataCtor.id &amp; &quot; }&quot;		&amp; NL &amp; _
		&quot;    )&quot;										&amp; NL &amp; _
		&quot;  )&quot;										&amp; NL &amp; _
		&quot;}&quot; _
	).x
	
	&apos; What&apos;s still missing is a typeCtor for cDataTypeCtor. We already
	&apos; have a ctor to construct DataTypeCtor s: cDataTypeCtor. It&apos;ll
	&apos; be quite simple again, with only one data ctor (cDataTypeCtor),
	&apos; and name &quot;TDataTypeCtor&quot;:
	&apos; TDataTypeCtor = DataTypeCtor String Int (List DataCtor)
	Dim tcDataTypeCtor As DataValue
	tcDataTypeCtor = _newDataValue(cDataTypeCtor, Array( _
		&quot;TDataTypeCtor&quot;, _
		0, _
		Array(cDataTypeCtor) _
	))
	&apos; and fill in the back-pointer:
	_setTypeCtor(cDataTypeCtor, tcDataTypeCtor)
	assertEqual(DataValue_same( _
		field(DataCtor_typeCtor, cDataTypeCtor), _
		tcDataTypeCtor), True).x
	
	Dim tcDataTypeCtorStr As String
	tcDataTypeCtorStr = DataValue_genericToString(tcDataTypeCtor)
	
	&apos;msgbox(tcDataTypeCtorStr &amp; NL &amp; NL &amp; _
	assertEqual(tcDataTypeCtorStr, _
		&quot;{ id: &quot; &amp; tcDataTypeCtor.id &amp; &quot;,&quot;					&amp; NL &amp; _
		&quot;  ctor: { id: &quot; &amp; cDataTypeCtor.id &amp; &quot;,&quot;			&amp; NL &amp; _
		&quot;    ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot;,&quot;				&amp; NL &amp; _
		&quot;      ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot; },&quot;			&amp; NL &amp; _
		&quot;      fields: Array(&quot;								&amp; NL &amp; _
		&quot;        &apos;DataCtor&apos;,&quot;								&amp; NL &amp; _
		&quot;        Array(&quot;									&amp; NL &amp; _
		&quot;          &apos;String&apos;,&quot;								&amp; NL &amp; _
		&quot;          &apos;List_of_TypeExpr&apos;,&quot;						&amp; NL &amp; _
		&quot;          &apos;TDataTypeCtor&apos;&quot;							&amp; NL &amp; _
		&quot;        ),&quot;										&amp; NL &amp; _
		&quot;        { id: &quot; &amp; tcDataCtor.id &amp; &quot;,&quot;				&amp; NL &amp; _
		&quot;          ctor: { id: &quot; &amp; cDataTypeCtor.id &amp; &quot; },&quot;	&amp; NL &amp; _
		&quot;          fields: Array(&quot;							&amp; NL &amp; _
		&quot;            &apos;TDataCtor&apos;,&quot;							&amp; NL &amp; _
		&quot;            0,&quot;									&amp; NL &amp; _
		&quot;            Array(&quot;								&amp; NL &amp; _
		&quot;              { id: &quot; &amp; cDataCtor.id &amp; &quot; }&quot;		&amp; NL &amp; _
		&quot;            )&quot;										&amp; NL &amp; _
		&quot;          )&quot;										&amp; NL &amp; _
		&quot;        }&quot;											&amp; NL &amp; _
		&quot;      )&quot;											&amp; NL &amp; _
		&quot;    },&quot;											&amp; NL &amp; _
		&quot;    fields: Array(&quot;								&amp; NL &amp; _
		&quot;      &apos;DataTypeCtor&apos;,&quot;								&amp; NL &amp; _
		&quot;      Array(&quot;										&amp; NL &amp; _
		&quot;        &apos;String&apos;,&quot;									&amp; NL &amp; _
		&quot;        &apos;Integer&apos;,&quot;								&amp; NL &amp; _
		&quot;        &apos;List_of_DataCtor&apos;&quot;						&amp; NL &amp; _
		&quot;      ),&quot;											&amp; NL &amp; _
		&quot;      { id: &quot; &amp; tcDataTypeCtor.id &amp; &quot; }&quot;			&amp; NL &amp; _
		&quot;    )&quot;												&amp; NL &amp; _
		&quot;  },&quot;												&amp; NL &amp; _
		&quot;  fields: Array(&quot;									&amp; NL &amp; _
		&quot;    &apos;TDataTypeCtor&apos;,&quot;								&amp; NL &amp; _
		&quot;    0,&quot;											&amp; NL &amp; _
		&quot;    Array(&quot;										&amp; NL &amp; _
		&quot;      { id: &quot; &amp; cDataTypeCtor.id &amp; &quot; }&quot;			&amp; NL &amp; _
		&quot;    )&quot;												&amp; NL &amp; _
		&quot;  )&quot;												&amp; NL &amp; _
		&quot;}&quot; _
	).x
	
	&apos; We have now established a structure of DataValue s where every
	&apos; DataValue has a
	&apos;   - a .ctor member which was made by &quot;applying&quot; cDataCtor to some arguments 
	&apos;   - a type ctor associated to it, and that is the .ctor&apos;s typeCtor field
	&apos; With that we can make more concise String representations of DataValue s.
	assertEqual(DataValue_toString(tcDataTypeCtor), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;TDataTypeCtor&apos; 0 Array(DataTypeCtor))&quot;).x
	assertEqual(DataValue_toString(tcDataCtor), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;TDataCtor&apos; 0 Array(DataCtor))&quot;).x
	assertEqual(DataValue_toString(cDataTypeCtor), _
		&quot;(TDataCtor.DataCtor &apos;DataTypeCtor&apos; Array(&apos;String&apos;, &apos;Integer&apos;, &apos;List_of_DataCtor&apos;) TDataTypeCtor)&quot;).x
	assertEqual(DataValue_toString(cDataCtor), _
		&quot;(TDataCtor.DataCtor &apos;DataCtor&apos; Array(&apos;String&apos;, &apos;List_of_TypeExpr&apos;, &apos;TDataTypeCtor&apos;) TDataCtor)&quot;).x
	
	&apos; The List data type
	&apos; ------------------
	
	&apos; Let&apos;s go back to old data ctor cNil. It itself has got a proper
	&apos; constructor (cDataCtor) but no DataTypeCtor in field typeCtor:
	assertEqual(field(DataCtor_typeCtor, cNil), Nothing).x
	
	&apos; So let&apos;s make one:
	Dim tcList As DataValue
	tcList = _newDataValue(cDataTypeCtor, Array( _
		&quot;List&quot;, 1, Nothing _
	))
	_setTypeCtor(cNil, tcList)
	&apos; There are two things that are different from what we did before:
	&apos;   - the arity field is set to 1, rather than 0
	&apos;   - the dataCtors field is left empty
	&apos; The former is to say that List will have a type parameter,
	&apos; and the latter is because we will be using *a List* again
	&apos; for this field - and once we have it do the same to the other
	&apos; TDataTypeCtor s we have.
	&apos; But before we can do so we need another data ctor for List:
	Dim cCons As DataValue
	cCons = _newDataValue(cDataCtor, Array( _
		&quot;Cons&quot;, vNil, tcList _
	))
	&apos; There we have left empty the argTypes field, again because we
	&apos; a List itself there. But we already filled in the type ctor:
	assert_same(field(DataCtor_typeCtor, cCons), tcList).x
	
	&apos; With those two data ctors we can now make List values.
	&apos; We already made one from cNil : vNil. It represents the 
	&apos; empty List. But that is exactly the argTypes list that 
	&apos; we want for the 0-arity data ctor cNil.
	cNil.fields(DataCtor_argTypes) = vNil
	&apos; A singleton list that contains just the data ctor cCons is this:
	x = _newDataValue(cCons, Array(cCons, vNil))
	&apos; ...and the two-elem list that contains both data ctors, cNil and
	&apos; and cCons - which we want for tcList&apos;s dataCtors field:
	tcList.fields(DataTypeCtor_dataCtors) = _newDataValue( _
		cCons, Array(cNil, x) _
	)

	assertEqual(DataValue_toString(tcList), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;List&apos; 1 [Nil, Cons])&quot;).x
	assertEqual(DataValue_toString(cCons), _
		&quot;(TDataCtor.DataCtor &apos;Cons&apos; [] List)&quot;).x
	assertEqual(DataValue_toString(cNil), _
		&quot;(TDataCtor.DataCtor &apos;Nil&apos; [] List)&quot;).x
	
	
	&apos; Now, we had given cCons an empty argTypes list, which needs to be fixed.
	&apos; We will express Types as yet another data type:
	Dim tcType As DataValue
	tcType = _newDataValue(cDataTypeCtor, Array(&quot;Type&quot;, 0, vNil))
	Dim cStr As DataValue, vStr As DataValue
	cStr = _newDataValue(cDataCtor, Array(&quot;String&quot;, vNil, tcType))
	&apos; add to dataCtors
	tcType.fields(DataTypeCtor_dataCtors) = _newDataValue(cCons, Array( _
		cStr, _
		field(DataTypeCtor_dataCtors, tcType) _
	))
	assertEqual(DataValue_toString(tcType), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;Type&apos; 0 [String])&quot;).x
	assertEqual(DataValue_toString(cStr), _
		&quot;(TDataCtor.DataCtor &apos;String&apos; [] Type)&quot;).x
	vStr = _newDataValue(cStr, Array())
	assertEqual(DataValue_toString(vStr), _
		&quot;Type.String&quot;).x
	
	
	Dim cInt As DataValue, vInt As DataValue
	cInt = _newDataValue(cDataCtor, Array(&quot;Integer&quot;, vNil, tcType))
	&apos; add to dataCtors
	tcType.fields(DataTypeCtor_dataCtors) = _newDataValue(cCons, Array( _
		cInt, _
		field(DataTypeCtor_dataCtors, tcType) _
	))
	assertEqual(DataValue_toString(tcType), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;Type&apos; 0 [Integer, String])&quot;).x
	assertEqual(DataValue_toString(cInt), _
		&quot;(TDataCtor.DataCtor &apos;Integer&apos; [] Type)&quot;).x
	vInt = _newDataValue(cInt, Array())
	assertEqual(DataValue_toString(vInt), _
		&quot;Type.Integer&quot;).x
	
	
	Dim cParam As DataValue
	cParam = _newDataValue(cDataCtor, Array( _
		&quot;TypeParam&quot;, _
		_newDataValue(cCons, Array(vInt, vNil)), _
		tcType _
	))
	&apos; add to dataCtors
	tcType.fields(DataTypeCtor_dataCtors) = _newDataValue(cCons, Array( _
		cParam, _
		field(DataTypeCtor_dataCtors, tcType) _
	))
	assertEqual(DataValue_toString(tcType), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;Type&apos; 0 [TypeParam, Integer, String])&quot;).x
	Dim vParam As DataValue
	vParam = _newDataValue(cParam, Array(0))
	assertEqual(DataValue_toString(vParam), _
		&quot;(Type.TypeParam 0)&quot;).x
	vParam.str = &quot;a0&quot;
	
	Dim cApp As DataValue
	cApp = _newDataValue(cDataCtor, Array( _
		&quot;TypeApp&quot;, _
		_newDataValue(cCons, Array(tcDataTypeCtor, _newDataValue(cCons, Array(tcType, vNil)))), _
		tcType _
	))
	&apos; add to dataCtors
	tcType.fields(DataTypeCtor_dataCtors) = _newDataValue(cCons, Array( _
		cApp, _
		field(DataTypeCtor_dataCtors, tcType) _
	))
	assertEqual(DataValue_toString(tcType), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;Type&apos; 0 [TypeApp, TypeParam, Integer, String])&quot;).x
	assertEqual(DataValue_toString(cApp), _
		&quot;(TDataCtor.DataCtor &apos;TypeApp&apos; [TDataTypeCtor, Type] Type)&quot;).x
	Dim vApp As DataValue
	vApp = _newDataValue(cApp, Array(tcList, vParam))
	assertEqual(DataValue_toString(vApp), _
		&quot;(Type.TypeApp (TDataTypeCtor.DataTypeCtor &apos;List&apos; 1 [Nil, Cons]) (Type.TypeParam 0))&quot;).x
	vApp.str = &quot;List &quot; &amp; vParam.str
	
	&apos; With vParam and vApp we can fix the argTypes List of cCons:
	argTypes = _
		_newDataValue(cCons, Array(vParam, _
		_newDataValue(cCons, Array(vApp, _
		vNil))))
	cCons.fields(DataCtor_argTypes) = argTypes
	assertEqual(DataValue_toString(cCons), _
		&quot;(TDataCtor.DataCtor &apos;Cons&apos; [(TypeParam 0), (TypeApp List (TypeParam 0))] List)&quot;).x
	
	
	&apos; fix the rest
	vApp = _newDataValue(cApp, Array(tcList, tcType))
	argTypes = vNil
	argTypes = _newDataValue(cCons, Array(tcDataTypeCtor, argTypes))
	argTypes = _newDataValue(cCons, Array(vApp,  argTypes))
	argTypes = _newDataValue(cCons, Array(vStr,  argTypes))
	cDataCtor.fields(DataCtor_argTypes) = argTypes
	assertEqual(DataValue_toString(cDataCtor), _
		&quot;(TDataCtor.DataCtor &apos;DataCtor&apos; [String, (TypeApp List Type), TDataTypeCtor] TDataCtor)&quot;).x
	
	
	tcDataCtor.fields(DataTypeCtor_dataCtors) = _newDataValue( _
		cCons, Array(cDataCtor , vNil))
	assertEqual(DataValue_toString(tcDataCtor), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;TDataCtor&apos; 0 [DataCtor])&quot;).x


	vApp = _newDataValue(cApp, Array(tcList, tcDataCtor))
	argTypes = vNil
	argTypes = _newDataValue(cCons, Array(vApp, argTypes))
	argTypes = _newDataValue(cCons, Array(vInt,  argTypes))
	argTypes = _newDataValue(cCons, Array(vStr,  argTypes))
	cDataTypeCtor.fields(DataCtor_argTypes) = argTypes
	assertEqual(DataValue_toString(cDataTypeCtor), _
		&quot;(TDataCtor.DataCtor &apos;DataTypeCtor&apos; [String, Integer, (TypeApp List TDataCtor)] TDataTypeCtor)&quot;).x
	
	
	tcDataTypeCtor.fields(DataTypeCtor_dataCtors) = _newDataValue( _
		cCons, Array(cDataTypeCtor , vNil))
	assertEqual(DataValue_toString(tcDataTypeCtor), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;TDataTypeCtor&apos; 0 [DataTypeCtor])&quot;).x
	
	&apos; from that we can reach everything in the object graph:
	bootstrapTypes = tcType
End Function	


Function test_bootstrapTypes()
	Dim tcType As Variant
	tcType = Tp.TType
	assertEqual(isDataValue(tcType), True).x
	assertEqual(fieldCount( tcType), 3).x
	assertEqual(field(DataTypeCtor_name,  tcType), &quot;Type&quot;).x
	assertEqual(field(DataTypeCtor_arity, tcType), 0).x
	&apos; field dataCtors later

	Dim cDataTypeCtor As Variant
	cDataTypeCtor = Tp.DataTypeCtor
	assertEqual(isDataValue(cDataTypeCtor), True).x
	assertEqual(fieldCount( cDataTypeCtor), 3).x
	assertEqual(field(DataTypeCtor_name, cDataTypeCtor), &quot;DataTypeCtor&quot;).x
	&apos; field argTypes later
	assert_hasCtor(tcType, cDataTypeCtor).x
	&apos; different from anything else so far:
	refute_same(cDataTypeCtor, tcType).x

	Dim tcDataTypeCtor As Variant
	tcDataTypeCtor = Tp.TDataTypeCtor
	assertEqual(isDataValue(tcDataTypeCtor), True).x
	assertEqual(fieldCount( tcDataTypeCtor), 3).x
	assertEqual(field(DataTypeCtor_name, tcDataTypeCtor), &quot;TDataTypeCtor&quot;).x
	assertEqual(field(DataTypeCtor_arity, tcDataTypeCtor), 0).x
	&apos; field dataCtors later
	assert_hasCtor(    tcDataTypeCtor,	cDataTypeCtor).x
	assert_hasTypeCtor(cDataTypeCtor,	tcDataTypeCtor).x
	&apos; TODO: confirm that tcDataTypeCtor dataCtors(0) = cDataTypeCtor
	&apos; different from anything else so far:
	refute_same(tcDataTypeCtor, tcType).x
	refute_same(tcDataTypeCtor, cDataTypeCtor).x

	Dim cDataCtor As Variant
	cDataCtor = Tp.DataCtor
	assertEqual(isDataValue(cDataCtor), True).x
	assertEqual(fieldCount( cDataCtor), 3).x
	assertEqual(field(DataCtor_name, cDataCtor), &quot;DataCtor&quot;).x
	&apos; field argTypes later
	assert_hasCtor(cDataCtor, 	cDataCtor).x
	assert_hasCtor(cDataTypeCtor,	cDataCtor).x
	&apos; different from anything else so far:
	refute_same(cDataCtor, tcType).x
	refute_same(cDataCtor, cDataTypeCtor).x
	refute_same(cDataCtor, tcDataTypeCtor).x
	
	Dim tcDataCtor As Variant
	tcDataCtor = Tp.TDataCtor
	assertEqual(isDataValue(tcDataCtor), True).x
	assertEqual(fieldCount( tcDataCtor), 3).x
	assertEqual(field(DataTypeCtor_name,  tcDataCtor), &quot;TDataCtor&quot;).x
	assertEqual(field(DataTypeCtor_arity, tcDataCtor), 0).x
	&apos; field dataCtors later
	assert_hasCtor(tcDataCtor, 		cDataTypeCtor).x
	assert_hasCtor(cDataTypeCtor, 	cDataCtor).x
	assert_hasTypeCtor(cDataCtor, 	tcDataCtor).x
	&apos; TODO: confirm that tcDataCtor dataCtors(0) = cDataCtor
	&apos; different from anything else so far:
	refute_same(tcDataCtor, tcType).x
	refute_same(tcDataCtor, cDataTypeCtor).x
	refute_same(tcDataCtor, tcDataTypeCtor).x
	refute_same(tcDataCtor, cDataCtor).x
	
	Dim tcList As Variant
	tcList = Tp.List
	assertEqual(isDataValue(tcList), True).x
	assertEqual(fieldCount(tcList), 3).x
	assertEqual(field(DataTypeCtor_name,  tcList), &quot;List&quot;).x
	assertEqual(field(DataTypeCtor_arity, tcList), 1).x
	&apos; its dataCtors field is a List instance:
	assert_hasTypeCtor(ctorOf(field(DataTypeCtor_dataCtors, tcList)), tcList).x
	assert_hasCtor(    tcList, cDataTypeCtor).x
	&apos; different from anything else so far:
	refute_same(tcList, tcType).x
	refute_same(tcList, cDataTypeCtor).x
	refute_same(tcList, tcDataTypeCtor).x
	refute_same(tcList, cDataCtor).x
	refute_same(tcList, tcDataCtor).x

	&apos; dataCtors fields of the other type ctors so far:
	assert_hasTypeCtor(ctorOf(field(DataTypeCtor_dataCtors, tcType)), 			tcList).x
	assert_hasTypeCtor(ctorOf(field(DataTypeCtor_dataCtors, tcDataTypeCtor)), 	tcList).x
	assert_hasTypeCtor(ctorOf(field(DataTypeCtor_dataCtors, tcDataCtor)), 		tcList).x

	&apos; argTypes fields of the data ctors so far:
	assert_hasTypeCtor(ctorOf(field(DataCtor_argTypes, cDataTypeCtor)),			tcList).x
	assert_hasTypeCtor(ctorOf(field(DataCtor_argTypes, cDataCtor)),				tcList).x
	

	&apos;---- data ctors of TList
	
	Dim vNil As Variant, cNil As Variant
	cNil = Tp.List_Nil
	assertEqual(isDataValue(cNil), True).x
	assertEqual(fieldCount(cNil),  3).x
	assert_hasCtor(    cNil, cDataCtor	).x
	assert_hasTypeCtor(cNil, tcList		).x
	
	vNil = applyDC(cNil)
	assertEqual(isDataValue(vNil), True).x
	assertEqual(fieldCount(vNil),  0).x
	&apos; applying cNil again yields the same instance:
	assert_same(applyDC(cNil), vNil).x
	assert_hasCtor(vNil, cNil).x

	&apos; Let&apos;s not test cNil&apos;s name, rather confirm that cNil is a
	&apos; singleton data ctor: its argTypes field is the same as vNil!
	assert_same(field(DataCtor_argTypes, cNil), vNil).x
	
	
	&apos; nil returns the same instance again
	assertEqual(DataValue_same(nil, vNil), True).x
	cNil = ctorOf(vNil)

	&apos; TList&apos;s dataCtors field is non-nil:
	Dim ListCtors
	ListCtors = field(DataTypeCtor_dataCtors, tcList)
	refute_same(ListCtors, vNil).x

	&apos; vNil is different from anything else so far:
	refute_same(vNil, tcType).x
	refute_same(vNil, cDataTypeCtor).x
	refute_same(vNil, tcDataTypeCtor).x
	refute_same(vNil, cDataCtor).x
	refute_same(vNil, tcDataCtor).x
	refute_same(vNil, tcList).x
	&apos; cNil is different from anything else so far:
	refute_same(cNil, vNil).x
	refute_same(cNil, tcType).x
	refute_same(cNil, cDataTypeCtor).x
	refute_same(cNil, tcDataTypeCtor).x
	refute_same(cNil, cDataCtor).x
	refute_same(cNil, tcDataCtor).x
	refute_same(cNil, tcList).x
	
	Dim cCons As Variant
	cCons = Tp.List_Cons
	assertEqual(isDataValue(cCons), True).x
	assert_hasCtor(    cCons, cDataCtor	).x
	assert_hasTypeCtor(cCons, tcList	).x
	&apos; Let&apos;s not test the name, rather confirm that it has 
	&apos; a non-nil argTypes field and is itself the data ctor of that!
	refute_same(field(DataCtor_argTypes, cCons), vNil).x
	assert_hasCtor(field(DataCtor_argTypes, cCons), cCons).x
	&apos; TList&apos;s dataCtors field is a cons value:
	assert_hasCtor(ListCtors, cCons).x

	&apos; cCons is different from anything else so far:
	refute_same(cCons, tcType).x
	refute_same(cCons, cDataTypeCtor).x
	refute_same(cCons, tcDataTypeCtor).x
	refute_same(cCons, cDataCtor).x
	refute_same(cCons, tcDataCtor).x
	refute_same(cCons, tcList).x
	refute_same(cCons, vNil).x
	refute_same(cCons, cNil).x
	
	&apos;--- apply cons, test isNil
	Dim xs As Variant, ys As Variant
	xs = vNil
	assertEqual(isNil(xs), True).x
	
	xs = cons(vNil, vNil)
	assertEqual(isDataValue(xs), True).x
	assert_hasCtor(xs, cCons).x
	assertEqual(isNil(xs), False).x
	ys = cons(vNil, xs)
	assertEqual(isDataValue(ys), True).x
	assert_hasCtor(ys, cCons).x
	assertEqual(isNil(ys), False).x
	
	assertThrows(isNil, Array(Empty)).x
	assertThrows(isNil, Array(Nothing)).x
	assertThrows(isNil, Array(0)).x
	assertThrows(isNil, Array(&quot;&quot;)).x
	assertThrows(isNil, Array(cNil)).x &apos; ctor != value
	
	&apos;--- List_car, List_cdr, List_nth
	xs = cons(vNil, cons(vNil, vNil))
	ys = cons(vNil, xs)
	assert_same(car(ys), vNil).x
	assert_same(cdr(ys), xs).x
	assert_same(car(xs), vNil).x
	xs = cons(2, cons(3, vNil))
	ys = cons(1, xs)
	assertEqual(                  car(ys),		1).x
	assert_same(         	      cdr(ys),	   xs).x
	assertEqual(                  car(xs),		2).x	
	assertEqual(              car(cdr(ys)),		2).x	
	assertEqual(              car(cdr(xs)),		3).x	
	assertEqual(          car(cdr(cdr(ys))),	3).x	
	assertEqual(	isNil(cdr(cdr(cdr(ys)))), 	True).x	

	assertEqual(            cadr(ys),	2).x	
	assertEqual(            cadr(xs),	3).x	
	assertEqual(	isNil(  cddr(xs)),	True).x	
	assertEqual(           caddr(ys),	3).x	
	assertEqual(	isNil( cdddr(ys)),	True).x	

	assertEqual(nth(0, xs), 2).x
	assertEqual(nth(1, xs), 3).x
	assertEqual(nth(0, ys), 1).x
	assertEqual(nth(1, ys), 2).x
	assertEqual(nth(2, ys), 3).x

	&apos;--- List_length
	assertEqual(length(			    vNil), 		0).x
	assertEqual(length(		cons(0, vNil)), 	1).x
	assertEqual(length(cons(0, cons(0, vNil))), 	2).x

	&apos;assertEqual(isFn(Fn.length), 	True).x	&apos; from Fn object
	&apos;assertEqual(isFn(length), 	True).x	&apos; from 0-arg call
	&apos;assertEqual(arity(length), 1).x
	
	&apos;assertEqual(apply(length,					vNil), 	 0).x
	&apos;assertEqual(apply(length,			cons(0, vNil)),	 1).x
	&apos;assertEqual(apply(length,	cons(0, cons(0, vNil))), 2).x

	
	&apos;--- with List_length and List_nth, 
	&apos;    check dataCtors fields of data type ctors so far (TType later)
	Dim dataCtors
	dataCtors = field(DataTypeCtor_dataCtors,         tcDataTypeCtor)
	assertEqual(length(dataCtors), 1).x
	assert_same(nth(0, dataCtors), cDataTypeCtor).x
	
	dataCtors = field(DataTypeCtor_dataCtors,         tcDataCtor)
	assertEqual(length(dataCtors), 1).x
	assert_same(nth(0, dataCtors), cDataCtor).x
	
	dataCtors = field(DataTypeCtor_dataCtors,         tcList)
	assertEqual(length(dataCtors), 2).x
	assert_same(nth(0, dataCtors), cNil).x
	assert_same(nth(1, dataCtors), cCons).x
	
	
	&apos;--- data ctors of TType

	dataCtors = field(DataTypeCtor_dataCtors, tcType)
	assertEqual(length(dataCtors), 2).x
	Dim cParam	: cParam = Tp.TType_Param
	Dim cApp	: cApp	 = Tp.TType_App
	assert_same(nth(0, dataCtors), cApp).x
	assert_same(nth(1, dataCtors), cParam).x
	
	assert_hasTypeCtor(cParam, 	tcType).x
	assert_hasTypeCtor(cApp, 	tcType).x

	&apos;--- native types
	Dim nStr : nStr = Tp.Native_String
	Dim nInt : nInt = Tp.Native_Integer
	
	refute_same(nStr, nInt).x

	&apos;--- fix argument order for DataTypeCtor
	Dim argTypes, at
	argTypes = field(DataCtor_argTypes, cDataTypeCtor)
	assertEqual(length(argTypes), 3).x
	
	assert_same(nth(DataTypeCtor_name,			argTypes), nStr).x
	assert_same(nth(DataTypeCtor_arity, 		argTypes), nInt).x
	&apos; third argType should be (App TList TDataCtor) - later

	
	&apos;--- TType data ctor: Param (Ntv Int)
	assertEqual(isDataValue(cParam), True		).x
	assertEqual( fieldCount(cParam), 3			).x
	assert_hasTypeCtor(     cParam,  tcType		).x
	assert_hasCtor(			cParam,  cDataCtor	).x
	assertEqual(field(DataCtor_name,     cParam),  &quot;Param&quot;).x
	argTypes =  field(DataCtor_argTypes, cParam)
	assertEqual(length(argTypes), 1).x
	assert_same(nth(0, argTypes), nInt).x

	&apos;--- apply data ctor Param
	Dim vParam As Variant
	vParam = TypeParam(42)
	assertEqual(isDataValue(vParam),	True	).x
	assertEqual( fieldCount(vParam),	1		).x
	assert_hasCtor(         vParam,		cParam	).x
	assertEqual(field(0,	vParam),	42).x

	&apos;--- TType data ctor: App Type Type
	assertEqual(isDataValue(cApp), True		).x
	assertEqual( fieldCount(cApp), 3			).x
	assert_hasTypeCtor(     cApp,  tcType		).x
	assert_hasCtor(			cApp,  cDataCtor	).x
	assertEqual(field(DataCtor_name,     cApp),  &quot;App&quot;).x
	argTypes =  field(DataCtor_argTypes, cApp)
	assertEqual(length(argTypes), 2).x
	assert_same(nth(0, argTypes), tcType).x
	assert_same(nth(1, argTypes), tcType).x

	&apos;--- apply data ctor App
	Dim vApp As Variant
	vApp = TypeApp(tcList, nInt)
	assertEqual(isDataValue(vApp),	True	).x
	assertEqual( fieldCount(vApp),	2		).x
	assert_hasCtor(         vApp,	cApp	).x	

	assert_same(field(0,	vApp),	tcList).x
	assert_same(field(1,	vApp),	nInt).x
	
	&apos; TODO: make fn TypeApp return a TFn on 0 args
	&apos;assertThrows(TypeApp, Array(TList(nInt), nStr))
	&apos;assertThrows(TypeApp, Array(nInt, tcList))
	
	
	&apos;--- apply data ctor DataTypeCtor

	
	
	&apos;--- argTypes of DataCtor
	argTypes =  field(DataCtor_argTypes, cDataCtor)
	assertEqual(length(argTypes), 3).x
	assert_same(nth(0, argTypes), nStr).x
	assert_same(nth(2, argTypes), tcDataTypeCtor).x
	at = nth(1, argTypes)
	assert_hasCtor(at, cApp).x
	assert_same(TypeApp_typeFn(at),  tcList).x
	assert_same(TypeApp_typeArg(at), tcType).x

	&apos;--- argTypes of DataTypeCtor
	argTypes =  field(DataCtor_argTypes, cDataTypeCtor)
	assertEqual(length(argTypes), 3).x
	assert_same(nth(0, argTypes), nStr).x
	assert_same(nth(1, argTypes), nInt).x
	at = nth(2, argTypes)
	assert_hasCtor(at, cApp).x
	assert_same(TypeApp_typeFn(at),  tcList).x
	assert_same(TypeApp_typeArg(at), tcDataCtor).x

	&apos;--- argTypes of Native
	argTypes =  field(DataCtor_argTypes, Tp.Native)
	assertEqual(length(argTypes), 3).x
	assert_same(nth(0, argTypes), nStr).x
	assert_same(nth(1, argTypes), nStr).x
	assert_same(nth(2, argTypes), nInt).x

	&apos;--- argTypes of List.Nil
	argTypes =  field(DataCtor_argTypes, cNil)
	assertEqual(length(argTypes), 0).x
	&apos;--- argTypes of List.Cons
	argTypes =  field(DataCtor_argTypes, cCons)
	assertEqual(length(argTypes), 2).x
	at = nth(0, argTypes)
	assert_hasCtor(at, cParam).x
	assertEqual(TypeParam_index(at), 0).x
	at = nth(1, argTypes)
	assert_hasCtor(at, cApp).x
	assert_same(TypeApp_typeFn(at),  	tcList).x
	assert_hasCtor(TypeApp_typeArg(at), cParam).x
	assertEqual(TypeParam_index(TypeApp_typeArg(at)), 0).x
	

End Function

	
Function test_Type_typeOf(Optional missing)
	If Not isMissing(missing) Then
		croak(&quot;test_Type_typeOf: must NOT pass argument!&quot;)
	End If
	
	&apos; VarType returns an Integer:
	assertEqual(VarType(VarType(Empty)), VarType(CInt(0))).x
	
	assertEqual(VarType(Empty),		0).x
	&apos;assertEqual(VarType(?),		1).x	&apos; doc says &quot;Null&quot; (?!)
	assertEqual(VarType(CInt(0)),	2).x
	assertEqual(VarType(CLng(0)),	3).x
	assertEqual(VarType(CSng(0)),	4).x
	assertEqual(VarType(CDbl(0)),	5).x
	&apos;assertEqual(VarType(?),	6).x		&apos; left empty in doc
	assertEqual(VarType(Date),		7).x
	assertEqual(VarType(&quot;string&quot;),	8).x
	assertEqual(VarType(Nothing),	9).x
	assertEqual(VarType(missing),	10).x
	assertEqual(VarType(True),		11).x
	&apos;assertEqual(VarType(?),		12).x	&apos; doc says &quot;Variant&quot;...
	assertEqual(VarType(CByte(0)),	17).x	&apos; not mentioned in doc
	
	Const vtArr = &amp;H2000
	Dim variantArray(0 To 3) As Variant
	assertEqual(VarType(variantArray),	vtArr + 12).x
	assertEqual(VarType(Array(1, 2)),	vtArr + 12).x
	Dim byteArray(0 To 3) As Byte
	assertEqual(VarType(byteArray),		vtArr + 17).x
	Dim intArray(0 To 3) As Integer
	assertEqual(VarType(intArray),		vtArr +  2).x
	Dim lngArray(0 To 3) As Long
	assertEqual(VarType(lngArray),		vtArr +  3).x
	Dim sngArray(0 To 3) As Single
	assertEqual(VarType(sngArray),		vtArr +  4).x
	Dim dblArray(0 To 3) As Double
	assertEqual(VarType(dblArray),		vtArr +  5).x
	Dim dateArray(0 To 3) As Date
	assertEqual(VarType(dateArray),		vtArr +  7).x
	Dim strArray(0 To 3) As String
	assertEqual(VarType(strArray),		vtArr +  8).x
	Dim objArray(0 To 3) As Object
	assertEqual(VarType(objArray),		vtArr +  9).x
	Dim boolArray(0 To 3) As Boolean
	assertEqual(VarType(boolArray),		vtArr + 11).x
	
	&apos; ATTENTION cByte, cInt, ... are BASIC *keywords*!
	Dim nByte	 : nByte	= Tp.Native_Byte
	Dim nInt	 : nInt		= Tp.Native_Integer
	Dim nLng	 : nLng		= Tp.Native_Long
	Dim nSng	 : nSng		= Tp.Native_Single
	Dim nDbl	 : nDbl		= Tp.Native_Double
	Dim nStr	 : nStr		= Tp.Native_String
	Dim nBool	 : nBool	= Tp.Native_Boolean
	Dim nObj 	 : nObj		= Tp.Native_Object
	Dim nEmpty	 : nEmpty	= Tp.Native_Empty
	Dim nDate	 : nDate	= Tp.Native_Date
	Dim nArray	 : nArray	= Tp.Native_Array
	Dim nVariant : nVariant	= Tp.Native_Variant
	
	assert_same(typeOf(Nothing),		nObj).x
	assert_same(typeOf(Empty),			nEmpty).x
	assert_same(typeOf(True),			nBool).x
	assert_same(typeOf(False),			nBool).x
	assert_same(typeOf(&quot;&quot;),				nStr).x
	assert_same(typeOf(&quot;blah&quot;),			nStr).x
	assert_same(typeOf(CByte(0)),		nByte).x
	assert_same(typeOf( 0),				nInt).x
	assert_same(typeOf( 1),				nInt).x
	assert_same(typeOf(-1),				nInt).x
	assert_same(typeOf(CLng(0)),		nLng).x
	assert_same(typeOf(CSng(0)),		nSng).x
	assert_same(typeOf(3.1415),			nDbl).x
	assert_same(typeOf(CDbl(0)),		nDbl).x
	assert_same(typeOf(Date),			nDate).x
	assert_same(typeOf(Array()),		nArray).x

	Dim o As Object, act As Variant
	
	&apos; an object without member .ctor:
	o = New TTest_TyName
	assert_same(typeOf(o), nObj).x
	o.tyname = &quot;foo&quot;
	assert_same(typeOf(o), nObj).x

	&apos; an object with (invalid) member .ctor: ~&gt; Native_Object
	o = New TTest_Ctor
	o.ctor = Empty		: assert_same(typeOf(o), nObj).x
	o.ctor = Nothing	: assert_same(typeOf(o), nObj).x
	o.ctor = True		: assert_same(typeOf(o), nObj).x
	o.ctor = False		: assert_same(typeOf(o), nObj).x
	o.ctor = &quot;&quot;			: assert_same(typeOf(o), nObj).x
	o.ctor = &quot;foo&quot;		: assert_same(typeOf(o), nObj).x
	o.ctor =  0			: assert_same(typeOf(o), nObj).x
	o.ctor =  1			: assert_same(typeOf(o), nObj).x
	o.ctor = -1			: assert_same(typeOf(o), nObj).x
	o.ctor = 3.1415		: assert_same(typeOf(o), nObj).x
	o.ctor = Array()	: assert_same(typeOf(o), nObj).x
	
	&apos; even a a data value as .ctor but not something
	&apos; that has itself .ctor = DataCtor:
	o.ctor = Tp.List	: assert_same(typeOf(o), nObj).x
	
	&apos; data values:
	assert_same(typeOf(Tp.DataTypeCtor),	Tp.TDataCtor).x
	assert_same(typeOf(Tp.TDataTypeCtor),	Tp.TDataTypeCtor).x

	assert_same(typeOf(Tp.DataCtor),		Tp.TDataCtor).x
	assert_same(typeOf(Tp.TDataCtor),		Tp.TDataTypeCtor).x
	
	assert_same(typeOf(Tp.TType),		Tp.TDataTypeCtor).x
	assert_same(typeOf(Tp.TType_App),	Tp.TDataCtor).x
	assert_same(typeOf(Tp.TType_Param),	Tp.TDataCtor).x
		
	assert_same(typeOf(Tp.Native),		Tp.TDataCtor).x
	assert_same(typeOf(Tp.TNative),		Tp.TDataTypeCtor).x
	assert_same(typeOf(nByte),			Tp.TNative).x
	assert_same(typeOf(nInt),			Tp.TNative).x
	assert_same(typeOf(nLng),			Tp.TNative).x
	assert_same(typeOf(nSng),			Tp.TNative).x
	assert_same(typeOf(nDbl),			Tp.TNative).x
	assert_same(typeOf(nStr),			Tp.TNative).x
	assert_same(typeOf(nBool),			Tp.TNative).x
	assert_same(typeOf(nEmpty),			Tp.TNative).x
	assert_same(typeOf(nObj),			Tp.TNative).x
	assert_same(typeOf(nDate),			Tp.TNative).x
	assert_same(typeOf(nArray),			Tp.TNative).x
	assert_same(typeOf(nVariant),		Tp.TNative).x
	
	Dim cNil  : cNil  = Tp.List_Nil
	Dim cCons : cCons = Tp.List_Cons
	
	assert_same(typeOf(Tp.List),	Tp.TDataTypeCtor).x
	assert_same(typeOf(cNil),		Tp.TDataCtor).x
	assert_same(typeOf(cCons),		Tp.TDataCtor).x

	Dim vNil : vNil = field(DataCtor_argTypes, cNil)
	assert_same(typeOf(vNil),	Tp.List).x
	Dim vCons : vCons = field(DataCtor_argTypes, cCons)
	assert_same(typeOf(vCons),	Tp.List).x
End Function


Function test_Type_typeStr()
	assertEqual(typeStr(Nothing),		&quot;Object&quot;).x
	assertEqual(typeStr(Empty),			&quot;Empty&quot;).x
	assertEqual(typeStr(True),			&quot;Boolean&quot;).x
	assertEqual(typeStr(False),			&quot;Boolean&quot;).x
	assertEqual(typeStr(&quot;&quot;),			&quot;String&quot;).x
	assertEqual(typeStr(&quot;blah&quot;),		&quot;String&quot;).x
	assertEqual(typeStr(CByte(0)),		&quot;Byte&quot;).x
	assertEqual(typeStr( 0),			&quot;Integer&quot;).x
	assertEqual(typeStr( 1),			&quot;Integer&quot;).x
	assertEqual(typeStr(-1),			&quot;Integer&quot;).x
	assertEqual(typeStr(CLng(0)),		&quot;Long&quot;).x
	assertEqual(typeStr(CSng(0)),		&quot;Single&quot;).x
	assertEqual(typeStr(3.1415),		&quot;Double&quot;).x
	assertEqual(typeStr(CDbl(0)),		&quot;Double&quot;).x
	assertEqual(typeStr(Date),			&quot;Date&quot;).x
	
	&apos; arrays
	
	Dim byteArray() As Byte
	assertEqual(typeName(byteArray),	&quot;Byte()&quot;).x
	assertEqual(typeStr(byteArray),		&quot;Array&quot;).x
	
	Dim intArray() As Integer
	assertEqual(typeName(intArray),		&quot;Integer()&quot;).x
	assertEqual(typeStr(intArray),		&quot;Array&quot;).x


	assertEqual(typeName(Array()),		&quot;Variant()&quot;).x
	assertEqual(typeStr(Array()),		&quot;Array&quot;).x
	Dim variantArray() As Variant
	assertEqual(typeName(variantArray),	&quot;Variant()&quot;).x
	assertEqual(typeStr(variantArray),	&quot;Array&quot;).x
	
	&apos; objects
	
	Dim t1 As New TTest_NoTyName
	assertEqual(typeStr(t1), &quot;Object&quot;).x

	Dim t2 As New TTest_TyName
	t2.tyname = &quot;foobar&quot;
	assertEqual(typeStr(t2), &quot;Object/foobar&quot;).x
	
	&apos; typeStr of a fn object
	assertEqual(typeStr(typeOf), &quot;Object/TFn&quot;).x
	
	
	&apos; data values
	
	assertEqual(typeStr(Tp.DataTypeCtor), 	&quot;Data/TDataCtor&quot;).x
	assertEqual(typeStr(Tp.TDataTypeCtor),	&quot;Data/TDataTypeCtor&quot;).x

	assertEqual(typeStr(Tp.DataCtor),		&quot;Data/TDataCtor&quot;).x
	assertEqual(typeStr(Tp.TDataCtor),		&quot;Data/TDataTypeCtor&quot;).x
		
	assertEqual(typeStr(Tp.TType),			&quot;Data/TDataTypeCtor&quot;).x
	assertEqual(typeStr(Tp.TType_App),		&quot;Data/TDataCtor&quot;).x
	assertEqual(typeStr(Tp.TType_Param),	&quot;Data/TDataCtor&quot;).x
		
	assertEqual(typeStr(Tp.Native),			&quot;Data/TDataCtor&quot;).x
	assertEqual(typeStr(Tp.TNative),		&quot;Data/TDataTypeCtor&quot;).x
	assertEqual(typeStr(Tp.Native_Byte),	&quot;Data/TNative&quot;).x
	assertEqual(typeStr(Tp.Native_Integer),	&quot;Data/TNative&quot;).x
	assertEqual(typeStr(Tp.Native_Long),	&quot;Data/TNative&quot;).x
	assertEqual(typeStr(Tp.Native_Single),	&quot;Data/TNative&quot;).x
	assertEqual(typeStr(Tp.Native_Double),	&quot;Data/TNative&quot;).x
	assertEqual(typeStr(Tp.Native_String),	&quot;Data/TNative&quot;).x
	assertEqual(typeStr(Tp.Native_Boolean),	&quot;Data/TNative&quot;).x
	assertEqual(typeStr(Tp.Native_Empty),	&quot;Data/TNative&quot;).x
	assertEqual(typeStr(Tp.Native_Object),	&quot;Data/TNative&quot;).x
	assertEqual(typeStr(Tp.Native_Date),	&quot;Data/TNative&quot;).x
	assertEqual(typeStr(Tp.Native_Array),	&quot;Data/TNative&quot;).x
	assertEqual(typeStr(Tp.Native_Variant),	&quot;Data/TNative&quot;).x
	
	&apos; list
	
	Dim a
	a = TList	&apos; the data type ctor
	assertEqual(typeStr(a), &quot;Data/TDataTypeCtor&quot;).x
	a = Tp.List	&apos; the data type ctor
	assertEqual(typeStr(a), &quot;Data/TDataTypeCtor&quot;).x
	a = TList	&apos; the data type ctor
	assertEqual(typeStr(a), &quot;Data/TDataTypeCtor&quot;).x
	a = TList(Tp.Native_Integer)
	&apos; the applied data type ctor is a TypeApp, hence:
	assertEqual(typeStr(a), &quot;Data/Type&quot;).x
	
	a = Tp.List_Nil	&apos; the data ctor
	assertEqual(typeStr(a), &quot;Data/TDataCtor&quot;).x
	a = nil	&apos; returns the singleton *value*
	assertEqual(typeStr(a), &quot;Data/List&quot;).x
	&apos;assertEqual(typeStr(a), &quot;Data/[a0]&quot;).x	&apos; TODO: typeStr for List
	
	a = Tp.List_Cons	&apos; the data ctor
	assertEqual(typeStr(a), &quot;Data/TDataCtor&quot;).x
	a = cons(nil, nil)	&apos; a cons value
	assertEqual(typeStr(a), &quot;Data/List&quot;).x
	&apos;assertEqual(typeStr(a), &quot;Data/[[a0]]&quot;).x	&apos; TODO: typeStr for List
	
End Function

Function test_Type_isType
	assertEqual(isType(Tp.TDataTypeCtor),			True).x
	assertEqual(isType(Tp.DataTypeCtor),			False).x
	assertEqual(isType(Tp.TDataCtor),				True).x
	assertEqual(isType(Tp.DataCtor),				False).x
	assertEqual(isType(Tp.TNative),					True).x
	assertEqual(isType(Tp.Native),					False).x
	assertEqual(isType(Tp.TType),					True).x
	assertEqual(isType(Tp.TType_Param),				False).x
	assertEqual(isType(TypeParam(0)),				True).x
	assertEqual(isType(Tp.TType_App),				False).x
	assertEqual(isType(TypeApp(TList, Tp.TType)),	True).x
	
	assertEqual(isType(Tp.Native_Boolean),	True).x
	assertEqual(isType(Tp.Native_Byte),		True).x
	assertEqual(isType(Tp.Native_Integer),	True).x
	assertEqual(isType(Tp.Native_Long),		True).x
	assertEqual(isType(Tp.Native_Single),	True).x
	assertEqual(isType(Tp.Native_Double),	True).x
	assertEqual(isType(Tp.Native_String),	True).x

	assertEqual(isType(Tp.Native_Object),	True).x
	assertEqual(isType(Tp.Native_Empty),	True).x
	assertEqual(isType(Tp.Native_Array),	True).x
	assertEqual(isType(Tp.Native_Date),		True).x
	assertEqual(isType(Tp.Native_Variant),	True).x
	
	&apos; unapplied List type ctor ??
	assertEqual(isType(Tp.List),				True).x
	assertEqual(isType(TList(Tp.Native_Long)),	True).x
	assertEqual(isType(Tp.List_Nil),			False).x
	assertEqual(isType(nil),					False).x
	assertEqual(isType(Tp.List_Cons),			False).x
	assertEqual(isType(cons(1, nil)),			False).x
	assertEqual(isType(List()),					False).x
	assertEqual(isType(List(1)),				False).x
	assertEqual(isType(List(1, 2)),				False).x

	assertEqual(isType(&quot;&quot;),				False).x
	assertEqual(isType(&quot;a&quot;),			False).x
	assertEqual(isType(&quot;foobar&quot;),		False).x
	assertEqual(isType(Nothing),		False).x
	assertEqual(isType(Empty),			False).x
	assertEqual(isType(True),			False).x
	assertEqual(isType(False),			False).x
	assertEqual(isType( 0),				False).x
	assertEqual(isType( 1),				False).x
	assertEqual(isType(-1),				False).x
	assertEqual(isType( 32766),			False).x &apos;0x7FFE
	assertEqual(isType( 32767),			False).x &apos;0x7FFF
	assertEqual(isType( 32768),			False).x &apos;0x8000 (!)
	assertEqual(isType( 65534),			False).x &apos;0xFFFE
	assertEqual(isType( 65535),			False).x &apos;0xFFFF
	assertEqual(isType( 65536),			False).x &apos;0x80000
	assertEqual(isType(-32766),			False).x &apos;0x8002
	assertEqual(isType(-32767),			False).x &apos;0x8001
	assertEqual(isType(-32768),			False).x &apos;0x8000
	assertEqual(isType(-32769),			False).x &apos;0x17FFF (!)
	assertEqual(isType(-65534),			False).x &apos;0xFFFE
	assertEqual(isType(-65535),			False).x &apos;0xFFFF
	assertEqual(isType(-65536),			False).x &apos;0x80000
	assertEqual(isType(3.14),			False).x
	assertEqual(isType(Array()),		False).x
	assertEqual(isType(Array(42)),		False).x
	assertEqual(isType(Array(42)),		False).x
	
	assertEqual(isType(CBool(0)),		False).x
	assertEqual(isType(CByte(0)),		False).x
	assertEqual(isType(CInt(0)),		False).x
	assertEqual(isType(CLng(0)),		False).x
	assertEqual(isType(CSng(0)),		False).x
	assertEqual(isType(CDbl(0)),		False).x
	assertEqual(isType(Date),			False).x

End Function

Function test_Type_hasType
	assertEqual(hasType(DataTypeCtor,	TDataCtor), 	True).x
	assertEqual(hasType(DataCtor,		TDataCtor), 	True).x
	assertEqual(hasType(TDataCtor,		TDataTypeCtor), True).x
	assertEqual(hasType(TDataTypeCtor,	TDataTypeCtor), True).x
	assertEqual(hasType(TType, 			TDataTypeCtor), True).x
		
	assertEqual(hasType(DataCtor,		TDataTypeCtor), False).x
	assertEqual(hasType(DataTypeCtor,	TDataTypeCtor), False).x

	assertThrows(hasType, Array(TDataCtor, DataCtor)).x
	
	assertEqual(hasType(Tp.List,		TType),			True).x
	assertEqual(hasType(Tp.List,		TDataTypeCtor),	True).x
	assertEqual(hasType(Tp.List,		TDataCtor),		False).x
	assertEqual(hasType(Tp.List_Nil,	TDataCtor),		True).x
	assertEqual(hasType(Tp.List_Cons,	TDataCtor),		True).x
	assertEqual(hasType(Tp.List_Nil,	TType),			False).x
	assertEqual(hasType(Tp.List_Cons,	TType),			False).x
	assertEqual(hasType(List(0),		TType),			False).x
	assertEqual(hasType(List(0, &quot;one&quot;),	TType),			False).x
	
	Dim a		: a		= TypeParam(0)
	Dim nBool	: nBool	= Tp.Native_Boolean
	Dim nByte	: nByte	= Tp.Native_Byte
	Dim nInt	: nInt	= Tp.Native_Integer
	Dim nLong	: nLong	= Tp.Native_Long
	Dim nStr	: nStr	= Tp.Native_String
	Dim nVar	: nVar	= Tp.Native_Variant
		
	assertEqual(hasType(a,					TType), True).x
	assertEqual(hasType(TypeApp(TList, a),	TType), True).x
	assertEqual(hasType(TList(a),			TType), True).x
	assertEqual(hasType(TList(nInt),		TType), True).x
	
	assertEqual(hasType(nBool,				Tp.TNative), True).x
	assertEqual(hasType(nByte,				Tp.TNative), True).x
	assertEqual(hasType(nInt,				Tp.TNative), True).x
	assertEqual(hasType(nLong,				Tp.TNative), True).x
	assertEqual(hasType(nStr,				Tp.TNative), True).x
	assertEqual(hasType(nVar,				Tp.TNative), True).x

	assertEqual(hasType(nBool,				TType), True).x
	assertEqual(hasType(nByte,				TType), True).x
	assertEqual(hasType(nInt,				TType), True).x
	assertEqual(hasType(nLong,				TType), True).x
	assertEqual(hasType(nStr,				TType), True).x
	assertEqual(hasType(nVar,				TType), True).x
	
	
	assertEqual(hasType(&quot;&quot;,				nStr),	 True).x
	assertEqual(hasType(&quot;a&quot;,			nStr),	 True).x
	assertEqual(hasType(&quot;foobar&quot;,		nStr),	 True).x
	assertEqual(hasType(Nothing,		nStr),	False).x
	assertEqual(hasType(Empty,			nStr),	False).x
	assertEqual(hasType(True,			nStr),	False).x
	assertEqual(hasType(False,			nStr),	False).x
	assertEqual(hasType(0,				nStr),	False).x
	assertEqual(hasType(1,				nStr),	False).x
	assertEqual(hasType(3.14,			nStr),	False).x
	assertEqual(hasType(Array(),		nStr),	False).x
	assertEqual(hasType(Array(42),		nStr),	False).x
	assertEqual(hasType(Array(42),		nStr),	False).x
	assertEqual(hasType(TList,			nStr),	False).x
	assertEqual(hasType(Tp.List_Nil,	nStr),	False).x
	assertEqual(hasType(Tp.List_Cons,	nStr),	False).x
	assertEqual(hasType(nil,			nStr),	False).x
	assertEqual(hasType(List(),			nStr),	False).x
	assertEqual(hasType(List(1),		nStr),	False).x
	assertEqual(hasType(List(1, 2),		nStr),	False).x

	assertEqual(hasType(&quot;&quot;,				nInt),	False).x
	assertEqual(hasType(&quot;a&quot;,			nInt),	False).x
	assertEqual(hasType(&quot;foobar&quot;,		nInt),	False).x
	assertEqual(hasType(Nothing,		nInt),	False).x
	assertEqual(hasType(Empty,			nInt),	False).x
	assertEqual(hasType(True,			nInt),	False).x
	assertEqual(hasType(False,			nInt),	False).x
	assertEqual(hasType( 0,				nInt),	 True).x
	assertEqual(hasType( 1,				nInt),	 True).x
	assertEqual(hasType(-1,				nInt),	 True).x
	assertEqual(hasType( 32766,			nInt),	 True).x &apos;0x7FFE
	assertEqual(hasType( 32767,			nInt),	 True).x &apos;0x7FFF
	assertEqual(hasType( 32768,			nInt),	False).x &apos;0x8000 (!)
	assertEqual(hasType( 65534,			nInt),	False).x &apos;0xFFFE
	assertEqual(hasType( 65535,			nInt),	False).x &apos;0xFFFF
	assertEqual(hasType( 65536,			nInt),	False).x &apos;0x80000
	assertEqual(hasType(-32766,			nInt),	 True).x &apos;0x8002
	assertEqual(hasType(-32767,			nInt),	 True).x &apos;0x8001
	assertEqual(hasType(-32768,			nInt),	 True).x &apos;0x8000
	assertEqual(hasType(-32769,			nInt),	False).x &apos;0x17FFF (!)
	assertEqual(hasType(-65534,			nInt),	False).x &apos;0xFFFE
	assertEqual(hasType(-65535,			nInt),	False).x &apos;0xFFFF
	assertEqual(hasType(-65536,			nInt),	False).x &apos;0x80000
	assertEqual(hasType(3.14,			nInt),	False).x
	assertEqual(hasType(Array(),		nInt),	False).x
	assertEqual(hasType(Array(42),		nInt),	False).x
	assertEqual(hasType(Array(42),		nInt),	False).x
	assertEqual(hasType(TList,			nInt),	False).x
	assertEqual(hasType(Tp.List_Nil,	nInt),	False).x
	assertEqual(hasType(Tp.List_Cons,	nInt),	False).x
	assertEqual(hasType(nil,			nInt),	False).x
	assertEqual(hasType(List(),			nInt),	False).x
	assertEqual(hasType(List(1),		nInt),	False).x
	assertEqual(hasType(List(1, 2),		nInt),	False).x
	
	&apos; lists
	
	assertEqual(hasType(nil,			TList(a)),		True).x
	assertEqual(hasType(nil,			TList(nInt)),	True).x
	assertEqual(hasType(nil,			TList(nStr)),	True).x
	assertEqual(hasType(nil,			TList(nVar)),	True).x
	
	assertEqual(hasType(List(1),		TList(a)),		True).x
	assertEqual(hasType(List(1),		TList(nInt)),	True).x

	&apos; TODO: hasType(..., TList) [unapplied TList]?
	assertEqual(hasType(List(1),		TList),		True).x
	
	&apos; NYI
	&apos;assertEqual(hasType(List(1),		TList(nStr)),	False).x
	&apos;assertEqual(hasType(List(1),		TList(nVar)),	False).x

	&apos; NYI
	&apos;assertEqual(hasType(3, TypeParam(0)), True).x
	
	
	assertEqual(hasType(3,		TList(nStr)), False).x
	assertEqual(hasType(&quot;foo&quot;,	TList(nStr)), False).x


	&apos; depending on isSubtypeOf
	
	assertEqual(hasType(TDataCtor,		TType), True).x
	assertEqual(hasType(TDataTypeCtor,	TType), True).x
	assertEqual(hasType(TList,			TType), True).x
	assertEqual(hasType(TType,			TType), True).x

	&apos;assertEqual(isSubtypeOf(TDataCtor,		TType), False).x
	&apos;assertEqual(isSubtypeOf(TDataTypeCtor,	TType), True).x
	&apos;assertEqual(isSubtypeOf(TList,			TType), False).x
	&apos;assertEqual(isSubtypeOf(TString,		TType), True).x
	&apos;assertEqual(isSubtypeOf(TInteger,		TType), True).x

End Function

Function test_Type_dot_str()
	assertEqual(TDataTypeCtor.str,	&quot;TDataTypeCtor&quot;).x
	assertEqual(TDataCtor.str,		&quot;TDataCtor&quot;).x
	assertEqual(TType.str, 			&quot;Type&quot;).x
	assertEqual(TList.str,			&quot;List&quot;).x


	&apos;assertEqual(DataTypeCtor.str,	&quot;TDataTypeCtor.DataTypeCtor&quot;).x
	assertEqual(DataTypeCtor.str,	&quot;DataTypeCtor :: Str -&gt; Int -&gt; (List TDataCtor) -&gt; TDataTypeCtor&quot;).x
	
	&apos;assertEqual(DataCtor.str,		&quot;TDataCtor.DataCtor&quot;).x
	assertEqual(DataCtor.str,		&quot;DataCtor :: Str -&gt; (List Type) -&gt; TDataTypeCtor -&gt; TDataCtor&quot;).x
	
	Dim vNil, cNil, cCons
	vNil = nil
	cNil = ctorOf(vNil)
	cCons = Tp.List_Cons
	assertEqual(vNil.str,		&quot;[]&quot;).x
	&apos;assertEqual(cNil.str,		&quot;List.Nil&quot;).x
	assertEqual(cNil.str,		&quot;Nil :: List a0&quot;).x
	&apos;assertEqualcCons.str,	&quot;List.Cons&quot;).x
	assertEqual(cCons.str,	&quot;Cons :: a0 -&gt; (List a0) -&gt; (List a0)&quot;).x
	
	Dim cNtv	: cNtv	= Tp.Native
	Dim nBool	: nBool	= Tp.Native_Boolean
	Dim nByte	: nByte	= Tp.Native_Byte
	Dim nInt	: nInt	= Tp.Native_Integer
	Dim nLong	: nLong	= Tp.Native_Long
	Dim nSng	: nSng	= Tp.Native_Single
	Dim nDbl	: nDbl	= Tp.Native_Double
	Dim nStr	: nStr	= Tp.Native_String
	Dim nDate	: nDate	= Tp.Native_Date
	Dim nEmpty	: nEmpty = Tp.Native_Empty
	Dim nObj	: nObj	= Tp.Native_Object
	Dim nArr	: nArr	= Tp.Native_Array
	Dim nVar	: nVar	= Tp.Native_Variant
		
	assertEqual(nBool.str,	cNtv.str &amp; &quot;_Bool&quot;).x
	assertEqual(nByte.str,	cNtv.str &amp; &quot;_Byte&quot;).x
	assertEqual(nInt.str,	cNtv.str &amp; &quot;_Int&quot;).x
	assertEqual(nLong.str,	cNtv.str &amp; &quot;_Long&quot;).x
	assertEqual(nSng.str,	cNtv.str &amp; &quot;_Single&quot;).x
	assertEqual(nDbl.str,	cNtv.str &amp; &quot;_Double&quot;).x
	assertEqual(nStr.str,	cNtv.str &amp; &quot;_Str&quot;).x
	assertEqual(nDate.str,	cNtv.str &amp; &quot;_Date&quot;).x
	assertEqual(nEmpty.str,	cNtv.str &amp; &quot;_Empty&quot;).x
	assertEqual(nObj.str,	cNtv.str &amp; &quot;_Obj&quot;).x
	assertEqual(nArr.str,	cNtv.str &amp; &quot;_Array&quot;).x
	assertEqual(nVar.str,	cNtv.str &amp; &quot;_Variant&quot;).x
	
	&apos;assertEqual(TypeParam.str,		&quot;Type.Param&quot;).x
	assertEqual(TypeParam.str,		&quot;Param :: Int -&gt; Type&quot;).x
	assertEqual(TypeParam(0).str,	&quot;a0&quot;).x
	assertEqual(TypeParam(1).str,	&quot;a1&quot;).x
	assertEqual(TypeParam(2).str,	&quot;a2&quot;).x
	
	&apos;assertEqual(TypeApp.str,				&quot;Type.App&quot;).x
	&apos;assertEqual(TList(TypeParam(0)).str,	&quot;List a0&quot;).x
	&apos;assertEqual(TList(nStr).str,			&quot;List Str&quot;).x
	&apos;assertEqual(TList(nInt).str,			&quot;List Int&quot;).x
	&apos;assertEqual(TList(TType).str,			&quot;List Type&quot;).x
	
	assertEqual(TypeApp.str,				&quot;App :: Type -&gt; Type -&gt; Type&quot;).x
	assertEqual(TList(TypeParam(0)).str,	&quot;[a0]&quot;).x
	assertEqual(TList(nStr).str,			&quot;[Str]&quot;).x
	assertEqual(TList(nInt).str,			&quot;[Int]&quot;).x
	assertEqual(TList(TType).str,			&quot;[Type]&quot;).x

	Dim t : t = TList(TList(nStr))
	&apos;assertEqual(t.str,	&quot;List (List Str)&quot;).x
	assertEqual(t.str,	&quot;[[Str]]&quot;).x
	
End Function

Function test_Data_toString()
	Dim x
	
	&apos; -- data type ctors
	x = TDataTypeCtor
	assertEqual(Data_toString(x), &quot;(TDataTypeCtor 0 [´DataTypeCtor])&quot;).x
	x = TDataCtor
	assertEqual(Data_toString(x), &quot;(TDataCtor 0 [´DataCtor])&quot;).x
	x = TType
	assertEqual(Data_toString(x), &quot;(Type 0 [´App, ´Param])&quot;).x
	x = TList
	assertEqual(Data_toString(x), &quot;(List 1 [´Nil, ´Cons])&quot;).x
	x = Tp.TNative
	assertEqual(Data_toString(x), &quot;(TNative 0 [´Native])&quot;).x
	x = TPattern
	assertEqual(Data_toString(x), &quot;(Pattern 0 [´Data, ´Const, ´Var, ´Any])&quot;).x

	Dim nInt  : nInt  = Tp.Native_Integer
	Dim nStr  : nStr  = Tp.Native_String
	Dim nBool : nBool = Tp.Native_Boolean
	&apos; -- types
	x = TypeParam(0)
	assertEqual(Data_toString(x), &quot;a0&quot;).x
	x = TypeParam(1)
	assertEqual(Data_toString(x), &quot;a1&quot;).x
	x = TList(TypeParam(2)) &apos; = TypeApp(TList, TypeParam(2))
	assertEqual(Data_toString(x), &quot;List a2&quot;).x
	x = TList(nInt)
	assertEqual(Data_toString(x), &quot;List Int&quot;).x
	x = TList(TType)
	assertEqual(Data_toString(x), &quot;List Type&quot;).x
	x = TList(TList(nInt))
	assertEqual(Data_toString(x), &quot;List (List Int)&quot;).x
	&apos; (0-arity) type ctors, viewed as Type
	x = TDataTypeCtor
	assertEqual(TType_toString(x), &quot;TDataTypeCtor&quot;).x
	x = TDataCtor
	assertEqual(TType_toString(x), &quot;TDataCtor&quot;).x
	x = TType
	assertEqual(TType_toString(x), &quot;Type&quot;).x
	&apos;x = TList &apos; &lt;----------------- TODO: unapplied List really a type?
	&apos;assertEqual(TType_toString(x), &quot;List ?&quot;).x
	x = Tp.TNative
	assertEqual(TType_toString(x), &quot;TNative&quot;).x
	x = TPattern
	assertEqual(TType_toString(x), &quot;Pattern&quot;).x
	&apos; native types - viewed as Type, not as NativeTypeCtor
	x = nInt
	assertEqual(TType_toString(x), &quot;Int&quot;).x
	x = nStr
	assertEqual(TType_toString(x), &quot;Str&quot;).x
	x = nBool
	assertEqual(TType_toString(x), &quot;Bool&quot;).x

	&apos; make up a type with two type parameters
	Dim tcPair, cPair
	tcPair = _mkDataTypeCtor(&quot;TPair&quot;, 2)
	cPair  = mkDataCtor(tcPair, &quot;Pair&quot;, List(TypeParam(0), TypeParam(1)))
	dim tcList : tcList = TList
	x = tcPair
	assertEqual(Data_toString(x), &quot;(TPair 2 [´Pair])&quot;).x
	&apos; as Type: &apos; &lt;----------------- TODO: unapplied TPair really a type?
	&apos;assertEqual(TType_toString(x), &quot;TPair ? ?&quot;).x
	&apos;x = TypeApp(tcPair, nStr)
	&apos;assertEqual(TType_toString(x), &quot;TPair Str ?&quot;).x

	&apos;x = TList(TypeApp(tcPair, nStr)) &apos; should throw &quot;incomplete type arg&quot;

	x = TypeApp(TypeApp(tcPair, nStr), nInt)
	assertEqual(TType_toString(x), &quot;TPair Str Int&quot;).x
	x = TypeApp(TypeApp(tcPair, TList(nStr)), nInt)
	assertEqual(TType_toString(x), &quot;TPair (List Str) Int&quot;).x
	x = TypeApp(TypeApp(tcPair, nStr), TList(nInt))
	assertEqual(TType_toString(x), &quot;TPair Str (List Int)&quot;).x
	x = TypeApp(TypeApp(tcPair, TList(nStr)), TList(nInt))
	assertEqual(TType_toString(x), &quot;TPair (List Str) (List Int)&quot;).x

	
	&apos; -- data ctors
	x = Tp.DataCtor
	assertEqual(Data_toString(x), _
		&quot;TDataCtor.DataCtor Str (List Type) TDataTypeCtor&quot;).x
	x = Tp.DataTypeCtor
	assertEqual(Data_toString(x), _
		&quot;TDataTypeCtor.DataTypeCtor Str Int (List TDataCtor)&quot;).x
	x = Tp.TType_Param
	assertEqual(Data_toString(x), &quot;Type.Param Int&quot;).x
	x = Tp.TType_App
	assertEqual(Data_toString(x), &quot;Type.App Type Type&quot;).x
	x = Tp.List_Nil
	assertEqual(Data_toString(x), &quot;List.Nil&quot;).x
	x = Tp.List_Cons
	assertEqual(Data_toString(x), &quot;List.Cons a0 (List a0)&quot;).x
	x = cPair
	assertEqual(Data_toString(x), &quot;TPair.Pair a0 a1&quot;).x

End Function


Function test_Type_applyDC()
	Dim a, c

	c = Tp.TType_Param
	a = applyDC(c, 0)
	assert_hasCtor(a, c).x
	
	a = applyDC(c)
	assertEqual(isFn(a), True).x
	
	a = apply(applyDC(c), 0)
	assert_hasCtor(a, c).x
	
	c = Tp.TType_App
	a = applyDC(c, TList)
	assertEqual(isFn(a), True).x
	a = apply(a, TypeParam(0))
	assert_hasCtor(a, c).x
	
	c = Tp.List_Cons
	a = applyDC(c, 42)
	assertEqual(isFn(a), True).x
	a = apply(a, nil)
	assert_hasCtor(a, c).x
	assertEqual(TList_equ(a, List(42)), True).x
	
	a = applyDC(c, 42, nil)
	assert_hasCtor(a, c).x
	assertEqual(TList_equ(a, List(42)), True).x
		
	a = applyDC(c)
	assertEqual(isFn(a), True).x
	a = apply(a, 4711)
	assertEqual(isFn(a), True).x
	a = apply(a, nil)
	assert_hasCtor(a, c).x
	assertEqual(TList_equ(a, List(4711)), True).x
	
	
	Dim tc, cFoo, cBar
	tc = applyDC(DataTypeCtor, &quot;TFoo&quot;, 0, nil)
	cFoo = mkDataCtor(tc, &quot;Foo&quot;, emptyArray)
	cBar = mkDataCtor(tc, &quot;Bar&quot;, emptyArray)
	&apos;show(cBar.str, DataValue_toString(cBar))
	a = applyDC(cFoo)
	&apos;show(a.str, DataValue_toString(a))
	&apos; should return singleton instances
	assert_same(applyDC(cFoo), a).x
	refute_same(applyDC(cBar), a).x
	a = applyDC(cBar)
	assert_same(applyDC(cBar), a).x
	
End Function

&apos; ##############################################


Function asdf
	&apos; But before we go on to make one, let&apos;s make things a bit more 
	&apos; interesting. Why not give him a brother:
	Dim cBar As DataValue
	cBar = _mkValueFrom_lax(cDataCtor, Array( _
		&quot;Bar&quot;, _
		emptyArray, _
		Nothing _
	)
	&apos; Bar just looks like his twin Foo, only the names are different.
	&apos; Of course they have the same &quot;parent&quot;:
	Dim tcFooOrBar As DataValue
	tcFooOrBar = _mkValueFrom_lax(cDataTypeCtor, Array( _
		&quot;FooOrBar&quot;, _
		0, _
		Array(cFoo, cBar) _
	)
	_setTypeCtor(cFoo, tcFooOrBar)
	_setTypeCtor(cBar, tcFooOrBar)
	&apos; FooOrBar = Foo | Bar
	&apos; We can now make values of type FooOrBar
	Dim y, z
	x = _mkValueFrom_lax(cFoo, Array())
	y = _mkValueFrom_lax(cBar, Array())
	z = _mkValueFrom_lax(cFoo, Array())
	&apos; the function isTypeOf takes a type and a value, and tests
	&apos; whether the value has the given type:
	assertEqual(isTypeOf(tcFooOrBar, x), True).x
	assertEqual(isTypeOf(tcFooOrBar, y), True).x
	assertEqual(isTypeOf(tcFooOrBar, z), True).x
	&apos; But of course, FooOrBar itself is NOT a FooOrBar
	assertEqual(isTypeOf(tcFooOrBar, tcFooOrBar), False).x
	&apos; Rather it is a TDataTypeCtor
	assertEqual(isTypeOf(tcDataTypeCtor, tcFooOrBar), True).x
	&apos; Similarly, neither cFoo nor cBar are FooBar s:
	assertEqual(isTypeOf(tcFooOrBar, cFoo), False).x
	assertEqual(isTypeOf(tcFooOrBar, cBar), False).x
	&apos; They&apos;re data constructors:
	assertEqual(isTypeOf(tcDataCtor, cFoo), True).x
	assertEqual(isTypeOf(tcDataCtor, cBar), True).x
	
	&apos; We can also dispatch on the values&apos; ctors (names).
	&apos; Since extracting the ctor&apos;s name will be common, we&apos;ll
	&apos; extract that into another helper function:
	assertEqual(ctorName(x), field(DataCtor_name, cFoo)).x
	assertEqual(ctorName(y), field(DataCtor_name, cBar)).x
	assertEqual(ctorName(z), field(DataCtor_name, cFoo)).x
	&apos; With that in place:
	Dim what As String, i As Integer, vs As Variant
	what = &quot;&quot;
	vs = Array(x, y, z)
	For i = 0 To 2
		Select Case ctorName(vs(i))
			Case &quot;Foo&quot;: what = what &amp; &quot;aFoo &quot;
			Case &quot;Bar&quot;: what = what &amp; &quot;aBar &quot;
		End Select
	Next i
	assertEqual(what, &quot;aFoo aBar aFoo &quot;).x
		
End Function

Function test_Type_destructure()
	Dim vP : vP = TypeParam(42)
	Dim vA : vA = TypeApp(TList, vP)
	Dim f
	
	f = _destructure(Tp.TType_Param, 0)
	assertEqual(isFn(f), True).x
	assertThrows(f, Array(vA)).x
	assertEqual(apply(f, vP), 42).x
	
	f = _destructure(Tp.TType_App, 0)
	assertEqual(isFn(f), True).x
	assertThrows(f, Array(vP)).x
	assert_same(apply(f, vA), TList).x
	
	f = _destructure(Tp.TType_App, 1)
	assertEqual(isFn(f), True).x
	assertThrows(f, Array(vP)).x
	assert_same(apply(f, vA), vP).x

End Function

Function test_Type_dataCtors()
	Dim tc, dcs
	tc = Tp.TDataTypeCtor : dcs = dataCtors(tc)
	assert_same(dcs, field(DataTypeCtor_dataCtors, tc)).x
	assertEqual(length(dcs), 1).x
	
	tc = Tp.TDataCtor : dcs = dataCtors(tc)
	assert_same(dcs, field(DataTypeCtor_dataCtors, tc)).x
	assertEqual(length(dcs), 1).x
	
	tc = Tp.TNative : dcs = dataCtors(tc)
	assert_same(dcs, field(DataTypeCtor_dataCtors, tc)).x
	assertEqual(length(dcs), 1).x
	
	tc = Tp.TType : dcs = dataCtors(tc)
	assert_same(dcs, field(DataTypeCtor_dataCtors, tc)).x
	assertEqual(length(dcs), 2).x
	
	tc = Tp.List : dcs = dataCtors(tc)
	assert_same(dcs, field(DataTypeCtor_dataCtors, tc)).x
	assertEqual(length(dcs), 2).x
	
	assertThrows(dataCtors, Array(Tp.DataTypeCtor)).x
	assertThrows(dataCtors, Array(Tp.DataCtor)).x
	assertThrows(dataCtors, Array(Tp.Native)).x
	assertThrows(dataCtors, Array(Tp.TType_Param)).x
	assertThrows(dataCtors, Array(Tp.TType_App)).x
	assertThrows(dataCtors, Array(Tp.List_Nil)).x
	assertThrows(dataCtors, Array(Tp.List_Cons)).x
	assertThrows(dataCtors, Array(nil)).x
	assertThrows(dataCtors, Array(List(1, 2, 3))).x
End Function

Function test_Type_findDataCtor()
	assert_same(findDataCtor(Tp.TDataTypeCtor, &quot;DataTypeCtor&quot;), Tp.DataTypeCtor).x
	assert_same(findDataCtor(Tp.TDataCtor, &quot;DataCtor&quot;), Tp.DataCtor).x
	assert_same(findDataCtor(Tp.TNative, &quot;Native&quot;), Tp.Native).x
	assert_same(findDataCtor(Tp.TType, &quot;Param&quot;), Tp.TType_Param).x
	assert_same(findDataCtor(Tp.TType, &quot;App&quot;), Tp.TType_App).x
	assert_same(findDataCtor(Tp.List, &quot;Nil&quot;), Tp.List_Nil).x
	assert_same(findDataCtor(Tp.List, &quot;Cons&quot;), Tp.List_Cons).x
End Function

Function test_Type_singletonVal()
	Dim v
	v = nil
	assert_same(singletonVal(Tp.List_Nil), v).x
	&apos; throws if data ctor is not singleton ctor
	assertThrows(singletonVal, Array(Tp.List_Cons)).x
	&apos; throws if passed something not a data ctor
	assertThrows(singletonVal, Array(v)).x
	assertThrows(singletonVal, Array(&quot;asdf&quot;)).x
End Function

Function test_Type_Type_arity()
	assertEqual(Type_arity(Tp.TDataTypeCtor), 	0).x
	assertEqual(Type_arity(Tp.TDataCtor), 		0).x
	assertEqual(Type_arity(Tp.TType),			0).x
	assertEqual(Type_arity(Tp.List), 			1).x
	assertEqual(Type_arity(Tp.TNative), 		0).x
	assertEqual(Type_arity(TypeParam(0)),		0).x
	assertEqual(Type_arity(TypeParam(1)),		0).x

	&apos; don&apos;t use applyDC, nor TypeApp(..)
	Dim cApp, nStr, vApp
	cApp = Tp.TType_App : nStr = Tp.Native_String
	vApp = _newDataValue(cApp, Array(Tp.List, nStr))
	assertEqual(Type_arity(vApp),				0).x
	
	&apos;assertThrows(Type_arity, Array(nil)).x	
	&apos;assertThrows(Type_arity, Array(&quot;foo&quot;)).x	

End Function



</script:module>