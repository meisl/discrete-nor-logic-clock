<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M06_AST" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit


Type TASN &apos; &quot;Abstract Syntax Node&quot;
	tyname As String
	label As Variant
	value As Variant
	children As Object
End Type


Sub Main
	test_AST()
End Sub


Function mkASN(label, value, children As Object)
	Dim result As New TASN
	result.tyname = &quot;TASN&quot;
	result.label = label
	result.value = value
	If Not(typeOf(children) = typeOf(nil)) Then
		croak(&quot;mkASN: invalid list of children &quot; &amp; toString(children))
	End If
	result.children = children
	mkAsn = result
End Function

Function isASN(x As Variant) As Boolean
	isASN = (typeOf(x) = &quot;Object/TASN&quot;)
End Function

Function TASN_toString(Optional n As Object)
	Dim result As Variant
	If isMissing(n) Then
		result = Fn.TASN_toString
	Else
		result = _TASN_toString(n, &quot;&quot;, &quot;&quot;)
	End If
	TASN_toString = result
End Function

Function _TASN_toString( _
	n As Object, _
	ByVal prefixN As String, _
	ByVal prefixC As String _
) As String
	Dim result As String
	result = _TASN_toString_head(n)
	Dim k As Integer, i As Integer
	k = asnChildCount(n)
	If k &gt; 0 Then
		i = InStr(1, result, &quot;:&quot;)
		If i = 0 Then : i = 1 : End If
		prefixC = prefixC &amp; Space(i)
		Dim child As Variant
		k = k - 1
		For i = 0 To k
			child = asnChild(n, i)
			If (i = k) Then &apos; last child
				result = result _
					   &amp; chr(13) &amp; chr(10) _
					   &amp; _TASN_toString( _
					   		child, _
							prefixC &amp; &quot;└&quot; , _
							prefixC &amp; &quot; &quot; _
						 )
			Else
				result = result _
					   &amp; chr(13) &amp; chr(10) _
					   &amp; _TASN_toString( _
					   		child, _
							prefixC &amp; &quot;├&quot; , _
							prefixC &amp; &quot;│&quot; _
						 )
			End If
		Next i
	End If
	result = prefixN &amp; &quot;─&quot; &amp; result
	_TASN_toString = result
End Function

Function _TASN_toString_head(n As Object) As String
	Dim result As String, lbl As Variant, val As Variant
	lbl = asnLabel(n)
	val = asnValue(n)
	If isEmpty(val) Then
		val = &quot;&quot;
	ElseIf isString(val) Then
		If (val = &quot;&quot;) Then
			val = &quot;ε&quot;
		Else
			val = toString(val)
		End If
	Else
		val = toString(val)
	End If
	If isEmpty(lbl) Then
		If val = &quot;&quot; Then
			result = &quot;:&quot;
		Else
			result = val
		End If
	Else
		If Not(isString(lbl)) Then
			lbl = toString(lbl)
		End If
		If val = &quot;&quot; Then
			result = lbl
		Else
			result = lbl &amp; &quot;:&quot; &amp; val
		End If
	End If
	_TASN_toString_head = result
End Function

Function asnLabel(n As Object)
	asnLabel = n.label
End Function

Function asnValue(n As Object)
	asnValue = n.value
End Function

Function asnChildren(n As Object)
	asnChildren = n.children
End Function

Function asnIsLeaf(n As Object) As Boolean
	asnIsLeaf = isNil(asnChildren(n))
End Function

Function asnChildCount(n As Object) As Integer
	asnChildCount = length(asnChildren(n))
End Function

Function asnChild(n As Object, ByVal i As Integer)
	Dim result As Variant, cs As Object, len As Integer
	If (i &lt; 0) Then
		croak(&quot;asnChild: invalid child index &quot; &amp; i)
	End If
	cs = asnChildren(n)
	len = length(cs)
	If (i &gt;= len) Then
		If len = 0 Then
			croak(&quot;asnChild: invalid child index &quot; &amp; i &amp; &quot; - has none&quot;)
		Else
			croak(&quot;asnChild: invalid child index &quot; &amp; i &amp; &quot; - has only &quot; &amp; len)
		End If
	Else
		While i &gt; 0
			cs = cdr(cs)
			i = i - 1
		Wend
		result = car(cs)
	End If
	asnChild = result
End Function

Function mkDtTerminal(Optional value As String)
	If isMissing(value) Then
		mkDtTerminal = Fn.mkDtTerminal
	Else
		mkDtTerminal = mkASN(Empty, value, nil)
	End If
End Function

Function mkDtCClass(Optional cclass As String, Optional value As String)
	If isMissing(cclass) Then
		mkDtCClass = Fn.mkDtCClass
	ElseIf isMissing(value) Then
		mkDtCClass = apply(Fn.mkDtCClass, cclass)
	Else
		mkDtCClass = mkASN(cclass, value, nil)
	End If
End Function
	
Function mkDtNonterminal( _
	Optional ruleName As String, _
	Optional children As Object _
)
	Dim result As Variant
	If isMissing(ruleName) Then
		result = Fn.mkDtNonterminal
	ElseIf isMissing(children) Then
		result = apply(Fn.mkDtNonterminal, ruleName)
	ElseIf isNil(children) Then
		croak(&quot;mkDtNonterminal: nil not valid as list of children&quot;)
	Else
		result = mkASN(ruleName, Empty, children)
	End If
	mkDtNonterminal = result
End Function

Function mkDtMult( _
	Optional label As String, _
	Optional children As Object _
)
	Dim result As Variant
	If isMissing(label) Then
		result = Fn.mkDtMult
	ElseIf isMissing(children) Then
		result = apply(Fn.mkDtMult, label)
	Else
		&apos;If isNil(children) Then
		&apos;	result = mkASN(label, &quot;&quot;, nil)
		&apos;Else
			result = mkASN(label, Empty, children)
		&apos;End If
	End If
	mkDtMult = result
End Function

Function toDerivationP(Optional ByVal p As Object)
	Dim result As Variant
	If isMissing(p) Then
		result = Fn.toDerivationP
	Else
		Dim seen As Object
		seen = nil
		result = _toDerivationP(p, seen, False)
		While Not(isNil(seen))
			p = car(seen)
			p.st2 = False
			p.st3 = Empty
			seen = cdr(seen)
		Wend
	End If
	toDerivationP = result
End Function

Function dtMultLabel(m As String, p As Object)
	Dim t As String
	Select Case p.tp
		Case &quot;item&quot;	:	t = &quot;.&quot; 
		Case &quot;str&quot;:		t = toString(p.st(0))
		Case &quot;choice&quot;:	t = &quot;(..|..)&quot;
		Case &quot;seq&quot;:		t = &quot;(...)&quot;
		Case &quot;ind&quot;:		t = getPIndName(p)
		Case &quot;sat&quot;
			If p.str &lt;&gt; &quot;&quot; Then
				t = &quot;(&quot; &amp; p.str &amp; &quot;)&quot;
			Else
				t = &quot;(&quot; &amp; TFn_toString(p.st0) &amp; &quot;)&quot;
			End If
		Case Else
			croak(&quot;dtMultLabel: cannot handle .tp=&quot; &amp; toString(p.tp))
	End Select
	dtMultLabel = &quot;(&quot; &amp; m &amp; &quot;):&quot; &amp; t
End Function

Const typ_Parser_ASN = &quot;Parser ASN&quot;
Const typ_Parser_List_ASN = &quot;Parser [ASN]&quot;

Function _toDerivationP( _
	ByVal p As Object, _
	ByRef seen As Object, _
	ByVal wantList As Boolean _
)
	Dim result As Variant
	Dim f As Object, s As String, q As Object, r As Object
	Dim qs As Object, rs As Object
	If isPMany(p) Then &apos; p is of shape (many1 q) +++ (return nil)
		q = p.st0.st0
		s = dtMultLabel(&quot;*&quot;, q)
		f = mkDtMult(s)
		q = _toDerivationP(q, seen, False)
		If q.typ = typ_Parser_List_ASN Then
			f = compose(f, mkDtNonterminal(&quot;(...)&quot;))
		End If
		&apos;result = pSeq(Array(pMany(q)), f)
		result = pBind(pMany(q), compose(pReturn, f))
		result.typ = typ_Parser_ASN
	ElseIf isPZeroOrOne(p) Then &apos; p is of shape q +++ (return Empty)
		q = p.st0
		s = dtMultLabel(&quot;?&quot;, q)
		f = mkDtMult(s)
		q = _toDerivationP(q, seen, True)
		If q.typ = typ_Parser_ASN Then
			f = compose(f, swap(cons, nil))
		End If
		&apos;result = pSeq(Array(pChoice(q, pReturn(nil))), f)
		result = pBind(pChoice(q, pReturn(nil)), compose(pReturn, f))
		result.typ = typ_Parser_ASN
	Else
		Select Case p.tp
			Case &quot;item&quot;
				f = mkDtCClass(&quot;(.)&quot;)
				result = pBind(p, compose(pReturn, f))
				&apos;result = pSeq(Array(p),f)
				result.typ = typ_Parser_ASN
			Case &quot;str&quot;
				f = mkDtTerminal
				result = pBind(p, compose(pReturn, f))
				&apos;result = pSeq(Array(p), f)
				result.typ = typ_Parser_ASN
			Case &quot;sat&quot;
				If p.str &lt;&gt; &quot;&quot; Then
					f = mkDtCClass(&quot;(&quot; &amp; p.str &amp; &quot;)&quot;
				Else
					f = mkDtCClass(&quot;(.):&quot; &amp; TFn_toString(p.st0))
				End If
				result = pBind(p, compose(pReturn, f))
				&apos;result = pSeq(Array(p), f)
				result.typ = typ_Parser_ASN
			Case &quot;choice&quot;
				q = _toDerivationP(p.st0, seen, wantList)
				r = _toDerivationP(p.st1, seen, wantList)
				If q.typ &lt;&gt; r.typ Then
					If q.typ = typ_Parser_ASN Then
						q = pBind(q, compose(pReturn, swap(cons, nil)))
					Else
						r = pBind(rq, compose(pReturn, swap(cons, nil)))
					End If
				End If
				result = pChoice(q, r)
				result.typ = q.typ
			Case &quot;many1&quot;
				q = p.st0
				s = dtMultLabel(&quot;+&quot;, q)
				f = mkDtMult(s)
				q = _toDerivationP(q, seen, False)
				If q.typ = typ_Parser_List_ASN Then
					f = compose(f, mkDtNonterminal(&quot;(...)&quot;))
				End If
				&apos;result = pSeq(Array(pMany1(q)), f)
				result = pBind(pMany1(q), compose(pReturn, f))
				result.typ = typ_Parser_ASN
			Case &quot;seq&quot; &apos; only simple sequences supported here
				f = p.st(1)
				If (getFnName(f) = getFnName(Fn.id)) Then
					qs = toList(p.st(0))
					rs = nil
					While Not(isNil(qs))
						q = car(qs)
						q = _toDerivationP(q, seen, True)
						If q.typ = typ_Parser_List_ASN Then
							q = pBind(q, compose(pReturn, _
								mkDtNonterminal(&quot;(...)&quot;)))
						End If
						rs = cons(q, rs)
						qs = cdr(qs)
					Wend
					result = pSeqL( _
						toArray(reverse(rs)), _
						id _
					)
					result.typ = typ_Parser_List_ASN			
				&apos;ElseIf isApplyToListId(f) Then
				Else
					croak(&quot;toDerivationP/NYI: pSeq(..., &quot; _
						 &amp; TFn_toString(p.st(1)) &amp; &quot;)&quot; _
						 &amp; chr(13) &amp; chr(10) _
						 &amp; toString(p)_
					)
				End If
			Case &quot;ind&quot;
				If p.st2 Then &apos; seen before
					If isEmpty(p.st3) Then
						croak(&quot;toDerivationP: replace &quot; &amp; p.st1 &amp; &quot;???&quot;)
					End If
					result = p.st3
				ElseIf isNull(p.st0) Then
					croak(&quot;toDerivationP/NYI: uninitialized indirection &quot; &amp; p.st1)
				Else
					p.st2 = True &apos; set the &quot;visited&quot;-mark
					seen = cons(p, seen)
					s = getPIndName(p)
					p.st3 = pInd(s)
					q = _toDerivationP(p.st0, seen, True)
					f = mkDtNonterminal(s)
					If q.typ = typ_Parser_ASN Then
						f = compose(f, swap(cons, nil))
					End If
					&apos;result = fixIndirection(q, _
					&apos;	pBind( _
					&apos;		q, _
					&apos;		compose(pReturn, f) _
					&apos;	)
					&apos;)
					result = fixIndirection(p.st3, _
						pSeq(Array( _
							q _
						), f)_
					)
					result.typ = typ_Parser_ASN
				End If
			Case Else
				croak(&quot;toDerivationP: cannot handle .tp=&quot; &amp; toString(p.tp))
		End Select
	End If
	_toDerivationP = result
End Function

&apos;= tests ======================================================================

Function test_AST()
	test_AST_TASN_toString()
	test_AST_toDerivationP()
	
	Dim n0 As Object
	n0 = mkASN(&quot;foo&quot;, &quot;bar&quot;, nil)
	
	assertEqual(typeOf(n0), &quot;Object/TASN&quot;).x
	assertEqual(length(asnChildren(n0)), 0).x
	assertEqual(asnChildCount(n0), 0).x
	assertEqual(asnIsLeaf(n0), True).x
	assertEqual(toString(n0), &quot;─foo:&apos;bar&apos;&quot;).x

	Dim n1 As Object
	n1 = mkASN(Empty, &quot;bar&quot;, nil)
	assertEqual(asnChildCount(n1), 0).x
	assertEqual(asnIsLeaf(n1), True).x
	assertEqual(toString(n1), &quot;─&apos;bar&apos;&quot;).x

	Dim n2 As Object
	n2 = mkASN(&quot;foo&quot;, Empty, nil)
	assertEqual(asnChildCount(n2), 0).x
	assertEqual(asnIsLeaf(n2), True).x
	assertEqual(toString(n2), &quot;─foo&quot;).x

	Dim n3 As Object
	n3 = mkASN(Empty, Empty, nil)
	assertEqual(asnChildCount(n3), 0).x
	assertEqual(asnIsLeaf(n3), True).x
	assertEqual(toString(n3), &quot;─:&quot;).x

	Dim n4 As Object, c0 As Object
	n4 = mkASN(&quot;S&quot;, Empty, List(n1))
	assertEqual(asnChildCount(n4), 1).x
	assertEqual(asnIsLeaf(n4), False).x
	c0 = asnChild(n4, 0)
	assertEqual(asnLabel(c0), asnLabel(n1)).x
	assertEqual(asnValue(c0), asnValue(n1)).x
	assertEqual(asnChildCount(c0), asnChildCount(n1)).x
	
	&apos;assertEqual(toString(n4), &quot;:&quot;).x
	
	Dim s As String
	n0 = mkDtTerminal(&quot;A&quot;)
	n0 = mkDtNonterminal(&quot;I&quot;, List(n0))
	n0 = mkDtNonterminal(&quot;F&quot;, List(n0))
	n0 = mkDtNonterminal(&quot;T&quot;, List(n0))
	
	n1 = mkDtTerminal(&quot;+&quot;)
	
	n2 = mkDtTerminal(&quot;B&quot;)
	n2 = mkDtNonterminal(&quot;I&quot;, List(n2))
	n2 = mkDtNonterminal(&quot;F&quot;, List(n2))
	
	n3 = mkDtTerminal(&quot;*&quot;)
	
	n4 = mkDtTerminal(&quot;C&quot;)
	n4 = mkDtNonterminal(&quot;I&quot;, List(n4))
	n4 = mkDtNonterminal(&quot;F&quot;, List(n4))
	n4 = mkDtNonterminal(&quot;T&quot;, List(n4))
	
	n4 = mkDtNonterminal(&quot;T&quot;, List(n2, n3, n4))
	n4 = mkDtNonterminal(&quot;S&quot;, List(n4))

	n4 = mkDtNonterminal(&quot;S&quot;, List(n0, n1, n4))
	
	s = toString(n4)
	test_AST = s
End Function

Function test_AST_TASN_toString()
	Dim n As Object
	n = mkASN(Empty, Empty, nil)
	assertEqual(TASN_toString(n), &quot;─:&quot;).x
	
	n = mkASN(Empty, &quot;x&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─&apos;x&apos;&quot;).x
	n =mkASN(Empty, &quot;&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─ε&quot;).x
	n = mkASN(Empty, &quot;foobar&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─&apos;foobar&apos;&quot;).x

	n = mkASN(&quot;S&quot;, Empty, nil)
	assertEqual(TASN_toString(n), &quot;─S&quot;).x
	n = mkASN(&quot;Foo&quot;, Empty, nil)
	assertEqual(TASN_toString(n), &quot;─Foo&quot;).x

	n = mkASN(&quot;*&quot;, &quot;&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─*:ε&quot;).x
	n = mkASN(&quot;+&quot;, &quot;&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─+:ε&quot;).x
	n = mkASN(&quot;?&quot;, &quot;&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─?:ε&quot;).x

	n = mkASN(&quot;*&quot;, &quot;W&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─*:&apos;W&apos;&quot;).x
	n = mkASN(&quot;+&quot;, &quot;W&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─+:&apos;W&apos;&quot;).x
	n = mkASN(&quot;?&quot;, &quot;W&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─?:&apos;W&apos;&quot;).x
	
	n = mkASN(&quot;W*&quot;, Empty, nil)
	assertEqual(TASN_toString(n), &quot;─W*&quot;).x
	n = mkASN(&quot;W+&quot;, Empty, nil)
	assertEqual(TASN_toString(n), &quot;─W+&quot;).x
	n = mkASN(&quot;W?&quot;, Empty, nil)
	assertEqual(TASN_toString(n), &quot;─W?&quot;).x
	
End Function

Function test_AST_toDerivationP()
	Dim p As Object, q As Object, r As Variant, x As Object

	p = pItem
	q = toDerivationP(p)
	refute_parses(q, &quot;&quot;).x
	x = mkDtCClass(&quot;(.)&quot;, &quot;a&quot;)
	assert_parses(q, &quot;a&quot;, x, 2).x
	x = mkDtCClass(&quot;(.)&quot;, &quot;b&quot;)
	assert_parses(q, &quot;bca&quot;, x, 2).x
	x = mkDtCClass(&quot;(.)&quot;, &quot;c&quot;)
	assert_parses(q, &quot;cabc&quot;, x, 2).x
	x = mkDtCClass(&quot;(.)&quot;, &quot; &quot;)
	assert_parses(q, &quot; xyzabc&quot;, x, 2).x
	
	p = pStr(&quot;z&quot;)
	q = toDerivationP(p)
	refute_parses(q, Array(&quot;&quot;, &quot;cba&quot;, &quot;x&quot;, &quot;y&quot;)).x
	x = mkDtTerminal(&quot;z&quot;)
	assert_parses(q, &quot;z&quot;, x, 2).x
	&apos; really reads only as many chars as pStr does:
	assert_parses(q, &quot;zz&quot;, x, 2).x
	assert_parses(q, &quot;zy&quot;, x, 2).x

	p = pStr(&quot;abc&quot;)
	q = toDerivationP(p)
	refute_parses(q, Array(&quot;&quot;, &quot;y&quot;, &quot;cba&quot;)).x
	x = mkDtTerminal(&quot;abc&quot;)
	assert_parses(q, &quot;abc&quot;, x, 4).x
	&apos; really reads only as many chars as pStr does:
	assert_parses(q, &quot;abcabc&quot;, x, 4).x
	assert_parses(q, &quot;abcxyz&quot;, x, 4).x

	p = pChoice(pStr(&quot;0&quot;), pStr(&quot;1&quot;))
	q = toDerivationP(p)
	refute_parses(q, Array(&quot;&quot;, &quot;y&quot;, &quot;cba&quot;)).x
	x = mkDtTerminal(&quot;0&quot;)
	assert_parses(q, &quot;0&quot;, x, 2).x
	x = mkDtTerminal(&quot;1&quot;)
	assert_parses(q, &quot;1&quot;, x, 2).x

	p = pSeqL(Array(pItem), id)
	q = toDerivationP(p)
	refute_parses(q, &quot;&quot;).x
	x = List(mkDtCClass(&quot;(.)&quot;, &quot;x&quot;))
	assert_parses(q, &quot;x&quot;, x, 2).x
	assert_parses(q, &quot;x1&quot;, x, 2).x
	x = List(mkDtCClass(&quot;(.)&quot;, &quot;y&quot;))
	assert_parses(q, &quot;y1abc&quot;, x, 2).x

	p = pSeqL(Array(pItem, pStr(&quot;1&quot;)), id)
	q = toDerivationP(p)
	refute_parses(q, &quot;&quot;, &quot;x0&quot;, &quot; a&quot;).x
	x = List(mkDtCClass(&quot;(.)&quot;, &quot;x&quot;), mkDtTerminal(&quot;1&quot;))
	assert_parses(q, &quot;x1&quot;, x, 3).x
	x = List(mkDtCClass(&quot;(.)&quot;, &quot;y&quot;), mkDtTerminal(&quot;1&quot;))
	assert_parses(q, &quot;y1abc&quot;, x, 3).x

	p = pSeqL(Array(pStr(&quot;0&quot;), pItem, pStr(&quot;1&quot;)), id)
	q = toDerivationP(p)
	refute_parses(q, &quot;&quot;, &quot;0&quot;, &quot;0a&quot;, &quot;xa1&quot;).x
	x = List(mkDtTerminal(&quot;0&quot;), mkDtCClass(&quot;(.)&quot;, &quot;a&quot;), mkDtTerminal(&quot;1&quot;))
	assert_parses(q, &quot;0a1&quot;, x, 4).x
	x = List(mkDtTerminal(&quot;0&quot;), mkDtCClass(&quot;(.)&quot;, &quot;b&quot;), mkDtTerminal(&quot;1&quot;))
	assert_parses(q, &quot;0b1xyz&quot;, x, 4).x
	
	p = pInd(&quot;Foo&quot;)
	p = fixIndirection(p, pItem)
	q = toDerivationP(p)
	refute_parses(q, &quot;&quot;).x
	x = mkDtNonterminal(getPIndName(p), List(mkDtCClass(&quot;(.)&quot;, &quot;a&quot;)))
	assert_parses(q, &quot;a&quot;, x, 2).x
	x = mkDtNonterminal(getPIndName(p), List(mkDtCClass(&quot;(.)&quot;, &quot;b&quot;)))
	assert_parses(q, &quot;b&quot;, x, 2).x
	assert_parses(q, &quot;bb&quot;, x, 2).x
	assert_parses(q, &quot;bc&quot;, x, 2).x
		
	p = pInd(&quot;Bar&quot;)
	p = fixIndirection(p, pSeqL(Array(pItem, pStr(&quot;1&quot;)), id)
	q = toDerivationP(p)
	&apos;msgbox(toString(p) &amp; chr(13) &amp; chr(13) &amp; toString(q))
	refute_parses(q, &quot;&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;a0&quot;, &quot;b&quot;, &quot;b1&quot;).x
	x = mkDtNonterminal(getPIndName(p), List( _
			mkDtCClass(&quot;(.)&quot;, &quot;a&quot;), mkDtTerminal(&quot;1&quot;) _
		))
	&apos;msgbox(toString(x))
	assert_parses(q, &quot;a1&quot;, x, 3).x
	assert_parses(q, &quot;a1b&quot;, x, 3).x

	&apos; -------------------------
	&apos; pMany under toDerivationP

	Dim termEps As Object, termZ As Object, termZY As Object
	termEps = mkDtTerminal(&quot;&quot;)
	termZ   = mkDtTerminal(&quot;z&quot;)
	termZY	= mkDtTerminal(&quot;zy&quot;)
	
	p = pStr(&quot;z&quot;)
	q = toDerivationP(pMany(p))
	x = mkDtMult(dtMultLabel(&quot;*&quot;, p), nil)
	assert_parses(q, &quot;&quot;, x, 1).x
	assert_parses(q, &quot;x&quot;, x, 1).x
	assert_parses(q, &quot;xy&quot;, x, 1).x
	assert_parses(q, &quot;xyz&quot;, x, 1).x

	x = mkDtMult(dtMultLabel(&quot;*&quot;, p), List(termZ))
	assert_parses(q, &quot;z&quot;, x, 2).x
	assert_parses(q, &quot;zx&quot;, x, 2).x

	x = mkDtMult(dtMultLabel(&quot;*&quot;, p), List(termZ, termZ))
	assert_parses(q, &quot;zz&quot;, x, 3).x
	assert_parses(q, &quot;zza&quot;, x, 3).x

	p = pStr(&quot;zy&quot;)
	q = toDerivationP(pMany(p))
	x = mkDtMult(dtMultLabel(&quot;*&quot;, p), nil)
	assert_parses(q, &quot;&quot;, x, 1).x
	assert_parses(q, &quot;x&quot;, x, 1).x
	assert_parses(q, &quot;xy&quot;, x, 1).x
	assert_parses(q, &quot;z&quot;, x, 1).x
	assert_parses(q, &quot;xzy&quot;, x, 1).x
	
	x = mkDtMult(dtMultLabel(&quot;*&quot;, p), List(termZY))
	assert_parses(q, &quot;zy&quot;, x, 3).x
	assert_parses(q, &quot;zyX&quot;, x, 3).x
	assert_parses(q, &quot;zyXzy&quot;, x, 3).x
	
	x = mkDtMult(dtMultLabel(&quot;*&quot;, p), List(termZY, termZY))
	assert_parses(q, &quot;zyzy&quot;, x, 5).x
	assert_parses(q, &quot;zyzyX&quot;, x, 5).x
	
	x = mkDtMult(dtMultLabel(&quot;*&quot;, p), List(termZY, termZY, termZY))
	assert_parses(q, &quot;zyzyzy&quot;, x, 7).x
	assert_parses(q, &quot;zyzyzyX&quot;, x, 7).x

	&apos; -------------------------
	&apos; pSat under toDerivationP

	p = pSat(equ(&quot;z&quot;))
	p.str = &quot;[z]&quot;
	q = toDerivationP(p)
	x = mkDtCClass(&quot;([z])&quot;, &quot;z&quot;)
	refute_parses(q, Array(&quot;&quot;, &quot;x&quot;, &quot;xy&quot;, &quot;xyz&quot;)).x
	assert_parses(q, &quot;z&quot;, x, 2).x
	assert_parses(q, &quot;zy&quot;, x, 2).x
	assert_parses(q, &quot;zyz&quot;, x, 2).x
	assert_parses(q, &quot;zzy&quot;, x, 2).x

	&apos; -------------------------
	&apos; pMany1(pSat) under toDerivationP

	p = pSat(compose(inRange(Asc(&quot;y&quot;), Asc(&quot;z&quot;)), Fn.Asc))
	p.str = &quot;[y-z]&quot;
	q = toDerivationP(pMany1(p))
	x = mkDtMult(dtMultLabel(&quot;+&quot;, p), List( _
		mkDtCClass(&quot;([y-z])&quot;, &quot;z&quot;) _
	))
	refute_parses(q, Array(&quot;&quot;, &quot;x&quot;, &quot;xy&quot;, &quot;xyz&quot;)).x
	assert_parses(q, &quot;z&quot;, x, 2).x
	assert_parses(q, &quot;zx&quot;, x, 2).x
	assert_parses(q, &quot;zxz&quot;, x, 2).x
	x = mkDtMult(dtMultLabel(&quot;+&quot;, p), List( _
		mkDtCClass(&quot;([y-z])&quot;, &quot;y&quot;), _
		mkDtCClass(&quot;([y-z])&quot;, &quot;z&quot;) _
	))
	assert_parses(q, &quot;yz&quot;, x, 3).x
	assert_parses(q, &quot;yzx&quot;, x, 3).x
	assert_parses(q, &quot;yzxz&quot;, x, 3).x
End Function

</script:module>