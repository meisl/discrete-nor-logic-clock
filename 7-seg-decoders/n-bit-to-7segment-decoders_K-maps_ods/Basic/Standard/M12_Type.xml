<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M12_Type" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit


Type TypeCtor
	_name	  As String	 &apos; cannot use just &quot;name&quot;, that&apos;s a BASIC directive
	arity	  As Integer &apos; the nr of typeArgs
	dataCtors As Array
End Type

Type DataType
	str		 As String	&apos; debugger shows that in inspector
	typeArgs As Array
	typeCtor As TypeCtor
End Type

Type DataCtor
	tag		 As String
	str		 As String	&apos; debugger shows that in inspector
	_name	 As String	&apos; see TypeCtor._name
	typeCtor As TypeCtor
	argTypes As Array
	arity    As Integer
End Type

Type DataValue
	str		 As String	&apos; debugger shows that in inspector
	ctor	 As DataCtor
	dataType As DataType
	fields   As Array
End Type

Sub Main
	[test_Type======================================]
End Sub


Function _newDataCtor( _
	typeCtor As TypeCtor, _
	name 	 As String, _
	argTypes As Array _
)
	Dim out As New DataCtor
	out.tag = &quot;DataCtor&quot;
	out._name = name
	out.typeCtor = typeCtor
	Dim lo As Integer : lo = LBound(argTypes)
	Dim hi As Integer : hi = UBound(argTypes)
	Dim n  As Integer : n = hi - lo + 1
	out.arity = n

	Dim typeStr As String, i As Integer
	typeStr = &quot;&quot;
	If n = 0 Then
		out.argTypes = Array()
	Else
		Dim ats(0 To n - 1)
		Dim t As Variant
		Dim k As Integer : k = 0
		For i = lo To hi
			t = argTypes(i)
			If isInteger(t) Then
				If (t &lt; 0) Or (t &gt;= typeCtor.arity) Then
					croak(&quot;_newDataCtor &quot; &amp; name &amp; &quot;: &quot; _
						&amp; &quot;invalid type var index &quot; &amp; t _
						&amp; &quot; - expected [0..&quot; &amp; (typeCtor.arity - 1) &amp; &quot;]&quot;_
					)
				End If
				typeStr = typeStr &amp; &quot;a&quot; &amp; t &amp; &quot; -&gt; &quot;
			ElseIf isType(t) Then
				If isArrowType(t) Then
					typeStr = typeStr &amp; &quot;(&quot; &amp; t.str &amp; &quot;)&quot;
				Else
					typeStr = typeStr &amp; t.str
				End If
				typeStr = typeStr &amp; &quot; -&gt; &quot;
			Else
				croak(&quot;_newDataCtor &quot; &amp; name &amp; &quot;: &quot; _
					&amp; &quot;invalid type arg &quot; &amp; toString(t) _
				)
			End If
			ats(k) = t
			k = k + 1
		Next i
	End If
	
	typeStr = typeStr &amp; typeCtor._name
	For i = 0 To typeCtor.arity - 1
		typeStr = typeStr &amp; &quot; a&quot; &amp; i
	Next i

	out.str = typeCtor._name &amp; &quot;.&quot; &amp; name &amp; &quot; :: &quot; &amp; typeStr
	_newDataCtor = out
End Function

Function _newTypeCtor( _
	name As String, _
	arity As Integer, _
	dataCtorDefs As Array _
) As TypeCtor
	Dim out As New TypeCtor
	out._name = name
	out.arity = arity
	Dim lo As Integer : lo = LBound(dataCtorDefs)
	Dim hi As Integer : hi = UBound(dataCtorDefs)
	Dim n  As Integer : n = hi - lo + 1
	If n = 0 Then
		out.dataCtors = Array()
	Else
		n = CInt(n / 2)
		Dim dataCtors(0 To n - 1)
		Dim c As Object
		Dim i As Integer : i = lo
		Dim k As Integer : k = 0
		Dim argTypes &apos; the types of the ctors arguments - NOT typeArgs!
		Do Until i &gt; hi
			c = _newDataCtor(out, dataCtorDefs(i), dataCtorDefs(i + 1))
			dataCtors(k) = c
			i = i + 2
			k = k + 1
		Loop
		out.dataCtors = dataCtors
	End If
	_newTypeCtor = out
End Function

Function TypeCtor_equ(a As TypeCtor, b As TypeCtor)
	Dim out
	out = (a._name = b._name)
	TypeCtor_equ = out
End Function

Function isDataType(x As Variant)
	Dim out
	out = False
	On Local Error Goto isDataType_end
	out = _isDataType(x) &apos; DON&apos;T .-access x here!! (simpler this way anyhow)
isDataType_end:
	isDataType = out
End Function

&apos; provokes an error if x isn&apos;t a DataType
Function _isDataType(x As DataType) As Boolean
	_isDataType = Not(isNull(x.typeCtor)) And isArray(x.typeArgs)
End Function

Function isType(t As Variant)
	isType = isDataType(t) Or False
End Function

Function isArrowType(x As Variant)
	Dim out
	out = False
	&apos; TODO: implent isArrowType
	isArrowType = out
End Function

&apos; that&apos;s how to make a DataType: apply a typeCtor to some types
Function applyTC(tc As TypeCtor, typeArgs As Array) As DataType
	Dim out, n As Integer, k As Integer
	k = LBound(typeArgs)
	n = UBound(typeArgs) - k + 1
	If (n &lt;&gt; tc.arity) Then
		croak(&quot;applyTC &quot; &amp; tc._name &amp; &quot;: expected &quot; &amp; tc.arity _
			&amp; &quot; type arg&quot; &amp; IIf(tc.arity = 1, &quot;&quot;, &quot;s&quot;) &amp; &quot; but got &quot; &amp; n _
			&amp; &quot;: &quot; &amp; NL &amp; toString(typeArgs) _
		)
	End If
	out = New DataType
	out.typeCtor = tc
	Dim str As String
	str = tc._name
	If n = 0 Then
		out.typeArgs = Array()
	Else
		Dim tas(0 To n - 1)
		Dim a
		Dim i As Integer
		For i = 0 To n - 1
			a = typeArgs(k)
			If isType(a) Then
				If isDataType(a) Then
					If a.typeCtor.arity = 0 Then
						str = str &amp; &quot; &quot; &amp; a.str
					Else
						str = str &amp; &quot; (&quot; &amp; a.str &amp; &quot;)&quot;
					End If
				&apos;ElseIf isBaseType(a) Or isTypeVar(a) Then
				&apos;	str = str &amp; &quot; &quot; a._name
				End If
			Else
				croak(&quot;applyTc: invalid type arg &quot; _
					&amp; &quot;- expected a Type, not &quot; &amp; typeOf(a) _
					&amp; &quot;: &quot; &amp; NL &amp; toString(a) _
				)
			End If
			tas(i) = a
			k = k + 1
		Next i
		out.typeArgs = tas
	End If
	out.str = str
	applyTC = out
End Function


Function Type_equ(a As Object, b As Object)
	Dim out
	out = False
	If isType(a) And isType(b) Then
		If isDataType(a) And isDataType(b) Then
			out = DataType_equ(a, b)
		&apos;ElseIf ... &apos;TODO: Type_equ for other Types
		End If
	Else
		croak(&quot;Type_equ: cannot compare &quot; &amp; typeOf(a) _
			&amp; &quot; and &quot; &amp; typeOf(b))
	End If
	Type_equ = out
End Function

Function DataType_equ(a As DataType, b As DataType)
	Dim out
	out = False
	If TypeCtor_equ(a.typeCtor, b.typeCtor) Then
		Dim aArgs : aArgs = a.typeArgs
		Dim bArgs : bArgs = b.typeArgs
		Dim i As Integer
		For i = 0 To UBound(aArgs)
			If Not(Type_equ(aArgs(i), bArgs(i))) Then
				Goto DataType_equ_end
			End If
		Next i
		out = True
	End If
DataType_equ_end:
	DataType_equ = out
End Function

Function applyDC(ctor As DataCtor, args As Array)
	Dim out
	Dim n As Integer, k As Integer
	n = UBound(args) - LBound(args) + 1
	k = ctor.arity
	If n &lt;&gt; k Then
		croak(&quot;applyDC &quot; &amp; ctor.name &amp; &quot;: expected &quot; &amp; k &amp; &quot; args &quot; _
			&amp; &quot; but got &quot; &amp; n
	End If
	out = New DataValue
	out.ctor = ctor
	out.fields = args
		
	applyDC = out
End Function


Function typeOf(x As Variant)
	Dim out As String
	out = TypeName(x)
	If out = &quot;Object&quot; Then
		out = _typeOf(x) &apos; DONT access fields in here!
	ElseIf IsArray(x) Then
		out = &quot;Array&quot;
	End If
	typeOf = out
End Function

Function _typeOf(o As Object)
	Dim out As String
	out = &quot;Object&quot;
	On Local Error Goto _typeOf_end
	out = out &amp; &quot;/&quot; &amp; _tyname(o)
_typeOf_end:
	_typeOf = out
End Function

Function _tyname(o As Object)
	_tyname = o.tyname
End Function

Function ctorOf(Optional x As Variant)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.ctorOf : End If
	Dim out As Variant
	If isMissing(x) Then : out = oFn
	Else
		out = Empty
		If isObject(x) Then
			If Not(isNull(x)) Then
				On Local Error Goto ctorOf_end
				out = _ctor(x) &apos; DONT access fields in here!
				If Not(isFn(out)) Then
					On Local Error Goto ctorOf_error
					out.provoke_an_error
				End If
			End If
		End If
	End If
ctorOf_end:
	ctorOf = out
	Exit Function
ctorOf_error:
	croak(&quot;ctorOf: object with invalid .ctor :: &quot; &amp; typeOf(out) &amp; NL &amp; toString(out))
End Function

Function _ctor(o As Object)
	_ctor = o.ctor
End Function



Function isString(Optional x As Variant)
	If isMissing(x) Then
		isString = Fn.isString
	Else
		isString = (typeOf(x) = typeOf(&quot;&quot;))
	End If
End Function

Function isInteger(Optional x As Variant)
	Dim out As Variant
	If isMissing(x) Then : out = Fn.isInteger
	Else 				 : out = (typeOf(x) = typeOf(0))
	End If
	isInteger = out
End Function


Function [test_Type======================================]
	test_Type_typeOf()
	test_Type_isObject()
	test_Type_isString()
	test_Type_isInteger()
	
	test_Type_isDataType()
	test_Type_TypeCtor()
	test_Type_DataCtor()
	test_Type_DataValue()
	test_Type_ctorOf()
End Function


Type TTest_NoTyname
End Type

Type TTest_Tyname
	tyname As String
End Type

Type TTest_Foo
	bar As Integer
End Type

Type TTest_Ctor
	ctor As Variant
End Type


Function test_Type_typeOf()
	assertEqual(typeOf(0), &quot;Integer&quot;).x
	assertEqual(typeOf(1), &quot;Integer&quot;).x
	assertEqual(typeOf(-42), &quot;Integer&quot;).x
	
	assertEqual(typeOf(&quot;&quot;), &quot;String&quot;).x
	assertEqual(typeOf(&quot;1&quot;), &quot;String&quot;).x
	
	assertEqual(typeOf(3.14), &quot;Double&quot;).x

	assertEqual(typeOf(Array()), &quot;Array&quot;).x

	assertEqual(typeOf(Empty), &quot;Empty&quot;).x
	assertEqual(typeOf(Nothing), &quot;Object&quot;).x


	Dim t1 As New TTest_NoTyName
	assertEqual(typeOf(t1), &quot;Object&quot;).x

	Dim t2 As New TTest_TyName
	t2.tyname = &quot;foobar&quot;
	assertEqual(typeOf(t2), &quot;Object/foobar&quot;).x
End Function
	
Function test_Type_ctorOf()
	assertEqual(ctorOf(Nothing),	Empty).x
	assertEqual(ctorOf(Empty),		Empty).x
	assertEqual(ctorOf(True),		Empty).x
	assertEqual(ctorOf(False),		Empty).x
	assertEqual(ctorOf(&quot;&quot;),			Empty).x
	assertEqual(ctorOf(&quot;blah&quot;),		Empty).x
	assertEqual(ctorOf( 0),			Empty).x
	assertEqual(ctorOf( 1),			Empty).x
	assertEqual(ctorOf(-1),			Empty).x
	assertEqual(ctorOf(3.1415),		Empty).x

	Dim o As Object, act As Variant
	
	&apos; an object without member .ctor:
	o = New TTest_TyName
	assertEqual(ctorOf(o), Empty).x
	o.tyname = &quot;foo&quot;
	assertEqual(ctorOf(o), Empty).x

	&apos; an object with a member .ctor:
	o = New TTest_Ctor
	o.ctor = Empty		: assertThrows(ctorOf, Array(o)).x
	o.ctor = Nothing	: assertThrows(ctorOf, Array(o)).x
	o.ctor = True		: assertThrows(ctorOf, Array(o)).x
	o.ctor = False		: assertThrows(ctorOf, Array(o)).x
	o.ctor = &quot;&quot;			: assertThrows(ctorOf, Array(o)).x
	o.ctor = &quot;foo&quot;		: assertThrows(ctorOf, Array(o)).x
	o.ctor =  0			: assertThrows(ctorOf, Array(o)).x
	o.ctor =  1			: assertThrows(ctorOf, Array(o)).x
	o.ctor = -1			: assertThrows(ctorOf, Array(o)).x
	o.ctor = 3.1415		: assertThrows(ctorOf, Array(o)).x
	o.ctor = Array()	: assertThrows(ctorOf, Array(o)).x
	
	o.ctor = New TTest_TyName
	assertThrows(ctorOf, Array(o)).x
	o.ctor.tyname = &quot;foo&quot;
	assertThrows(ctorOf, Array(o)).x

	o.ctor = Fn.cons
	act = ctorOf(o)
	assertEqual(isFn(act), True).x
	assertEqual(getFnName(act), getFnName(Fn.cons)).x
	assertEqual(arity(act), arity(Fn.cons)).x
End Function

&apos; isObject is a BASIC function:
&apos; make sure we know exactly what it does
Function test_Type_isObject()
	Dim o As Object

	assertEqual(isObject(Nothing),	True).x

	assertEqual(isObject(Empty),	False).x
	assertEqual(isObject(True),		False).x
	assertEqual(isObject(False),	False).x
	assertEqual(isObject(&quot;&quot;),		False).x
	assertEqual(isObject(&quot;foobar&quot;),	False).x
	assertEqual(isObject( 0),		False).x
	assertEqual(isObject( 1),		False).x
	assertEqual(isObject(-1),		False).x
	assertEqual(isObject(3.1415),	False).x
	assertEqual(isObject(Array()),	False).x

	o = New TTest_Foo
	assertEqual(isObject(o), True).x
	o.bar = 4711
	assertEqual(isObject(o), True).x
End Function

&apos; isString: implemented above
Function test_Type_isString()
	assertEqual(isString(&quot;&quot;),                  True).x
	assertEqual(isString(&quot;a&quot;),                 True).x
	assertEqual(isString(&quot;foobar&quot;),            True).x
	assertEqual(isString(Nothing),            False).x
	assertEqual(isString(Empty),              False).x
	assertEqual(isString(True),               False).x
	assertEqual(isString(False),              False).x
	assertEqual(isString(0),                  False).x
	assertEqual(isString(1),                  False).x
	assertEqual(isString(3.14),               False).x
	assertEqual(isString(Array()),            False).x
	assertEqual(isString(Array(42)),          False).x
	assertEqual(isString(Array(42)),          False).x
	
	assertEqual(arity(Fn.isString),	1).x &apos; from Fn object
	assertEqual(arity(isString),	1).x &apos; from 0-arg call
	
	assertEqual(apply(isString, &quot;&quot;),         True).x
	assertEqual(apply(isString, &quot;a&quot;),        True).x
	assertEqual(apply(isString, &quot;foobar&quot;),   True).x
	assertEqual(apply(isString, Nothing),   False).x
	assertEqual(apply(isString, Empty),     False).x
	assertEqual(apply(isString, True),      False).x
	assertEqual(apply(isString, False),     False).x
	assertEqual(apply(isString, 0),         False).x
	assertEqual(apply(isString, 1),         False).x
	assertEqual(apply(isString, 3.14),      False).x
	assertEqual(apply(isString, Array()),   False).x
	assertEqual(apply(isString, Array(42)), False).x
	assertEqual(apply(isString, Array(42)), False).x
End Function

&apos; isInteger: implemented above
Function test_Type_isInteger()
	assertEqual(isInteger(&quot;&quot;),                 False).x
	assertEqual(isInteger(&quot;a&quot;),                False).x
	assertEqual(isInteger(&quot;foobar&quot;),           False).x
	assertEqual(isInteger(Nothing),            False).x
	assertEqual(isInteger(Empty),              False).x
	assertEqual(isInteger(True),               False).x
	assertEqual(isInteger(False),              False).x
	assertEqual(isInteger( 0),                  True).x
	assertEqual(isInteger( 1),                  True).x
	assertEqual(isInteger(-1),                  True).x
	assertEqual(isInteger( 32766),              True).x &apos;0x7FFE
	assertEqual(isInteger( 32767),              True).x &apos;0x7FFF
	assertEqual(isInteger( 32768),             False).x &apos;0x8000 (!)
	assertEqual(isInteger( 65534),             False).x &apos;0xFFFE
	assertEqual(isInteger( 65535),             False).x &apos;0xFFFF
	assertEqual(isInteger( 65536),             False).x &apos;0x80000
	assertEqual(isInteger(-32766),              True).x &apos;0x8002
	assertEqual(isInteger(-32767),              True).x &apos;0x8001
	assertEqual(isInteger(-32768),              True).x &apos;0x8000
	assertEqual(isInteger(-32769),             False).x &apos;0x17FFF (!)
	assertEqual(isInteger(-65534),             False).x &apos;0xFFFE
	assertEqual(isInteger(-65535),             False).x &apos;0xFFFF
	assertEqual(isInteger(-65536),             False).x &apos;0x80000
	assertEqual(isInteger(3.14),               False).x
	assertEqual(isInteger(Array()),            False).x
	assertEqual(isInteger(Array(42)),          False).x
	assertEqual(isInteger(Array(42)),          False).x
End Function

Function test_Type_isDataType()
	&apos; positive tests below in test_TypeCtor
	&apos; main thing to prove is that it doesn&apos;t throw
	assertEqual(isDataType(Nothing),            False).x
	assertEqual(isDataType(Empty),              False).x
	assertEqual(isDataType(True),               False).x
	assertEqual(isDataType(False),              False).x
	assertEqual(isDataType(&quot;&quot;),                 False).x
	assertEqual(isDataType(&quot;a&quot;),                False).x
	assertEqual(isDataType(&quot;foobar&quot;),           False).x
	assertEqual(isDataType(0),                  False).x
	assertEqual(isDataType(1),                  False).x
	assertEqual(isDataType(3.14),               False).x
	assertEqual(isDataType(Array()),            False).x
	assertEqual(isDataType(Array(42)),          False).x
	assertEqual(isDataType(Array(42)),          False).x
	
	Dim o As Object
	o = New TTest_Foo
	assertEqual(isDataType(o), False).x
End Function

Function test_Type_TypeCtor()
	Dim tc0, tc1
	tc0 = _newTypeCtor(&quot;TC0&quot;, 0, Array())
	assertEqual(isDataType(tc0),           False).x
	assertEqual(tc0._name, &quot;TC0&quot;).x
	assertEqual(tc0.arity, 	  0 ).x
	assertEqual(TypeCtor_equ(tc0, tc0), 	True).x
	
	tc1 = _newTypeCtor(&quot;TC1&quot;, 1, Array())
	assertEqual(tc1._name, &quot;TC1&quot;).x
	assertEqual(tc1.arity, 	  1 ).x
	assertEqual(TypeCtor_equ(tc1, tc1), 	True).x

	assertEqual(TypeCtor_equ(tc0, tc1), 	False).x
	assertEqual(TypeCtor_equ(tc1, tc0), 	False).x
	
	Dim dt0, args
	args = Array()
	dt0 = applyTC(tc0, args)
	assertEqual(isDataType(dt0), True).x
	assertEqual(LBound(dt0.typeArgs),  0).x
	assertEqual(UBound(dt0.typeArgs), -1).x
	assertEqual(TypeCtor_equ(tc0, dt0.typeCtor), True).x
	
	Redim args(0 To 1)
	assertEqual(UBound(dt0.typeArgs), -1).x

	Dim dt1
	&apos;assertThrows(Fn.applyTC, Array(tc1, Array(tc1)) ).x
	args = Array(dt0)
	dt1 = applyTC(tc1, args)
	assertEqual(LBound(dt1.typeArgs),  0).x
	assertEqual(UBound(dt1.typeArgs),  0).x
	assertEqual(TypeCtor_equ(tc1, dt1.typeCtor), True).x
	assertEqual(DataType_equ(dt1.typeArgs(0), dt0), True).x

	&apos; the typeArgs array cannot be changed via ByRef var:
	args(0) = dt1
	assertEqual(DataType_equ(dt1.typeArgs(0), dt0), True).x

	Dim dt1b
	args = Array(dt0)
	dt1b = applyTC(tc1, args)
	assertEqual(DataType_equ(dt1b, dt1), True).x
	
	args = Array(dt1) &apos; TC1 (TC1 TC0) is also a proper DataType
	dt1b = applyTC(tc1, args) &apos; but different from TC1 TC0:
	assertEqual(DataType_equ(dt1b, dt1), False).x
End Function

Function test_Type_DataCtor()
	Dim tc
	Dim c1, c2
	Dim dtUnit, dtBool, dtMaybeUnit, dtMaybeBool
	
	&apos; no type args, only 1 zero-arg data ctor ~ Unit
	tc = _newTypeCtor(&quot;TC_Unit&quot;, 0, _
		Array( _
			&quot;_Unit&quot;, Array() _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_Unit&quot;).x
	assertEqual(c1.arity,       0).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	dtUnit = applyTC(tc, Array())
	
	&apos; no type args, 2 zero-arg data ctors ~ Bool
	tc = _newTypeCtor(&quot;TC_Bool&quot;, 0, _
		Array( _
			&quot;_False&quot;, Array(), _
			&quot;_True&quot;,  Array() _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_False&quot;).x
	assertEqual(c1.arity,        0).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	c2 = tc.dataCtors(1)
	assertEqual(c2._name, &quot;_True&quot;).x
	assertEqual(c2.arity,       0).x
	assertEqual(TypeCtor_equ(c2.typeCtor, tc), True).x
	dtBool = applyTC(tc, Array())
	
	&apos; one type args, 2 data ctors ~ Maybe
	tc = _newTypeCtor(&quot;TC_Maybe&quot;, 1, _
		Array( _
			&quot;_None&quot;, Array(), _
			&quot;_Some&quot;, Array(0) _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_None&quot;).x
	assertEqual(c1.arity,      0).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	c2 = tc.dataCtors(1)
	assertEqual(c2._name, &quot;_Some&quot;).x
	assertEqual(c2.arity,       1).x
	assertEqual(TypeCtor_equ(c2.typeCtor, tc), True).x

	&apos;show(c1.str, c2.str)

	dtMaybeUnit = applyTC(tc, Array(dtUnit))
	dtMaybeBool = applyTC(tc, Array(dtBool))
	
	&apos;show(dtMaybeUnit.str)

	&apos; dataCtors may only refer to typeVars with index &lt; typeCtor.arity:
	&apos;assertThrows(_newTypeCtor(&quot;TC_Foo&quot;, 0, Array(&quot;_Bar&quot;, Array(0)))).x
	&apos;assertThrows(_newTypeCtor(&quot;TC_Foo&quot;, 1, Array(&quot;_Bar&quot;, Array(1)))).x
		
	&apos; two type args, one 2-arg data ctors ~ Pair
	tc = _newTypeCtor(&quot;TC_Pair&quot;, 2, _
		Array( _
			&quot;_Pair&quot;, Array(0, 1) _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_Pair&quot;).x
	assertEqual(c1.arity,       2).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x

	&apos; two type args, two 1-arg data ctors ~ Either
	tc = _newTypeCtor(&quot;TC_Either&quot;, 2, _
		Array( _
			&quot;_Left&quot;,  Array(0), _
			&quot;_Right&quot;, Array(1) _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_Left&quot;).x
	assertEqual(c1.arity,       1).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	c2 = tc.dataCtors(1)
	assertEqual(c2._name, &quot;_Right&quot;).x
	assertEqual(c2.arity,       1).x
	assertEqual(TypeCtor_equ(c2.typeCtor, tc), True).x
	
	
	&apos;-- data ctors with non-var argument types:

	&apos; one type arg, 1 data ctors ~ package together something and a Bool
	tc = _newTypeCtor(&quot;TC_Foo&quot;, 1, _
		Array( _
			&quot;_Bar&quot;, Array(0, dtMaybeBool) _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_Bar&quot;).x
	assertEqual(c1.arity,      2).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	
	&apos;show(c1.str)

End Function


Function test_Type_DataValue()
	Dim tc, dt
	Dim c1, c2
	Dim v1, v2
	
	tc = _newTypeCtor(&quot;TC_Unit&quot;, 0, Array( _
		&quot;_Unit&quot;, Array() _
	))
	dt = applyTC(tc, Array())
	c1 = tc.dataCtors(0)
	assertEqual(c1.arity, 0).x
	v1 = applyDC(c1, Array())
	show(v1.ctor.str, c1.str)
	assertEqual(DataType_equ(v1.dataType, dt), True).x
End Function


</script:module>