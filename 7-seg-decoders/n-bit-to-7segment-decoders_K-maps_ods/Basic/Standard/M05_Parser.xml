<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M05_Parser" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit


Type Parser
	tyname As String
	tp As String
	st As Array
End Type


Sub Main
	test_Parser()
	Stop
	Dim s As String
	Dim pDigit As Parser, pHexDigit As Parser, pHexNum As Parser, pHexLit As Parser
	Set pDigit = mkChoice(mkChoice(mkChoice(pStr(&quot;0&quot;), pStr(&quot;1&quot;)), pStr(&quot;2&quot;)), pStr(&quot;3&quot;))
	Set pHexDigit = mkChoice(pDigit, mkChoice(mkChoice(mkChoice(mkChoice(mkChoice(pStr(&quot;A&quot;), pStr(&quot;B&quot;)), pStr(&quot;C&quot;)), pStr(&quot;D&quot;)), pStr(&quot;E&quot;)), pStr(&quot;F&quot;)))
	Set pHexNum = mkSeq(Array(mkMany(pHexDigit)), &quot;readHex&quot;)
	Set pHexLit = mkSeq(Array(pStr(&quot;0x&quot;), pHexNum), &quot;snd&quot;)
	Dim p As Parser 
	&apos;mkChoice(pItem(), pReturn(&quot;bar&quot;))
	Set p = mkSeq(Array(pHexLit, mkMany(pWs)), &quot;fst&quot;)
	s = &quot;FF 0x1F __Âµ 0&quot;

	MsgBox( _
		&quot;applying parser &apos;&quot; &amp; p.tp &amp; &quot;&apos; to &quot; &amp; toString(s) &amp; &quot;: &quot; &amp; chr(13) _
		&amp; toString(applyP(p, s)) _
	)

End Sub

&apos;==================================================================

Function mkParser(tp As String, st As Variant)
	Dim result As New Parser
	result.tyname = &quot;TParser&quot;
	result.tp = tp
	result.st = st
	mkParser = result
End Function

Function pFail()
	Static result As New Parser
	If result.tp = &quot;&quot; Then
		result = mkParser(&quot;fail&quot;, Array())
	End If
	pFail = result
End Function

Function parseFailure()
	parseFailure = nil
End Function

Function isParseFailure(parseResult) As Boolean
	If typeOf(parseResult) &lt;&gt; typeOf(parseFailure) Then
		isParseFailure = False
	Else
		isParseFailure = equ(parseResult, parseFailure)
	End If
End Function

Function pReturn(x As Variant)
	pReturn = mkParser(&quot;return&quot;, Array(x))
End Function

Function pItem()
	Static result As New Parser
	If result.tp = &quot;&quot; Then
		result = mkParser(&quot;item&quot;, Array())
	End If
	pItem = result
End Function

Function pStr(t As String)
	If (Len(t) = 0) Then
		croak(&quot;pStr: cannot match &apos;exactly&apos; the empty string t=&apos;&apos;&quot;)
	Else
		pStr = mkParser(&quot;str&quot;, Array(t))
	End If
End Function

Function mkChoice(p1 As Parser, p2 As Parser)
	mkChoice = mkParser(&quot;choice&quot;, Array(p1, p2))
End Function

Function mkMany(p As Parser)
	mkMany = mkParser(&quot;many&quot;, Array(p))
End Function

Function mkBind(fName As String, p As Parser)
	If Not existsF(fName) Then
		croak(&quot;mkBind: unknown function &quot; &amp; toString(fName))
	Else
		mkBind = mkParser(&quot;bind&quot;, Array(p, fName))
	End If
End Function

Function mkSeq(ps As Array, fName As String)
	If Not existsF(fName) Then
		croak(&quot;mkSeq: unknown function &quot; &amp; toString(fName))
	Else
		mkSeq = mkParser(&quot;seq&quot;, Array(ps, fName))
	End If
End Function

&apos;==================================================================


Function pWs()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = mkChoice(pStr(&quot; &quot;), pStr(Chr(9))
	End If
	pWs = result
End Function

Function pBinDigit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = mkChoice(pStr(&quot;0&quot;), pStr(&quot;1&quot;))
	End If
	pBinDigit = result
End Function

Function pDecDigit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = mkChoice(pBinDigit, mkChoice(pStr(&quot;2&quot;), pStr(&quot;3&quot;))
	End If
	pDecDigit = result
End Function

Function lookupParser(pName As String) As Parser
	Dim result As Parser
	Select Case pName
		Case &quot;pWs&quot;:			result = pWs
		Case &quot;pBinDigit&quot;:	result = pBinDigit
		Case &quot;pDecDigit&quot;:	result = pDecDigit
		Case Else
			croak(&quot;unknown parser &quot; &amp; pName)
	End Select
	lookupParser = result
End Function

&apos;==================================================================

Function parse(pName As String, s As String)
	Dim result As String
	result = toString(applyP(lookupParser(pName), s))
	if (result = &quot;Empty&quot;) then
		MsgBox(pName &amp; &quot; on &quot; &amp; tostring(s) &amp; &quot; yielded &quot; &amp; result)
	end if
	parse = result
End Function

Function applyP(ByVal parser As Variant, s As String, Optional pos As Integer)
	Dim p As Parser
	If IsNull(parser) Or IsEmpty(parser) Then
		croak(&quot;applyP: parser p = &quot; &amp; toString(parser))
	ElseIf TypeName(parser) = &quot;Object&quot; Then
		Set p = parser
	Else
		croak(&quot;applyP: invalid arg parser - &quot; &amp; toString(parser))
	End If
	If IsMissing(pos) Then
		pos = 1
	End If

	Dim result As Variant
	Dim nxtPos As Integer
	If p.tp = &quot;return&quot; Then
		result = Array(p.st(0), pos)
	ElseIf p.tp = &quot;fail&quot; Then
		result = parseFailure
	ElseIf p.tp = &quot;item&quot; Then
		If pos &lt;= Len(s) Then
			result = Array(Mid(s, pos, 1), pos + 1)
		Else
			result = parseFailure
		End If
	ElseIf p.tp = &quot;choice&quot; Then
		result = applyP(p.st(0), s, pos)
		If isParseFailure(result) Then
			result = applyP(p.st(1), s, pos)
		End If
	ElseIf p.tp = &quot;str&quot; Then
		Dim match As String
		Dim matchLen As Integer
		match = p.st(0)
		matchLen = Len(match)
		If (Mid(s, pos, matchLen) = match) Then
			result = Array(match, pos + matchLen)
		Else
			result = parseFailure
		End If
		&apos;MsgBox(&quot;str(&quot; &amp; toString(match) &amp; &quot;), s=&quot; &amp; toString(s) &amp; &quot;, pos=&quot; &amp; toString(pos) &amp; &quot;, matchLen=&quot; &amp; toString(matchLen)_
		&apos;	&amp; chr(13) &amp; &quot;~&gt;&quot; &amp; toString(result))
	ElseIf p.tp = &quot;many&quot; Then
		Dim lst As Object
		Dim lstLen As Integer
		nxtPos = pos
		lstLen = 0
		Set lst = nil
		result = applyP(p.st(0), s, nxtPos)
		While Not(isParseFailure(result))
			nxtPos = result(1)
			Set lst = cons(result(0), lst)
			lstLen = lstLen + 1
			result = applyP(p.st(0), s, nxtPos)
		Wend
		If lstLen = 0 Then
			result = Array(Array(), nxtPos)
		Else
			ReDim things(0 To lstLen-1) As Variant
			While lstLen &gt; 0
				lstLen = lstLen - 1
				things(lstLen) = lst.head
				Set lst = lst.tail
			Wend
			result = Array(things, nxtPos)
		End If
	ElseIf p.tp = &quot;bind&quot; Then
		result = applyP(p.st(0), s, pos)
		If Not isParseFailure(result) Then
			Dim fResult As Variant
			fResult = applyToList(p.st(1), toList(result(0)))
			result(0) = fResult
		End If
	ElseIf p.tp = &quot;seq&quot; Then
		Dim innerParsers As Variant, t As Variant
		Dim i As Integer, j As Integer, k As Integer
		innerParsers = p.st(0)
		i = LBound(innerParsers)
		k = UBound(innerParsers)
		j = 0
		nxtPos = pos
		Dim iResults(0 To k-i) As Variant
		Do
			t = applyP(innerParsers(i), s, nxtPos)
			If Not isParseFailure(t) Then
				iResults(j) = t(0)
				nxtPos = t(1)
				i = i + 1
				j = j + 1
			End If
		Loop Until (i &gt; k) Or isParseFailure(t)
		If Not IsEmpty(t) Then
&apos;			Dim fResult As Variant
			fResult = applyToList(p.st(1), toList(iResults))
			result = t
			result(0) = fResult
		End If
		MsgBox(&quot;seq/&quot; &amp; p.st(1) &amp; &quot;: &quot; &amp; toString(result))
	Else
		result = &quot;unknown Parser &apos;&quot; &amp; p.tp &amp; &quot;&apos;&quot;
		MsgBox(&quot;Error in applyP: &quot; &amp; result)
	End If
	applyP = result
End Function


&apos;= tests ============================================================

Function test_Parser()
	test_Parser_fail()
	test_Parser_item()
	test_Parser_return()
	test_Parser_str()
	
End Function

Function assert_parse(ByVal p As Variant, ByVal s As String, ByVal expected As Variant)
	If isString(p) Then
		p = lookupParser(p)
	End If
	If Not(isString(expected)) Then
		expected = toString(expected)
	End If
	assertEqual(typeOf(p), &quot;Object/TParser&quot;).x
	Dim actual As Variant
	actual = applyP(p, s)
	
	assert_parse = assertEqual(toString(actual), expected)
End Function

Function test_Parser_fail()
	assert_parse(pFail, &quot;&quot;,		parseFailure).x
	assert_parse(pFail, &quot; &quot;,	parseFailure).x
	assert_parse(pFail, &quot;a&quot;,	parseFailure).x
	assert_parse(pFail, &quot;1&quot;,	parseFailure).x
	assert_parse(pFail, &quot;[]&quot;,	parseFailure).x
End Function

Function test_Parser_item()
	assert_parse(pItem, &quot;&quot;,			parseFailure).x
	assert_parse(pItem, &quot; &quot;,		Array(&quot; &quot;, 2)).x
	assert_parse(pItem, &quot;a&quot;,		Array(&quot;a&quot;, 2)).x
	assert_parse(pItem, &quot;1&quot;,		Array(&quot;1&quot;, 2)).x
	assert_parse(pItem, &quot;[]&quot;,		Array(&quot;[&quot;, 2)).x
	assert_parse(pItem, &quot;abcd&quot;,		Array(&quot;a&quot;, 2)).x
	assert_parse(pItem, chr(13),	Array(chr(13), 2)).x
End Function

Function test_Parser_return()
	Dim p As Parser
	Dim expected As Variant

	p = pReturn(&quot;bar&quot;)
	expected = Array(&quot;bar&quot;, 1)
	assert_parse(p, &quot;&quot;,			expected).x
	assert_parse(p, &quot; &quot;,		expected).x
	assert_parse(p, &quot;a&quot;,		expected).x
	assert_parse(p, &quot;1&quot;,		expected).x
	assert_parse(p, &quot;[]&quot;,		expected).x
	assert_parse(p, &quot;abcd&quot;,		expected).x
	assert_parse(p, chr(13),	expected).x

	p = pReturn(4711)	
	expected = Array(4711, 1)
	assert_parse(p, &quot;&quot;,			expected).x
	assert_parse(p, &quot; &quot;,		expected).x
	assert_parse(p, &quot;a&quot;,		expected).x
	assert_parse(p, &quot;1&quot;,		expected).x
	assert_parse(p, &quot;[]&quot;,		expected).x
	assert_parse(p, &quot;abcd&quot;,		expected).x
	assert_parse(p, chr(13),	expected).x
End Function

Function test_Parser_str()
	Dim p As Parser

&apos;	assertThrows(pStr, Array(&quot;&quot;)).x

	p = pStr(&quot;bar&quot;)
	assert_parse(p, &quot;&quot;,				parseFailure).x
	assert_parse(p, &quot; &quot;,			parseFailure).x
	assert_parse(p, &quot; &quot; &amp; chr(13),	parseFailure).x
	assert_parse(p, &quot;asdf&quot;,			parseFailure).x
	assert_parse(p, &quot; bar&quot;,			parseFailure).x
	assert_parse(p, &quot;b&quot;,			parseFailure).x
	assert_parse(p, &quot;ba&quot;,			parseFailure).x
	assert_parse(p, &quot;bar&quot;,			Array(&quot;bar&quot;, 4)).x
	assert_parse(p, &quot;barb&quot;,			Array(&quot;bar&quot;, 4)).x
	assert_parse(p, &quot;barba&quot;,		Array(&quot;bar&quot;, 4)).x
	assert_parse(p, &quot;barbar&quot;,		Array(&quot;bar&quot;, 4)).x

	p = pStr(chr(13))
	assert_parse(p, &quot;&quot;,				parseFailure).x
	assert_parse(p, &quot; &quot;,			parseFailure).x
	assert_parse(p, &quot; &quot; &amp; chr(13),	parseFailure).x
	assert_parse(p, &quot;asdf&quot;,			parseFailure).x
	assert_parse(p, &quot; bar&quot;,			parseFailure).x
	assert_parse(p, &quot;b&quot;,			parseFailure).x
	assert_parse(p, &quot;ba&quot;,			parseFailure).x
	assert_parse(p, &quot;bar&quot;,			parseFailure).x
	assert_parse(p, &quot;barb&quot;,			parseFailure).x
	assert_parse(p, &quot;barba&quot;,		parseFailure).x
	assert_parse(p, &quot;barbar&quot;,		parseFailure).x
	assert_parse(p, chr(13),					Array(&quot;\n&quot;, 2)).x
	assert_parse(p, chr(13) &amp; &quot;bar&quot;,			Array(&quot;\n&quot;, 2)).x
	assert_parse(p, chr(13) &amp; chr(13),			Array(&quot;\n&quot;, 2)).x
	assert_parse(p, chr(13) &amp; chr(13) &amp; &quot;bar&quot;,	Array(&quot;\n&quot;, 2)).x
End Function


</script:module>