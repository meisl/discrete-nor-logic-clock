<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M06_AST" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit


Type TASN &apos; &quot;Abstract Syntax Node&quot;
	tyname As String
	label As Variant
	value As Variant
	children As Object
End Type


Sub Main
	test_AST()
End Sub


Function mkASN(label, value, children As Object)
	Dim result As New TASN
	result.tyname = &quot;TASN&quot;
	result.label = label
	result.value = value
	If Not(typeOf(children) = typeOf(nil)) Then
		croak(&quot;mkASN: invalid list of children &quot; &amp; toString(children))
	End If
	result.children = children
	mkAsn = result
End Function

Function isASN(x As Variant) As Boolean
	isASN = (typeOf(x) = &quot;Object/TASN&quot;)
End Function

Function TASN_toString(Optional n As Object)
	Dim result As Variant
	If isMissing(n) Then
		result = Fn.TASN_toString
	Else
		result = _TASN_toString(n, &quot;&quot;, &quot;&quot;)
	End If
	TASN_toString = result
End Function

Function _TASN_toString( _
	n As Object, _
	ByVal prefixN As String, _
	ByVal prefixC As String _
) As String
	Dim result As String
	result = _TASN_toString_head(n)
	Dim k As Integer, i As Integer
	k = asnChildCount(n)
	If k &gt; 0 Then
		i = InStr(1, result, &quot;:&quot;)
		If i = 0 Then : i = 1 : End If
		prefixC = prefixC &amp; Space(i)
		Dim child As Variant
		k = k - 1
		For i = 0 To k
			child = asnChild(n, i)
			If (i = k) Then &apos; last child
				result = result _
					   &amp; chr(13) &amp; chr(10) _
					   &amp; _TASN_toString( _
					   		child, _
							prefixC &amp; &quot;└&quot; , _
							prefixC &amp; &quot; &quot; _
						 )
			Else
				result = result _
					   &amp; chr(13) &amp; chr(10) _
					   &amp; _TASN_toString( _
					   		child, _
							prefixC &amp; &quot;├&quot; , _
							prefixC &amp; &quot;│&quot; _
						 )
			End If
		Next i
	End If
	result = prefixN &amp; &quot;─&quot; &amp; result
	_TASN_toString = result
End Function

Function _TASN_toString_head(n As Object) As String
	Dim result As String, lbl As Variant, val As Variant
	lbl = asnLabel(n)
	val = asnValue(n)
	If isEmpty(val) Then
		val = &quot;&quot;
	ElseIf isString(val) Then
		If (val = &quot;&quot;) Then
			val = &quot;ε&quot;
		Else
			val = toString(val)
		End If
	Else
		val = toString(val)
	End If
	If isEmpty(lbl) Then
		If val = &quot;&quot; Then
			result = &quot;:&quot;
		Else
			result = val
		End If
	Else
		If Not(isString(lbl)) Then
			lbl = toString(lbl)
		End If
		If val = &quot;&quot; Then
			result = lbl
		Else
			result = lbl &amp; &quot;:&quot; &amp; val
		End If
	End If
	_TASN_toString_head = result
End Function

Function asnLabel(n As Object)
	asnLabel = n.label
End Function

Function asnValue(n As Object)
	asnValue = n.value
End Function

Function asnChildren(n As Object)
	asnChildren = n.children
End Function

Function asnIsLeaf(n As Object) As Boolean
	asnIsLeaf = isNil(asnChildren(n))
End Function

Function asnChildCount(n As Object) As Integer
	asnChildCount = length(asnChildren(n))
End Function

Function asnChild(n As Object, ByVal i As Integer)
	Dim result As Variant, cs As Object, len As Integer
	If (i &lt; 0) Then
		croak(&quot;asnChild: invalid child index &quot; &amp; i)
	End If
	cs = asnChildren(n)
	len = length(cs)
	If (i &gt;= len) Then
		If len = 0 Then
			croak(&quot;asnChild: invalid child index &quot; &amp; i &amp; &quot; - has none&quot;)
		Else
			croak(&quot;asnChild: invalid child index &quot; &amp; i &amp; &quot; - has only &quot; &amp; len)
		End If
	Else
		While i &gt; 0
			cs = cdr(cs)
			i = i - 1
		Wend
		result = car(cs)
	End If
	asnChild = result
End Function

Function mkDtTerminal(Optional value As String)
	If isMissing(value) Then
		mkDtTerminal = Fn.mkDtTerminal
	Else
		mkDtTerminal = mkASN(Empty, value, nil)
	End If
End Function

Function mkDtCClass(Optional cclass As String, Optional value As String)
	If isMissing(cclass) Then
		mkDtCClass = Fn.mkDtCClass
	ElseIf isMissing(value) Then
		mkDtCClass = apply(Fn.mkDtCClass, cclass)
	Else
		mkDtCClass = mkASN(cclass, value, nil)
	End If
End Function
	
Function mkDtNonterminal( _
	Optional ruleName As String, _
	Optional children As Object _
)
	Dim result As Variant
	If isMissing(ruleName) Then
		result = Fn.mkDtNonterminal
	ElseIf isMissing(children) Then
		result = apply(Fn.mkDtNonterminal, ruleName)
	ElseIf isNil(children) Then
		croak(&quot;mkDtNonterminal: nil not valid as list of children&quot;)
	Else
		result = mkASN(ruleName, Empty, children)
	End If
	mkDtNonterminal = result
End Function

Function mkDtMult( _
	Optional label As String, _
	Optional children As Object _
)
	Dim result As Variant
	If isMissing(label) Then
		result = Fn.mkDtMult
	ElseIf isMissing(children) Then
		result = apply(Fn.mkDtMult, label)
	Else
		&apos;If isNil(children) Then
		&apos;	result = mkASN(label, &quot;&quot;, nil)
		&apos;Else
			result = mkASN(label, Empty, children)
		&apos;End If
	End If
	mkDtMult = result
End Function

Function toDerivationP(Optional p As Object)
	If isMissing(p) Then
		toDerivationP = Fn.toDerivationP
		Exit Function
	End If
	Dim result As Variant, f As Object
	Select Case p.tp
		Case &quot;str&quot;
			result = pBind(p, compose(pReturn, mkDtTerminal))
		Case &quot;item&quot;
			result = pBind(p, compose(pReturn, mkDtCClass(&quot;(.)&quot;)))
			&apos;result = pSeq(Array(p), mkDtCClass(&quot;(.)&quot;))
		Case &quot;choice&quot;
			result = pChoice( _
				toDerivationP(p.st0), _
				toDerivationP(p.st1) _
			)
		Case &quot;seq&quot; &apos; only simple sequences supported here
			f = p.st(1)
			If (getFnName(f) = getFnName(Fn.id)) Then
				result = pSeqL( _
					map(Fn.toDerivationP, p.st(0)), _
					id _
				)			
			&apos;ElseIf isApplyToListId(f) Then
			Else
				croak(&quot;toDerivationP/NYI: pSeq(..., &quot; _
					 &amp; TFn_toString(p.st(1)) &amp; &quot;)&quot; _
					 &amp; chr(13) &amp; chr(10) _
					 &amp; toString(p)_
				)
			End If
		Case &quot;ind&quot;
			If p.st2 Then &apos; seen before
				If isEmpty(p.st3) Then
					croak(&quot;toDerivationP: replace &quot; &amp; p.st1 &amp; &quot;???&quot;)
				End If
				result = p.st3
			ElseIf isNull(p.st0) Then
				croak(&quot;toDerivationP/NYI: uninitialized indirection &quot; &amp; p.st1)
			Else &apos; p.st0 returns a single ASN
				p.st2 = True &apos; set the &quot;visited&quot;-mark
				Dim name As String, q As Object
				name = p.st1
				q = pInd(name)
				p.st3 = q
				q = fixIndirection(q, pBind( _
						toDerivationP(p.st0), _
						compose(pReturn, compose( _
							mkDtNonterminal(q.st1), _
							ite(isList, _
								id, _
								swap(cons, nil) _
							) _
						)) _
				))
				&apos;q = fixIndirection(q, pSeq( _
				&apos;		Array(toDerivationP(p.st0)), _
				&apos;		compose( _
				&apos;			mkDtNonterminal(q.st1), _
				&apos;			ite(isList, _
				&apos;				id, _
				&apos;				swap(cons, nil) _
				&apos;			) _
				&apos;		) _
				&apos;))
				p.st3 = Empty
				p.st2 = False &apos; clear the &quot;visited&quot;-mark
				
				result = q
			End If
		Case Else
			croak(&quot;toDerivationP: cannot handle .tp=&quot; &amp; toString(p.tp))
	End Select
	
	toDerivationP = result
End Function

Function pStr_dt(s As String)
	pStr_dt = pBind(pStr(s), compose(pReturn, mkDtTerminal))
End Function

Function pMany_dt(p As Object)
	pMany_dt = pBind(pMany(p), compose(pReturn, _
		compose( _
			mkDtMult(&quot;(*):W&quot;), _
			id _
		) _
	))
&apos;			map(ite(isString, compose(mkDtTerminal, concat(&quot;!!&quot;)), id) _
&apos;			map(mkDtTerminal) _
End Function

Function pZeroOrOne_dt(p As Object)
	Dim q As Object, f As Object
	q = pZeroOrOne(p)
	f = compose( _
			mkDtMult(&quot;(?):(..|..)&quot;), _
			ite(Fn.isEmpty, _
				fstArg(nil), _
				swap(cons, nil) _
			) _
		)
	pZeroOrOne_dt = pBind(q, compose(pReturn, f))
End Function

&apos;= tests ======================================================================

Function test_AST()
	test_AST_TASN_toString()
	test_AST_toDerivationP()
	test_AST_pMany_dt()

	Dim n0 As Object
	n0 = mkASN(&quot;foo&quot;, &quot;bar&quot;, nil)
	
	assertEqual(typeOf(n0), &quot;Object/TASN&quot;).x
	assertEqual(length(asnChildren(n0)), 0).x
	assertEqual(asnChildCount(n0), 0).x
	assertEqual(asnIsLeaf(n0), True).x
	assertEqual(toString(n0), &quot;─foo:&apos;bar&apos;&quot;).x

	Dim n1 As Object
	n1 = mkASN(Empty, &quot;bar&quot;, nil)
	assertEqual(asnChildCount(n1), 0).x
	assertEqual(asnIsLeaf(n1), True).x
	assertEqual(toString(n1), &quot;─&apos;bar&apos;&quot;).x

	Dim n2 As Object
	n2 = mkASN(&quot;foo&quot;, Empty, nil)
	assertEqual(asnChildCount(n2), 0).x
	assertEqual(asnIsLeaf(n2), True).x
	assertEqual(toString(n2), &quot;─foo&quot;).x

	Dim n3 As Object
	n3 = mkASN(Empty, Empty, nil)
	assertEqual(asnChildCount(n3), 0).x
	assertEqual(asnIsLeaf(n3), True).x
	assertEqual(toString(n3), &quot;─:&quot;).x

	Dim n4 As Object, c0 As Object
	n4 = mkASN(&quot;S&quot;, Empty, List(n1))
	assertEqual(asnChildCount(n4), 1).x
	assertEqual(asnIsLeaf(n4), False).x
	c0 = asnChild(n4, 0)
	assertEqual(asnLabel(c0), asnLabel(n1)).x
	assertEqual(asnValue(c0), asnValue(n1)).x
	assertEqual(asnChildCount(c0), asnChildCount(n1)).x
	
	&apos;assertEqual(toString(n4), &quot;:&quot;).x
	
	Dim s As String
	n0 = mkDtTerminal(&quot;A&quot;)
	n0 = mkDtNonterminal(&quot;I&quot;, List(n0))
	n0 = mkDtNonterminal(&quot;F&quot;, List(n0))
	n0 = mkDtNonterminal(&quot;T&quot;, List(n0))
	
	n1 = mkDtTerminal(&quot;+&quot;)
	
	n2 = mkDtTerminal(&quot;B&quot;)
	n2 = mkDtNonterminal(&quot;I&quot;, List(n2))
	n2 = mkDtNonterminal(&quot;F&quot;, List(n2))
	
	n3 = mkDtTerminal(&quot;*&quot;)
	
	n4 = mkDtTerminal(&quot;C&quot;)
	n4 = mkDtNonterminal(&quot;I&quot;, List(n4))
	n4 = mkDtNonterminal(&quot;F&quot;, List(n4))
	n4 = mkDtNonterminal(&quot;T&quot;, List(n4))
	
	n4 = mkDtNonterminal(&quot;T&quot;, List(n2, n3, n4))
	n4 = mkDtNonterminal(&quot;S&quot;, List(n4))

	n4 = mkDtNonterminal(&quot;S&quot;, List(n0, n1, n4))
	
	s = toString(n4)
	test_AST = s
End Function

Function test_AST_TASN_toString()
	Dim n As Object
	n = mkASN(Empty, Empty, nil)
	assertEqual(TASN_toString(n), &quot;─:&quot;).x
	
	n = mkASN(Empty, &quot;x&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─&apos;x&apos;&quot;).x
	n =mkASN(Empty, &quot;&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─ε&quot;).x
	n = mkASN(Empty, &quot;foobar&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─&apos;foobar&apos;&quot;).x

	n = mkASN(&quot;S&quot;, Empty, nil)
	assertEqual(TASN_toString(n), &quot;─S&quot;).x
	n = mkASN(&quot;Foo&quot;, Empty, nil)
	assertEqual(TASN_toString(n), &quot;─Foo&quot;).x

	n = mkASN(&quot;*&quot;, &quot;&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─*:ε&quot;).x
	n = mkASN(&quot;+&quot;, &quot;&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─+:ε&quot;).x
	n = mkASN(&quot;?&quot;, &quot;&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─?:ε&quot;).x

	n = mkASN(&quot;*&quot;, &quot;W&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─*:&apos;W&apos;&quot;).x
	n = mkASN(&quot;+&quot;, &quot;W&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─+:&apos;W&apos;&quot;).x
	n = mkASN(&quot;?&quot;, &quot;W&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─?:&apos;W&apos;&quot;).x
	
	n = mkASN(&quot;W*&quot;, Empty, nil)
	assertEqual(TASN_toString(n), &quot;─W*&quot;).x
	n = mkASN(&quot;W+&quot;, Empty, nil)
	assertEqual(TASN_toString(n), &quot;─W+&quot;).x
	n = mkASN(&quot;W?&quot;, Empty, nil)
	assertEqual(TASN_toString(n), &quot;─W?&quot;).x
	
End Function

Function test_AST_toDerivationP()
	Dim p As Object, q As Object, r As Variant, x As Object

	p = pItem
	q = toDerivationP(p)
	refute_parses(q, &quot;&quot;).x
	x = mkDtCClass(&quot;(.)&quot;, &quot;a&quot;)
	assert_parses(q, &quot;a&quot;, x, 2).x
	x = mkDtCClass(&quot;(.)&quot;, &quot;b&quot;)
	assert_parses(q, &quot;bca&quot;, x, 2).x
	x = mkDtCClass(&quot;(.)&quot;, &quot;c&quot;)
	assert_parses(q, &quot;cabc&quot;, x, 2).x
	x = mkDtCClass(&quot;(.)&quot;, &quot; &quot;)
	assert_parses(q, &quot; xyzabc&quot;, x, 2).x
	
	p = pStr(&quot;z&quot;)
	q = toDerivationP(p)
	refute_parses(q, Array(&quot;&quot;, &quot;cba&quot;, &quot;x&quot;, &quot;y&quot;)).x
	x = mkDtTerminal(&quot;z&quot;)
	assert_parses(q, &quot;z&quot;, x, 2).x
	&apos; really reads only as many chars as pStr does:
	assert_parses(q, &quot;zz&quot;, x, 2).x
	assert_parses(q, &quot;zy&quot;, x, 2).x

	p = pStr(&quot;abc&quot;)
	q = toDerivationP(p)
	refute_parses(q, Array(&quot;&quot;, &quot;y&quot;, &quot;cba&quot;)).x
	x = mkDtTerminal(&quot;abc&quot;)
	assert_parses(q, &quot;abc&quot;, x, 4).x
	&apos; really reads only as many chars as pStr does:
	assert_parses(q, &quot;abcabc&quot;, x, 4).x
	assert_parses(q, &quot;abcxyz&quot;, x, 4).x

	p = pChoice(pStr(&quot;0&quot;), pStr(&quot;1&quot;))
	q = toDerivationP(p)
	refute_parses(q, Array(&quot;&quot;, &quot;y&quot;, &quot;cba&quot;)).x
	x = mkDtTerminal(&quot;0&quot;)
	assert_parses(q, &quot;0&quot;, x, 2).x
	x = mkDtTerminal(&quot;1&quot;)
	assert_parses(q, &quot;1&quot;, x, 2).x

	p = pSeqL(Array(pItem), id)
	q = toDerivationP(p)
	refute_parses(q, &quot;&quot;).x
	x = List(mkDtCClass(&quot;(.)&quot;, &quot;x&quot;))
	assert_parses(q, &quot;x&quot;, x, 2).x
	assert_parses(q, &quot;x1&quot;, x, 2).x
	x = List(mkDtCClass(&quot;(.)&quot;, &quot;y&quot;))
	assert_parses(q, &quot;y1abc&quot;, x, 2).x

	p = pSeqL(Array(pItem, pStr(&quot;1&quot;)), id)
	q = toDerivationP(p)
	refute_parses(q, &quot;&quot;, &quot;x0&quot;, &quot; a&quot;).x
	x = List(mkDtCClass(&quot;(.)&quot;, &quot;x&quot;), mkDtTerminal(&quot;1&quot;))
	assert_parses(q, &quot;x1&quot;, x, 3).x
	x = List(mkDtCClass(&quot;(.)&quot;, &quot;y&quot;), mkDtTerminal(&quot;1&quot;))
	assert_parses(q, &quot;y1abc&quot;, x, 3).x

	p = pSeqL(Array(pStr(&quot;0&quot;), pItem, pStr(&quot;1&quot;)), id)
	q = toDerivationP(p)
	refute_parses(q, &quot;&quot;, &quot;0&quot;, &quot;0a&quot;, &quot;xa1&quot;).x
	x = List(mkDtTerminal(&quot;0&quot;), mkDtCClass(&quot;(.)&quot;, &quot;a&quot;), mkDtTerminal(&quot;1&quot;))
	assert_parses(q, &quot;0a1&quot;, x, 4).x
	x = List(mkDtTerminal(&quot;0&quot;), mkDtCClass(&quot;(.)&quot;, &quot;b&quot;), mkDtTerminal(&quot;1&quot;))
	assert_parses(q, &quot;0b1xyz&quot;, x, 4).x
	
	p = pInd(&quot;Foo&quot;)
	p = fixIndirection(p, pItem)
	q = toDerivationP(p)
	refute_parses(q, &quot;&quot;).x
	x = mkDtNonterminal(q.st1, List(mkDtCClass(&quot;(.)&quot;, &quot;a&quot;)))
	assert_parses(q, &quot;a&quot;, x, 2).x
	x = mkDtNonterminal(q.st1, List(mkDtCClass(&quot;(.)&quot;, &quot;b&quot;)))
	assert_parses(q, &quot;b&quot;, x, 2).x
	assert_parses(q, &quot;bb&quot;, x, 2).x
	assert_parses(q, &quot;bc&quot;, x, 2).x
		
	p = pInd(&quot;Bar&quot;)
	p = fixIndirection(p, pSeqL(Array(pItem, pStr(&quot;1&quot;)), id)
	q = toDerivationP(p)
	msgbox(toString(p) &amp; chr(13) &amp; chr(13) &amp; toString(q))
	refute_parses(q, &quot;&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;a0&quot;, &quot;b&quot;, &quot;b1&quot;).x
	x = mkDtNonterminal(q.st1, List(mkDtCClass(&quot;(.)&quot;, &quot;a&quot;), mkDtTerminal(&quot;1&quot;)))
	msgbox(toString(x))
	assert_parses(q, &quot;a1&quot;, x, 3).x
	assert_parses(q, &quot;a1b&quot;, x, 3).x
End Function

Function test_AST_pMany_dt()
	Dim p As Object, r As Variant, x As Object
	Dim termEps As Object, termZ As Object, termZY As Object
	termEps = mkDtTerminal(&quot;&quot;)
	termZ   = mkDtTerminal(&quot;z&quot;)
	termZY	= mkDtTerminal(&quot;zy&quot;)
	
	p = pMany_dt(pStr_dt(&quot;z&quot;))
	x = mkDtMult(&quot;*&quot;, nil)
	assert_parses(p, &quot;&quot;, x, 1).x
	assert_parses(p, &quot;x&quot;, x, 1).x
	assert_parses(p, &quot;xy&quot;, x, 1).x
	assert_parses(p, &quot;xyz&quot;, x, 1).x

	x = mkDtNonterminal(&quot;*&quot;, List(termZ))
	r = applyP(p, &quot;z&quot;)
	r = TASN_toString(r(0))
	assert_parses(p, &quot;z&quot;, x, 2).x
	assert_parses(p, &quot;zx&quot;, x, 2).x

	x = mkDtNonterminal(&quot;*&quot;, List(termZ, termZ))
	assert_parses(p, &quot;zz&quot;, x, 3).x
	assert_parses(p, &quot;zza&quot;, x, 3).x

	p = pMany_dt(pStr_dt(&quot;zy&quot;))
	x = mkDtMult(&quot;*&quot;, nil)
	assert_parses(p, &quot;&quot;, x, 1).x
	assert_parses(p, &quot;x&quot;, x, 1).x
	assert_parses(p, &quot;xy&quot;, x, 1).x
	assert_parses(p, &quot;z&quot;, x, 1).x
	assert_parses(p, &quot;xzy&quot;, x, 1).x
	
	x = mkDtNonterminal(&quot;*&quot;, List(termZY))
	assert_parses(p, &quot;zy&quot;, x, 3).x
	assert_parses(p, &quot;zyX&quot;, x, 3).x
	assert_parses(p, &quot;zyXzy&quot;, x, 3).x
	
	x = mkDtNonterminal(&quot;*&quot;, List(termZY, termZY))
	assert_parses(p, &quot;zyzy&quot;, x, 5).x
	assert_parses(p, &quot;zyzyX&quot;, x, 5).x
	
	x = mkDtNonterminal(&quot;*&quot;, List(termZY, termZY, termZY))
	assert_parses(p, &quot;zyzyzy&quot;, x, 7).x
	assert_parses(p, &quot;zyzyzyX&quot;, x, 7).x
End Function

</script:module>