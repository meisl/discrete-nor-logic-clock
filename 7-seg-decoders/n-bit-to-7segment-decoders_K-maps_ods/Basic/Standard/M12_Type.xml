<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M12_Type" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit


Type TypeCtor
	_name	  As String	 &apos; cannot use just &quot;name&quot;, that&apos;s a BASIC directive
	arity	  As Integer &apos; the nr of typeArgs
	dataCtors As DataCtor Array
End Type

Type DataType
	str		 As String	&apos; debugger shows that in inspector
	typeArgs As Array
	typeCtor As TypeCtor
End Type

Type DataCtor
	tag		 As String
	str		 As String	&apos; debugger shows that in inspector
	_name	 As String	&apos; see TypeCtor._name
	typeCtor As TypeCtor
	argTypes As Array
	arity    As Integer
End Type



Const DataCtor_name     = 0
Const DataCtor_argTypes = 1
Const DataCtor_typeCtor = 2

Const DataTypeCtor_name  	 = 0
Const DataTypeCtor_arity 	 = 1
Const DataTypeCtor_dataCtors = 2

		
Type DataValue
	str		 As String	&apos; debugger shows that in inspector
	id		 As Long
	ctor	 As DataCtor
	fields   As Array
End Type

Sub Main
	[test_Type======================================]
End Sub


Function _newDataValue(ctor As DataValue, ByRef args As Array)
	Static instanceCount As Long
	Dim out As New DataValue
	out.ctor   = ctor
	out.fields = args
	out.id	   = instanceCount
	instanceCount = instanceCount + 1

	If Not(isNull(ctor)) Then
		_validate(out)
	End If
	_newDataValue = out
End Function


Function _validate(v As DataValue)
	Dim a As Integer : a = LBound(v.fields)
	If a &lt;&gt; 0 Then
		croak(&quot;_validate &quot; &amp; ctor.fields(DataCtor_name) &amp; &quot;:&quot; _
			&amp; NL &amp; &quot;expected 0-based args Array&quot; _
			&amp; NL &amp; &quot;but got a &quot; &amp; a &amp; &quot;-based one: &quot; _
			&amp; NL &amp; toString(v.fields) _
		)
	End If
	Goto _validate_check_count_only	&apos; can comment out
	&apos;Goto _validate_check_types		&apos; can comment out

_validate_end:	&apos; to make &quot;no-checks&quot; the shortest path
	Exit Function
	
_validate_check_types:
	croak(&quot;_validate/type-check: NYI&quot;)
	Goto _validate_end
	
_validate_check_count_only:
	Dim x As Integer
	a = UBound(v.fields)
	x = UBound(v.ctor.fields(DataCtor_argTypes))
	If x &lt;&gt; a Then
		x = x + 1
		a = a + 1
		croak(&quot;_validate: DataCtor &quot; &amp; v.ctor.fields(DataCtor_name) _
			&amp; &quot; requires &quot; &amp; x &amp; IIf(x = 1, &quot; arg&quot;, &quot; args&quot;) _
			&amp; &quot; - got &quot; &amp; a _
		)
	End If
	Goto _validate_end
End Function


&apos; duck-type like test:
&apos; - does it have member .ctor of (BASIC) type Object?
&apos; - does it have member .fields of (BASIC) type Array?
Function isDataValue(x As Variant)
	Dim out
	out = False
	&apos; TODO: isDataValue: check isObject &amp; Not isNull first
	On Local Error Goto isDataValue_end
	If isObject(_ctor(x)) And isArray(_fields(x)) Then
		out = True
	End If
isDataValue_end:
	isDataValue = out
End Function

Function _ctor(o As Object)
	_ctor = o.ctor
End Function

Function _fields(o As Object)
	_fields = o.fields
End Function

Function field(idx As Integer, v As DataValue)
	field = v.fields(idx)
End Function


Function DataValue_same(a As DataValue, b As DataValue)
	DataValue_same = (a.id = b.id)
End Function

Function DataValue_genericToString(v As DataValue)
	Dim out
	Dim ctor   As Variant : ctor   = v.ctor
	Dim fields As Variant : fields = v.fields
	Dim cStr   As String
	Dim fStr   As String
	If isDataValue(ctor) Then
		If DataValue_same(v, ctor) Then
			cStr = cStr &amp; &quot;-&gt;self&quot;
		Else
			cStr = cStr &amp; DataValue_genericToString(ctor)
		End If
	Else
		cStr = toString(ctor)
	End If
	If isArray(fields) Then
		fStr = &quot;Array(&quot;
		Dim i As Integer, w As Variant
		For i = 0 To UBound(fields)
			If i &gt; 0 Then : fStr = fStr &amp; &quot;, &quot; : End If
			w = fields(i)
			If isDataValue(w) Then
				fStr = fStr &amp; DataValue_genericToString(w)
			Else
				fStr = fStr &amp; toString(w)
			End If
		Next i
		fStr = fStr &amp; &quot;)&quot;
	Else
		fStr = toString(fields)
	End If
	out = &quot;{ctor: &quot; &amp; cStr &amp; &quot;, fields: &quot; &amp; fStr &amp; &quot;}&quot;
	DataValue_genericToString = out
End Function


Function _applyDataCtor_lax(ctor As DataValue, args As Array)
	Dim x As Integer, a As Integer
	a = LBound(args)
	If a &lt;&gt; 0 Then
		croak(&quot;_applyDataCtor_lax &quot; &amp; ctor.fields(DataCtor_name) &amp; &quot;:&quot; _
			&amp; NL &amp; &quot;invalid &quot; &amp; a &amp; &quot;-based args Array&quot; _
			&amp; NL &amp; &quot;expected 0-based Array&quot;)
	Else
		x = UBound(ctor.fields(DataCtor_argTypes))
		a = UBound(args)
		If a &lt;&gt; x Then
			a = a + 1 : x = x + 1
			croak(&quot;_applyDataCtor_lax &quot; &amp; ctor.fields(DataCtor_name) _
				&amp; &quot;:&quot; _
				&amp; NL &amp; &quot;expected &quot; &amp; x &amp; &quot; arg&quot; &amp; IIf(x = 1, &quot;&quot;, &quot;s&quot;) _
				&amp; &quot; but got &quot; &amp; a _
				&amp; NL &amp; toString(args))
		End If
	End If
	_applyDataCtor_lax = _newDataValue(ctor, args)
End Function

Sub _setTypeCtor(dataCtor As DataValue, dataTypeCtor As DataValue)
	&apos; TODO: check that dataCtor really is a DataCtor
	&apos; TODO: check that dataTypeCtor really is a DatatypeCtor
	dataCtor.fields(DataCtor_typeCtor) = dataTypeCtor
End Sub

Function isDataTypeCtor(tc As DataValue)
	Dim out
	out = False
	Dim c As DataValue
	c = tc.ctor
	Dim cName As String
	cName = c.fields(DataCtor_name)
	If cName = &quot;DataTypeCtor&quot; Then
		Dim tcName As String
		tcName = c.fields(DataCtor_typeCtor).fields(DataTypeCtor_name) 
		If tcName = &quot;TDataTypeCtor&quot; Then
			out = True
		End If
	End If
	isDataTypeCtor = out
End Function

Function isTypeOf(t As Object, v As DataValue)
	Dim out
	out = False
	If Not(isDataValue(t)) Then
		croak(&quot;isTypeOf/NYI: test against non-dataType type &quot; &amp; toString(t))
	End If
	If isDataTypeCtor(t) Then
		Dim r As Integer
		r = field(DataTypeCtor_arity, t)
		If (r &lt;&gt; 0) Then
			croak(&quot;isTypeOf/NYI: test against not-completely-applied TypeCtor &quot; &amp; toString(t))
		End If
		Dim c  As DataValue : c  = ctorOf(v)
		Dim tc As DataValue : tc = field(DataCtor_typeCtor, c)
		
		out = field(DataTypeCtor_name, tc) = field(DataTypeCtor_name, t)
	Else
		croak(&quot;isTypeOf/NYI: test against type &quot; &amp; toString(t))
	End If
	isTypeOf = out
End Function

Function _newDataCtor( _
	typeCtor As TypeCtor, _
	name 	 As String, _
	argTypes As Array _
)
	Dim out As New DataCtor
	out.tag = &quot;DataCtor&quot;
	out._name = name
	out.typeCtor = typeCtor
	Dim lo As Integer : lo = LBound(argTypes)
	Dim hi As Integer : hi = UBound(argTypes)
	Dim n  As Integer : n = hi - lo + 1
	out.arity = n

	Dim typeStr As String, i As Integer
	typeStr = &quot;&quot;
	If n = 0 Then
		out.argTypes = Array()
	Else
		Dim ats(0 To n - 1)
		Dim t As Variant
		Dim k As Integer : k = 0
		For i = lo To hi
			t = argTypes(i)
			If isInteger(t) Then
				If (t &lt; 0) Or (t &gt;= typeCtor.arity) Then
					croak(&quot;_newDataCtor &quot; &amp; name &amp; &quot;: &quot; _
						&amp; &quot;invalid type var index &quot; &amp; t _
						&amp; &quot; - expected [0..&quot; &amp; (typeCtor.arity - 1) &amp; &quot;]&quot;_
					)
				End If
				typeStr = typeStr &amp; &quot;a&quot; &amp; t &amp; &quot; -&gt; &quot;
			ElseIf isType(t) Then
				If isArrowType(t) Then
					typeStr = typeStr &amp; &quot;(&quot; &amp; t.str &amp; &quot;)&quot;
				Else
					typeStr = typeStr &amp; t.str
				End If
				typeStr = typeStr &amp; &quot; -&gt; &quot;
			Else
				croak(&quot;_newDataCtor &quot; &amp; name &amp; &quot;: &quot; _
					&amp; &quot;invalid type arg &quot; &amp; toString(t) _
				)
			End If
			ats(k) = t
			k = k + 1
		Next i
	End If
	
	typeStr = typeStr &amp; typeCtor._name
	For i = 0 To typeCtor.arity - 1
		typeStr = typeStr &amp; &quot; a&quot; &amp; i
	Next i

	out.str = typeCtor._name &amp; &quot;.&quot; &amp; name &amp; &quot; :: &quot; &amp; typeStr
	_newDataCtor = out
End Function

Function _newTypeCtor( _
	name As String, _
	arity As Integer, _
	dataCtorDefs As Array _
) As TypeCtor
	Dim out As New TypeCtor
	out._name = name
	out.arity = arity
	Dim lo As Integer : lo = LBound(dataCtorDefs)
	Dim hi As Integer : hi = UBound(dataCtorDefs)
	Dim n  As Integer : n = hi - lo + 1
	If n = 0 Then
		out.dataCtors = Array()
	Else
		n = CInt(n / 2)
		Dim dataCtors(0 To n - 1)
		Dim c As Object
		Dim i As Integer : i = lo
		Dim k As Integer : k = 0
		Dim argTypes &apos; the types of the ctors arguments - NOT typeArgs!
		Do Until i &gt; hi
			c = _newDataCtor(out, dataCtorDefs(i), dataCtorDefs(i + 1))
			dataCtors(k) = c
			i = i + 2
			k = k + 1
		Loop
		out.dataCtors = dataCtors
	End If
	_newTypeCtor = out
End Function

Function isDataType(x As Variant)
	Dim out
	out = False
	On Local Error Goto isDataType_end
	out = _isDataType(x) &apos; DON&apos;T .-access x here!! (simpler this way anyhow)
isDataType_end:
	isDataType = out
End Function

&apos; provokes an error if x isn&apos;t a DataType
Function _isDataType(x As DataType) As Boolean
	_isDataType = Not(isNull(x.typeCtor)) And isArray(x.typeArgs)
End Function

Function isType(t As Variant)
	isType = isDataType(t) Or False
End Function

Function isArrowType(x As Variant)
	Dim out
	out = False
	&apos; TODO: implent isArrowType
	isArrowType = out
End Function

&apos; that&apos;s how to make a DataType: apply a typeCtor to some types
Function applyTC(tc As TypeCtor, typeArgs As Array) As DataType
	Dim out, n As Integer, k As Integer
	k = LBound(typeArgs)
	n = UBound(typeArgs) - k + 1
	If (n &lt;&gt; tc.arity) Then
		croak(&quot;applyTC &quot; &amp; tc._name &amp; &quot;: expected &quot; &amp; tc.arity _
			&amp; &quot; type arg&quot; &amp; IIf(tc.arity = 1, &quot;&quot;, &quot;s&quot;) &amp; &quot; but got &quot; &amp; n _
			&amp; &quot;: &quot; &amp; NL &amp; toString(typeArgs) _
		)
	End If
	out = New DataType
	out.typeCtor = tc
	Dim str As String
	str = tc._name
	If n = 0 Then
		out.typeArgs = Array()
	Else
		Dim tas(0 To n - 1)
		Dim a
		Dim i As Integer
		For i = 0 To n - 1
			a = typeArgs(k)
			If isType(a) Then
				If isDataType(a) Then
					If a.typeCtor.arity = 0 Then
						str = str &amp; &quot; &quot; &amp; a.str
					Else
						str = str &amp; &quot; (&quot; &amp; a.str &amp; &quot;)&quot;
					End If
				&apos;ElseIf isBaseType(a) Or isTypeVar(a) Then
				&apos;	str = str &amp; &quot; &quot; a._name
				End If
			Else
				croak(&quot;applyTc: invalid type arg &quot; _
					&amp; &quot;- expected a Type, not &quot; &amp; typeOf(a) _
					&amp; &quot;: &quot; &amp; NL &amp; toString(a) _
				)
			End If
			tas(i) = a
			k = k + 1
		Next i
		out.typeArgs = tas
	End If
	out.str = str
	applyTC = out
End Function

&apos; --- equ ---

Function TypeCtor_equ(a As TypeCtor, b As TypeCtor)
	Dim out
	out = (a._name = b._name)
	TypeCtor_equ = out
End Function

Function DataType_equ(a As DataType, b As DataType)
	Dim out
	out = False
	If TypeCtor_equ(a.typeCtor, b.typeCtor) Then
		Dim aArgs : aArgs = a.typeArgs
		Dim bArgs : bArgs = b.typeArgs
		Dim i As Integer
		For i = 0 To UBound(aArgs)
			If Not(Type_equ(aArgs(i), bArgs(i))) Then
				Goto DataType_equ_end
			End If
		Next i
		out = True
	End If
DataType_equ_end:
	DataType_equ = out
End Function

Function DataCtor_equ(a As DataCtor, b As DataCtor)
	Dim out
	out = False
	If a._name = b._name Then
		out = TypeCtor_equ(a.typeCtor, b.typeCtor)
	End If
	DataCtor_equ = out
End Function

Function Type_equ(a As Object, b As Object)
	Dim out
	out = False
	If isType(a) And isType(b) Then
		If isDataType(a) And isDataType(b) Then
			out = DataType_equ(a, b)
		&apos;ElseIf ... &apos;TODO: Type_equ for other Types
		End If
	Else
		croak(&quot;Type_equ: cannot compare &quot; &amp; typeOf(a) _
			&amp; &quot; and &quot; &amp; typeOf(b))
	End If
	Type_equ = out
End Function






Function applyDC(c As DataCtor, _
	Optional a0, _
	Optional a1, _
	Optional a2, _
	Optional a3, _
	Optional a4 _
)
	Dim out As Object
	If     isMissing(a0) Then :	out = _newDataValue(c, emptyArray)
	ElseIf isMissing(a1) Then :	out = _newDataValue(c, Array(a0))
	ElseIf isMissing(a2) Then :	out = _newDataValue(c, Array(a0, a1))
	ElseIf isMissing(a3) Then :	out = _newDataValue(c, Array(a0, a1, a2))
	ElseIf isMissing(a4) Then :	out = _newDataValue(c, Array(a0, a1, a2, a3))
	Else
		croak(&quot;applyDC &quot; &amp; ctor.name &amp; &quot;: &quot; _
			&amp; &quot; only up to 4 args supported - got 5&quot; _
		)
	End If
	applyDC = out
End Function


Function typeOf(x As Variant)
	Dim out As String
	out = TypeName(x)
	If out = &quot;Object&quot; Then
		out = _typeOf(x) &apos; DONT access fields in here!
	ElseIf IsArray(x) Then
		out = &quot;Array&quot;
	End If
	typeOf = out
End Function

Function _typeOf(o As Object)
	Dim out As String
	out = &quot;Object&quot;
	On Local Error Goto _typeOf_end
	out = out &amp; &quot;/&quot; &amp; _tyname(o)
_typeOf_end:
	_typeOf = out
End Function

Function _tyname(o As Object)
	_tyname = o.tyname
End Function

Function ctorOf(Optional x As Variant)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.ctorOf : End If
	Dim out As Variant
	If isMissing(x) Then : out = oFn
	Else
		out = Empty
		If isObject(x) Then
			If Not(isNull(x)) Then
				On Local Error Goto ctorOf_end
				out = _ctor(x) &apos; DONT access fields in here!
				If Not(isDataValue(out)) Then
					On Local Error Goto ctorOf_error
					Dim null As Object
					null.provoke_an_error
				End If
			End If
		End If
	End If
ctorOf_end:
	ctorOf = out
	Exit Function
ctorOf_error:
	croak(&quot;ctorOf: object with invalid .ctor :: &quot; _
	    &amp; typeOf(out) &amp; NL &amp; toString(out))
End Function

Function ctorName(v As DataValue)
	Dim out
	out = v.ctor.fields(DataCtor_name)
	ctorName = out
End Function


Function isString(Optional x As Variant)
	If isMissing(x) Then
		isString = Fn.isString
	Else
		isString = (typeOf(x) = typeOf(&quot;&quot;))
	End If
End Function

Function isInteger(Optional x As Variant)
	Dim out As Variant
	If isMissing(x) Then : out = Fn.isInteger
	Else 				 : out = (typeOf(x) = typeOf(0))
	End If
	isInteger = out
End Function


Function [test_Type======================================]
	test_Type_typeOf()
	test_Type_isObject()
	test_Type_isString()
	test_Type_isInteger()
	
	test_Type_isDataValue()
	test_Type_DataValue()
	test_Type_ctorOf()
	
	bootStrap()
		
	&apos;test_Type_isDataType()
	&apos;test_Type_TypeCtor()
	&apos;test_Type_DataCtor()
End Function


Type TTest_NoTyname
End Type

Type TTest_Tyname
	tyname As String
End Type

Type TTest_Foo
	bar As Integer
End Type

Type TTest_Ctor
	ctor As Variant
End Type


Function test_Type_typeOf()
	assertEqual(typeOf(0), &quot;Integer&quot;).x
	assertEqual(typeOf(1), &quot;Integer&quot;).x
	assertEqual(typeOf(-42), &quot;Integer&quot;).x
	
	assertEqual(typeOf(&quot;&quot;), &quot;String&quot;).x
	assertEqual(typeOf(&quot;1&quot;), &quot;String&quot;).x
	
	assertEqual(typeOf(3.14), &quot;Double&quot;).x

	assertEqual(typeOf(Array()), &quot;Array&quot;).x

	assertEqual(typeOf(Empty), &quot;Empty&quot;).x
	assertEqual(typeOf(Nothing), &quot;Object&quot;).x


	Dim t1 As New TTest_NoTyName
	assertEqual(typeOf(t1), &quot;Object&quot;).x

	Dim t2 As New TTest_TyName
	t2.tyname = &quot;foobar&quot;
	assertEqual(typeOf(t2), &quot;Object/foobar&quot;).x
End Function


&apos; isObject is a BASIC function:
&apos; make sure we know exactly what it does
Function test_Type_isObject()
	Dim o As Object

	assertEqual(isObject(Nothing),	True).x

	assertEqual(isObject(Empty),	False).x
	assertEqual(isObject(True),		False).x
	assertEqual(isObject(False),	False).x
	assertEqual(isObject(&quot;&quot;),		False).x
	assertEqual(isObject(&quot;foobar&quot;),	False).x
	assertEqual(isObject( 0),		False).x
	assertEqual(isObject( 1),		False).x
	assertEqual(isObject(-1),		False).x
	assertEqual(isObject(3.1415),	False).x
	assertEqual(isObject(Array()),	False).x

	o = New TTest_Foo
	assertEqual(isObject(o), True).x
	o.bar = 4711
	assertEqual(isObject(o), True).x
End Function

&apos; isString: implemented above
Function test_Type_isString()
	assertEqual(isString(&quot;&quot;),                  True).x
	assertEqual(isString(&quot;a&quot;),                 True).x
	assertEqual(isString(&quot;foobar&quot;),            True).x
	assertEqual(isString(Nothing),            False).x
	assertEqual(isString(Empty),              False).x
	assertEqual(isString(True),               False).x
	assertEqual(isString(False),              False).x
	assertEqual(isString(0),                  False).x
	assertEqual(isString(1),                  False).x
	assertEqual(isString(3.14),               False).x
	assertEqual(isString(Array()),            False).x
	assertEqual(isString(Array(42)),          False).x
	assertEqual(isString(Array(42)),          False).x
	
	assertEqual(arity(Fn.isString),	1).x &apos; from Fn object
	assertEqual(arity(isString),	1).x &apos; from 0-arg call
	
	assertEqual(apply(isString, &quot;&quot;),         True).x
	assertEqual(apply(isString, &quot;a&quot;),        True).x
	assertEqual(apply(isString, &quot;foobar&quot;),   True).x
	assertEqual(apply(isString, Nothing),   False).x
	assertEqual(apply(isString, Empty),     False).x
	assertEqual(apply(isString, True),      False).x
	assertEqual(apply(isString, False),     False).x
	assertEqual(apply(isString, 0),         False).x
	assertEqual(apply(isString, 1),         False).x
	assertEqual(apply(isString, 3.14),      False).x
	assertEqual(apply(isString, Array()),   False).x
	assertEqual(apply(isString, Array(42)), False).x
	assertEqual(apply(isString, Array(42)), False).x
End Function

&apos; isInteger: implemented above
Function test_Type_isInteger()
	assertEqual(isInteger(&quot;&quot;),                 False).x
	assertEqual(isInteger(&quot;a&quot;),                False).x
	assertEqual(isInteger(&quot;foobar&quot;),           False).x
	assertEqual(isInteger(Nothing),            False).x
	assertEqual(isInteger(Empty),              False).x
	assertEqual(isInteger(True),               False).x
	assertEqual(isInteger(False),              False).x
	assertEqual(isInteger( 0),                  True).x
	assertEqual(isInteger( 1),                  True).x
	assertEqual(isInteger(-1),                  True).x
	assertEqual(isInteger( 32766),              True).x &apos;0x7FFE
	assertEqual(isInteger( 32767),              True).x &apos;0x7FFF
	assertEqual(isInteger( 32768),             False).x &apos;0x8000 (!)
	assertEqual(isInteger( 65534),             False).x &apos;0xFFFE
	assertEqual(isInteger( 65535),             False).x &apos;0xFFFF
	assertEqual(isInteger( 65536),             False).x &apos;0x80000
	assertEqual(isInteger(-32766),              True).x &apos;0x8002
	assertEqual(isInteger(-32767),              True).x &apos;0x8001
	assertEqual(isInteger(-32768),              True).x &apos;0x8000
	assertEqual(isInteger(-32769),             False).x &apos;0x17FFF (!)
	assertEqual(isInteger(-65534),             False).x &apos;0xFFFE
	assertEqual(isInteger(-65535),             False).x &apos;0xFFFF
	assertEqual(isInteger(-65536),             False).x &apos;0x80000
	assertEqual(isInteger(3.14),               False).x
	assertEqual(isInteger(Array()),            False).x
	assertEqual(isInteger(Array(42)),          False).x
	assertEqual(isInteger(Array(42)),          False).x
End Function

Function test_Type_isDataValue()
	&apos; positive tests below
	assertEqual(isDataValue(&quot;&quot;),                 False).x
	assertEqual(isDataValue(&quot;a&quot;),                False).x
	assertEqual(isDataValue(&quot;foobar&quot;),           False).x
	assertEqual(isDataValue(Nothing),            False).x
	assertEqual(isDataValue(Empty),              False).x
	assertEqual(isDataValue(True),               False).x
	assertEqual(isDataValue(False),              False).x
	assertEqual(isDataValue( 0),                 False).x
	assertEqual(isDataValue( 1),                 False).x
	assertEqual(isDataValue(-1),                 False).x
	assertEqual(isDataValue( 32766),             False).x &apos;0x7FFE
	assertEqual(isDataValue( 32767),             False).x &apos;0x7FFF
	assertEqual(isDataValue( 32768),             False).x &apos;0x8000 (!)
	assertEqual(isDataValue( 65534),             False).x &apos;0xFFFE
	assertEqual(isDataValue( 65535),             False).x &apos;0xFFFF
	assertEqual(isDataValue( 65536),             False).x &apos;0x80000
	assertEqual(isDataValue(-32766),             False).x &apos;0x8002
	assertEqual(isDataValue(-32767),             False).x &apos;0x8001
	assertEqual(isDataValue(-32768),             False).x &apos;0x8000
	assertEqual(isDataValue(-32769),             False).x &apos;0x17FFF (!)
	assertEqual(isDataValue(-65534),             False).x &apos;0xFFFE
	assertEqual(isDataValue(-65535),             False).x &apos;0xFFFF
	assertEqual(isDataValue(-65536),             False).x &apos;0x80000
	assertEqual(isDataValue(3.14),               False).x
	assertEqual(isDataValue(Array()),            False).x
	assertEqual(isDataValue(Array(42)),          False).x
	assertEqual(isDataValue(Array(42)),          False).x
End Function

Function test_Type_DataValue()
	Dim v, c
	v = _newDataValue(Nothing, emptyArray)
	assertEqual(v.ctor, Nothing)
	assertEqual(LBound(v.fields),  0).x
	assertEqual(UBound(v.fields), -1).x
	assertEqual(isDataValue(v), True).x

	v = _newDataValue(Nothing, Array(42))
	assertEqual(v.ctor, Nothing)
	assertEqual(UBound(v.fields), 0).x
	assertEqual(v.fields(0), 42).x 
	assertEqual(isDataValue(v), True).x

	v = _newDataValue(Nothing, Array(&quot;foo&quot;, 4711))
	assertEqual(v.ctor, Nothing)
	assertEqual(UBound(v.fields), 1).x
	assertEqual(v.fields(0), &quot;foo&quot;).x 
	assertEqual(v.fields(1), 4711).x 
	assertEqual(isDataValue(v), True).x
End Function

	
Function test_Type_ctorOf()
	assertEqual(ctorOf(Nothing),	Empty).x
	assertEqual(ctorOf(Empty),		Empty).x
	assertEqual(ctorOf(True),		Empty).x
	assertEqual(ctorOf(False),		Empty).x
	assertEqual(ctorOf(&quot;&quot;),			Empty).x
	assertEqual(ctorOf(&quot;blah&quot;),		Empty).x
	assertEqual(ctorOf( 0),			Empty).x
	assertEqual(ctorOf( 1),			Empty).x
	assertEqual(ctorOf(-1),			Empty).x
	assertEqual(ctorOf(3.1415),		Empty).x

	Dim o As Object, act As Variant
	
	&apos; an object without member .ctor:
	o = New TTest_TyName
	assertEqual(ctorOf(o), Empty).x
	o.tyname = &quot;foo&quot;
	assertEqual(ctorOf(o), Empty).x

	&apos; an object with a member .ctor:
	o = New TTest_Ctor
	o.ctor = Empty		: assertThrows(ctorOf, Array(o)).x
	o.ctor = Nothing	: assertThrows(ctorOf, Array(o)).x
	o.ctor = True		: assertThrows(ctorOf, Array(o)).x
	o.ctor = False		: assertThrows(ctorOf, Array(o)).x
	o.ctor = &quot;&quot;			: assertThrows(ctorOf, Array(o)).x
	o.ctor = &quot;foo&quot;		: assertThrows(ctorOf, Array(o)).x
	o.ctor =  0			: assertThrows(ctorOf, Array(o)).x
	o.ctor =  1			: assertThrows(ctorOf, Array(o)).x
	o.ctor = -1			: assertThrows(ctorOf, Array(o)).x
	o.ctor = 3.1415		: assertThrows(ctorOf, Array(o)).x
	o.ctor = Array()	: assertThrows(ctorOf, Array(o)).x
	&apos; even a fn object:
	o.ctor = ctorOf		: assertThrows(ctorOf, Array(o)).x
End Function

Function bootStrap()
	Dim cFoo, v
	&apos; let&apos;s make something that is (almost) a DataCtor
	cFoo = _newDataValue(Nothing, Array( _
		&quot;Foo&quot;, _
		emptyArray, _
		Nothing _
	)
	assertEqual(isDataValue(cFoo), True).x
	
	&apos; There&apos;s a member .id on each DataValue which is unique to
	&apos; the particular instance. This yields a notion of sameness:
	assertEqual(DataValue_same(cFoo, cFoo), True).x
	&apos; Even if we provide the very same values, we&apos;ll get a
	&apos; different instance:
	v = _newDataValue(Nothing, Array( _
		&quot;Foo&quot;, _
		emptyArray, _
		Nothing _
	)
	assertEqual(DataValue_same(v, cFoo), False).x
	&apos; &quot;Sameness&quot; is of course symmetric, ie x same y iff y same x:
	assertEqual(DataValue_same(cFoo, v), False).x
	&apos; ...and it is of course reflexive, ie forall x: x same x
	assertEqual(DataValue_same(v, v), True).x
	
	&apos; The function DataValue_genericToString provides a way to
	&apos; see what&apos;s inside a DataValue:
	Dim cFooStr As String
	cFooStr = DataValue_genericToString(cFoo)
	assertEqual( _
		cFooStr, _
		 &quot;{&quot; _
		 	&amp; &quot;ctor: Nothing, &quot; _
			&amp; &quot;fields: Array(&quot; _
				&amp; &quot;&apos;Foo&apos;, &quot; _ 
				&amp; &quot;Array(), &quot; _ 
				&amp; &quot;Nothing&quot; _
			&amp; &quot;)&quot; _
		&amp; &quot;}&quot; _
	).x

	&apos; with that we can make a Foo value:
	v = _newDataValue(cFoo, emptyArray)
	assertEqual(isDataValue(v), True).x
	&apos; it has a constructor that ctorOf accepts:
	assertEqual(isDataValue(ctorOf(v)), True).x
	Dim vStr As String
	vStr = DataValue_genericToString(v)
	assertEqual( _
		vStr, _
		&quot;{ctor: &quot; &amp; cFooStr &amp; &quot;, fields: Array()}&quot; _
	).x
	
	&apos; access ctor fields:
	&apos; TODO: why not .fields ?
	Dim c
	c = ctorOf(v)
	assertEqual(           field(DataCtor_name,     c),      &quot;Foo&quot;).x
	assert_toString_equals(field(DataCtor_argTypes, c), emptyArray).x
	assertEqual(           field(DataCtor_typeCtor, c),    Nothing).x
	
	&apos; Since the ctor is itself a DataValue - what&apos;s the ctor of that ctor?
	Dim cDataCtor As DataValue
	&apos; it&apos;ll be a DataValue again, and it&apos;ll be a data ctor with
	&apos; - name: &quot;DataCtor&quot;
	&apos; - argTypes: a list of argument types
	&apos; - and as the third field typeCtor: a DataTypeCtor
	&apos; The typeCtor field will be left empty for now, but we must mention
	&apos; it in the definition of DataCtor. Therefore there are not only
	&apos; two entries in argTypes - &quot;String&quot; and &quot;List_of_TypeExpr&quot; - but three: the
	&apos; third must be &quot;TDataTypeCtor&quot;.
	Dim cName As String, argTypes As Variant
	cName    = &quot;DataCtor&quot;
	&apos; The argTypes should be types (type expressions), which we don&apos;t have yet
	&apos; But types (type expressions) may also be type variables. Let&apos;s
	&apos; just use plain strings and pretend they&apos;re type vars.
	argTypes = Array(&quot;String&quot;, &quot;List_of_TypeExpr&quot;, &quot;TDataTypeCtor&quot;)
	cDataCtor = _newDataValue(Nothing, Array(cName, argTypes, Nothing))
	c = cDataCtor
	assertEqual(           field(DataCtor_name,     c), cName).x
	assert_toString_equals(field(DataCtor_argTypes, c), argTypes).x
	assertEqual(           field(DataCtor_typeCtor, c), Nothing).x

	&apos; What does it look like?
	Dim cDataCtorStr As String
	cDataCtorStr = DataValue_genericToString(cDataCtor)
	assertEqual( _
		cDataCtorStr, _
		 &quot;{&quot; _ 
		 	&amp; &quot;ctor: Nothing, &quot; _
			&amp; &quot;fields: Array(&quot; _
				&amp; &quot;&apos;DataCtor&apos;, &quot; _ 
				&amp; &quot;Array(&quot; _
					&amp; &quot;&apos;String&apos;, &quot; _
					&amp; &quot;&apos;List_of_TypeExpr&apos;, &quot; _
					&amp; &quot;&apos;TDataTypeCtor&apos;&quot; _
				&amp; &quot;), &quot; _ 
				&amp; &quot;Nothing&quot; _
			&amp; &quot;)&quot; _
		&amp; &quot;}&quot; _
	).x

	&apos; Let&apos;s put this in as cFoo&apos;s .ctor:
	cFoo.ctor = cDataCtor
	&apos; Now cFoo looks like this:
	cFooStr = DataValue_genericToString(cFoo)
	assertEqual( _
		cFooStr, _
		 &quot;{&quot; _
		 	&amp; &quot;ctor: &quot; &amp; cDataCtorStr &amp; &quot;, &quot; _
			&amp; &quot;fields: Array(&quot; _
				&amp; &quot;&apos;Foo&apos;, &quot; _ 
				&amp; &quot;Array(), &quot; _ 
				&amp; &quot;Nothing&quot; _
			&amp; &quot;)&quot; _
		&amp; &quot;}&quot; _
	).x
	
	
	&apos; What&apos;s the ctor of cDataCtor?
	&apos; Since again, cDataCtor is just a DataValue, it&apos;s constructor
	&apos; must be a data ctor as we have just described, ie have fields:
	&apos; - 1st a String for the name - which we don&apos;t care about
	&apos; - 2nd a three-elem list with types &quot;String&quot;, &quot;List_of_Type_Expr&quot;
	&apos;       and &quot;TDataTypeCtor&quot;
	&apos; - 3rd a a value of type &quot;TDataTypeCtor&quot; (still left empty)
	&apos; But that&apos;s just cDataCtor itself!
	cDataCtor.ctor = cDataCtor
	&apos; Also: once we worked out the typeCtor field (left empty but we
	&apos; already &quot;know&quot; it must be a value of type &quot;TDataTypeCtor&quot;)
	&apos; - it&apos;ll work just fine as the typeCtor for both cDataCtor, and
	&apos; its constructor. Proof: if it works for cDataCtor then it will
	&apos; work for cDataCtor :)
	
	&apos; But we&apos;ve created a problem with traversing the structure
	&apos; in order to create a string representation. 
	&apos; TODO: infinite regression in toString(cDataCtor) via .ctor
	&apos; In the special case at hand, DataCtor, it&apos;s enough to not
	&apos; go down the .ctor member if it&apos;s the same as the current
	&apos; instance. This is indicated by &quot;-&gt;self&quot;:
	cDataCtorStr = DataValue_genericToString(cDataCtor)
	assertEqual( _
		cDataCtorStr, _
		 &quot;{&quot; _ 
		 	&amp; &quot;ctor: -&gt;self, &quot; _
			&amp; &quot;fields: Array(&quot; _
				&amp; &quot;&apos;DataCtor&apos;, &quot; _ 
				&amp; &quot;Array(&quot; _
					&amp; &quot;&apos;String&apos;, &quot; _
					&amp; &quot;&apos;List_of_TypeExpr&apos;, &quot; _
					&amp; &quot;&apos;TDataTypeCtor&apos;&quot; _
				&amp; &quot;), &quot; _ 
				&amp; &quot;Nothing&quot; _
			&amp; &quot;)&quot; _
		&amp; &quot;}&quot; _
	).x
	
	
	&apos; So what&apos;s the type of cDataCtor, ie what should we put it&apos;s 
	&apos; typeCtor field?
	&apos; It&apos;s the very simple data type
	&apos;   TDataCtor = DataCtor Str (List TypeExpr)
	&apos; The &quot;DataCtor&quot; on the rhs is just a data ctor as we have defined,
	&apos; and it&apos;s name is &quot;DataCtor&quot;.
	&apos; On the lhs, however, it&apos;s a DataTypeCtor and there&apos;s &quot;T&quot; as a name
	&apos; prefix. We *could* have given it just the same name, but the &quot;T&quot; may
	&apos; help to reduce confusion (a little bit...).
	&apos; Now, a DataTypeCtor has
	&apos; - a name (a String)
	&apos; - an arity (an Integer), which is the nr of it&apos;s type parameters
	&apos; - zero or more DataCtors
	&apos; We can describe that by defining another data ctor - which itself,
	&apos; as we saw, has DataCtor as it&apos;s (data) constructor:
	Dim cDataTypeCtor As DataValue, arity As Integer
	cDataTypeCtor = _newDataValue(cDataCtor, Array( _
		&quot;DataTypeCtor&quot;, _
		Array(&quot;String&quot;, &quot;Integer&quot;, &quot;List_of_DataCtor&quot;), _
		Nothing _
	))
	&apos; Except for the typeCtor field - again left empty -
	&apos; what we&apos;ve just done will be bread-and-butter: create a value
	&apos; from a data ctor where the value&apos;s fields are filled with the
	&apos; argument values - provided they comply with the data ctor&apos;s
	&apos; typeArgs.
	&apos; Let&apos;s factor this out:
	cDataTypeCtor = _applyDataCtor_lax(cDataCtor, Array( _
		&quot;DataTypeCtor&quot;, _
		Array(&quot;String&quot;, &quot;Integer&quot;, &quot;List_of_DataCtor&quot;), _
		Nothing _
	))
	&apos; The function _applyDataCtor_lax will check if the nr of arguments
	&apos; is correct, but it will NOT try to check their types.
	&apos; It will then create a DataValue and fill in members
	&apos; .ctor and .fields
	assertEqual(isDataValue(cDataTypeCtor), 		True).x
	assertEqual(isDataValue(ctorOf(cDataTypeCtor)), True).x
	assertEqual( _
		field(DataCtor_name, ctorOf(cDataTypeCtor)), _
		field(DataCtor_name, cDataCtor) _
	).x
	assert_toString_equals( _
		field(DataCtor_argTypes, ctorOf(cDataTypeCtor)), _
		field(DataCtor_argTypes, cDataCtor) _
	).x
	&apos; and also - even if still empty:
	assert_toString_equals( _
		field(DataCtor_typeCtor, ctorOf(cDataTypeCtor)), _
		field(DataCtor_typeCtor, cDataCtor) _
	).x
	&apos;TODO: Another repeated pattern is that of making DataValues that serve
	&apos; as DataCtor s:
	&apos;cTypeCtor = _mkDataCtor(&quot;DataTypeCtor&quot;, Nothing)
	&apos; This will stick in the repeated cDataCtor as .ctor member and
	&apos; Array(&quot;String&quot;, &quot;Integer&quot;, &quot;List_of_DataCtor&quot;) as argType field
	
	&apos; Let&apos;s inspect cDataTypeCtor.
	Dim cDataTypeCtorStr As String
	cDataTypeCtorStr = DataValue_genericToString(cDataTypeCtor)
	assertEqual(cDataTypeCtorStr, _
		 &quot;{&quot; _ 
		 	&amp; &quot;ctor: &quot; &amp; cDataCtorStr &amp; &quot;, &quot; _
			&amp; &quot;fields: Array(&quot; _
				&amp; &quot;&apos;DataTypeCtor&apos;, &quot; _ 
				&amp; &quot;Array(&quot; _
					&amp; &quot;&apos;String&apos;, &quot; _
					&amp; &quot;&apos;Integer&apos;, &quot; _
					&amp; &quot;&apos;List_of_DataCtor&apos;&quot; _
				&amp; &quot;), &quot; _ 
				&amp; &quot;Nothing&quot; _
			&amp; &quot;)&quot; _
		&amp; &quot;}&quot; _
	).x
	&apos; Or the whole picture:
	assertEqual(cDataTypeCtorStr, _
		 &quot;{&quot; _ 
		 	&amp; &quot;ctor: {&quot; _
				&amp; &quot;ctor: -&gt;self, &quot; _
				&amp; &quot;fields: Array(&quot; _
					&amp; &quot;&apos;DataCtor&apos;, &quot; _ 
					&amp; &quot;Array(&quot; _
						&amp; &quot;&apos;String&apos;, &quot; _
						&amp; &quot;&apos;List_of_TypeExpr&apos;, &quot; _
						&amp; &quot;&apos;TDataTypeCtor&apos;&quot; _
					&amp; &quot;), &quot; _ 
					&amp; &quot;Nothing&quot; _
				&amp; &quot;)&quot; _ 
			&amp; &quot;}, &quot; _
			&amp; &quot;fields: Array(&quot; _
				&amp; &quot;&apos;DataTypeCtor&apos;, &quot; _ 
				&amp; &quot;Array(&quot; _
					&amp; &quot;&apos;String&apos;, &quot; _
					&amp; &quot;&apos;Integer&apos;, &quot; _
					&amp; &quot;&apos;List_of_DataCtor&apos;&quot; _
				&amp; &quot;), &quot; _ 
				&amp; &quot;Nothing&quot; _
			&amp; &quot;)&quot; _
		&amp; &quot;}&quot; _
	).x
	
	
	&apos; Now we&apos;ll make a value from that cDataTypeCtor, and that value
	&apos; will serve as the typeCtor for DataCtor:
	Dim tcDat As DataValue
	tcDat = _applyDataCtor_lax(cDataTypeCtor, Array( _
		&quot;TDataCtor&quot;, _
		0, _
		Array(cDataCtor) _
	)
	&apos; Since cDataCtor is a (the only) data ctor of tcDat, cDataCtor&apos;s
	&apos; &quot;typeCtor&quot; field points back to tcDat. We could do this by indexing
	&apos; into the .fields member and writing it there, like so:
	&apos; cDataCtor.fields(DataCtor_typeCtor) = tcDat
	&apos; But again, this pointer-fixing will occur everytime we create a new
	&apos; data type (and its constructors), so:
 	assertEqual(field(DataCtor_typeCtor, cDataCtor), Nothing).x
	&apos; was empty, now set it:
	_setTypeCtor(cDataCtor, tcDat)
	&apos; now it&apos;s set:
	Dim it
	it = field(DataCtor_typeCtor, cDataCtor)
	assertEqual(isDataValue(it), True).x
	&apos; we also have constants for accessing a DataTypeCtor&apos;s fields:	
	assertEqual( _
		field(DataTypeCtor_name, it), _
		field(DataTypeCtor_name, tcDat) ).x
	assertEqual( _
		field(DataTypeCtor_arity, it), _
		field(DataTypeCtor_arity, tcDat) ).x
	assert_toString_equals( _
		field(DataTypeCtor_dataCtors, it), _
		field(DataTypeCtor_dataCtors, tcDat) ).x


	&apos; What&apos;s still missing is a typeCtor for cDataTypeCtor. We already
	&apos; have a ctor to construct DataTypeCtor s: cDataTypeCtor. It&apos;ll
	&apos; be quite simple again, with only one data ctor (cDataTypeCtor),
	&apos; and name &quot;TDataTypeCtor&quot;:
	&apos; TDataTypeCtor = DataTypeCtor String Int (List DataCtor)
	Dim tcTyp As DataValue
	tcTyp = _applyDataCtor_lax(cDataTypeCtor, Array( _
		&quot;TDataTypeCtor&quot;, _
		0, _
		Array(cDataTypeCtor) _
	))
	&apos; and fill in the back-pointer:
	_setTypeCtor(cDataTypeCtor, tcTyp)
	
	&apos; Let&apos;s go back to old data ctor cFoo. It itself has got a proper
	&apos; constructor (cDataCtor) but no DataTypeCtor in field typeCtor:
	assertEqual(field(DataCtor_typeCtor, cFoo), Nothing).x
	&apos; But before we go on to make one, let&apos;s make things a bit more 
	&apos; interesting. Why not give him a brother:
	Dim cBar As DataValue
	cBar = _applyDataCtor_lax(cDataCtor, Array( _
		&quot;Bar&quot;, _
		emptyArray, _
		Nothing _
	)
	&apos; Bar just looks like his twin Foo, only the names are different.
	&apos; Of course they have the same &quot;parent&quot;:
	Dim tcFooOrBar As DataValue
	tcFooOrBar = _applyDataCtor_lax(cDataTypeCtor, Array( _
		&quot;FooOrBar&quot;, _
		0, _
		Array(cFoo, cBar) _
	)
	_setTypeCtor(cFoo, tcFooOrBar)
	_setTypeCtor(cBar, tcFooOrBar)
	&apos; FooOrBar = Foo | Bar
	&apos; We can now make values of type FooOrBar
	Dim x, y, z
	x = _applyDataCtor_lax(cFoo, Array())
	y = _applyDataCtor_lax(cBar, Array())
	z = _applyDataCtor_lax(cFoo, Array())
	&apos; the function isTypeOf takes a type and a value, and tests
	&apos; whether the value has the given type:
	assertEqual(isTypeOf(tcFooOrBar, x), True).x
	assertEqual(isTypeOf(tcFooOrBar, y), True).x
	assertEqual(isTypeOf(tcFooOrBar, z), True).x
	&apos; But of course, FooOrBar itself is NOT a FooOrBar
	assertEqual(isTypeOf(tcFooOrBar, tcFooOrBar), False).x
	&apos; Rather it is a TDataTypeCtor
	assertEqual(isTypeOf(tcTyp, tcFooOrBar), True).x
	&apos; Similarly, neither cFoo nor cBar are FooBar s:
	assertEqual(isTypeOf(tcFooOrBar, cFoo), False).x
	assertEqual(isTypeOf(tcFooOrBar, cBar), False).x
	&apos; They&apos;re data constructors:
	assertEqual(isTypeOf(tcDat, cFoo), True).x
	assertEqual(isTypeOf(tcDat, cBar), True).x
	
	&apos; We can also dispatch on the values&apos; ctors (names).
	&apos; Since extracting the ctor&apos;s name will be common, we&apos;ll
	&apos; extract that into another helper function:
	assertEqual(ctorName(x), field(DataCtor_name, cFoo)).x
	assertEqual(ctorName(y), field(DataCtor_name, cBar)).x
	assertEqual(ctorName(z), field(DataCtor_name, cFoo)).x
	&apos; With that in place:
	Dim what As String, i As Integer, vs As Variant
	what = &quot;&quot;
	vs = Array(x, y, z)
	For i = 0 To 2
		Select Case ctorName(vs(i))
			Case &quot;Foo&quot;: what = what &amp; &quot;aFoo &quot;
			Case &quot;Bar&quot;: what = what &amp; &quot;aBar &quot;
		End Select
	Next i
	assertEqual(what, &quot;aFoo aBar aFoo &quot;).x
	
	&apos; Well, FooOrBar seems a bit boring. However, imagine just
	&apos; different names:
	&apos; - &quot;Foo&quot;      -&gt; &quot;False&quot;
	&apos; - &quot;Bar&quot;      -&gt; &quot;True&quot;
	&apos; - &quot;FooOrBar&quot; -&gt; &quot;Bool&quot;
	&apos; From that we can see that even simple enumerations like that
	&apos; are useful. Let&apos;s enumerate some types we have in BASIC:
	&apos; BasicType = Boolean | String | Integer | Long | Double | Object
	Dim cBoolean, cString, cInteger, cLong, cDouble, cObject
	cBoolean = _applyDataCtor_lax(cDataCtor, Array(&quot;Boolean&quot;, emptyArray, Nothing))
	cString  = _applyDataCtor_lax(cDataCtor, Array(&quot;String&quot;,  emptyArray, Nothing))
	cInteger = _applyDataCtor_lax(cDataCtor, Array(&quot;Integer&quot;, emptyArray, Nothing))
	cLong    = _applyDataCtor_lax(cDataCtor, Array(&quot;Long&quot;,    emptyArray, Nothing))
	cDouble  = _applyDataCtor_lax(cDataCtor, Array(&quot;Double&quot;,  emptyArray, Nothing))
	cObject  = _applyDataCtor_lax(cDataCtor, Array(&quot;Object&quot;,  emptyArray, Nothing))
	Dim dataCtors, tcBasicType
	dataCtors = Array(cBoolean, cString, cInteger, cLong, cDouble, cObject)
	tcBasicType = _applyDataCtor_lax(cDataTypeCtor, _
		Array(&quot;BasicType&quot;, 0, dataCtors) _
	)
	For i = 0 To UBound(dataCtors)
		_setTypeCtor(dataCtors(i), tcBasicType)
	Next i
	&apos; So now these are all proper data ctors:
	For i = 0 To UBound(dataCtors)
		assertEqual(isTypeOf(tcDat, dataCtors(i)), True).x
	Next i

	&apos; Values created from these constructors:
	Dim vBoolean, vString, vInteger, vLong, vDouble, vObject
	vBoolean = _applyDataCtor_lax(cBoolean, emptyArray)
	vString  = _applyDataCtor_lax(cString,  emptyArray)
	vInteger = _applyDataCtor_lax(cInteger, emptyArray)
	vLong    = _applyDataCtor_lax(cLong,    emptyArray)
	vDouble  = _applyDataCtor_lax(cDouble,  emptyArray)
	vObject  = _applyDataCtor_lax(cObject,  emptyArray)
	Dim vBasicTypes
	vBasicTypes = Array(vBoolean, vString, vInteger, vLong, vDouble, vObject)
	
	&apos; They&apos;re all of type BasicType:
	For i = 0 To UBound(dataCtors)
		v = vBasicTypes(i)
		assertEqual(isTypeOf(tcBasicType, v), True).x
	Next i
	&apos; And they&apos;re not FooOrBar s, or DataCtor s or whatever:
	For i = 0 To UBound(dataCtors)
		v = vBasicTypes(i)
		assertEqual(isTypeOf(tcFooOrBar, v), False).x
		assertEqual(isTypeOf(tcDat,		 v), False).x
		assertEqual(isTypeOf(tcTyp,		 v), False).x
	Next i
	
	&apos; With that we can replace the dummy strings &quot;String&quot; and &quot;Integer&quot;
	&apos; that we used when defining DataCtor and DataTypeCtor:
	cDataCtor.fields(DataCtor_argTypes)(0) = vString &apos; field name
	&apos; TODO: (even before) set cDataCtor.argType(2) = tcTyp
	cDataTypeCtor.fields(DataCtor_argTypes)(0) = vString  &apos; field name
	cDataTypeCtor.fields(DataCtor_argTypes)(1) = vInteger &apos; field arity

		
End Function



&apos; ##############################################
Function test_Type_DataValue_old()	
	Dim tc, dt
	Dim c1, c2
	Dim v1, v2
	
	tc = _newTypeCtor(&quot;TC_Unit&quot;, 0, Array( _
		&quot;_Unit&quot;, Array() _
	))
	dt = applyTC(tc, Array())
	c1 = tc.dataCtors(0)
	assertEqual(c1.arity, 0).x
	
	v1 = applyDC(c1)
	assertEqual(DataCtor_equ(v1.ctor, c1), True).x
	assertEqual(UBound(v1.fields), UBound(Array())).x
	v1 = applyDC(c1, Array())

	show(v1.ctor.str, c1.str)
	assertEqual(DataType_equ(v1.dataType, dt), True).x
End Function



Function test_Type_isDataType()
	&apos; positive tests below in test_TypeCtor
	&apos; main thing to prove is that it doesn&apos;t throw
	assertEqual(isDataType(Nothing),            False).x
	assertEqual(isDataType(Empty),              False).x
	assertEqual(isDataType(True),               False).x
	assertEqual(isDataType(False),              False).x
	assertEqual(isDataType(&quot;&quot;),                 False).x
	assertEqual(isDataType(&quot;a&quot;),                False).x
	assertEqual(isDataType(&quot;foobar&quot;),           False).x
	assertEqual(isDataType(0),                  False).x
	assertEqual(isDataType(1),                  False).x
	assertEqual(isDataType(3.14),               False).x
	assertEqual(isDataType(Array()),            False).x
	assertEqual(isDataType(Array(42)),          False).x
	assertEqual(isDataType(Array(42)),          False).x
	
	Dim o As Object
	o = New TTest_Foo
	assertEqual(isDataType(o), False).x
End Function

Function test_Type_TypeCtor()
	Dim tc0, tc1
	tc0 = _newTypeCtor(&quot;TC0&quot;, 0, Array())
	assertEqual(isDataType(tc0),           False).x
	assertEqual(tc0._name, &quot;TC0&quot;).x
	assertEqual(tc0.arity, 	  0 ).x
	assertEqual(TypeCtor_equ(tc0, tc0), 	True).x
	
	tc1 = _newTypeCtor(&quot;TC1&quot;, 1, Array())
	assertEqual(tc1._name, &quot;TC1&quot;).x
	assertEqual(tc1.arity, 	  1 ).x
	assertEqual(TypeCtor_equ(tc1, tc1), 	True).x

	assertEqual(TypeCtor_equ(tc0, tc1), 	False).x
	assertEqual(TypeCtor_equ(tc1, tc0), 	False).x
	
	Dim dt0, args
	args = Array()
	dt0 = applyTC(tc0, args)
	assertEqual(isDataType(dt0), True).x
	assertEqual(LBound(dt0.typeArgs),  0).x
	assertEqual(UBound(dt0.typeArgs), -1).x
	assertEqual(TypeCtor_equ(tc0, dt0.typeCtor), True).x
	
	Redim args(0 To 1)
	assertEqual(UBound(dt0.typeArgs), -1).x

	Dim dt1
	&apos;assertThrows(Fn.applyTC, Array(tc1, Array(tc1)) ).x
	args = Array(dt0)
	dt1 = applyTC(tc1, args)
	assertEqual(LBound(dt1.typeArgs),  0).x
	assertEqual(UBound(dt1.typeArgs),  0).x
	assertEqual(TypeCtor_equ(tc1, dt1.typeCtor), True).x
	assertEqual(DataType_equ(dt1.typeArgs(0), dt0), True).x

	&apos; the typeArgs array cannot be changed via ByRef var:
	args(0) = dt1
	assertEqual(DataType_equ(dt1.typeArgs(0), dt0), True).x

	Dim dt1b
	args = Array(dt0)
	dt1b = applyTC(tc1, args)
	assertEqual(DataType_equ(dt1b, dt1), True).x
	
	args = Array(dt1) &apos; TC1 (TC1 TC0) is also a proper DataType
	dt1b = applyTC(tc1, args) &apos; but different from TC1 TC0:
	assertEqual(DataType_equ(dt1b, dt1), False).x
End Function

Function test_Type_DataCtor()
	Dim tc
	Dim c1, c2
	Dim dtUnit, dtBool, dtMaybeUnit, dtMaybeBool
	
	&apos; no type args, only 1 zero-arg data ctor ~ Unit
	tc = _newTypeCtor(&quot;TC_Unit&quot;, 0, _
		Array( _
			&quot;_Unit&quot;, Array() _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_Unit&quot;).x
	assertEqual(c1.arity,       0).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	dtUnit = applyTC(tc, Array())
	
	&apos; no type args, 2 zero-arg data ctors ~ Bool
	tc = _newTypeCtor(&quot;TC_Bool&quot;, 0, _
		Array( _
			&quot;_False&quot;, Array(), _
			&quot;_True&quot;,  Array() _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_False&quot;).x
	assertEqual(c1.arity,        0).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	c2 = tc.dataCtors(1)
	assertEqual(c2._name, &quot;_True&quot;).x
	assertEqual(c2.arity,       0).x
	assertEqual(TypeCtor_equ(c2.typeCtor, tc), True).x
	dtBool = applyTC(tc, Array())
	
	&apos; one type args, 2 data ctors ~ Maybe
	tc = _newTypeCtor(&quot;TC_Maybe&quot;, 1, _
		Array( _
			&quot;_None&quot;, Array(), _
			&quot;_Some&quot;, Array(0) _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_None&quot;).x
	assertEqual(c1.arity,      0).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	c2 = tc.dataCtors(1)
	assertEqual(c2._name, &quot;_Some&quot;).x
	assertEqual(c2.arity,       1).x
	assertEqual(TypeCtor_equ(c2.typeCtor, tc), True).x

	&apos;show(c1.str, c2.str)

	dtMaybeUnit = applyTC(tc, Array(dtUnit))
	dtMaybeBool = applyTC(tc, Array(dtBool))
	
	&apos;show(dtMaybeUnit.str)

	&apos; dataCtors may only refer to typeVars with index &lt; typeCtor.arity:
	&apos;assertThrows(_newTypeCtor(&quot;TC_Foo&quot;, 0, Array(&quot;_Bar&quot;, Array(0)))).x
	&apos;assertThrows(_newTypeCtor(&quot;TC_Foo&quot;, 1, Array(&quot;_Bar&quot;, Array(1)))).x
		
	&apos; two type args, one 2-arg data ctors ~ Pair
	tc = _newTypeCtor(&quot;TC_Pair&quot;, 2, _
		Array( _
			&quot;_Pair&quot;, Array(0, 1) _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_Pair&quot;).x
	assertEqual(c1.arity,       2).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x

	&apos; two type args, two 1-arg data ctors ~ Either
	tc = _newTypeCtor(&quot;TC_Either&quot;, 2, _
		Array( _
			&quot;_Left&quot;,  Array(0), _
			&quot;_Right&quot;, Array(1) _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_Left&quot;).x
	assertEqual(c1.arity,       1).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	c2 = tc.dataCtors(1)
	assertEqual(c2._name, &quot;_Right&quot;).x
	assertEqual(c2.arity,       1).x
	assertEqual(TypeCtor_equ(c2.typeCtor, tc), True).x
	
	
	&apos;-- data ctors with non-var argument types:

	&apos; one type arg, 1 data ctors ~ package together something and a Bool
	tc = _newTypeCtor(&quot;TC_Foo&quot;, 1, _
		Array( _
			&quot;_Bar&quot;, Array(0, dtMaybeBool) _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_Bar&quot;).x
	assertEqual(c1.arity,      2).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	
	&apos;show(c1.str)
	
	&apos; List a b = Nil
	&apos;          | Cons a List b a

	&apos; Now for *recursive* dataTypes, such as List a
	tc = _newTypeCtor(&quot;TC_List&quot;, 1, _
		Array( _
			&quot;_Nil&quot;,  Array(), _
			&quot;_Cons&quot;, Array(0, tc), _
		) _
	)
	c1 = tc.dataCtors(0)
	c2 = tc.dataCtors(1)
	show(c2.str)
	&apos; close the loop:
	c2.argTypes(1) = tc
	show(c2.str)
	
	assertEqual(c1._name, &quot;_Nil&quot;).x
	assertEqual(c1.arity,      0).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	assertEqual(c2._name, &quot;_Cons&quot;).x
	assertEqual(c2.arity,       2).x
	assertEqual(TypeCtor_equ(c2.typeCtor, tc), True).x
	
	show(applyTC(tc, Array(dtBool)).str)
End Function



</script:module>