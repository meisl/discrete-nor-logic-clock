<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M11_Expr" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit

&apos; data Expr = Val Any
&apos;           | Var Str
&apos;           | Lam Str Expr
&apos;           | App Expr Expr
&apos;           | Err Str
&apos;           | Builtin Obj

Const TExpr_tyname = &quot;TExpr&quot;
Type TExpr
	tyname	As String
	which	As String
	id		As Long
	a0		As Variant
	a1		As Variant
End Type


Sub Main
	[test_Expr======================================]()
End Sub


Function newExpr(which As String, a0 As Variant, a1 As Variant)
	Static instanceCount As Long
	Dim out As New TExpr
	out.tyname = TExpr_tyname
	out.which  = which
	out.a0	   = a0
	out.a1	   = a1
	out.id     = instanceCount
	instanceCount = instanceCount + 1
	newExpr = out
End Function

Function isExpr(Optional x As Variant)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.isExpr : End If
	Dim out As Variant
	If isMissing(x) Then
		out = oFn
	Else
		out = (typeStr(x) = &quot;Object/&quot; &amp; TExpr_tyname)
	End If
	isExpr = out
End Function

Function TExpr_same(Optional x As Object, Optional y As Object)
	&apos;Static oFn As Object : If isNull(oFn) Then : oFn = Fn.TExpr_same : End If
	Dim out As Variant
	If isMissing(x) Then 	 : out = oFn
	ElseIf isMissing(y) Then : out = apply(oFn, x)
	Else
		If isExpr(x) And isExpr(y) Then
			out = (x.id = y.id)
		Else
			croak(&quot;TExpr_same: invalid types &quot; &amp; typeStr(x) &amp; &quot;, &quot; &amp; typeStr(y))
		End If
	End If
	TExpr_same = out
End Function

Function TExpr_equ(Optional x As Object, Optional y As Object)
	&apos;Static oFn As Object : If isNull(oFn) Then : oFn = Fn.TExpr_equ : End If
	Dim out As Variant
	If isMissing(x) Then 	 : out = oFn
	ElseIf isMissing(y) Then : out = apply(oFn, x)
	ElseIf TExpr_same(x, y) Then
		out = True
	ElseIf (x.which = y.which) Then
		Select Case x.which
			Case &quot;Val&quot;:	out = equ(x.a0, y.a0)
			Case &quot;Var&quot;:	out = (x.a0 = y.a0)
			Case &quot;Lam&quot;
				If (x.a0 = y.a0) Then
					out = TExpr_equ(x.a1, y.a1) &apos; tail-recursive!
				Else
					out = False
				End If
			Case &quot;App&quot;
				out = TExpr_equ(x.a0, y.a0) 
				If out Then
					out = TExpr_equ(x.a1, y.a1) &apos; tail-recursive!
				End If
			&apos;Case &quot;BuiltIn&quot; &apos; TODO: TExpr_equ Builtin
		Case Else
			croak(&quot;TExpr_equ: unsupported expr .which = &quot; &amp; toString(x.which))
		End Select
	Else
		out = False
	End If
	TExpr_equ = out
End Function

Function xpVal(v As Variant)
	xpVal = newExpr(&quot;Val&quot;, v, Empty)
End Function

Function xpVar(ByVal s As String)
	xpVar = newExpr(&quot;Var&quot;, s, Empty)
End Function

Function xpLam(ByVal s As String, ByVal x As Object)
	xpLam = newExpr(&quot;Lam&quot;, s, x)
End Function

Function xpApp(ByVal f As Object, ByVal a As Variant)
	xpApp = newExpr(&quot;App&quot;, f, a)
End Function

Function xpBuiltin(ByVal oFn As Object)
	xpBuiltin = newExpr(&quot;Builtin&quot;, oFn, Empty)
End Function

Function xpErr(ByVal msg As String)
	xpErr = newExpr(&quot;Err&quot;, msg, Empty)
End Function


&apos; Builtin (+) 
&apos; ~&gt; Lam &quot;fresh_1&quot; 
&apos;        (Lam &quot;fresh_2&quot;
&apos;             (App
&apos;                  (App (Builtin (+))
&apos;                       (fresh_1)     
&apos;                  )
&apos;                  fresh_2
&apos;             )
&apos;        )


Function evalX(ByVal x As Object, ByVal env As Object)
	evalX = _evalX(x, env, nil)
End Function

Function _evalX( _
	ByVal x     As Object, _
	ByVal env   As Object, _
	ByVal argXs As Object _
)
	Dim out As Variant
	Select Case x.which
		Case &quot;Val&quot;:	out = x.a0
		Case &quot;Var&quot;
			Dim v As Variant
			v = lookup(x.a0, env)
			If isEmpty(v) Then
				croak(&quot;evalX: unbound Var &quot; &amp; toString(x.a0))
			Else
				out = v
			End If
		Case &quot;Lam&quot;
		 	out = List(x, env)
		Case &quot;Builtin&quot;: out = x.a0
		Case &quot;App&quot;
			Dim f As Object, a As Variant
_evalX_descend_Apps:
			f = x.a0
			a = x.a1
			If (f.which = &quot;App&quot;) Then
				&apos; tail-call:
				&apos;out = _evalX(f, env, cons(a, argXs))
				argXs = cons(a, argXs)
				x = f
				Goto _evalX_descend_Apps
			Else
				f = evalX(f, env)
				&apos; tail-call:
				out = _applyX(f, env, cons(a, argXs))
			End If
		Case &quot;Err&quot;
		 	croak(x.a0)
		Case Else
			croak(&quot;evalX: unsupported expr .which = &quot; &amp; toString(x.which))
	End Select
	_evalX = out
End Function

Function _applyX( _
	ByVal f As Object, _
	ByVal dynamicEnv As Object, _
	ByVal argXs As Object _
)
	Dim out As Variant, arg As Variant
_applyX_begin:
	If isList(f) Then &apos; eval&apos;d Lambda (= nothing but the lambda expr together with a (lexical) env)
		Dim x As Object, v As String, body As Object, lexicalEnv As Object
		x = car(f)
		v = x.a0
		body = x.a1
		lexicalEnv = cadr(f)
		If (v &lt;&gt; &quot;_&quot;) Then
			arg = evalX(car(argXs), dynamicEnv)
			lexicalEnv = extend(lexicalEnv, v, arg)
		End If
		out = evalX(body, lexicalEnv)
		argXs = cdr(argXs)
		If Not(isNil(argXs)) Then
			&apos;out = _applyX(out, dynamicEnv, argXs) &apos; tail-recursive
			f = out
			Goto _applyX_begin
		End If
	Else
		Dim r As Integer, n As Integer, argVs As Object
			n = length(argXs)
			argVs = nil
			Do Until(isNil(argXs))	&apos; strict: eval argXs from left to right
				arg = car(argXs)	&apos; *before* passing them to oFn
				argVs = cons(evalX(arg, dynamicEnv), argVs)
				argXs = cdr(argXs)
			Loop
		argVs = reverse(argVs)		
		r = arity(f)
		If False And (r &lt;&gt; n) Then
			show(&quot;applying &quot; &amp; getFnName(f) _
					&amp; &quot; (arity &quot; &amp; r &amp; &quot;) to &quot; &amp; n &amp; &quot; args&quot;, _
				argVs _
			)
		End If
		out = applyToList(f, argVs)
	End If
	_applyX = out
End Function

Function [test_Expr======================================]
	test_Expr_isExpr()
	&apos; TODO: test TExpr_same
	&apos; TODO: test TExpr_equ
	test_Expr_eval_Val()
	test_Expr_eval_Var()
	test_Expr_eval_Builtin() &apos; App (Builtin ...) ... tested here
	test_Expr_eval_Lam() &apos; App (Lam ...) ... tested here
End Function

Function test_Expr_isExpr()
	Dim x As Object
	assertEqual(isExpr(xpVal(True)), 					 True).x
	assertEqual(isExpr(xpVar(&quot;a&quot;)), 					 True).x
	assertEqual(isExpr(xpLam(&quot;a&quot;, xpVar(&quot;a&quot;))), 		 True).x
	assertEqual(isExpr(xpApp(xpVar(&quot;a&quot;), xpVal(False))), True).x
End Function

Function test_Expr_eval_Val()
	Dim x As Object, e As Object, v As Variant
	e = envEmpty
	v = &quot;foo&quot; :	x = xpVal(v)
	assertEqual(evalX(x, e), v).x
	v = &quot;bar&quot;
	assertEqual(evalX(x, e), &quot;foo&quot;).x
	e = extend(e, &quot;foo&quot;, &quot;bar&quot;)
	assertEqual(evalX(x, e), &quot;foo&quot;).x
End Function

Function test_Expr_eval_Var()
	Dim x As Object, e As Object, v As Variant
	e = envEmpty
	x = xpVar(&quot;a&quot;)
	v = &quot;foo&quot;
	e = extend(e, &quot;a&quot;, v) &apos; must wrap it in a Val
	assertEqual(evalX(x, e), v).x
	
	e = extend(e, &quot;b&quot;, v)
	x = xpVar(&quot;b&quot;)
	assertEqual(evalX(x, e), v).x
End Function

Function test_Expr_eval_Builtin()
	Dim f As Object, a As Object, e As Object, x As Variant, act As Variant
	e = envEmpty
	assertEqual(arity(Fn.fstArg), 2).x &apos; are we assuming the right arity?
	f = xpBuiltin(Fn.fstArg)
	
	&apos; first, Builtin as such evaluates to the fn obj withing:
	a = evalX(f, e)
	assertEqual(isFn(a), True).x
	assertEqual(getFnName(a), getFnName(Fn.fstArg)).x
	assertEqual(arity(a), 2).x
	
	&apos; let&apos;s apply it to as many args as it expects:
	a = xpVal(42)
	x = xpApp(xpApp(f, a), xpVal(88))
	act = evalX(x, e)
	assertEqual(act, 42).x
	
	&apos; partial application:
	x = xpApp(f, a)
	act = evalX(x, e)
	assertEqual(isFn(act), True).x
	assertEqual(getFnName(act), getFnName(Fn.fstArg)).x
	assertEqual(arity(act), 1).x
	
	&apos; apply partially applied fn to more args:
	x = xpApp(xpVar(&quot;K_42&quot;), xpVal(88))
	act = evalX(x, extend(e, &quot;K_42&quot;, act))
	assertEqual(act, 42).x
	
	&apos; &quot;over-application&quot;:
	x = xpApp(xpApp(xpApp(f, xpBuiltin(id)), xpVal(1)), xpVal(2))
	act = evalX(x, e)
	assertEqual(act, 2).x
	
	&apos;----------------
	&apos; apply builtin swap (arity 3)
	assertEqual(arity(Fn.swap), 3).x &apos; are we assuming the right arity?
	f = xpBuiltin(Fn.swap)

	&apos; let&apos;s apply it to as many args as it expects:
	a = xpBuiltin(Fn.cons)
	x = xpApp(xpApp(xpApp(f, a), xpVal(nil)), xpVal(42))
	act = evalX(x, e)
	assert_toString_equals(act, List(42)).x
	
	&apos; partial application (2 more missing):
	x = xpApp(f, a)
	act = evalX(x, e)
	assertEqual(isFn(act), True).x
	assertEqual(getFnName(act), getFnName(Fn.swap)).x
	assertEqual(arity(act), 2).x
	
	&apos; partial application (1 more missing):
	x = xpApp(xpApp(f, a), xpVal(List(2))
	act = evalX(x, e)
	assertEqual(isFn(act), True).x
	assertEqual(getFnName(act), getFnName(Fn.swap)).x
	assertEqual(arity(act), 1).x

	&apos; apply partially applied fn to more args:
	x = xpApp(xpVar(&quot;swap_cons_[2]&quot;), xpVal(1))
	act = evalX(x, extend(e, &quot;swap_cons_[2]&quot;, act))
	assert_toString_equals(act, List(1, 2)).x
End Function

Function test_Expr_eval_Lam()
	Dim x As Object, e As Object, act As Variant
	e = envEmpty
	x = xpLam(&quot;a&quot;, xpVal(42))
	
	act = evalX(x, e)
	assertEqual(isList(act), True).x
	assertEqual(length(act), 2).x
	assertEqual(TExpr_same(car(act), x), True).x
	assertEqual(Env_toString(cadr(act)), Env_toString(e)).x
		
	e = extend(e, &quot;a&quot;, 4711)
	act = evalX(x, e)
	assertEqual(isList(act), True).x
	assertEqual(length(act), 2).x
	assertEqual(TExpr_same(car(act), x), True).x
	assertEqual(Env_toString(cadr(act)), Env_toString(e)).x

	&apos; one-arg lambda

	Dim f As Object, a As Object
	e = envEmpty
	f = xpLam(&quot;a&quot;, xpVal(42))
	a = xpVal(88)
	x = xpApp(f, a)
	assertEqual(evalX(x, e), 42).x
	e = extend(e, &quot;a&quot;, 4711)
	assertEqual(evalX(x, e), 42).x

	f = xpLam(&quot;a&quot;, xpVar(&quot;a&quot;))
	x = xpApp(f, a)
	assertEqual(evalX(x, e), 88).x

	f = xpLam(&quot;_&quot;, xpVar(&quot;a&quot;))
	x = xpApp(f, a)
	assertEqual(evalX(x, e), 4711).x

	&apos; lexical scope:
	&apos; evaluate the lambda in its own env, then apply that in another
	e = extend(envEmpty, &quot;a&quot;, 4711)
	act = evalX(xpLam(&quot;_&quot;, xpVar(&quot;a&quot;)), e)
	e = extend(envEmpty, &quot;it&quot;, act)
	x = xpApp(xpVar(&quot;it&quot;), xpVal(88))
	act = evalX(x, e)
	assertEqual(act, 4711).x

	&apos; &quot;over-applying a one-arg lambda (which returns a builtin fn obj)
	&apos; make sure we&apos;re assuming the right arity:
	assertEqual(arity(Fn.fstArg), 2).x
	f = xpLam(&quot;_&quot;, xpVal(Fn.fstArg))
	x = xpApp(xpApp(xpApp(f, xpVal(1)), xpVal(2)), xpVal(3))
	assertEqual(evalX(x, e), 2).x

	&apos; two-arg lambda
	&apos; \ys.\y.cons y ys
	f = xpLam(&quot;ys&quot;, xpLam(&quot;y&quot;, xpApp(xpApp(xpVar(&quot;cons&quot;), xpVar(&quot;y&quot;)), xpVar(&quot;ys&quot;)))
	e = extend(envEmpty, &quot;cons&quot;, Fn.cons)
	x = xpApp(xpApp(f, xpVal(List(2, 3))), xpVal(1))
	act = evalX(x, e)
	assertEqual(equ(act, List(1, 2, 3)), True).x

	&apos; &quot;_&quot; parameter isn&apos;t eval&apos;d
	f = xpLam(&quot;_&quot;, xpVal(42))
	x = xpApp(f, xpErr(&quot;Boom!&quot;))
	act = evalX(x, envEmpty)
	assertEqual(act, 42).x
	
	f = xpLam(&quot;a&quot;, xpLam(&quot;_&quot;, xpVar(&quot;a&quot;)))
	x = xpApp(xpApp(f, xpVal(42)), xpErr(&quot;Boom!&quot;))
	act = evalX(x, envEmpty)
	assertEqual(act, 42).x

End Function


</script:module>