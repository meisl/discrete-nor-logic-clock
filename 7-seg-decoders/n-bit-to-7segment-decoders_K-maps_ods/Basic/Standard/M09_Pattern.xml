<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M09_Pattern" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit

&apos; data Pattern = Any
&apos;              | Val Type.Any
&apos;              | Var Str
&apos;              | Dat TypeCtor [Pattern]

Const TPattern_tyname = &quot;TPattern&quot;
Type TPattern
	tyname	As String
	which	As String
	a0		As Variant
End Type


Sub Main
	TPattern
	[test_Pattern======================================]()
End Sub


Function TPattern()
	Static out As Object
	If isNull(out) Then
		Dim tcPat
		tcPat = _mkDataTypeCtor(&quot;Pattern&quot;, 0)
		out = tcPat
		Dim cAny, cVar, cConst, cData
		cAny   = _mkDataCtor(tcPat, &quot;Any&quot;, 	 nil)
		cVar   = _mkDataCtor(tcPat, &quot;Var&quot;, 	 List(Tp.Native_String))
		cConst = _mkDataCtor(tcPat, &quot;Const&quot;, List(Tp.Native_Variant))
		cData  = _mkDataCtor(tcPat, &quot;Data&quot;,  List(TDataCtor, TList(tcPat)))
		&apos;msgbox(hasType(&quot;asdf&quot;, Tp.Native_Variant))
		&apos;show(cData.str)
	End If
	TPattern = out
End Function

Function Pattern_Any()
	Static out As Object : If isNull(out) Then
		out = singletonVal(findDataCtor(TPattern, &quot;Any&quot;))
		out.str = &quot;_&quot;
	End If
	Pattern_Any = out
End Function

Function Pattern_Var(Optional nm)
	Static c As Object : If isNull(c) Then
		c = findDataCtor(TPattern, &quot;Var&quot;)
	End If
	Dim out
	If isMissing(nm) Then
		out = applyDC(c)
	Else
		out = applyDC(c, nm)
		out.str = &quot;´&quot; &amp; nm
	End If
	Pattern_Var = out
End Function

Function Pattern_Var_name(Optional x)
	Static c As Object : If isNull(c) Then
		c = _ctor(Pattern_Var(&quot;x&quot;))
	End If
	Pattern_Var_name = _destructure(c, 0, x)
End Function

Function Pattern_Const(Optional val)
	Static c As Object : If isNull(c) Then
		c = findDataCtor(TPattern, &quot;Const&quot;)
	End If
	Dim out
	If isMissing(val) Then
		out = applyDC(c)
	Else
		out = applyDC(c, val)
		out.str = &quot;´&quot; &amp; toString(val)
	End If
	Pattern_Const = out
End Function

Function Pattern_Const_value(Optional x)
	Static c As Object : If isNull(c) Then
		c = _ctor(Pattern_Const(&quot;x&quot;))
	End If
	Pattern_Const_value = _destructure(c, 0, x)
End Function

Function Pattern_Data(Optional dc, Optional argPatterns)
	Static oFn As Object, tcPat As Object, cDat As Object
	If isNull(oFn) Then
		oFn = Fn.Pattern_Data
		tcPat = TPattern
		cDat = findDataCtor(tcPat, &quot;Data&quot;)
	End If
	Dim out
	If isMissing(dc) Then
		out = oFn
	ElseIf isMissing(argPatterns) Then
		out = apply(oFn, dc)
	Else
		out = applyDC(cDat, dc, argPatterns)
		&apos; still have to make sure argPatterns isa [Pattern]
		Dim aps As Object : aps = argPatterns
		Dim ats As Object : ats = argTypes(dc)
		If length(aps) &lt;&gt; length(ats) Then
			Goto Pattern_Data_2nd_arg_wrong_count
		End If
		Dim ap As Variant	&apos; might be whatever
		Dim at As Object	&apos; should be a Type
		Dim i As Integer
		Do Until(isNil(aps))
			ap = car(aps) : aps = cdr(aps)
			at = car(ats) : ats = cdr(ats)
			If hasType(ap, tcPat) Then
				&apos; TODO: check if it is compatible with at
			Else
				Goto Pattern_Data_2nd_arg_type_error
			End If
			i = i + 1
		Loop
		out.str = &quot;´&quot; &amp; nameOf(dc)
		If i &gt; 0 Then
			out.str = out.str &amp; &quot; ...&quot;
		End If
	End If
	Pattern_Data = out
	Exit Function
Pattern_Data_2nd_arg_type_error:
	Dim msg As String
	On Local Error Goto Pattern_Data_2nd_arg_type_error_skipToString
	msg = &quot;:&quot; &amp; NL &amp; toString(ap)
Pattern_Data_2nd_arg_type_error_skipToString:
	msg = &quot;invalid 2nd arg: expected a [TPattern]&quot; _
		&amp; NL &amp; &quot;but there&apos;s a &quot; &amp; typeStr(ap) _
		&amp; &quot; at index &quot; &amp; i _
		&amp; msg
	On Local Error Goto 0 &apos; disable error handler
	croak(msg)
Pattern_Data_2nd_arg_wrong_count:
	On Local Error Goto 0 &apos; disable error handler
	croak(&quot;invalid 2nd arg: &quot; &amp; nameOf(dc) _
		&amp; &quot; needs &quot; &amp; length(argTypes(dc)) &amp; &quot; args&quot; _
		&amp; NL &amp; &quot;but we got &quot; &amp; length(argPatterns) &amp; &quot; patterns&quot; _
	)
End Function

Function Pattern_Data_ctor(Optional x)
	Static c As Object : If isNull(c) Then
		c = _ctor(Pattern_Data(_ctor(nil), nil))
	End If
	Pattern_Data_ctor = _destructure(c, 0, x)
End Function

Function Pattern_Data_args(Optional x)
	Static c As Object : If isNull(c) Then
		c = _ctor(Pattern_Data(_ctor(nil), nil))
	End If
	Pattern_Data_args = _destructure(c, 1, x)
End Function

Function singletonPat(v)
	singletonPat = Pattern_Data(_ctor(v), nil)
End Function

Function isPattern(Optional x)
	Static oFn As Object, tcPat As Object
	If isNull(oFn) Then
		oFn = Fn.isPattern
		tcPat = TPattern
	End If
	Dim out
	If isMissing(x) Then : out = oFn
	Else				 : out = hasType(x, tcPat)
	End If
	isPattern = out
End Function

Function patNil()
	Static out As Object : If isNull(out) Then 
		out = singletonPat(nil)
	End If
	patNil = out
End Function

Function patCons(hd, tl)
	Static cCons As Object : If isNull(cCons) Then : cCons = Tp.List_Cons : End If
	patCons = Pattern_Data(cCons, List(hd, tl))
End Function

Function patList( _
	Optional a0, _
	Optional a1, _
	Optional a2, _
	Optional a3, _
	Optional a4, _
	Optional a5, _
	Optional a6, _
	Optional a7, _
	Optional a8, _
	Optional a9, _
	Optional a10 _
)
	Dim out
	out = patNil
	If isMissing(a0 ) Then : Goto patList_0  : End If
	If isMissing(a1 ) Then : Goto patList_1  : End If
	If isMissing(a2 ) Then : Goto patList_2  : End If
	If isMissing(a3 ) Then : Goto patList_3  : End If
	If isMissing(a4 ) Then : Goto patList_4  : End If
	If isMissing(a5 ) Then : Goto patList_5  : End If
	If isMissing(a6 ) Then : Goto patList_6  : End If
	If isMissing(a7 ) Then : Goto patList_7  : End If
	If isMissing(a8 ) Then : Goto patList_8  : End If
	If isMissing(a9 ) Then : Goto patList_9  : End If
	If isMissing(a10) Then : Goto patList_10 : Else
		croak(&quot;only 10 args supported - got 11&quot;)
	End If
patList_10: out = patCons(a9, out)
patList_9:  out = patCons(a8, out)
patList_8:  out = patCons(a7, out)
patList_7:  out = patCons(a6, out)
patList_6:  out = patCons(a5, out)
patList_5:  out = patCons(a4, out)
patList_4:  out = patCons(a3, out)
patList_3:  out = patCons(a2, out)
patList_2:  out = patCons(a1, out)
patList_1:  out = patCons(a0, out)
patList_0:
	patList = out
End Function


Function TPattern_toString(Optional p As Object)
	Static oFn As Object
	If isNull(oFn) Then
		oFn = Fn.TPattern_toString
	End If
	Dim out
	If isMissing(p) Then
		out = oFn
	Else
		out = _TPattern_toString(p, False)
	End If
	TPattern_toString = out
End Function
	
Function _TPattern_toString( _
	p As Object, _
	needParens As Boolean _
)
	Static cAny		As Object
	Static idAny	As Integer
	Static idVar	As Integer
	Static idConst	As Integer
	Static idData	As Integer
	If isNull(cAny) Then
		cAny = findDataCtor(TPattern, &quot;Any&quot;)
		idAny   = _id(cAny)
		idVar   = _id(findDataCtor(TPattern, &quot;Var&quot;))
		idConst = _id(findDataCtor(TPattern, &quot;Const&quot;))
		idData  = _id(findDataCtor(TPattern, &quot;Data&quot;))
	End If
	Dim out As Variant
	&apos; TODO: specialize singleton patterns like patAny, patNil, ...
	On Local Error Goto _TPattern_toString_error
	Select Case _id(_ctor(p))
		Case idAny:			out = &quot;_&quot;
		Case idVar:			out = Pattern_Var_name(p)
		Case idConst:
			Dim v : v = Pattern_Const_value(p)
			If isEmpty(v) Then
				out = &quot;()&quot;
			Else
				out = toString(v)
			End If
		Case idData:
			If DataValue_same(p, patNil) Then
				out = &quot;[]&quot;
			Else
				Dim c  : c  = Pattern_Data_ctor(p)
				Dim ps : ps = Pattern_Data_args(p)
				If DataValue_same(c, Tp.List_Cons) Then
					Dim pHd : pHd = car(ps)
					Dim pTl : pTl = cadr(ps)
					If DataValue_same(pTl, patNil) Then
						out = &quot;[&quot; &amp; _TPattern_toString(pHd, False) &amp; &quot;]&quot;
					Else
						out = _TPattern_toString(pHd, True) _
							&amp; &quot;:&quot; _
							&amp; _TPattern_toString(pTl, True)
						If needParens Then
							out = &quot;(&quot; &amp; out &amp; &quot;)&quot;
						End If
					End If
				Else
					Dim q As Object
					out = nameOf(c)
					If Not(isNil(ps)) Then
						Do Until isNil(ps)
							q = car(ps)
							ps = cdr(ps)
							out = out &amp; &quot; &quot; &amp; _TPattern_toString(q, True)
						Loop
						If needParens Then
							out = &quot;(&quot; &amp; out &amp; &quot;)&quot;
						End If
					End If
				End If
			End If	

		Case Else
_TPattern_toString_error:
			On Local Error Goto 0 &apos; disable error handler
			croak(&quot;TPattern_toString: bad pattern &quot; &amp; typeStr(p))
	End Select
	_TPattern_toString = out
End Function

Function match( _
	Optional ByRef p As Object, _
	Optional ByRef e As Variant, _
	Optional ByVal x As Variant _
)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.match : End If
	Dim out As Variant
	If isMissing(p) Then
		out = oFn
	Else
		If Not(hasType(p, TPattern)) Then
			croak(&quot;match: not a pattern: &quot; &amp; typeStr(p))
		ElseIf isMissing(e) Then 	: out = apply(oFn, p)
		ElseIf isEmpty(e) Or isFn(e) Then
			If isMissing(x) Then	: out = apply(oFn, p, e)
			ElseIf isEmpty(e) Then	: out = Empty
			Else
				out = _match(p, e, x)
			End If
		Else
			croak(&quot;match: bad environment: &quot; &amp; typeStr(e))
		End If
	End If
	match = out
End Function

Function _match( _
	ByVal p As Object, _
	ByVal e As Variant, _
	ByVal x As Variant _
)
	Static cAny		As Object
	Static idAny	As Integer
	Static idVar	As Integer
	Static idConst	As Integer
	Static idData	As Integer
	If isNull(cAny) Then
		cAny = findDataCtor(TPattern, &quot;Any&quot;)
		idAny   = _id(cAny)
		idVar   = _id(findDataCtor(TPattern, &quot;Var&quot;))
		idConst = _id(findDataCtor(TPattern, &quot;Const&quot;))
		idData  = _id(findDataCtor(TPattern, &quot;Data&quot;))
	End If
	Dim out
	Select Case _id(_ctor(p))
		Case idAny:		out = e
		Case idConst
			Dim v : v = Pattern_Const_value(p)
			If equ(x, v) Then
				out = e
			Else
				out = Empty
			End If
		Case Else
			croak(&quot;match: bad pattern &quot; &amp; typeStr(p))
	End Select
	_match = out
End Function



Function newPattern(which As String, a0 As Variant)
	Dim out As New TPattern
	out.tyname = TPattern_tyname
	out.which  = which
	out.a0	   = a0
	newPattern = out
End Function

Function patAny()
	Static out As Object : If isNull(out) Then
		out = newPattern(&quot;Any&quot;, Empty)
	End If
	patAny = out
End Function

Function patVal(v As Variant)
	Dim out As Variant
	out = newPattern(&quot;Val&quot;, v)
	patVal = out
End Function

Function patVar(s As String)
	Dim out As Variant
	out = newPattern(&quot;Var&quot;, s)
	patVar = out
End Function

Function patList_nil()
	Static out As Object : If isNull(out) Then : out = newPattern(&quot;List.nil&quot;, nil) : End If
	patList_nil = out
End Function

Function patDat(ctor As Object)
	Dim out As Object
	out = newPattern(&quot;Dat&quot;, ctor)
	patDat = out
End Function

Function patList_cons(patHd As Variant, patTl As Object)
	Dim out As Variant
	&apos; TODO: make sure patHd and patTl are proper patterns
	out = newPattern(&quot;List.cons&quot;, List(patHd, patTl))
	patList_cons = out
End Function

Function patASN(patLabel As Variant, patValue As Object, patChildren As Object)
	Dim out As Variant
	&apos; TODO: make sure patLabel, patValue and patChildren are proper patterns
	out = newPattern(&quot;ASN&quot;, List(patLabel, patValue, patChildren))
	patASN = out
End Function

&apos; matches :: Pattern a -&gt; Maybe Env -&gt; a -&gt; Maybe Env
&apos; matches _          None     _ = None
&apos; matches Any        (Some e) x = Some e
&apos; matches (Val v)    (Some e) x = if x = v then Some e else None
&apos; matches (Var s)    (Some e) x = case (lookup s e) of
&apos;                              None   -&gt; Some (extend e s x)
&apos;                              Some y -&gt; matches (Val y) (Some e) x
&apos; matches (Dat c qs) (Some e) x = if (typeCtor x) != c
&apos;                                 then None
&apos;                                 else let f = (\acc q.let fs = fst acc
&apos;                                                          me = snd acc
&apos;                                                      in
&apos;                                                      case me of
&apos;                                                        None   -&gt; None
&apos;                                                        e&apos; -&gt; (matches q e&apos; (car fs), cdr fs)
&apos;									   in
&apos;                                      foldl f (fields x, Some e) qs
Function matches( _
	Optional ByRef p As Object, _
	Optional ByRef e As Variant, _
	Optional ByVal x As Variant _
)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.matches : End If
	Dim out As Variant
	If isMissing(p) Then 		: out = oFn
	ElseIf isMissing(e) Then 	: out = apply(oFn, p)
	ElseIf isMissing(x) Then	: out = apply(oFn, p, e)
	ElseIf isEmpty(e) Then		: out = Empty
	Else
		out = _matches(p, e, x, nil)
	End If
	matches = out
End Function

Function _matches( _
	ByVal p As Object, _
	ByVal e As Variant, _
	ByVal x As Variant, _
	ByVal args As Object _
)
	If isEmpty(e) Then
		_matches = Empty
		Exit Function
	End If
	Dim out As Variant, u As Variant
_matches_dispatch:
	Select Case p.which
		Case &quot;Any&quot;: 	out = e
		Case &quot;Val&quot;
			u = p.a0
_matches_Val_equalityTest:
			&apos;On Local Error Goto _matches_Val_equalityTest_threw
			If equ(x, u) Then
				out = e
			Else
				out = Empty
			End If
		Case &quot;Var&quot;
			Dim s As String, y As Variant
			s = p.a0
			y = lookup(s, e)
			If isEmpty(y) Then
				out = extend(e, s, x)
			Else
				&apos; tail-call:
				&apos;out = _matches(patVal(y), e, x, args)
				u = y
				Goto _matches_Val_equalityTest
			End If
		Case &quot;App&quot;
			Dim f As Object, a As Variant
_matches_descend_Apps:
			f = p.a0
			a = p.a1
			If (f.which = &quot;App&quot;) Then
				&apos; tail-call:
				&apos;out = _matches(f, e, x, cons(a, args))
				args = cons(a, args)
				p = f
				Goto _matches_descend_Apps
			Else
				&apos; tail-call:
				out = _matchApplication(f, e, x, cons(a, args))
			End If
		Case &quot;List.nil&quot;
			If Not(isList(x)) Then
				out = Empty	&apos; TODO: maybe throw on type error?
			ElseIf isNil(x) Then
				out = e
			Else
				out = Empty
			End If
		Case &quot;List.cons&quot;
			If Not(isList(x)) Then
				out = Empty	&apos; TODO: maybe throw on type error?
			ElseIf isNil(x) Then
				out = Empty
			Else
				Dim patHd As Object, patTl As Object
				patHd = car(p.a0)
				out = _matches(patHd, e,   car(x), args)
				If isEmpty(out) Then : Goto _matches_end : End If
				patTl = cadr(p.a0)
				&apos; tail-call:
				&apos;out = _matches(patTl, out, cdr(x), args)
			
				p = patTl
				e = out
				x = cdr(x)
				Goto _matches_dispatch
			End If
		Case &quot;ASN&quot;
			If Not(isASN(x)) Then
				out = Empty	&apos; TODO: maybe throw on type error?
			Else
				Dim patLabel As Object, patValue As Object, patChildren As Object
				patLabel    = car(p.a0)
				out = _matches(patLabel,    e,   asnLabel(x),    args)
				If isEmpty(out) Then : Goto _matches_end : End If
				patValue    = cadr(p.a0)
				out = _matches(patValue,    out, asnValue(x),    args)
				If isEmpty(out) Then : Goto _matches_end : End If
				patChildren = caddr(p.a0)
				&apos; tail-call:
				&apos;out = _matches(patChildren, out, asnChildren(x), args)
				p = patChildren
				e = out
				x = asnChildren(x)
				Goto _matches_dispatch
			End If
		Case Else
			croak(&quot;TPattern_matches: unsupported pattern .which = &quot; &amp; toString(p.which))
	End Select
_matches_end:
	_matches = out
End Function

Function _matchApplication( _
	ByVal ptOp  As Object, _
	ByVal env   As Variant, _
	ByVal val   As Variant, _
	ByVal args  As Object _
)
	Dim out As Variant
	out = Empty
	If ptOp.which &lt;&gt; &quot;Dat&quot; Then
		croak(&quot;_matchApplication: unsupported op pattern &quot; &amp; NL &amp; TPattern_toString(ptOp))
	End If
	Dim ctor As Variant
	ctor = ctorOf(val)
	If isEmpty(ctor) Then &apos; not a datatype value
		out = Empty	&apos; TODO: maybe throw on type error?
	Else
		Dim ctorName As String, opName As String
		ctorName = getFnName(ctor)
		opName = getFnName(ptOp.a0)
		If ctorName = opName Then
			Dim opArity As Integer, ctorArity As Integer
			opArity = arity(ptOp.a0)
			ctorArity = arity(ctor)
			If opArity &lt;&gt; ctorArity Then
				croak(&quot;_matchApplication/NYI: unequal arities of op &quot; _
					&amp; opName &amp; &quot; (&quot; &amp; opArity &amp; &quot;)&quot; _
					&amp; &quot; &lt;&gt; &quot; &amp; ctorName &amp; &quot; (&quot; &amp; ctorArity &amp; &quot;)&quot; _
				)
			End If
			show(&quot;_matchApplication/NYI: applyToList &quot; &amp; opName _
				&amp; &quot; &quot; &amp; toString(args) _
				&amp; NL &amp; &quot; matched against&quot;, val _
			)
		End If
	End If
	_matchApplication = out
End Function


Function [test_Pattern======================================]()
	test_Pattern_TPattern()
	test_Pattern_Any()
	test_Pattern_Var()
	test_Pattern_Const()
	test_Pattern_Data()
	
	test_Pattern_singletonPat()
	test_Pattern_patNil()
	&apos;test_Pattern_patCons()
	test_Pattern_patList()

	test_Pattern_isPattern()
	test_Pattern_toString()
	
	test_Pattern_match()
	test_Pattern_matches_Any()
	test_Pattern_matches_Const()

	test_Pattern_matches_Var()
	test_Pattern_matches_List()
	test_Pattern_matches_ASN()
End Function

Function test_Pattern_TPattern()
	Dim tc : tc = TPattern
	Dim dcs
	assert_hasCtor(tc, Tp.DataTypeCtor).x
	dcs = dataCtors(tc)
	assertEqual(isList(dcs), True).x
	assertEqual(isNil(dcs), False).x
End Function

Function test_Pattern_Any()
	Dim cAny : cAny = findDataCtor(TPattern, &quot;Any&quot;)
	Dim vAny : vAny = Pattern_Any()
	assert_hasCtor(vAny, cAny).x
	&apos; returns the same value again:
	assert_same(Pattern_Any(), vAny).x
End Function

Function test_Pattern_Var()
	Dim cVar : cVar = findDataCtor(TPattern, &quot;Var&quot;)
	Dim vVar : vVar = Pattern_Var(&quot;foo&quot;)
	assert_hasCtor(vVar, cVar).x
	&apos; destructure:
	assertEqual(Pattern_Var_name(vVar), &quot;foo&quot;).x
	
	assertEqual(isFn(Pattern_Var()), True).x
	&apos;assertThrows(Pattern_Var, Array(1)).x	&apos; TODO: typecheck in applyDC
End Function

Function test_Pattern_Const()
	Dim cConst : cConst = findDataCtor(TPattern, &quot;Const&quot;)
	Dim vConst : vConst = Pattern_Const(42)
	assert_hasCtor(vConst, cConst).x
	&apos; destructure:
	assertEqual(Pattern_Const_value(vConst), 42).x

	assertEqual(Pattern_Const_value(Pattern_Const(Nothing)), Nothing).x
	assertEqual(Pattern_Const_value(Pattern_Const(Empty)), 	 Empty).x
	assertEqual(Pattern_Const_value(Pattern_Const(&quot;qmbl&quot;)),  &quot;qmbl&quot;).x
	&apos;assertEqual(Pattern_Const_value(Pattern_Const()), ).x
	
	assertEqual(isFn(Pattern_Const()), True).x
End Function

Function test_Pattern_Data()
	Dim cDat : cDat = findDataCtor(TPattern, &quot;Data&quot;)
	Dim cNil : cNil = Tp.List_Nil
	Dim vNil : vNil = nil
	Dim pNil : pNil = Pattern_Data(cNil, vNil)
	assert_hasCtor(pNil, cDat).x
	&apos; destructure:
	assert_same(Pattern_Data_ctor(pNil), cNil).x
	assert_same(Pattern_Data_args(pNil), vNil).x
	
	Dim c, args, p
	c = Tp.List_Cons
	args = List(Pattern_Const(1), pNil)
	p = Pattern_Data(c, args)
	assert_hasCtor(p, cDat).x
	&apos; destructure:
	assert_same(Pattern_Data_ctor(p), c).x
	assert_same(Pattern_Data_args(p), args).x
	
	&apos; expects a data ctor as 1st arg
	assertThrows(Pattern_Data, Array(TList, args)).x
	assertThrows(Pattern_Data, Array(vNil,  args)).x
	assertThrows(Pattern_Data, Array(&quot;foo&quot;, args)).x
	
	&apos; expects a List as 2nd arg
	assertThrows(Pattern_Data, Array(c, &quot;foo&quot;)).x
	
	&apos; expects a List of *Patterns* as 2nd arg
	assertThrows(Pattern_Data, Array(c, List(1, pNil))).x
	
	&apos; Pattern list must be same length as data ctor&apos;s argTypes
	assertThrows(Pattern_Data, Array(c, List(pNil))).x

	&apos; Patterns must be compatible with data ctor&apos;s argTypes:
	&apos;NYI: assertThrows(Pattern_Data, Array(c, List(pNil, pNil))).x
End Function

Function test_Pattern_singletonPat()
	Dim cNil  : cNil  = _ctor(nil)
	Dim cData : cData = _ctor(Pattern_Data(cNil, nil))
	Dim p
	p = singletonPat(nil)
	assert_hasCtor(p, cData).x
	assert_same(Pattern_data_ctor(p), cNil).x
	assert_same(Pattern_data_args(p), nil).x
End Function

Function test_Pattern_patNil()
	Dim cNil  : cNil  = Tp.List_Nil
	Dim cData : cData = _ctor(Pattern_Data(cNil, nil))
	Dim p
	p = patNil
	assert_hasCtor(p, cData).x
	assert_same(Pattern_data_ctor(p), cNil).x
	assert_same(Pattern_data_args(p), nil).x
	&apos; returns the same value again:
	assert_same(patNil, p).x
End Function

Function test_Pattern_patList()
	Dim cNil  : cNil  = Tp.List_Nil
	Dim cCons : cCons = Tp.List_Cons
	Dim cData : cData = _ctor(Pattern_Data(cNil, nil))
	Dim pAny  : pAny  = Pattern_Any
	Dim pNil  : pNil  = patNil
	Dim p, args
	p = patList()
	assert_hasCtor(p, cData).x
	assert_same(Pattern_data_ctor(p), cNil).x
	assert_same(Pattern_data_args(p), nil).x
	&apos; for empty list (pattern): returns the same value again:
	assert_same(patList(), p).x
	
	p = patList(pAny)
	assert_hasCtor(p, cData).x
	assert_same(Pattern_data_ctor(p), cCons).x
	args = Pattern_data_args(p)
	assertEqual(length(args), 2).x
	assert_same(car(args), pAny).x
	assert_same(cadr(args), pNil).x
	assert_same(cddr(args), nil).x
	
	Dim p1 : p1 = Pattern_Const(1)
	p = patList(pAny, p1)
	assert_hasCtor(p, cData).x
	assert_same(Pattern_data_ctor(p), cCons).x
	args = Pattern_data_args(p)
	assertEqual(length(args), 2).x
	assert_same(car(args), pAny).x
	p = cadr(args)
	assert_hasCtor(p, cData).x
	assert_same(Pattern_data_ctor(p), cCons).x
	args = Pattern_data_args(p)
	assertEqual(length(args), 2).x
	assert_same(car(args), p1).x
	p = cadr(args)
	assert_hasCtor(p, cData).x
	assert_same(p, pNil).x
	
	Dim pVar : pVar = Pattern_Var(&quot;x&quot;)
	p = patList(pAny, p1, pVar)
	assert_hasCtor(p, cData).x
	assert_same(Pattern_data_ctor(p), cCons).x
	args = Pattern_data_args(p)
	assertEqual(length(args), 2).x
	assert_same(car(args), pAny).x
	p = cadr(args)
	assert_hasCtor(p, cData).x
	assert_same(Pattern_data_ctor(p), cCons).x
	args = Pattern_data_args(p)
	assertEqual(length(args), 2).x
	assert_same(car(args), p1).x
	p = cadr(args)
	assert_hasCtor(p, cData).x
	assert_same(Pattern_data_ctor(p), cCons).x
	args = Pattern_data_args(p)
	assertEqual(length(args), 2).x
	assert_same(car(args), pVar).x
	p = cadr(args)
	assert_hasCtor(p, cData).x
	assert_same(p, pNil).x
End Function


Function test_Pattern_isPattern()
	assertEqual(isPattern(Pattern_Any),		True).x
	
	assertEqual(isPattern(Pattern_Const(Empty)), 	True).x
	assertEqual(isPattern(Pattern_Const(Nothing)), 	True).x
	assertEqual(isPattern(Pattern_Const(&quot;&quot;)), 		True).x
	assertEqual(isPattern(Pattern_Const(&quot;a&quot;)),		True).x
	
	assertEqual(isPattern(Pattern_Var(&quot;a&quot;)),		True).x
	assertEqual(isPattern(Pattern_Var(&quot;b&quot;)),		True).x

	assertEqual(isPattern(patNil),	True).x
	&apos;assert_hasType(patNil,	TPattern).x

	assertEqual(isPattern(Pattern_Data( _
		Tp.List_Cons, List(Pattern_Any, Pattern_Any))),	True).x

	assertEqual(isPattern(Empty),		False).x
	assertEqual(isPattern(Nothing),		False).x
	assertEqual(isPattern(True),		False).x
	assertEqual(isPattern(False),		False).x
	assertEqual(isPattern(&quot;&quot;),			False).x
	assertEqual(isPattern(&quot;foo&quot;),		False).x
	assertEqual(isPattern(0),			False).x
	assertEqual(isPattern(1),			False).x
	assertEqual(isPattern(4711),		False).x
	assertEqual(isPattern(CLng(4711)),	False).x
	assertEqual(isPattern(3.1415),		False).x
	
	Dim f As Object
	f = isPattern	&apos; &quot;partial&quot; application
	assertEqual(arity(f),				1).x
	
	assertEqual(apply(f, Empty),		False).x
	assertEqual(apply(f, Nothing),		False).x
	assertEqual(apply(f, True),			False).x
	assertEqual(apply(f, False),		False).x
	assertEqual(apply(f, &quot;&quot;),			False).x
	assertEqual(apply(f, &quot;foo&quot;),		False).x
	assertEqual(apply(f, 0),			False).x
	assertEqual(apply(f, 1),			False).x
	assertEqual(apply(f, 4711),			False).x
	assertEqual(apply(f, CLng(4711)),	False).x
	assertEqual(apply(f, 3.1415),		False).x
End Function

Function test_Pattern_toString()
	Dim p As Object
	assertEqual(toString(Pattern_Any),				&quot;_&quot;).x

	assertEqual(toString(Pattern_Const(Empty)),		&quot;()&quot;).x

	assert_toString_equals(Pattern_Const(Nothing),   Nothing).x
	assert_toString_equals(Pattern_Const(True),	     	True).x
	assert_toString_equals(Pattern_Const(False),	   False).x
	assert_toString_equals(Pattern_Const(&quot;&quot;), 		      &quot;&quot;).x
	assert_toString_equals(Pattern_Const(&quot;a&quot;), 	      	 &quot;a&quot;).x
	assert_toString_equals(Pattern_Const(&quot;foo&quot;), 	   &quot;foo&quot;).x
	assert_toString_equals(Pattern_Const(CR), 	  	      CR).x
	assert_toString_equals(Pattern_Const(LF), 	  	      LF).x
	assert_toString_equals(Pattern_Const(TAB),   	     TAB).x
	assert_toString_equals(Pattern_Const(    0),           0).x
	assert_toString_equals(Pattern_Const(    1),           1).x
	assert_toString_equals(Pattern_Const(    2),           2).x
	assert_toString_equals(Pattern_Const( 4711),        4711).x
	assert_toString_equals(Pattern_Const(3.1415),     3.1415).x
	assert_toString_equals(Pattern_Const(CLng(42)), CLng(42)).x
	assert_toString_equals(Pattern_Const(CLng(42)),       42).x
	
	assertEqual(toString(Pattern_Var(&quot;a&quot;)), &quot;a&quot;).x
	assertEqual(toString(Pattern_Var(&quot;b&quot;)), &quot;b&quot;).x
	
	assertEqual(toString(patNil), 	 &quot;[]&quot;).x
	assertEqual(toString(patList()), &quot;[]&quot;).x
	&apos; patterns for a list with exactly one elem:
	p = patList(Pattern_Any)
	assertEqual(TPattern_toString(p), &quot;[_]&quot;).x
	p = patCons(Pattern_Any, patNil)
	assertEqual(toString(p), &quot;[_]&quot;).x
	&apos; pattern for a list with exactly two elems:
	p = patList(Pattern_Any, Pattern_Any)
	assertEqual(toString(p), &quot;_:[_]&quot;).x
	&apos; patterns for a list with at least one elem:
	p = patCons(Pattern_Any, Pattern_Any)
	assertEqual(toString(p), &quot;_:_&quot;).x
	p = patCons(Pattern_Var(&quot;y&quot;), Pattern_Var(&quot;ys&quot;))
	assertEqual(toString(p), &quot;y:ys&quot;).x
	&apos; pattern for a list with at least two elems:
	p = patCons(Pattern_Var(&quot;x&quot;), p)
	assertEqual(toString(p), &quot;x:(y:ys)&quot;).x
	
	&apos; patterns that match a pattern (patterns for a pattern)
	Dim cAny : cAny = _ctor(Pattern_Any)
	p = Pattern_Data(cAny, nil)
	assertEqual(toString(p), &quot;Any&quot;).x
	
	Dim cVar : cVar = findDataCtor(TPattern, &quot;Var&quot;)
	p = Pattern_Data(cVar, List(Pattern_Const(&quot;x&quot;)))
	assertEqual(TPattern_toString(p), &quot;Var &apos;x&apos;&quot;).x
	p = Pattern_Data(cVar, List(Pattern_Var(&quot;x&quot;)))
	assertEqual(toString(p), &quot;Var x&quot;).x
	
	&apos; pattern that matches a list of two Var patterns having the same varname:
	p = patList(p, p)
	assertEqual(TPattern_toString(p), &quot;(Var x):[Var x]&quot;).x
	&apos;assertEqual(TPattern_toString(p), &quot;[Var x, Var x]&quot;).x

	Dim cConst : cConst = findDataCtor(TPattern, &quot;Const&quot;)
	p = Pattern_Data(cConst, List(Pattern_Const(42)))
	assertEqual(TPattern_toString(p), &quot;Const 42&quot;).x

	Dim cData : cData = findDataCtor(TPattern, &quot;Data&quot;)
	p = Pattern_Data(cData, List(Pattern_Var(&quot;ctor&quot;), Pattern_Var(&quot;args&quot;))
	assertEqual(TPattern_toString(p), &quot;Data ctor args&quot;).x

	&apos; pattern to match a particular data ctor (as opposed to a value *of* that ctor)
	Dim cDataCtor : cDataCtor = Tp.DataCtor
	Dim cNil      : cNil = Tp.List_Nil
	p = Pattern_Data(cDataCtor, List( _
		Pattern_Const(nameOf(cNil)), _
		Pattern_Var(&quot;argTypes&quot;), _
		Pattern_Var(&quot;typeCtor&quot;) _
	))
	assertEqual(TPattern_toString(p), &quot;DataCtor &apos;Nil&apos; argTypes typeCtor&quot;).x

	&apos; pattern that matches a pattern that matches the empty list
	p = Pattern_Data(cData, List(p, Pattern_Any))
	assertEqual(TPattern_toString(p), _
		&quot;Data (DataCtor &apos;Nil&apos; argTypes typeCtor) _&quot;).x
	
End Function

Function assert_matches(p As Object, env As Variant, ByVal vs As Variant)
	assert_matches = _match_assertions(p, env, vs, envEmpty) &apos; TODO: expect particular env
End Function

Function refute_matches(p As Object, env As Variant, ByVal vs As Variant)
	refute_matches = _match_assertions(p, env, vs, Empty)
End Function

Function _match_assertions(p As Object, env As Variant, ByVal vs As Variant, expected As Variant)
	If Not(isPattern(p)) Then
		croak(IIf(isEmpty(expected), &quot;refute&quot;, &quot;assert&quot;) &amp; &quot;_matches: invalid pattern &quot; &amp; toString(p))
	End If
	Dim testResult As Object
	Dim val As Variant, i As Integer, gotArray As Boolean
	gotArray = isArray(vs)
	If Not(gotArray) Then
		vs = Array(vs)
	End If
	For i = LBound(vs) To UBound(vs)
		testResult = _single_match_assertion(p, env, vs(i), expected, gotArray, i)
		If testResult.isFail Then
			Goto _match_assertions_end
		End If
	Next i
_match_assertions_end:
	_match_assertions = testResult
End Function

Function _single_match_assertion( _
	p As Object, _
	env As Variant, _
	val As Variant, _
	expected As Variant, _
	gotArray As Boolean, _
	i As Integer _
)
	Dim matchResult As Variant, testResult As Object
	matchResult = match(p, env, val)
	If isEmpty(matchResult) = isEmpty(expected) Then &apos; don&apos;t use assertEqual in order to avoid stupid MsgBox
		testResult = assertEqual(True, True) &apos; inc assertionCount
	Else
		Dim msg As String, valStr As String, pStr As String, eStr As String, mStr As String
		valStr = toString(val)
		pStr = toString(p)
		If isEmpty(env) Then : eStr = &quot;Empty (None)&quot;
		Else : eStr = Env_toString(env) : End If
		If isEmpty(matchResult) Then : mStr = &quot;Empty (None)&quot;
		Else : mStr = Env_toString(matchResult) : End If
		msg = &quot;pattern&quot; _
			&amp; NL &amp; &quot;  &quot; &amp; pStr _
			&amp; NL &amp; &quot;under env&quot; _
			&amp; NL &amp; &quot;  &quot; &amp; eStr _
			&amp; NL &amp; NL &amp; &quot;expected &quot; &amp; IIf(isEmpty(expected), &quot;NOT &quot;, &quot;&quot;) &amp; &quot;to match:&quot; _
			&amp; NL &amp; &quot;  &quot; &amp; valStr _
			&amp; NL &amp; NL &amp; &quot;but returned env&quot; _
			&amp; NL &amp; mStr
		If gotArray Then
			msg = &quot;at index &quot; &amp; i &amp; &quot;: &quot; _
				&amp; NL &amp; msg
		End If
		testResult = mkFail(matchResult, expected, msg)
	End If
	_single_match_assertion = testResult
End Function

Function test_Pattern_match()
	Dim f
	f = match
	assertEqual(arity(f), 3).x
	assertThrows(f, Array(Empty, Empty, Empty)).x
	
	f = match(Pattern_Any)
	assertEqual(arity(f), 2).x
	apply(f, Empty, Empty) &apos; should not throw
	apply(f, envEmpty, Empty) &apos; should not throw
	assertThrows(f, Array(Nothing, Empty)).x
	assertThrows(f, Array(&quot;foo&quot;, Empty)).x
End Function

Function test_Pattern_matches_Any()
	Dim p As Object, f As Object, e As Variant
	f = match
	assertEqual(arity(f), 3).x

	p = Pattern_Any

	&apos; under env = Empty (None) it does not match anything:
	e = Empty
	refute_matches(p, e, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
	)).x
	refute_matches(p, e, Array( _
		nil, List(nil), List(1, 2, 3) _
	)).x
		
	e = envEmpty
	assert_matches(p, e, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
End Function

Function test_Pattern_matches_Const()
	Dim p As Object, f As Object, e As Variant
	p = Pattern_Const(Empty)

	&apos; under env = Empty (None) it does not match anything:
	e = Empty
	refute_matches(p, e, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	e = envEmpty
	assert_matches(p, e, Empty).x
	f = match(p, e)
	assert_toString_equals(apply(f, Empty), envEmpty).x
	refute_matches(p, e, Array( _
		       Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
		
	p = Pattern_Const(Nothing)
	&apos; under env = Empty (None) it does not match anything:
	e = Empty
	refute_matches(p, Empty, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	e = envEmpty
	assert_matches(p, e, Nothing).x
	
	&apos; TODO: decide what match should do if it wouldn&apos;t type-check
	&apos;refute_matches(p, e, Empty			).x
	&apos;refute_matches(p, e, nil			).x
	&apos;refute_matches(p, e, List(nil)		).x
	&apos;refute_matches(p, e, List(1, 2, 3)	).x
	&apos;refute_matches(p, e, Array( _
	&apos;	Empty, _
	&apos;	nil, List(nil), List(1, 2, 3) _
	&apos;)).x
	
	f = match(p, e)
	assertThrows(f, Array(      True)).x
	assertThrows(f, Array(     False)).x
	assertThrows(f, Array(         0)).x
	assertThrows(f, Array(         1)).x
	assertThrows(f, Array(         2)).x
	assertThrows(f, Array(      4711)).x
	assertThrows(f, Array(CLng(4711))).x
	assertThrows(f, Array(    3.1415)).x

	
	p = Pattern_Const(&quot;&quot;)
	&apos; under env = Empty (None) it does not match anything:
	e = Empty
	refute_matches(p, e, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	e = envEmpty
	assert_matches(p, e, &quot;&quot;).x
	refute_matches(p, e, Array( Empty, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot; )).x
	f = match(p, e)
	assertThrows(f, Array(   Nothing)).x
	assertThrows(f, Array(      True)).x
	assertThrows(f, Array(     False)).x
	assertThrows(f, Array(         0)).x
	assertThrows(f, Array(         1)).x
	assertThrows(f, Array(         2)).x
	assertThrows(f, Array(      4711)).x
	assertThrows(f, Array(CLng(4711))).x
	assertThrows(f, Array(    3.1415)).x	

		
	p = Pattern_Const(CInt(0))
	&apos; under env = Empty (None) it does not match anything:
	e = Empty
	refute_matches(p, e, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	e = envEmpty
	assert_matches(p, e, 0).x
	refute_matches(p, e, Array( _
		Empty, _
		1, 2, 3, -1, -2, -3, 4711 _
	)
	f = match(p, e)
	assertThrows(f, Array(   Nothing)).x
	assertThrows(f, Array(      True)).x
	assertThrows(f, Array(     False)).x
	assertThrows(f, Array(  CByte(0))).x
	assertThrows(f, Array(   CLng(0))).x
	assertThrows(f, Array(   CSng(0))).x
	assertThrows(f, Array(   CDbl(0))).x
	assertThrows(f, Array(       &quot;0&quot;)).x
	assertThrows(f, Array(CLng(4711))).x
	assertThrows(f, Array(    3.1415)).x	

End Function	
	
Function test_Pattern_matches_Var()
	Dim p As TPattern, f As Object, e As Object
	f = matches
	e = envEmpty
	
	p = patVar(&quot;a&quot;)
	assert_matches(p, e, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	&apos; under env = Empty (None) it does not match anything:
	refute_matches(p, Empty, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	
	&apos; bind the var &quot;a&quot; to the value &quot;foo&quot;:
	e = matches(p, envEmpty, &quot;foo&quot;)
	&apos; under this env var-pattern &quot;a&quot; matches only &quot;foo&quot;:
	assert_matches(p, e, 		&quot;foo&quot;).x
	refute_matches(p, e, 		&quot;bar&quot;).x
	&apos; but under an env where &quot;a&quot; isn&apos;t bound it still matches anything
	e = extend(envEmpty, &quot;b&quot;, &quot;foo&quot;)
	assert_matches(p, e, &quot;foo&quot;).x
	assert_matches(p, e, &quot;bar&quot;).x
	f = matches(p, e)
	assertThrows(f, Array(   Nothing)).x
	assertThrows(f, Array(      True)).x
	assertThrows(f, Array(     False)).x
	assertThrows(f, Array(         0)).x
	assertThrows(f, Array(         1)).x
	assertThrows(f, Array(         2)).x
	assertThrows(f, Array(      4711)).x
	assertThrows(f, Array(CLng(4711))).x
	assertThrows(f, Array(    3.1415)).x	
End Function	
	
Function test_Pattern_matches_List()
	Dim p As TPattern, f As Object, e As Object
	f = matches
	e = envEmpty
	
	&apos; pattern of the empty list
	p = patList_nil
	assert_matches(p, e, nil).x
	refute_matches(p, e, List(nil)).x
	
	&apos; pattern of a non-empty list
	p = patList_cons(patVar(&quot;x&quot;), patVar(&quot;xs&quot;))
	refute_matches(p, e, nil).x
	assert_matches(p, e, List(nil)				).x
	assert_matches(p, e, List(nil, nil)			).x
	assert_matches(p, e, List(1)				).x
	assert_matches(p, e, List(1, 2, 3)			).x
	assert_matches(p, e, List(&quot;a&quot;)				).x
	assert_matches(p, e, List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)	).x
	
	&apos; pattern of a singleton list
	p = patList_cons(patVar(&quot;x&quot;), patList_nil)
	refute_matches(p, e, nil).x
	assert_matches(p, e, List(nil)				).x
	refute_matches(p, e, List(nil, nil)			).x
	assert_matches(p, e, List(1)				).x
	refute_matches(p, e, List(1, 2, 3)			).x
	assert_matches(p, e, List(&quot;a&quot;)				).x
	refute_matches(p, e, List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)	).x
	
	&apos; pattern of a list with head equal to tail (so head must be a list, too)
	p = patList_cons(patVar(&quot;x&quot;), patVar(&quot;x&quot;))
	refute_matches(p, e, nil).x
	assert_matches(p, e, List(nil)				).x
	refute_matches(p, e, List(nil, nil)			).x
	&apos;refute_matches(p, e, List(1)				).x	&apos; does not type-check (x:1 matched against a list)
	&apos;refute_matches(p, e, List(1, 2, 3)			).x &apos; -&quot;-
	&apos;assert_matches(p, e, List(&quot;a&quot;)				).x &apos; -&quot;-
	&apos;refute_matches(p, e, List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)	).x &apos; -&quot;-
	&apos;refute_matches(p, e, List(List(1), List(1))	).x &apos; does not type-check
	assert_matches(p, e, List(List(1), 1) ).x
	refute_matches(p, e, List(List(1), 2) ).x
	
	&apos; pattern of a list with first two elems equal
	p = patList_cons(patVar(&quot;x&quot;), patList_cons(patVar(&quot;x&quot;), patAny))
	refute_matches(p, e, nil).x
	refute_matches(p, e, List(nil)				).x
	assert_matches(p, e, List(nil, nil)			).x
	refute_matches(p, e, List(1)				).x
	assert_matches(p, e, List(1, 1)				).x
	refute_matches(p, e, List(1, 2)				).x
	assert_matches(p, e, List(1, 1, 3)			).x
	refute_matches(p, e, List(1, 2, 3)			).x
	assert_matches(p, e, List(1, 1, 2, 3)		).x
End Function
	
Function test_Pattern_matches_ASN()
	Dim p As Object, f As Object, e As Object, v As Object
	Dim act As Variant
	Dim x As Object, w As Object
	f = matches
	e = envEmpty

	v = mkDtTerminal(&quot;Foo&quot;)
	p = patASN(patAny, patAny, patList_nil)
	assert_matches(p, e, v).x
	p = patASN(patVal(Empty), patVar(&quot;val&quot;), patList_nil)
	assert_matches(p, e, v).x
	e = matches(p, e, v)
	assertEqual(lookup(&quot;val&quot;, e), &quot;Foo&quot;).x
	

	&apos;ASN &quot;Alt&quot;  () [x]        -&gt; x
	p = patASN(patVal(&quot;Alt&quot;), patVal(Empty), patList_cons(patVar(&quot;x&quot;), patList_nil))
	v = mkDtNonterminal(&quot;Con&quot;, List(mkDtNonterminal(&quot;Atom&quot;, List(mkASN(&quot;Terminal&quot;, &quot;foo&quot;, nil)))))
	e = envEmpty
	refute_matches(p, e, v).x
	v = mkDtNonterminal(&quot;Alt&quot;, List(v))
	assert_matches(p, e, v).x
	e = matches(p, e, v)
	assertEqual(isASN(lookup(&quot;x&quot;, e)), True).x
	assert_toString_equals(lookup(&quot;x&quot;, e), asnChild(v, 0)).x
	
	&apos;ASN lbl    () [ASN () val []] -&gt; ASN lbl v []
	&apos;inner one first:
	p = patASN(patVal(Empty), patVar(&quot;val&quot;), patList_nil)
	p = patASN(patVar(&quot;lbl&quot;), patVal(Empty), patList_cons(p, patList_nil))
	v = mkDtNonTerminal(&quot;Foo&quot;, List(mkDtTerminal(&quot;bar&quot;)))
	e = envEmpty
	assert_matches(p, e, v).x
	e = matches(p, e, v)
	assertEqual(lookup(&quot;lbl&quot;, e), &quot;Foo&quot;).x
	assertEqual(lookup(&quot;val&quot;, e), &quot;bar&quot;).x
	
	w = xpApp( _
			xpApp( _
				xpApp( _
					xpBuiltin(mkASN), _
					xpVar(&quot;lbl&quot;) _
				), _
				xpVar(&quot;val&quot;) _
			), xpVal(nil) _
		)
	w = evalX(w, e)
	&apos;show(v)
	&apos;show(w)
	assert_toString_equals(w, mkASN(&quot;Foo&quot;, &quot;bar&quot;, nil)).x
		
	&apos;ASN &quot;Con&quot;  () [x]        -&gt; x
	&apos;ASN &quot;Atom&quot; () [x]        -&gt; x
	
End Function	


</script:module>