<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M06_AST" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit

Const TASN_tyname = &quot;TASN&quot;
Type TASN &apos; &quot;Abstract Syntax Node&quot;
	tyname As String
	label As Variant
	value As Variant
	children As Object
End Type


Sub Main
	test_AST()
End Sub

Const dtAnonConLabel = &quot;(. . .)&quot;
Const dtAnonAltLabel = &quot;(..|..)&quot;
Const typ_Parser_ASN = &quot;Parser ASN&quot;
Const typ_Parser_List_ASN = &quot;Parser [ASN]&quot;

&apos; Function rather than Const so it can be accessed from spreadsheet
Function dtOpt_hideSkipped()   : dtOpt_hideSkipped   = 1 : End Function
Function dtOpt_doFoldlConcat() : dtOpt_doFoldlConcat = 2 : End Function
Function dtOpt_implicitMult()  : dtOpt_implicitMult  = 4 : End Function
Function dtOpt_promoteSingleTerminal()  : dtOpt_promoteSingleTerminal  = 8 : End Function


Function isASN(x As Variant) As Boolean
	isASN = (typeOf(x) = &quot;Object/&quot; &amp; TASN_tyname)
End Function

Function TASN_dot( _
	Optional fieldName As String, _
	Optional instance As Object _
)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.TASN_dot : End If
	Dim result As Variant
	If isMissing(fieldName) Then
		result = oFn
	Else
		&apos; TODO/dot-access: check if fieldName is valid, even before we get an instance
		If isMissing(instance) Then
			result = apply(oFn, fieldName)
		ElseIf isASN(instance) Then
			Select Case fieldName
				Case &quot;label&quot;:	 result = instance.label
				Case &quot;value&quot;:	 result = instance.value
				Case &quot;children&quot;: result = instance.children
				Case Else
					croak(&quot;TASN_dot: no such field: &quot; &amp; toString(fieldName))
			End Select
		Else
			croak(&quot;TASN_dot: .&quot; &amp; fieldName &amp; &quot; - not an ASN instance:&quot; _
				&amp; NL &amp; toString(instance))
		End If
	End If
	TASN_dot = result
	Exit Function
End Function

Function mkASN( _
	Optional label, _
	Optional value, _
	Optional children As Object _
)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.mkASN : End If
	Dim result As Variant
	If isMissing(label) Then
		result = oFn
	ElseIf isMissing(value) Then
		result = apply(oFn, label)
	ElseIf isMissing(children) Then
		result = apply(oFn, label, value)
	Else
		result = New TASN
		result.tyname = &quot;TASN&quot;
		result.label = label
		result.value = value
		If Not(typeOf(children) = typeOf(nil)) Then
			croak(&quot;mkASN: invalid list of children &quot; &amp; toString(children))
		End If
		result.children = children
	End If
	mkAsn = result
End Function


Function asnLabel(Optional n As Object)
	asnLabel = _apply(Fn.TASN_dot, &quot;label&quot;, n)
End Function

Function asnValue(Optional n As Object)
	asnValue = _apply(Fn.TASN_dot, &quot;value&quot;, n)
End Function

Function asnChildren(n As Object)
	asnChildren = _apply(Fn.TASN_dot, &quot;children&quot;, n)
End Function

Function asnIsLeaf(n As Object) As Boolean
	asnIsLeaf = isNil(asnChildren(n))
End Function

Function asnChildCount(n As Object) As Integer
	asnChildCount = length(asnChildren(n))
End Function

Function TASN_toString(Optional n As Object)
	Dim result As Variant
	If isMissing(n) Then
		result = Fn.TASN_toString
	Else
		result = _TASN_toString(n, &quot;&quot;, &quot;&quot;)
	End If
	TASN_toString = result
End Function

Function _TASN_toString( _
	n As Object, _
	ByVal prefixN As String, _
	ByVal prefixC As String _
) As String
	Dim result As String
	result = _TASN_toString_head(n)
	Dim k As Integer, i As Integer
	k = asnChildCount(n)
	If k &gt; 0 Then
		i = InStr(1, result, &quot;:&quot;)
		If i = 0 Then : i = 1 : End If
		prefixC = prefixC &amp; Space(i)
		Dim child As Variant
		k = k - 1
		For i = 0 To k
			child = asnChild(n, i)
			If (i = k) Then &apos; last child
				result = result _
					   &amp; chr(13) &amp; chr(10) _
					   &amp; _TASN_toString( _
					   		child, _
							prefixC &amp; &quot;└&quot; , _
							prefixC &amp; &quot; &quot; _
						 )
			Else
				result = result _
					   &amp; chr(13) &amp; chr(10) _
					   &amp; _TASN_toString( _
					   		child, _
							prefixC &amp; &quot;├&quot; , _
							prefixC &amp; &quot;│&quot; _
						 )
			End If
		Next i
	End If
	result = prefixN &amp; &quot;─&quot; &amp; result
	_TASN_toString = result
End Function

Function _TASN_toString_head(n As Object) As String
	Dim result As String, lbl As Variant, val As Variant
	lbl = asnLabel(n)
	val = asnValue(n)
	If isEmpty(val) Then
		val = &quot;&quot;
	ElseIf isString(val) Then
		If (val = &quot;&quot;) Then
			val = &quot;ε&quot;
		Else
			val = toString(val)
		End If
	Else
		val = toString(val)
	End If
	If isEmpty(lbl) Then
		If val = &quot;&quot; Then
			result = &quot;:&quot;
		Else
			result = val
		End If
	Else
		If Not(isString(lbl)) Then
			lbl = toString(lbl)
		End If
		If val = &quot;&quot; Then
			result = lbl
		Else
			result = lbl &amp; &quot;:&quot; &amp; val
		End If
	End If
	_TASN_toString_head = result
End Function


Function asnChild(n As Object, ByVal i As Integer)
	Dim result As Variant, cs As Object, len As Integer
	If (i &lt; 0) Then
		croak(&quot;asnChild: invalid child index &quot; &amp; i)
	End If
	cs = asnChildren(n)
	len = length(cs)
	If (i &gt;= len) Then
		If len = 0 Then
			croak(&quot;asnChild: invalid child index &quot; &amp; i &amp; &quot; - has none&quot;)
		Else
			croak(&quot;asnChild: invalid child index &quot; &amp; i &amp; &quot; - has only &quot; &amp; len)
		End If
	Else
		While i &gt; 0
			cs = cdr(cs)
			i = i - 1
		Wend
		result = car(cs)
	End If
	asnChild = result
End Function

Function mkDtTerminal(Optional value As String)
	If isMissing(value) Then
		mkDtTerminal = Fn.mkDtTerminal
	Else
		mkDtTerminal = mkASN(Empty, value, nil)
	End If
End Function

Function mkDtCClass(Optional cclass As String, Optional value As String)
	If isMissing(cclass) Then
		mkDtCClass = Fn.mkDtCClass
	ElseIf isMissing(value) Then
		mkDtCClass = apply(Fn.mkDtCClass, cclass)
	Else
		mkDtCClass = mkASN(cclass, value, nil)
	End If
End Function
	
Function mkDtNonterminal( _
	Optional ruleName As String, _
	Optional children As Object _
)
	Dim result As Variant
	If isMissing(ruleName) Then
		result = Fn.mkDtNonterminal
	ElseIf isMissing(children) Then
		result = apply(Fn.mkDtNonterminal, ruleName)
	ElseIf isNil(children) Then
		croak(&quot;mkDtNonterminal: &quot; _
			&amp; toString(ruleName) _
			&amp; &quot; nil not valid as list of children&quot;)
	Else
		result = mkASN(ruleName, Empty, children)
	End If
	mkDtNonterminal = result
End Function

&apos; Abstract Syntax Node representing an anonymous alternation
Function mkDtAnonAlt(Optional children As Object)
	Static oFn As Object : If isNull(oFn) Then : oFn = mkASN(dtAnonAltLabel, Empty) : End If
	Dim result As Variant
	If isMissing(children) Then
		result = oFn
	Else
		result = apply(oFn, children)
	End If
	mkDtAnonAlt = result
End Function

&apos; Abstract Syntax Node representing an anonymous concatenation
Function mkDtAnonCon(Optional children As Object)
	Static oFn As Object : If isNull(oFn) Then : oFn = mkASN(dtAnonConLabel, Empty) : End If
	Dim result As Variant
	If isMissing(children) Then
		result = oFn
	Else
		result = apply(oFn, children)
	End If
	mkDtAnonCon = result
End Function

Function mkDtMult( _
	Optional label As String, _
	Optional children As Object _
)
	Dim result As Variant
	If isMissing(label) Then
		result = Fn.mkDtMult
	ElseIf isMissing(children) Then
		result = apply(Fn.mkDtMult, label)
	Else
		&apos;If isNil(children) Then
		&apos;	result = mkASN(label, &quot;&quot;, nil)
		&apos;Else
			result = mkASN(label, Empty, children)
		&apos;End If
	End If
	mkDtMult = result
End Function

Function mkDtSkip(p As Object)
	Dim result As Variant
	result = mkASN(dtMultLabel(&quot;skip&quot;, p), Empty, nil)
	mkDtSkip = result
End Function

Function dtMultLabel(m As String, p As Object)
	Dim t As String
	Select Case p.tp
		Case &quot;item&quot;	:	t = &quot;.&quot; 
		Case &quot;str&quot;:		t = toString(p.st(0))
		Case &quot;choice&quot;:	t = dtAnonAltLabel
		Case &quot;seq&quot;:		t = dtAnonConLabel
		Case &quot;ind&quot;:		t = getPIndName(p)
		Case &quot;skip&quot;:	
			dtMultLabel = dtMultLabel(m &amp; &quot;°skip&quot;, p.st0)
			Exit Function
		Case &quot;sat&quot;
			If p.str &lt;&gt; &quot;&quot; Then
				t = &quot;(&quot; &amp; p.str &amp; &quot;)&quot;
			Else
				t = &quot;(&quot; &amp; TFn_toString(p.st0) &amp; &quot;)&quot;
			End If
		Case Else
			croak(&quot;dtMultLabel: cannot handle .tp=&quot; &amp; toString(p.tp))
	End Select
	dtMultLabel = &quot;(&quot; &amp; m &amp; &quot;):&quot; &amp; t
End Function


Function toDerivationP(p As Object, options As Integer)
	Dim result As Object
	Dim seen As Object, q As Object
	seen = nil
	result = _toDerivationP(p, seen, options)
	While Not(isNil(seen))
		q = car(seen)
		q.st2 = False	&apos; clear visited marker
		q.st3 = Empty	&apos; clear ptr to with what it was replaced
		seen = cdr(seen)
	Wend
	toDerivationP = result
End Function

Function _wrapSkipWithDummyASN(p As Object)
	Dim result As Object
	If isPSkip(p) Then &apos; it&apos;ll return Empty on success
		&apos; so when we still need an ASN, we wrap it with a dummy
		result = pBind(p, fstArg(pReturn(mkDtSkip(p.st0))))
		result.typ = typ_Parser_ASN
	Else
		result = p
	End If
	_wrapSkipWithDummyASN = result
End Function

Function _toDerivationP( _
	ByVal p As Object, _
	ByRef seen As Object, _
	ByVal options As Integer _
)
	Dim result As Variant
	Dim f As Object, s As String, fName As String
	Dim q As Object, r As Object
	Dim qs As Object, rs As Object
	If isPMany(p) Then &apos; p is of shape (many1 q)?
		q = p.st0.st0
		s = dtMultLabel(&quot;*&quot;, q)
		f = mkDtMult(s)
		q = _toDerivationP(q, seen, options)
		If q.typ = typ_Parser_List_ASN Then
			q = pBind(q, compose(pReturn, mkDtAnonCon))
		End If
		result = pMany(q)
		If (options And dtOpt_implicitMult) &lt;&gt; 0 Then
			result.typ = typ_Parser_List_ASN
		Else
			result = pBind(result, compose(pReturn, f))
			result.typ = typ_Parser_ASN
		End If
	ElseIf isPZeroOrOne(p) Then
		q = p.st0
		q = _toDerivationP(q, seen, options)
		q = _wrapSkipWithDummyASN(q)
		If q.typ = typ_Parser_ASN Then
			q = pBind(q, compose(pReturn, swap(cons, nil)))
		ElseIf q.typ = typ_Parser_List_ASN Then
			q = pBind(q, compose(pReturn, _
				compose( _
					swap(cons, nil), _
					mkDtAnonCon _
				) _
			))
		Else
			croak(&quot;toDerivationP/zeroOrOne: q.typ = &quot; _
				&amp; toString(q.typ) _
				&amp; chr(13) &amp; chr(10) &amp; toString(q) _
			)
		End If
		result = pZeroOrOne2(nil, q)
		If (options And dtOpt_implicitMult) &lt;&gt; 0 Then
			result.typ = typ_Parser_List_ASN
		Else
			s = dtMultLabel(&quot;?&quot;, p.st0)
			f = mkDtMult(s)
			result = pBind(result, compose(pReturn, f))
			result.typ = typ_Parser_ASN
		End If
	Else
		Select Case p.tp
			Case &quot;many1&quot;
				q = p.st0
				s = dtMultLabel(&quot;+&quot;, q)
				f = mkDtMult(s)
				q = _toDerivationP(q, seen, options)
				If q.typ = typ_Parser_List_ASN Then
					q = pBind(q, compose(pReturn, mkDtAnonCon))
				End If
				result = pMany1(q)
				If (options And dtOpt_implicitMult) &lt;&gt; 0 Then
					result.typ = typ_Parser_List_ASN
				Else
					result = pBind(result, compose(pReturn, f))
					result.typ = typ_Parser_ASN
				End If
			Case &quot;skip&quot;
				If (options And dtOpt_hideSkipped) Then
					result = p &apos; so when applying p it&apos;ll return Empty
				Else
					q = _toDerivationP(p.st0, seen, options)
					f = mkDtNonterminal(&quot;(skip)&quot;)
					If q.typ = typ_Parser_ASN Then
						f = compose(f, swap(cons, nil))
					End If
					&apos;q = pBind(q, compose(pReturn, f))
					&apos;q.typ = typ_Parser_ASN
					result = q
				End If
			Case &quot;item&quot;
				f = mkDtCClass(&quot;(.)&quot;)
				result = pBind(p, compose(pReturn, f))
				&apos;result = pSeq(Array(p),f)
				result.typ = typ_Parser_ASN
			Case &quot;str&quot;
				f = mkDtTerminal
				result = pBind(p, compose(pReturn, f))
				&apos;result = pSeq(Array(p), f)
				result.typ = typ_Parser_ASN
			Case &quot;sat&quot;
				If p.str &lt;&gt; &quot;&quot; Then
					f = mkDtCClass(&quot;(&quot; &amp; p.str &amp; &quot;)&quot;
				Else
					f = mkDtCClass(&quot;(.):&quot; &amp; TFn_toString(p.st0))
				End If
				result = pBind(p, compose(pReturn, f))
				&apos;result = pSeq(Array(p), f)
				result.typ = typ_Parser_ASN
			Case &quot;choice&quot;
				q = _toDerivationP(p.st0, seen, options)
				r = _toDerivationP(p.st1, seen, options)
				If q.typ &lt;&gt; r.typ Then
					If q.typ = typ_Parser_ASN Then
						q = pBind(q, compose(pReturn, swap(cons, nil)))
					Else
						r = pBind(rq, compose(pReturn, swap(cons, nil)))
					End If
				End If
				result = pChoice(q, r)
				result.typ = q.typ
			Case &quot;seq&quot; &apos; only simple sequences supported here
				&apos;result = Empty
				qs = toList(p.st(0))
				rs = nil
				f = p.st(1)
				fName = getFnName(f)
				If (fName = getFnName(Fn.id)) Then
					While Not(isNil(qs))
						q = car(qs)
						q = _toDerivationP(q, seen, options)
						If q.typ = typ_Parser_List_ASN Then
							q = pBind(q, compose(pReturn, _
								mkDtAnonCon))
						End If
						rs = cons(q, rs)
						qs = cdr(qs)
					Wend
					result = pSeqL( _
						toArray(reverse(rs)), _
						id _
					)
					result.typ = typ_Parser_List_ASN
				ElseIf fName = getFnName(Fn.applyToList) Then
					f = car(partialArgs(f))
					fName = getFnName(f)
					If fName = getFnName(Fn.id) Then
						If (options And dtOpt_hideSkipped) Then
							Dim tmpTyp As Variant
							While Not(isNil(qs))
								q = car(qs)
								q = _toDerivationP(q, seen, options)
								If Not(isPSkip(q)) Then
									tmpTyp = q.typ
								End If
								rs = cons(q, rs)
								qs = cdr(qs)
							Wend
							result = pSeq( _
								toArray(reverse(rs)), _
								id _
							)
							result.typ = tmpTyp
						Else
							result = _toDerivationP( _
								pSeqL(p.st(0), id), _
								seen, _
								options _
							)
						End If
					ElseIf fName = getFnName(Fn.cons) Then
						&apos; For this to take effect in the derivation tree
						&apos; we must end up with an ASN and a [ASN], and
						&apos; nothing else as arguments for cons.
						&apos; So, if there are skips amongst the inner parsers
						&apos; they must be hidden (dtOpt_hideSkipped).
						&apos; Similarly, if there are multiplicity ops then these
						&apos; must not be made explicit (dtOpt_implicitMult).
						&apos; However, we do not test those options here.
						&apos; Rather we look at the .typ s of the transformed
						&apos; inner parsers.
						Dim typs As Object
						typs = nil
						While Not(isNil(qs))
							q = car(qs)
							q = _toDerivationP(q, seen, options)
							If Not(isPSkip(q)) Then
								typs = cons(q.typ, typs)
							End If
							rs = cons(q, rs)
							qs = cdr(qs)
						Wend
						&apos; ATTENTION: typs is backwards
						If equ(typs, List( _
								typ_Parser_List_ASN, _
								typ_Parser_ASN _
							)) _
						Then
							result = pSeq(toArray(reverse(rs)), cons)
							result.typ = typ_Parser_List_ASN
						Else
							&apos; What we could do is make a big list with
							&apos; the 2nd arg for cons &quot;flattened&quot; in
							&apos;msgbox(&quot;pSeq(..., cons): &quot; &amp; toString(typs) _
							&apos;&amp; chr(13) &amp; chr(10) &amp; toString(p))
							result = _toDerivationP( _
								pSeqL(p.st(0), id), _
								seen, options)
						End If
					ElseIf fName = getFnName(Fn.foldl) Then
						f = car(partialArgs(f))
						fName = getFnName(f)
						If fName = getFnName(Fn.concat) Then
							If (options And dtOpt_doFoldlConcat) Then
								&apos; let it do its thing and package up
								&apos; the result under a Terminal ASN
								result = pBind(p, compose(pReturn, _
									mkDtTerminal))
								result.typ = typ_Parser_ASN
							Else
								&apos; ignore the foldl concat and show
								&apos; results as a list:
								result = _toDerivationP( _
									pSeq(p.st(0), cons), seen, options)
							End If
						End If
					ElseIf fName = getFnName(Fn.concat) Then
						If (options And dtOpt_doFoldlConcat) Then
							&apos; let it do its thing and package up
							&apos; the result under a Terminal ASN
							result = pBind(p, compose(pReturn, _
								mkDtTerminal))
							result.typ = typ_Parser_ASN
						Else
							&apos; ignore the concat and show
							&apos; results as a list:
							result = _toDerivationP( _
								pSeqL(p.st(0), id), seen, options)
						End If
					End If		
				End If
				If isEmpty(result) Then
					croak(&quot;toDerivationP/NYI: pSeq(..., &quot; _
						 &amp; TFn_toString(p.st(1)) &amp; &quot;)&quot; _
						 &amp; chr(13) &amp; chr(10) _
						 &amp; toString(p)_
					)
				End If
			Case &quot;ind&quot;
				If p.st2 Then &apos; seen before
					If isEmpty(p.st3) Then
						croak(&quot;toDerivationP: replace &quot; &amp; p.st1 &amp; &quot;???&quot;)
					End If
					result = p.st3
				ElseIf isNull(p.st0) Then
					croak(&quot;toDerivationP/NYI: uninitialized indirection &quot; &amp; p.st1)
				Else
					p.st2 = True &apos; set the &quot;visited&quot;-mark
					seen = cons(p, seen)
					s = getPIndName(p)
					p.st3 = pInd(s)
					q = _toDerivationP(p.st0, seen, options)
					q = _wrapSkipWithDummyASN(q)
					
					If (options And dtOpt_promoteSingleTerminal) _
						And (q.typ = typ_Parser_ASN) _
					Then &apos; TODO: do the work at transformation time rather than parse time
						f = swap(mkASN(s), nil)
						f = ite(compose(Fn.isEmpty, asnLabel), _
								compose(f, asnValue), _
								compose(mkDtNonterminal(s), swap(cons, nil)) _
							)
						q = pBind(q, compose(pReturn, f))
						&apos;s = toString(p.st0) &amp; &quot; :: &quot; &amp; toString(p.st0.typ)
						&apos;msgbox(s &amp; NL &amp; toString(q))
					Else
						f = mkDtNonterminal(s)
						If q.typ = typ_Parser_ASN Then
							f = compose(f, swap(cons, nil))
						End If
						q = pBind(q, compose(pReturn, f))
					End If
					result = fixIndirection(p.st3, q)
					result.typ = typ_Parser_ASN
				End If
			Case Else
				croak(&quot;toDerivationP: cannot handle .tp=&quot; _
					&amp; toString(p.tp) _
					&amp; NL &amp; toString(p) _
				)
		End Select
	End If
	_toDerivationP = result
End Function

&apos;= tests ======================================================================

Function test_AST()
	test_AST_toDerivationP_skip(0)
	test_AST_toDerivationP_skip(dtOpt_hideSkipped)

	test_AST_mkASN()
	test_AST_TASN_toString()
	
	test_AST_toDerivationP_simple(0)
	test_AST_toDerivationP_simple(dtOpt_hideSkipped)

	test_AST_toDerivationP_mult(0)
	test_AST_toDerivationP_mult(dtOpt_hideSkipped)

	test_AST_toDerivationP_skip(0)
	test_AST_toDerivationP_skip(dtOpt_hideSkipped)
End Function 

Function test_AST_mkASN()
	Dim f As Object
	f = Fn.mkASN
	assertEqual(isFn(f), True).x
	assertEqual(arity(f), 3).x

	f = mkASN
	assertEqual(isFn(f), True).x
	assertEqual(arity(f), 3).x

	f = mkASN(&quot;foo&quot;)
	assertEqual(isFn(f), True).x
	assertEqual(arity(f), 2).x

	f = mkASN(&quot;foo&quot;, &quot;bar&quot;)
	assertEqual(isFn(f), True).x
	assertEqual(arity(f), 1).x
	
	Dim n0 As Object
	n0 = mkASN(&quot;foo&quot;, &quot;bar&quot;, nil)
	
	assertEqual(typeOf(n0), &quot;Object/TASN&quot;).x
	assertEqual(length(asnChildren(n0)), 0).x
	assertEqual(asnChildCount(n0), 0).x
	assertEqual(asnIsLeaf(n0), True).x
	assertEqual(toString(n0), &quot;─foo:&apos;bar&apos;&quot;).x

	Dim n1 As Object
	n1 = mkASN(Empty, &quot;bar&quot;, nil)
	assertEqual(asnChildCount(n1), 0).x
	assertEqual(asnIsLeaf(n1), True).x
	assertEqual(toString(n1), &quot;─&apos;bar&apos;&quot;).x

	Dim n2 As Object
	n2 = mkASN(&quot;foo&quot;, Empty, nil)
	assertEqual(asnChildCount(n2), 0).x
	assertEqual(asnIsLeaf(n2), True).x
	assertEqual(toString(n2), &quot;─foo&quot;).x

	Dim n3 As Object
	n3 = mkASN(Empty, Empty, nil)
	assertEqual(asnChildCount(n3), 0).x
	assertEqual(asnIsLeaf(n3), True).x
	assertEqual(toString(n3), &quot;─:&quot;).x

	Dim n4 As Object, c0 As Object
	n4 = mkASN(&quot;S&quot;, Empty, List(n1))
	assertEqual(asnChildCount(n4), 1).x
	assertEqual(asnIsLeaf(n4), False).x
	c0 = asnChild(n4, 0)
	assertEqual(asnLabel(c0), asnLabel(n1)).x
	assertEqual(asnValue(c0), asnValue(n1)).x
	assertEqual(asnChildCount(c0), asnChildCount(n1)).x
	
	&apos;assertEqual(toString(n4), &quot;:&quot;).x
	
	Dim s As String
	n0 = mkDtTerminal(&quot;A&quot;)
	n0 = mkDtNonterminal(&quot;I&quot;, List(n0))
	n0 = mkDtNonterminal(&quot;F&quot;, List(n0))
	n0 = mkDtNonterminal(&quot;T&quot;, List(n0))
	
	n1 = mkDtTerminal(&quot;+&quot;)
	
	n2 = mkDtTerminal(&quot;B&quot;)
	n2 = mkDtNonterminal(&quot;I&quot;, List(n2))
	n2 = mkDtNonterminal(&quot;F&quot;, List(n2))
	
	n3 = mkDtTerminal(&quot;*&quot;)
	
	n4 = mkDtTerminal(&quot;C&quot;)
	n4 = mkDtNonterminal(&quot;I&quot;, List(n4))
	n4 = mkDtNonterminal(&quot;F&quot;, List(n4))
	n4 = mkDtNonterminal(&quot;T&quot;, List(n4))
	
	n4 = mkDtNonterminal(&quot;T&quot;, List(n2, n3, n4))
	n4 = mkDtNonterminal(&quot;S&quot;, List(n4))

	n4 = mkDtNonterminal(&quot;S&quot;, List(n0, n1, n4))
	
	s = toString(n4)
	test_AST_mkASN = s
End Function

Function test_AST_TASN_toString()
	Dim n As Object
	n = mkASN(Empty, Empty, nil)
	assertEqual(TASN_toString(n), &quot;─:&quot;).x
	
	n = mkASN(Empty, &quot;x&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─&apos;x&apos;&quot;).x
	n =mkASN(Empty, &quot;&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─ε&quot;).x
	n = mkASN(Empty, &quot;foobar&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─&apos;foobar&apos;&quot;).x

	n = mkASN(&quot;S&quot;, Empty, nil)
	assertEqual(TASN_toString(n), &quot;─S&quot;).x
	n = mkASN(&quot;Foo&quot;, Empty, nil)
	assertEqual(TASN_toString(n), &quot;─Foo&quot;).x

	n = mkASN(&quot;*&quot;, &quot;&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─*:ε&quot;).x
	n = mkASN(&quot;+&quot;, &quot;&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─+:ε&quot;).x
	n = mkASN(&quot;?&quot;, &quot;&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─?:ε&quot;).x

	n = mkASN(&quot;*&quot;, &quot;W&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─*:&apos;W&apos;&quot;).x
	n = mkASN(&quot;+&quot;, &quot;W&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─+:&apos;W&apos;&quot;).x
	n = mkASN(&quot;?&quot;, &quot;W&quot;, nil)
	assertEqual(TASN_toString(n), &quot;─?:&apos;W&apos;&quot;).x
	
	n = mkASN(&quot;W*&quot;, Empty, nil)
	assertEqual(TASN_toString(n), &quot;─W*&quot;).x
	n = mkASN(&quot;W+&quot;, Empty, nil)
	assertEqual(TASN_toString(n), &quot;─W+&quot;).x
	n = mkASN(&quot;W?&quot;, Empty, nil)
	assertEqual(TASN_toString(n), &quot;─W?&quot;).x
End Function

Function test_AST_toDerivationP_simple(opts As Integer)
	Dim p As Object, q As Object, x As Object

	&apos; ------------------------
	&apos; pItem under toDerivationP

	p = pItem
	q = toDerivationP(p, opts)
	refute_parses(q, &quot;&quot;).x
	x = mkDtCClass(&quot;(.)&quot;, &quot;a&quot;)
	assert_parses(q, &quot;a&quot;, x, 2).x
	x = mkDtCClass(&quot;(.)&quot;, &quot;b&quot;)
	assert_parses(q, &quot;bca&quot;, x, 2).x
	x = mkDtCClass(&quot;(.)&quot;, &quot;c&quot;)
	assert_parses(q, &quot;cabc&quot;, x, 2).x
	x = mkDtCClass(&quot;(.)&quot;, &quot; &quot;)
	assert_parses(q, &quot; xyzabc&quot;, x, 2).x
	
	&apos; ------------------------
	&apos; pStr under toDerivationP

	p = pStr(&quot;z&quot;)
	q = toDerivationP(p, opts)
	refute_parses(q, Array(&quot;&quot;, &quot;cba&quot;, &quot;x&quot;, &quot;y&quot;)).x
	x = mkDtTerminal(&quot;z&quot;)
	assert_parses(q, &quot;z&quot;, x, 2).x
	&apos; really reads only as many chars as pStr does:
	assert_parses(q, &quot;zz&quot;, x, 2).x
	assert_parses(q, &quot;zy&quot;, x, 2).x

	p = pStr(&quot;abc&quot;)
	q = toDerivationP(p, opts)
	refute_parses(q, Array(&quot;&quot;, &quot;y&quot;, &quot;cba&quot;)).x
	x = mkDtTerminal(&quot;abc&quot;)
	assert_parses(q, &quot;abc&quot;, x, 4).x
	&apos; really reads only as many chars as pStr does:
	assert_parses(q, &quot;abcabc&quot;, x, 4).x
	assert_parses(q, &quot;abcxyz&quot;, x, 4).x
	
	&apos; ------------------------
	&apos; pSat under toDerivationP

	p = pSat(equ(&quot;z&quot;))
	p.str = &quot;[z]&quot;
	q = toDerivationP(p, opts)
	x = mkDtCClass(&quot;([z])&quot;, &quot;z&quot;)
	refute_parses(q, Array(&quot;&quot;, &quot;x&quot;, &quot;xy&quot;, &quot;xyz&quot;)).x
	assert_parses(q, &quot;z&quot;, x, 2).x
	assert_parses(q, &quot;zy&quot;, x, 2).x
	assert_parses(q, &quot;zyz&quot;, x, 2).x
	assert_parses(q, &quot;zzy&quot;, x, 2).x

	&apos; ---------------------------
	&apos; pChoice under toDerivationP

	p = pChoice(pStr(&quot;0&quot;), pStr(&quot;1&quot;))
	q = toDerivationP(p, opts)
	refute_parses(q, Array(&quot;&quot;, &quot;y&quot;, &quot;cba&quot;)).x
	x = mkDtTerminal(&quot;0&quot;)
	assert_parses(q, &quot;0&quot;, x, 2).x
	x = mkDtTerminal(&quot;1&quot;)
	assert_parses(q, &quot;1&quot;, x, 2).x

	&apos; -------------------------
	&apos; pSeqL under toDerivationP

	p = pSeqL(Array(pItem), id)
	q = toDerivationP(p, opts)
	refute_parses(q, &quot;&quot;).x
	x = List(mkDtCClass(&quot;(.)&quot;, &quot;x&quot;))
	assert_parses(q, &quot;x&quot;, x, 2).x
	assert_parses(q, &quot;x1&quot;, x, 2).x
	x = List(mkDtCClass(&quot;(.)&quot;, &quot;y&quot;))
	assert_parses(q, &quot;y1abc&quot;, x, 2).x

	p = pSeqL(Array(pItem, pStr(&quot;1&quot;)), id)
	q = toDerivationP(p, opts)
	refute_parses(q, &quot;&quot;, &quot;x0&quot;, &quot; a&quot;).x
	x = List(mkDtCClass(&quot;(.)&quot;, &quot;x&quot;), mkDtTerminal(&quot;1&quot;))
	assert_parses(q, &quot;x1&quot;, x, 3).x
	x = List(mkDtCClass(&quot;(.)&quot;, &quot;y&quot;), mkDtTerminal(&quot;1&quot;))
	assert_parses(q, &quot;y1abc&quot;, x, 3).x

	p = pSeqL(Array(pStr(&quot;0&quot;), pItem, pStr(&quot;1&quot;)), id)
	q = toDerivationP(p, opts)
	refute_parses(q, &quot;&quot;, &quot;0&quot;, &quot;0a&quot;, &quot;xa1&quot;).x
	x = List(mkDtTerminal(&quot;0&quot;), mkDtCClass(&quot;(.)&quot;, &quot;a&quot;), mkDtTerminal(&quot;1&quot;))
	assert_parses(q, &quot;0a1&quot;, x, 4).x
	x = List(mkDtTerminal(&quot;0&quot;), mkDtCClass(&quot;(.)&quot;, &quot;b&quot;), mkDtTerminal(&quot;1&quot;))
	assert_parses(q, &quot;0b1xyz&quot;, x, 4).x
	
	&apos; ------------------------
	&apos; pInd under toDerivationP

	p = pInd(&quot;Foo&quot;)
	p = fixIndirection(p, pItem)
	q = toDerivationP(p, opts)
	refute_parses(q, &quot;&quot;).x
	x = mkDtNonterminal(getPIndName(p), List(mkDtCClass(&quot;(.)&quot;, &quot;a&quot;)))
	assert_parses(q, &quot;a&quot;, x, 2).x
	x = mkDtNonterminal(getPIndName(p), List(mkDtCClass(&quot;(.)&quot;, &quot;b&quot;)))
	assert_parses(q, &quot;b&quot;, x, 2).x
	assert_parses(q, &quot;bb&quot;, x, 2).x
	assert_parses(q, &quot;bc&quot;, x, 2).x
		
	p = pInd(&quot;Bar&quot;)
	p = fixIndirection(p, pSeqL(Array(pItem, pStr(&quot;1&quot;)), id)
	q = toDerivationP(p, opts)
	&apos;msgbox(toString(p) &amp; chr(13) &amp; chr(13) &amp; toString(q))
	refute_parses(q, &quot;&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;a0&quot;, &quot;b&quot;, &quot;b1&quot;).x
	x = mkDtNonterminal(getPIndName(p), List( _
			mkDtCClass(&quot;(.)&quot;, &quot;a&quot;), mkDtTerminal(&quot;1&quot;) _
		))
	&apos;msgbox(toString(x))
	assert_parses(q, &quot;a1&quot;, x, 3).x
	assert_parses(q, &quot;a1b&quot;, x, 3).x
End Function

Function test_AST_toDerivationP_mult(opts As Integer)
	Dim p As Object, q As Object, r As Variant, x As Object

	Dim termEps As Object, termY As Object, termZ As Object, termZY As Object
	termEps = mkDtTerminal(&quot;&quot;)
	termY   = mkDtTerminal(&quot;y&quot;)
	termZ   = mkDtTerminal(&quot;z&quot;)
	termZY	= mkDtTerminal(&quot;zy&quot;)

	&apos; ------------------------------
	&apos; pZeroOrOne under toDerivationP

	&apos; -- pZeroOrOne(pItem)
	
	p = pItem
	q = toDerivationP(pZeroOrOne(p), opts)
	x = mkDtMult(dtMultLabel(&quot;?&quot;, p), nil)
	assert_parses(q, &quot;&quot;, x, 1).x
	x = mkDtMult(dtMultLabel(&quot;?&quot;, p), List(mkDtCClass(&quot;(.)&quot;, &quot;z&quot;)))
	assert_parses(q, &quot;z&quot;, x, 2).x
	assert_parses(q, &quot;zy&quot;, x, 2).x	&apos; reads at most one

	&apos; -- pZeroOrOne(pStr)
	
	p = pStr(&quot;z&quot;)
	q = toDerivationP(pZeroOrOne(p), opts)
	x = mkDtMult(dtMultLabel(&quot;?&quot;, p), nil)
	assert_parses(q, &quot;&quot;, x, 1).x
	assert_parses(q, &quot;y&quot;, x, 1).x
	assert_parses(q, &quot;yz&quot;, x, 1).x
	x = mkDtMult(dtMultLabel(&quot;?&quot;, p), List(termZ))
	assert_parses(q, &quot;z&quot;, x, 2).x
	assert_parses(q, &quot;zz&quot;, x, 2).x	&apos; reads at most one
	assert_parses(q, &quot;zy&quot;, x, 2).x


	&apos; -- pZeroOrOne(pSeqL(..., id))
	
	p = pSeqL(Array(pStr(&quot;z&quot;), pStr(&quot;y&quot;)), id)
	q = toDerivationP(pZeroOrOne(p), opts)
	x = mkDtMult(dtMultLabel(&quot;?&quot;, p), nil)
	assert_parses(q, &quot;&quot;, x, 1).x
	assert_parses(q, &quot;abc&quot;, x, 1).x
	x = mkDtMult(dtMultLabel(&quot;?&quot;, p), List( _
		mkDtAnonCon(List(termZ, termY)) _
	))
	assert_parses(q, &quot;zy&quot;, x, 3).x
	assert_parses(q, &quot;zyz&quot;, x, 3).x
	assert_parses(q, &quot;zyzz&quot;, x, 3).x
	assert_parses(q, &quot;zyzy&quot;, x, 3).x	&apos; reads at most one
	assert_parses(q, &quot;zyzyz&quot;, x, 3).x
	assert_parses(q, &quot;zyzyzz&quot;, x, 3).x
		

	&apos; -------------------------
	&apos; pMany under toDerivationP

	&apos; -- pMany(pStr(...))

	p = pStr(&quot;z&quot;)
	q = toDerivationP(pMany(p), opts)
	x = mkDtMult(dtMultLabel(&quot;*&quot;, p), nil)
	assert_parses(q, &quot;&quot;, x, 1).x
	assert_parses(q, &quot;x&quot;, x, 1).x
	assert_parses(q, &quot;xy&quot;, x, 1).x
	assert_parses(q, &quot;xyz&quot;, x, 1).x

	x = mkDtMult(dtMultLabel(&quot;*&quot;, p), List(termZ))
	assert_parses(q, &quot;z&quot;, x, 2).x
	assert_parses(q, &quot;zx&quot;, x, 2).x

	x = mkDtMult(dtMultLabel(&quot;*&quot;, p), List(termZ, termZ))
	assert_parses(q, &quot;zz&quot;, x, 3).x
	assert_parses(q, &quot;zza&quot;, x, 3).x

	p = pStr(&quot;zy&quot;)
	q = toDerivationP(pMany(p), opts)
	x = mkDtMult(dtMultLabel(&quot;*&quot;, p), nil)
	assert_parses(q, &quot;&quot;, x, 1).x
	assert_parses(q, &quot;x&quot;, x, 1).x
	assert_parses(q, &quot;xy&quot;, x, 1).x
	assert_parses(q, &quot;z&quot;, x, 1).x
	assert_parses(q, &quot;xzy&quot;, x, 1).x
	
	x = mkDtMult(dtMultLabel(&quot;*&quot;, p), List(termZY))
	assert_parses(q, &quot;zy&quot;, x, 3).x
	assert_parses(q, &quot;zyX&quot;, x, 3).x
	assert_parses(q, &quot;zyXzy&quot;, x, 3).x
	
	x = mkDtMult(dtMultLabel(&quot;*&quot;, p), List(termZY, termZY))
	assert_parses(q, &quot;zyzy&quot;, x, 5).x
	assert_parses(q, &quot;zyzyX&quot;, x, 5).x
	
	x = mkDtMult(dtMultLabel(&quot;*&quot;, p), List(termZY, termZY, termZY))
	assert_parses(q, &quot;zyzyzy&quot;, x, 7).x
	assert_parses(q, &quot;zyzyzyX&quot;, x, 7).x

	&apos; -- pMany(pSeqL(..., id))
	
	p = pSeqL(Array(pStr(&quot;z&quot;), pStr(&quot;y&quot;)), id)
	q = toDerivationP(pMany(p), opts)
	x = mkDtMult(dtMultLabel(&quot;*&quot;, p), nil)
	assert_parses(q, &quot;&quot;, x, 1).x
	assert_parses(q, &quot;abc&quot;, x, 1).x
	x = mkDtMult(dtMultLabel(&quot;*&quot;, p), List( _
		mkDtAnonCon(List(termZ, termY)) _
	))
	assert_parses(q, &quot;zy&quot;, x, 3).x
	assert_parses(q, &quot;zyz&quot;, x, 3).x
	assert_parses(q, &quot;zyzz&quot;, x, 3).x
	x = mkDtMult(dtMultLabel(&quot;*&quot;, p), List( _
		mkDtAnonCon(List(termZ, termY)), _
		mkDtAnonCon(List(termZ, termY)) _
	))
	assert_parses(q, &quot;zyzy&quot;, x, 5).x
	assert_parses(q, &quot;zyzyz&quot;, x, 5).x
	assert_parses(q, &quot;zyzyzz&quot;, x, 5).x
			

	&apos; --------------------------
	&apos; pMany1 under toDerivationP

	&apos; -------------------------
	&apos; pMany1(pSat) under toDerivationP

	p = pSat(compose(inRange(Asc(&quot;y&quot;), Asc(&quot;z&quot;)), Fn.Asc))
	p.str = &quot;[y-z]&quot;
	q = toDerivationP(pMany1(p), opts)
	x = mkDtMult(dtMultLabel(&quot;+&quot;, p), List( _
		mkDtCClass(&quot;([y-z])&quot;, &quot;z&quot;) _
	))
	refute_parses(q, Array(&quot;&quot;, &quot;x&quot;, &quot;xy&quot;, &quot;xyz&quot;)).x
	assert_parses(q, &quot;z&quot;, x, 2).x
	assert_parses(q, &quot;zx&quot;, x, 2).x
	assert_parses(q, &quot;zxz&quot;, x, 2).x
	x = mkDtMult(dtMultLabel(&quot;+&quot;, p), List( _
		mkDtCClass(&quot;([y-z])&quot;, &quot;y&quot;), _
		mkDtCClass(&quot;([y-z])&quot;, &quot;z&quot;) _
	))
	assert_parses(q, &quot;yz&quot;, x, 3).x
	assert_parses(q, &quot;yzx&quot;, x, 3).x
	assert_parses(q, &quot;yzxz&quot;, x, 3).x
	
	
	&apos; -- pMany1(pSeqL(..., id))
	
	p = pSeqL(Array(pStr(&quot;z&quot;), pStr(&quot;y&quot;)), id)
	q = toDerivationP(pMany1(p), opts)
	refute_parses(q, &quot;&quot;, x, 1).x
	refute_parses(q, &quot;abc&quot;, x, 1).x
	x = mkDtMult(dtMultLabel(&quot;+&quot;, p), List( _
		mkDtAnonCon(List(termZ, termY)) _
	))
	assert_parses(q, &quot;zy&quot;, x, 3).x
	assert_parses(q, &quot;zyz&quot;, x, 3).x
	assert_parses(q, &quot;zyzz&quot;, x, 3).x
	x = mkDtMult(dtMultLabel(&quot;+&quot;, p), List( _
		mkDtAnonCon(List(termZ, termY)), _
		mkDtAnonCon(List(termZ, termY)) _
	))
	assert_parses(q, &quot;zyzy&quot;, x, 5).x
	assert_parses(q, &quot;zyzyz&quot;, x, 5).x
	assert_parses(q, &quot;zyzyzz&quot;, x, 5).x

	&apos; -- pMany1(pSeqL(pStr, id))
	
	p = pStr(&quot;z&quot;)
	p = pSeqL(Array(p), id)
	r = pMany1(p)
	q = toDerivationP(r, opts)
	refute_parses(r, &quot;&quot;).x
	refute_parses(q, &quot;&quot;).x
	x = mkDtMult(dtMultLabel(&quot;+&quot;, p), List( _
		mkDtAnonCon(List(termZ)) _
	))
	assert_parses(r, &quot;z&quot;,  List(List(&quot;z&quot;)), 2).x
	assert_parses(r, &quot;zy&quot;, List(List(&quot;z&quot;)), 2).x
	assert_parses(q, &quot;z&quot;,  x, 2).x
	assert_parses(q, &quot;zy&quot;, x, 2).x
	x = mkDtMult(dtMultLabel(&quot;+&quot;, p), List( _
		mkDtAnonCon(List(termZ)), _
		mkDtAnonCon(List(termZ)) _
	))
	assert_parses(r, &quot;zz&quot;,  List(List(&quot;z&quot;), List(&quot;z&quot;)), 3).x
	assert_parses(r, &quot;zzy&quot;, List(List(&quot;z&quot;), List(&quot;z&quot;)), 3).x
	assert_parses(q, &quot;zz&quot;,  x, 3).x
	assert_parses(q, &quot;zzy&quot;, x, 3).x
	
End Function

Function test_AST_toDerivationP_skip(opts As Integer)
	Dim p As Object, q As Object, x As Variant
	Dim hideSkipped As Boolean
	hideSkipped = ((opts And dtOpt_hideSkipped) &lt;&gt; 0)
	
	Dim termEps As Object, termY As Object, termZ As Object, termZY As Object
	termEps = mkDtTerminal(&quot;&quot;)
	termY   = mkDtTerminal(&quot;y&quot;)
	termZ   = mkDtTerminal(&quot;z&quot;)
	termZY	= mkDtTerminal(&quot;zy&quot;)

	&apos; -- pSkip(pItem)
	
	p = pItem
	q = toDerivationP(pSkip(p), opts)
	refute_parses(q, &quot;&quot;).x
	If hideSkipped Then
		x = Empty
	Else
		x = mkDtCClass(&quot;(.)&quot;, &quot;y&quot;)
	End If
	assert_parses(q, &quot;y&quot;, x, 2).x
	assert_parses(q, &quot;yz&quot;, x, 2).x

	&apos; -- pInd(pSkip(...))
	
	p = fixIndirection(pInd(&quot;P&quot;), pSkip(pItem))
	q = toDerivationP(p, opts)
	refute_parses(q, &quot;&quot;).x
	If hideSkipped Then
		x = mkDtNonterminal(&quot;P&quot;, List(mkDtSkip(pItem) ))
	Else
		x = mkDtNonterminal(&quot;P&quot;, List(mkDtCClass(&quot;(.)&quot;, &quot;y&quot;)
	End If
	&apos;TODO: handle empty pSeq/pSeqL (ie maybe all innerParsers are skip)
	assert_parses(q, &quot;y&quot;, x, 2).x
	assert_parses(q, &quot;yz&quot;, x, 2).x

	&apos; -- pZeroOrOne(pSkip(...))
	
	p = pSkip(pItem)
	q = toDerivationP(pZeroOrOne(p), opts)
	x = mkDtMult(dtMultLabel(&quot;?&quot;, p), nil)
	assert_parses(q, &quot;&quot;, x, 1).x
	If hideSkipped Then
		&apos; even with hideSkipped it&apos;ll show up because it&apos;s under pZeroOrOne
		x = mkDtMult(dtMultLabel(&quot;?&quot;, p), List(mkDtSkip(p.st0)))
	Else
		x = mkDtMult(dtMultLabel(&quot;?&quot;, p), List(mkDtCClass(&quot;(.)&quot;, &quot;y&quot;)))
	End If		
	assert_parses(q, &quot;y&quot;, x, 2).x
	assert_parses(q, &quot;yz&quot;, x, 2).x

	If Not(hideSkipped) Then
		x = mkDtMult(dtMultLabel(&quot;?&quot;, p), List(mkDtCClass(&quot;(.)&quot;, &quot;z&quot;)))
	End If		
	assert_parses(q, &quot;z&quot;, x, 2).x
	assert_parses(q, &quot;zz&quot;, x, 2).x	&apos; reads at most one
	assert_parses(q, &quot;zy&quot;, x, 2).x

	&apos; -- pSeq(pSkip, ..., id)
	
	p = pSeq(Array(pSkip(pStr(&quot; &quot;)), pStr(&quot;z&quot;)), id)
	refute_parses(p, Array(&quot;&quot;, &quot;z&quot;, &quot; &quot;, &quot;zz&quot;, &quot;  &quot;)).x
	assert_parses(p, &quot; z&quot;,  &quot;z&quot;, 3).x
	assert_parses(p, &quot; z &quot;, &quot;z&quot;, 3).x
	assert_parses(p, &quot; zz&quot;, &quot;z&quot;, 3).x
	q = toDerivationP(p, opts)
	If hideSkipped Then
		x = mkDtTerminal(&quot;z&quot;)
	Else
		x = List(mkDtTerminal(&quot; &quot;), mkDtTerminal(&quot;z&quot;))
	End If
	refute_parses(q, Array(&quot;&quot;, &quot;z&quot;, &quot; &quot;, &quot;zz&quot;, &quot;  &quot;)).x
	assert_parses(q, &quot; z&quot;,  x, 3).x
	assert_parses(q, &quot; z &quot;, x, 3).x
	assert_parses(q, &quot; zz&quot;, x, 3).x

End Function

</script:module>