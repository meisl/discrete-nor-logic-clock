<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M04_Fn" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit

Const TFn_tyname = &quot;TFn&quot;
Type TFn
	tyname		As String
	str			As Variant
	which		As Variant
	arity 		As Integer
	partialArgs As Variant
	args		As Variant
End Type

Type TFnObjs
	_instances	As Object
	
	typeOf		As Object
	ctorOf		As Object
	hasType		As Object
	destructure	As Object
	singletonVal	As Object
	
	isEmpty		As Object
	isString	As Object
	
	id 			As Object
	fstArg 		As Object
	sndArg 		As Object
	swap 		As Object
	compose 	As Object
	ite			As Object
	asc			As Object
	chr			As Object
	ucase		As Object
	lcase		As Object
	add			As Object
	mul			As Object
	toString	As Object
	concat		As Object
	readHex		As Object
	equ			As Object
	neq			As Object
	inRange		As Object
	
	TFn_toString	As Object
	applyToList		As Object
	
	TList_toString	As Object
	TList_equ		As Object
	isList			As Object
	isNil			As Object
	cons			As Object
	length			As Object
	car				As Object
	cdr				As Object
	cadr			As Object
	caddr			As Object
	map				As Object
	filter			As Object
	skipWhile		As Object
	skipUntil		As Object
	foldl			As Object
	foldr			As Object
	foldl1			As Object
	foldr1			As Object
	adjoin			As Object
	flatten 		As Object
	reverse 		As Object
	
	TParser_toString	As Object
	mkParser 			As Object
	pReturn				As Object
	pStr				As Object
	pBind				As Object
	pChoice				As Object
	pMany				As Object
	pMany1				As Object
	pZeroOrOne			As Object
	pZeroOrOne2			As Object
	mkTypeVar			As Object
	maybeMakeArrowType	As Object
	mkTypeCtor			As Object
	mkTupleType			As Object
	
	TASN_dot			As Object
	TASN_toString		As Object
	mkASN				As Object
	mkDtTerminal		As Object
	mkDtCClass			As Object
	mkDtNonterminal		As Object
	mkDtMult			As Object
	
	isPattern			As Object
	TPattern_toString	As Object
	matches				As Object
	
	isExpr				As Object
End Type


Sub Main
	[test_Fn ===============]()
End Sub


Function _newFn(name As String, arity As Integer, Optional typ)
	Dim out As New TFn
	out.tyname = TFn_tyname
	out.which = name
	out.arity = arity
	If Not(isMissing(typ)) Then
		out.str = name &amp; &quot; :: &quot; &amp; typ
	Else
		out.str = name
	End If
	_newFn = out
End Function

Function mkFn(ByRef fs As Object, name As String, arity As Integer, Optional typ)
	Dim out
	out = _newFn(name, arity, typ)
	fs = cons(out, fs)
	mkFn = out
End Function

Function Fn
	Static out As Object
	If isNull(out) Then
		Dim fs As Object : fs = nil
		out = New TFnObjs
				
		out.typeOf		= mkFn(fs, &quot;typeOf&quot;,		1, &quot;Any -&gt; Type&quot;)
		out.ctorOf		= mkFn(fs, &quot;ctorOf&quot;,		1, &quot;Any -&gt; Maybe TDataCtor&quot;)
		out.hasType		= mkFn(fs, &quot;hasType&quot;,		2, &quot;Any -&gt; Typ -&gt; Bool&quot;)
		out.destructure	= mkFn(fs, &quot;destructure&quot;,	3, &quot;TDataCtor -&gt; Int -&gt; Any -&gt; Any&quot;)
		out.singletonVal = mkFn(fs, &quot;singletonVal&quot;,	1, &quot;TDataCtor -&gt; Any&quot;)
		
		out.isEmpty		= mkFn(fs, &quot;isEmpty&quot;,		1, &quot;Any -&gt; Bool&quot;)
		out.isString	= mkFn(fs, &quot;isString&quot;,		1, &quot;Any -&gt; Bool&quot;)
		out.isExpr		= mkFn(fs, &quot;isExpr&quot;,		1, &quot;Any -&gt; Bool&quot;)	
		
		out.toString	= mkFn(fs, &quot;toString&quot;,		1, &quot;Any -&gt; Str&quot;)
		out.id			= mkFn(fs, &quot;id&quot;,			1, &quot;a -&gt; a&quot;)
		out.fstArg		= mkFn(fs, &quot;fstArg&quot;,		2, &quot;a -&gt; b -&gt; a&quot;)
		out.sndArg		= mkFn(fs, &quot;sndArg&quot;,		1, &quot;a -&gt; b -&gt; b&quot;)
		out.swap		= mkFn(fs, &quot;swap&quot;,			3, &quot;(b -&gt; a -&gt; c) -&gt; a -&gt; b -&gt; c&quot;)
		out.compose		= mkFn(fs, &quot;compose&quot;,		3, &quot;(b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c&quot;)
		out.ite			= mkFn(fs, &quot;ite&quot;,			4, &quot;(a -&gt; Bool) -&gt; (a -&gt; b) -&gt; (a -&gt; b) -&gt; a -&gt; b&quot;)
		out.add			= mkFn(fs, &quot;add&quot;,			2, &quot;Long -&gt; Long -&gt; Long&quot;)
		out.mul			= mkFn(fs, &quot;mul&quot;,			2, &quot;Long -&gt; Long -&gt; Long&quot;)
		out.inRange		= mkFn(fs, &quot;inRange&quot;,		3, &quot;Long -&gt; Long -&gt; Long -&gt; Bool&quot;)
		out.equ			= mkFn(fs, &quot;equ&quot;,			2, &quot;a -&gt; a -&gt; Bool&quot;)
		out.neq			= mkFn(fs, &quot;neq&quot;,			2, &quot;a -&gt; a -&gt; Bool&quot;)
		out.concat		= mkFn(fs, &quot;concat&quot;,		2, &quot;Str -&gt; Str -&gt; Str&quot;)
		out.asc			= mkFn(fs, &quot;asc&quot;,			1, &quot;Char -&gt; Int&quot;)
		out.chr			= mkFn(fs, &quot;chr&quot;,			1, &quot;Int -&gt; Char&quot;)
		out.ucase		= mkFn(fs, &quot;ucase&quot;,			1, &quot;Str -&gt; Str&quot;)
		out.lcase		= mkFn(fs, &quot;lcase&quot;,			1, &quot;Str -&gt; Str&quot;)
		out.readHex		= mkFn(fs, &quot;readHex&quot;,		1, &quot;Str -&gt; Long&quot;)
		
		out.TFn_toString = mkFn(fs, &quot;TFn_toString&quot;,	1, &quot;(a -&gt; b) -&gt; Str&quot;)
		out.applyToList	= mkFn(fs, &quot;applyToList&quot;,	2)
		
		out.TList_toString	= mkFn(fs, &quot;TList_toString&quot;,	1)
		out.TList_equ		= mkFn(fs, &quot;TList_equ&quot;,			2)
		out.isList			= mkFn(fs, &quot;isList&quot;,			1, &quot;Any -&gt; Bool&quot;)
		out.isNil			= mkFn(fs, &quot;isNil&quot;,				1, &quot;[a] -&gt; Bool&quot;)
		out.cons			= mkFn(fs, &quot;cons&quot;,				2, &quot;a -&gt; [a] -&gt; [a]&quot;)
		out.length			= mkFn(fs, &quot;length&quot;,			1)
		out.car				= mkFn(fs, &quot;car&quot;,				1)
		out.cdr				= mkFn(fs, &quot;cdr&quot;,				1)
		out.cadr			= mkFn(fs, &quot;cadr&quot;,				1)
		out.caddr			= mkFn(fs, &quot;caddr&quot;,				1)
		out.map				= mkFn(fs, &quot;map&quot;,				2, &quot;(a -&gt; b) -&gt; [a] -&gt; [b]&quot;)
		out.filter			= mkFn(fs, &quot;filter&quot;,			2, &quot;(a -&gt; Bool) -&gt; [a] -&gt; [a]&quot;)
		out.skipWhile		= mkFn(fs, &quot;skipWhile&quot;,			2, &quot;(a -&gt; Bool) -&gt; [a] -&gt; [a]&quot;)
		out.skipUntil		= mkFn(fs, &quot;skipUntil&quot;,			2, &quot;(a -&gt; Bool) -&gt; [a] -&gt; [a]&quot;)
		out.foldl			= mkFn(fs, &quot;foldl&quot;,				3)
		out.foldr			= mkFn(fs, &quot;foldr&quot;,				3)
		out.foldl1			= mkFn(fs, &quot;foldl1&quot;,			2)
		out.foldr1			= mkFn(fs, &quot;foldr1&quot;,			2)
		out.adjoin			= mkFn(fs, &quot;adjoin&quot;,			2)
		out.flatten			= mkFn(fs, &quot;flatten&quot;,			1, &quot;List List a -&gt; List a&quot;)
		out.reverse			= mkFn(fs, &quot;reverse&quot;,			1, &quot;List a -&gt; List a&quot;)
		
		out.TParser_toString = mkFn(fs, &quot;TParser_toString&quot;,	1, &quot;Parser a -&gt; Str&quot;)
		out.mkParser		= mkFn(fs, &quot;mkParser&quot;,			2, &quot;Str -&gt; Any -&gt; Parser a&quot;)
		out.pReturn			= mkFn(fs, &quot;pReturn&quot;,			1, &quot;a -&gt; Parser a&quot;)
		out.pStr			= mkFn(fs, &quot;pStr&quot;,				1, &quot;Str -&gt; Parser Str&quot;)
		out.pBind			= mkFn(fs, &quot;pBind&quot;,				2, &quot;Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b&quot;)
		out.pChoice			= mkFn(fs, &quot;pChoice&quot;,			2, &quot;Parser a -&gt; Parser a -&gt; Parser a&quot;)
		out.pMany			= mkFn(fs, &quot;pMany&quot;,				1, &quot;Parser a -&gt; Parser [a]&quot;)
		out.pMany1			= mkFn(fs, &quot;pMany1&quot;,				1, &quot;Parser a -&gt; Parser [a]&quot;)
		out.pZeroOrOne		= mkFn(fs, &quot;pZeroOrOne&quot;,			1, &quot;Parser a -&gt; Parser (Maybe a)&quot;)
		out.pZeroOrOne2		= mkFn(fs, &quot;pZeroOrOne2&quot;,		2, &quot;Parser a -&gt; a -&gt; Parser a&quot;)
		out.mkTypeVar		= mkFn(fs, &quot;mkTypeVar&quot;,			1, &quot;Char -&gt; Str&quot;)
		out.maybeMakeArrowType = mkFn(fs, &quot;maybeMakeArrowType&quot;,	2, &quot;Typ -&gt; Maybe Typ -&gt; Typ&quot;)
		out.mkTypeCtor		= mkFn(fs, &quot;mkTypeCtor&quot;,			2, &quot;Str -&gt; [Typ] -&gt; Typ&quot;)
		out.mkTupleType		= mkFn(fs, &quot;mkTupleType&quot;,		2, &quot;Typ -&gt; [Typ] -&gt; Typ&quot;)
		
		out.TASN_dot		= mkFn(fs, &quot;TASN_dot&quot;,			2, &quot;Str -&gt; ASN -&gt; Any&quot;)
		out.TASN_toString	= mkFn(fs, &quot;TASN_toString&quot;,		1, &quot;ASN -&gt; Str&quot;)
		out.mkASN			= mkFn(fs, &quot;mkASN&quot;,				3, &quot;Any -&gt; a -&gt; [b] -&gt; ASN&quot;)
		out.mkDtTerminal	= mkFn(fs, &quot;mkDtTerminal&quot;,		1, &quot;Str -&gt; ASN&quot;)
		out.mkDtCClass		= mkFn(fs, &quot;mkDtCClass&quot;,			2, &quot;Str -&gt; Str -&gt; ASN&quot;)
		out.mkDtNonterminal	= mkFn(fs, &quot;mkDtNonterminal&quot;,	2, &quot;Str -&gt; [ASN] -&gt; ASN&quot;)
		out.mkDtMult		= mkFn(fs, &quot;mkDtMult&quot;,			2, &quot;Str -&gt; [ASN] -&gt; ASN&quot;)
		
		out.isPattern		= mkFn(fs, &quot;isPattern&quot;,			1, &quot;Any -&gt; Bool&quot;)
		out.TPattern_toString = mkFn(fs, &quot;TPattern_toString&quot;,	1, &quot;Pattern a -&gt; Str&quot;)
		out.matches			= mkFn(fs, &quot;matches&quot;,			3, &quot;Pattern a -&gt; Maybe Env -&gt; a -&gt; Maybe Env&quot;)
		
		
		out._instances = fs
	End If
	Fn = out
End Function


Function mkPartialApp(fn As Object, arg As Variant)
	Dim result As New TFn
	result.tyname = TFn_tyname
	Dim baseArity As Integer, newArity As Integer
	Dim args As Variant
	If isPartialApp(fn) Then
		Dim innerArity As Integer, argPos As Integer
		Dim innerArgs As Variant
		result.which = fn.which
		innerArity = fn.arity
		baseArity = fn.which.arity
		newArity = innerArity - 1
		argPos = baseArity - newArity - 1
		ReDim args(0 To baseArity - 2)
		args(argPos) = arg
		innerArgs = fn.args
		Do
			argPos = argPos - 1
			args(argPos) = innerArgs(argPos)
		Loop Until argPos = 0
		result.args = args
		result.partialArgs = cons(arg, partialArgs(fn))
	Else
		result.which = fn
		baseArity = fn.arity
		newArity = baseArity - 1
		ReDim args(0 To baseArity - 2)
		args(0) = arg
		result.args = args
		result.partialArgs = cons(arg, nil)
	End If
	result.arity = newArity
	mkPartialApp = result
End Function

Function TFn_toString(ByVal f)
	Dim result As String, r As Integer, n As String, h As Variant, t As Object, k As Integer
	f = asFn(f)
	r = arity(f)
	n = getFnName(f)
	k = 0
	If isPartialApp(f) Then
		t = reverse(partialArgs(f))
		If n = &quot;compose&quot; Then
			If r = 1 Then
				&apos;result = &quot;\a&quot; &amp; k &amp; &quot;.&quot; &amp; TFn_toString(car(t)) &amp; &quot; (&quot; &amp; TFn_toString(cadr(t)) &amp; &quot; a&quot; &amp; k &amp; &quot;)&quot;
				&apos;k = k + 1
				result = TFn_toString(car(t)) &amp; &quot; Â° &quot; &amp; TFn_toString(cadr(t))
				&apos;result = &quot;(&quot; &amp; result &amp; &quot;)&quot;
			Else &apos; r = 2
				result = n &amp; TFn_toString(car(t))
				result = &quot;(&quot; &amp; result &amp; &quot;)&quot;
				&apos;croak(&quot;TFn_toString/NYI: compose partially applied to just 1 arg&quot;)
			End If
		ElseIf (n = &quot;swap&quot;) And (r = 1) Then
			Dim g As Object, x As Object
			g = car(t)
			x = cadr(t)
			If getFnName(g) = &quot;cons&quot; Then
				If isNil(x) Then
					result =  &quot;\a&quot; &amp; k &amp; &quot;.[a&quot; &amp; k &amp; &quot;]&quot;
					k = k + 1
				Else
					result =  &quot;\a&quot; &amp; k &amp; &quot;.cons a&quot; &amp; k &amp; &quot; &quot; &amp; toString(x)
					k = k + 1
				EndIf
			Else
				result =  &quot;\a&quot; &amp; k &amp; &quot;.&quot; &amp; TFn_toString(g) &amp; &quot; a&quot; &amp; k &amp; &quot; &quot; &amp; toString(x)
				k = k + 1
			End If
		Else
			result = &quot;(&quot; &amp; n &apos;&amp; &quot;_&quot; &amp; r
			While Not(isNil(t))
				h = car(t)
				t = cdr(t)
				If (isFn(h)) Then
					result = result &amp; &quot; &quot; &amp; TFn_toString(h)
				Else
					result = result &amp; &quot; &quot; &amp; toString(h)
				End If
			Wend
			result = result &amp; &quot;)&quot;
		End If
	Else
		result = n &apos;&amp; &quot;_&quot; &amp; r
	End If
	TFn_toString = result
End Function

Function lookupFn(name As String) As Variant
	Dim out As Variant
	Dim fs As Object, f As Object
	fs = Fn._instances
	Do Until(isNil(fs))
		f = car(fs)
		If (getFnName(f) = name) Then
			out = f
			Exit Do
		End If
		fs = cdr(fs)
	Loop
	lookupFn = out
End Function

Function arity(fn As Object) As Integer
	arity = fn.arity
End Function

Function getFnTypeStr(f As Object) As String
	Dim fName As String
	fName = getFnName(f)
	getFnTypeStr = Mid(f.str, Len(fName &amp; &quot; :: &quot;) + 1)
End Function

Function isFn(ByVal fn As Variant) As Boolean
	If isObject(fn) Then
		Dim oFn As Object
		Set oFn = fn
		On Local Error Goto isFn_returnsFalse
		oFn.which
		oFn.arity
		oFn.partialArgs
		isFn = True
		Exit Function
	End If
isFn_returnsFalse:
	isFn = False
End Function

Function asFn(fn As Variant, Optional ByVal msg As String)
	Dim f As Variant
	If isString(fn) Then
		croak(&quot;asFn: got String &quot; &amp; toString(fn))
		f = lookupFn(fn)
		If isEmpty(f) Then
			If isMissing(msg) Then : msg = &quot;&quot; : Else : msg = msg &amp; CR : End If
			croak(msg &amp; &quot;unknown function: &quot; &amp; toString(fn))
		End If
	Else
		f = fn
	End If
	If Not(isFn(f)) Then
		If isMissing(msg) Then : msg = &quot;&quot; : Else : msg = msg &amp; CR : End If
		croak(msg &amp; &quot;not a valid function: &quot; &amp; toString(f))
	End If
	asFn = f
End Function

Function isPartialApp(fn As Object) As Boolean
	isPartialApp = Not(isEmpty(fn.partialArgs))
End Function

Function partialArgs(fn As Object)	&apos; ATTENTION: stored in reverse order!
	Dim result As Object
	If isPartialApp(fn) Then
		result = fn.partialArgs
	Else
		result = nil
	End If
	partialArgs = result
End Function

Function getFnName(f As Object)
	If isPartialApp(f) Then
		getFnName = getFnName(f.which)
	Else
		getFnName = f.which
	End If
End Function

Function apply1(ByVal fn As Variant, ByVal arg As Variant)
	Dim result As Variant, r As Integer
	fn = asFn(fn)	&apos; makes sure it really is a function
	r = arity(fn)
	If r = 1 Then
		result = applyLast(fn, arg)
	Else
		result = mkPartialApp(fn, arg)
	End If
	apply1 = result
End Function

Function applyLast(ByVal fn As Object, arg As Variant)
	Dim out As Variant
	Dim reverseArgs As Object
	Dim baseArity As Integer
	Dim args As Variant
	Dim name As String
	If isPartialApp(fn) Then
		reverseArgs = partialArgs(fn)
		args = fn.args
		fn = fn.which
	Else
		reverseArgs = nil
	End If
	baseArity = fn.arity
	name = fn.which
	Dim a0 As Variant, a1 As Variant, a2 As Variant, a3 As Variant
	On baseArity Goto applyLast_of_one, applyLast_of_two, applyLast_of_three, applyLast_of_four
	Goto applyLast_of_fiveOrMore
applyLast_of_one:
	a0 = arg
	Select Case name
		Case &quot;typeOf&quot;:				out = typeOf(				a0)
		Case &quot;ctorOf&quot;:				out = ctorOf(				a0)
		Case &quot;singletonVal&quot;:		out = singletonVal(			a0)
		
		Case &quot;isEmpty&quot;:				out = isEmpty(				a0)
		Case &quot;isString&quot;:			out = isString(				a0)

		Case &quot;id&quot;: 					out = a0
		Case &quot;sndArg&quot;:				out = sndArg(				a0)
		Case &quot;asc&quot;:					out = Asc(					a0)
		Case &quot;chr&quot;:					out = Chr(					a0)
		Case &quot;ucase&quot;:				out = UCase(				a0)
		Case &quot;lcase&quot;:				out = LCase(				a0)
		Case &quot;toString&quot;:			out = toString(				a0)
		Case &quot;readHex&quot;:				out = readHex(				a0)
		Case &quot;isList&quot;:				out = isList(				a0)
		Case &quot;isNil&quot;:				out = isNil(				a0)
		Case &quot;length&quot;:				out = length(				a0)
		Case &quot;car&quot;:					out = car(					a0)
		Case &quot;cdr&quot;:					out = cdr(					a0)
		Case &quot;cadr&quot;:				out = cadr(					a0)
		Case &quot;caddr&quot;:				out = caddr(				a0)
		Case &quot;flatten&quot;:				out = flatten(				a0)
		Case &quot;reverse&quot;: 			out = reverse(				a0)
		Case &quot;toArray&quot;: 			out = toArray(				a0)
		Case &quot;pStr&quot;: 				out = pStr(					a0)
		Case &quot;pReturn&quot;:				out = pReturn(				a0)
		Case &quot;pMany&quot;:				out = pMany(				a0)
		Case &quot;pMany1&quot;:				out = pMany1(				a0)
		Case &quot;pZeroOrOne&quot;:			out = pZeroOrOne(			a0)
		Case &quot;mkTypeVar&quot;:			out = mkTypeVar(			a0)
		Case &quot;TFn_toString&quot;:		out = TFn_toString(			a0)
		Case &quot;TList_toString&quot;:		out = TList_toString(		a0)
		Case &quot;TParser_toString&quot;:	out = TParser_toString(		a0)
		Case &quot;TASN_toString&quot;:		out = TASN_toString(		a0)
		Case &quot;mkDtTerminal&quot;:		out = mkDtTerminal(			a0)
		Case &quot;isPattern&quot;:			out = isPattern(			a0)
		Case &quot;TPattern_toString&quot;:	out = TPattern_toString(	a0)
		Case &quot;isExpr&quot;:				out = isExpr(				a0)
		Case Else
			Goto applyLast_unknownF
	End Select
	applyLast = out
	Exit Function
applyLast_of_two:
	a0 = car(reverseArgs) &apos;fn.args(0)
	a1 = arg
	Select Case name
		Case &quot;applyDC&quot;:				out = applyDC(			a0, a1)
		Case &quot;hasType&quot;:				out = hasType(			a0, a1)
		
		Case &quot;TList_equ&quot;:			out = TList_equ(		a0, a1)
		Case &quot;fstArg&quot;:				out = a0
		Case &quot;add&quot;:					out = CLng(a0 + a1)
		Case &quot;mul&quot;:					out = CLng(a0 * a1)
		Case &quot;concat&quot;:				out = a0 &amp; a1
		Case &quot;equ&quot;:					out = equ(				a0, a1)
		Case &quot;neq&quot;:					out = Not(equ(			a0, a1))
		Case &quot;applyToList&quot;:			out = applyToList(		a0, a1)
		Case &quot;cons&quot;:				out = cons(				a0, a1)
		Case &quot;map&quot;:					out = map(				a0, a1)
		Case &quot;filter&quot;:				out = filter(			a0, a1)
		Case &quot;skipWhile&quot;:			out = skipWhile(		a0, a1)
		Case &quot;skipUntil&quot;:			out = skipUntil(		a0, a1)
		Case &quot;foldl1&quot;:				out = foldl1(			a0, a1)
&apos;		Case &quot;foldr1&quot;:				out = foldr1(			a0, a1)
		Case &quot;adjoin&quot;:				out = adjoin(			a0, a1)
		Case &quot;mkParser&quot;:			out = mkParser(			a0, a1)
		Case &quot;pBind&quot;:				out = pBind(			a0, a1)
		Case &quot;pChoice&quot;:				out = pChoice(			a0, a1)
		Case &quot;pZeroOrOne2&quot;:			out = pZeroOrOne2(		a0, a1)
		Case &quot;maybeMakeArrowType&quot;:	out = maybeMakeArrowType(a0, a1)
		Case &quot;mkTypeCtor&quot;:			out = mkTypeCtor(		a0, a1)
		Case &quot;mkTupleType&quot;:			out = mkTupleType(		a0, a1)
		Case &quot;TASN_dot&quot;:			out = TASN_dot(			a0, a1)
		Case &quot;mkDtCClass&quot;:			out = mkDtCClass(		a0, a1)
		Case &quot;mkDtNonterminal&quot;:		out = mkDtNonterminal(	a0, a1)
		Case &quot;mkDtMult&quot;:			out = mkDtMult(			a0, a1)
		Case Else
			Goto applyLast_unknownF
	End Select
	applyLast = out
	Exit Function
applyLast_of_three:
	a0 = cadr(reverseArgs) &apos;fn.args(0)
	a1 = car(reverseArgs) &apos;fn.args(1)
	a2 = arg
	Select Case name
		Case &quot;destructure&quot;:			out = _destructure(	a0, a1, a2)
		Case &quot;applyDC&quot;:				out = applyDC(		a0, a1, a2)

		Case &quot;swap&quot;:				out = apply(a0, a2, a1)
		Case &quot;compose&quot;:				out = _compose(a0, a1, a2)	&apos;	apply(a0, apply(a1, a2))	&apos;
		Case &quot;inRange&quot;:				out = CBool( (a0 &lt;= a2) And (a2 &lt;= a1) )
		Case &quot;foldl&quot;:				out = foldl(		a0, a1, a2)
		Case &quot;foldr&quot;:				out = foldr(		a0, a1, a2)
		Case &quot;mkASN&quot;:				out = mkASN(		a0, a1, a2)
		Case &quot;matches&quot;:				out = matches(	a0, a1, a2)
		Case Else
			Goto applyLast_unknownF
	End Select
	applyLast = out
	Exit Function
applyLast_of_four:
	a0 = caddr(reverseArgs) &apos;fn.args(0)
	a1 = cadr(reverseArgs) &apos;fn.args(1)
	a2 = car(reverseArgs) &apos;fn.args(2)
	a3 = arg
	Select Case name
		Case &quot;applyDC&quot;:				out = applyDC(	a0, a1, a2, a3)

		Case &quot;ite&quot;
			If applyLast(a0, a3) Then
				out = apply1(a1, a3)
			Else
				out = apply1(a2, a3)
			End if
		Case Else
			Goto applyLast_unknownF
	End Select
	applyLast = out
	Exit Function
applyLast_of_fiveOrMore:
	croak(&quot;applyLast/NYI: five or more args&quot;)
applyLast_unknownF:
	croak(&quot;applyLast: unknown fn &apos;&quot; &amp; name &amp; &quot;&apos; (arity: &quot; &amp; baseArity &amp; &quot;)&quot;)
End Function

Function applyToList(Optional ByVal f As Variant, Optional ByVal args As Object)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.applyToList : End If
	Dim result As Variant
	If isMissing(args) Then
		If isMissing(f) Then
			result = oFn
		Else
			f = asFn(f, &quot;applyToList: invalid 1st arg&quot;)
			result = apply1(oFn, f)
		End If
	ElseIf isNil(args) Then
		Dim fstr As String
		fstr = toString(f)
		croak(&quot;applyToList: empty args list for &quot; &amp; CR &amp; fstr)
	Else
		&apos; applyToList = foldl apply1 f args
		f = asFn(f, &quot;applyToList: invalid 1st arg&quot;)
		result = f
		While Not(isNil(args))
			result = apply1(result, car(args))
			args = cdr(args)
		Wend
	End If
	applyToList = result
End Function

Function _apply(fn As Object, Optional a0, Optional a1, Optional a2, Optional a3, Optional a4)
	If isMissing(a0) Then
		_apply = fn
	ElseIf isMissing(a1) Then
		_apply = apply1(fn, a0)
	ElseIf isMissing(a2) Then
		_apply = apply1(apply1(fn, a0), a1)
	ElseIf isMissing(a3) Then
		_apply = apply1(apply1(apply1(fn, a0), a1), a2)
	ElseIf isMissing(a4) Then
		_apply = apply1(apply1(apply1(apply1(fn, a0), a1), a2), a3)
	Else
		croak(&quot;_apply/NYI: more than 4 args&quot;)
	End If
End Function

Function apply(ByVal fn As Variant, a0, Optional a1, Optional a2, Optional a3, Optional a4, Optional a5, Optional a6, Optional a7, Optional a8, Optional a9, Optional a10)
	Dim args As Object
	If Not(isFn(fn)) Then
&apos;		croak(&quot;apply: invalid 1st arg:&quot; &amp; CR &amp; toString(fn))
	End If
	fn = asFn(fn, &quot;apply: invalid 1st arg&quot;)
	If isMissing(a1) Then
		If arity(fn) = 1 Then
			apply = applyLast(fn, a0)
		Else
			apply = apply1(fn, a0)
		End If
	ElseIf isMissing(a2) Then
		apply = apply1(apply1(fn, a0), a1)
	ElseIf isMissing(a3) Then
		apply = apply1(apply1(apply1(fn, a0), a1), a2)
	Else
		args = List(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
		apply = applyToList(fn, args)
	End If
End Function

&apos;= tests ============================================================

Function [test_Fn ===============]()
	Dim i As Integer
		
	Dim fId As Variant
	fId = Fn.id
	assertEqual(isPartialApp(fId), False).x
	assertEqual(arity(fId), 1).x
	assertEqual(apply(fId, 0), id(0)).x
	
	Dim temp As Object
	temp = fId &apos; do not access fields on fId directly...!
	assertEqual(temp.tyname &lt;&gt; &quot;&quot;, True).x
	

	Dim fCar As Variant
	fCar = Fn.car
	assertEqual(isPartialApp(fCar), False).x
	assertEqual(isNil(partialArgs(fCar)), True).x
	assertEqual(arity(fCar), 1).x
	
	assertEqual( apply1(fCar, List(9)), 9 ).x
	assertEqual( apply1(fCar, List(&quot;a&quot;)), &quot;a&quot; ).x
		
	Dim fEqu As Variant
	fEqu = Fn.equ
	assertEqual(isPartialApp(fEqu), False).x
	assertEqual(isNil(partialArgs(fEqu)), True).x
	assertEqual(arity(fEqu), 2).x
	assertEqual(apply(fEqu, 1, 2), False).x
	assertEqual(apply(fEqu, 1, 1), True).x
	
	Dim eq5 As Variant
	eq5 = apply(fEqu, 5)
	assertEqual(isPartialApp(eq5), True).x
	assertEqual(isNil(partialArgs(eq5)), False).x
	assertEqual(arity(eq5), 1).x
	
	&apos; partially applied fns also have a proper .tyname:
	&apos; Note typeStr is the BASIC type, not the actual fn type
	assertEqual(typeStr(eq5), typeStr(fId)).x
	
	Dim eq5_7 As Variant
	eq5_7 = apply1(eq5, 7)
	assertEqual(eq5_7, False).x

	Dim eq5_5 As Variant
	eq5_5 = apply1(eq5, 5)
	assertEqual(eq5_5, True).x

	Dim konst5 As Variant
	konst5 = apply1(Fn.fstArg, 5)
	assertEqual(isPartialApp(konst5), True).x
	assertEqual(arity(konst5), 1).x
	assertEqual(apply1(konst5, 7), 	5).x
	&apos; easy partial application:
	assertEqual(arity(fstArg), 2).x
	konst5 = fstArg(5)
	assertEqual(arity(konst5), 1).x
	assertEqual(apply(konst5, 7), 	5).x
	assertEqual(fstArg(5, 7), 		5).x
		
	Dim sndArg5 As Variant
	sndArg5 = apply1(Fn.sndArg, 5)
	
	assertEqual(arity(sndArg5), 1).x
	assertEqual(apply1(sndArg5, 7), 7).x
	
	&apos; easy partial application:
	sndArg5 = sndArg(5)
	assertEqual(arity(sndArg5), 1).x
	assertEqual(apply(sndArg5, 7), 	7).x
	assertEqual(sndArg(5, 7), 		7).x
		
	Dim fIte As Variant
	fIte = Fn.ite
	assertEqual(isPartialApp(fIte), False).x
	assertEqual(arity(fIte), 4).x

	Dim iteKFalse As Variant
	iteKFalse = apply1(fIte, fstArg(False))
	assertEqual(isPartialApp(iteKFalse), True).x
	assertEqual(arity(iteKFalse), 3).x

	Dim iteKFalseK42 As Variant
	iteKFalseK42 = apply1(iteKFalse, fstArg(42))
	assertEqual(isPartialApp(iteKFalseK42), True).x
	assertEqual(arity(iteKFalseK42), 2).x
	
	Dim iteKFalseK42Id As Variant
	iteKFalseK42Id = apply1(iteKFalseK42, id)
	assertEqual(arity(iteKFalseK42Id), 1).x

	assertEqual(apply(iteKFalseK42Id, &quot;Seven&quot;), &quot;Seven&quot;).x
	Dim iteKTrueK42Id As Variant, KTrue As Variant, K42 As Variant
	iteKTrueK42Id = ite(fstArg(True), fstArg(42), fId)
	assertEqual(arity(iteKTrueK42Id), 1).x
	assertEqual(apply(iteKTrueK42Id, &quot;Seven&quot;), 42).x
&apos;	MsgBox( toString(iteFalse42Seven) )

	Dim fAsc As Variant
	fAsc = Fn.asc
	assertEqual(arity(fAsc), 1).x
	assertEqual(apply(fAsc, &quot; &quot;), 		Asc(&quot; &quot;)).x
	assertEqual(apply(fAsc, TAB), 	       9).x
	assertEqual(apply(fAsc, CR), 	      13).x
	assertEqual(apply(fAsc, &quot;0&quot;), 		Asc(&quot;0&quot;)).x
	assertEqual(apply(fAsc, &quot;9&quot;), 		Asc(&quot;9&quot;)).x
	assertEqual(apply(fAsc, &quot;A&quot;), 		Asc(&quot;A&quot;)).x
	assertEqual(apply(fAsc, &quot;B&quot;), 		Asc(&quot;B&quot;)).x
	assertEqual(apply(fAsc, &quot;Z&quot;), 		Asc(&quot;Z&quot;)).x

	Dim fChr As Variant
	fChr = Fn.chr
	assertEqual(arity(fChr), 1).x
	assertEqual(apply(fChr,  9), 	TAB).x
	assertEqual(apply(fChr, 13), 	CR).x
	assertEqual(apply(fChr, 32), 	Chr(32)).x
	assertEqual(apply(fChr, 48), 	Chr(48)).x
	assertEqual(apply(fChr, 65), 	Chr(65)).x
	assertEqual(apply(fChr, 66), 	Chr(66)).x
	assertEqual(apply(fChr, 90), 	Chr(90)).x


	Dim fAdd As Variant
	fAdd = Fn.add
	assertEqual(arity(fAdd), 2).x
	assertEqual(apply(fAdd,  0,  0), 	add(0, 0)).x
	assertEqual(apply(fAdd,  0,  1), 	add(0, 1)).x
	assertEqual(apply(fAdd,  7, -5), 	add(7, -5)).x
	&apos; partial application
	fAdd = apply(fAdd, 65535)
	assertEqual(apply(fAdd, 65535), add(65535, 65535)).x

	Dim fMul As Variant
	fMul = Fn.mul
	assertEqual(arity(fMul), 2).x
	assertEqual(apply(fMul,  0,  0), 	mul(0, 0)).x
	assertEqual(apply(fMul,  0,  1), 	mul(0, 1)).x
	assertEqual(apply(fMul,  7, -5), 	mul(7, -5)).x
	&apos; partial application
	fMul = apply(fMul, 65535)
	assertEqual(apply(fMul, 32767), mul(65535, 32767)).x

	Dim fReadhex As Variant
	fReadHex = Fn.readHex
	assertEqual(arity(fReadHex), 1).x
	assertEqual(apply(fReadHex,  &quot;0&quot;),  readHex(&quot;0&quot;)).x
	assertEqual(apply(fReadHex,  &quot;1&quot;),  readHex(&quot;1&quot;)).x
	assertEqual(apply(fReadHex,  &quot;2&quot;),  readHex(&quot;2&quot;)).x
	assertEqual(apply(fReadHex,  &quot;3&quot;),  readHex(&quot;3&quot;)).x
	assertEqual(apply(fReadHex,  &quot;4&quot;),  readHex(&quot;4&quot;)).x
	assertEqual(apply(fReadHex,  &quot;5&quot;),  readHex(&quot;5&quot;)).x
	assertEqual(apply(fReadHex,  &quot;6&quot;),  readHex(&quot;6&quot;)).x
	assertEqual(apply(fReadHex,  &quot;7&quot;),  readHex(&quot;7&quot;)).x
	assertEqual(apply(fReadHex,  &quot;8&quot;),  readHex(&quot;8&quot;)).x
	assertEqual(apply(fReadHex,  &quot;9&quot;),  readHex(&quot;9&quot;)).x

	assertEqual(apply(fReadHex,  &quot;A&quot;),  readHex(&quot;A&quot;)).x
	assertEqual(apply(fReadHex,  &quot;a&quot;),  readHex(&quot;a&quot;)).x

	assertEqual(apply(fReadHex,  &quot;F&quot;),  readHex(&quot;F&quot;)).x
	assertEqual(apply(fReadHex,  &quot;f&quot;),  readHex(&quot;f&quot;)).x


	assertEqual(arity(Fn.applyToList), 2).x

	assertEqual(apply(Fn.toString, &quot;abcd&quot;), &quot;&apos;abcd&apos;&quot;).x
End Function

</script:module>