<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M09_Pattern" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit

Const TPattern_tyname = &quot;TPattern&quot;
Type TPattern
	tyname	As String
	which	As String
	a0		As Variant
End Type
&apos; data Pattern a = Any
&apos;                | Val a
&apos;                | Var Str
&apos;                | Dat TypeCtor [Pattern Any]

Sub Main
	[test_Pattern======================================]
End Sub


Function newPattern(which As String, a0 As Variant)
	Dim out As New TPattern
	out.tyname = TPattern_tyname
	out.which  = which
	out.a0	   = a0
	newPattern = out
End Function

Function isPattern(Optional x As Variant)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.isPattern : End If
	Dim out As Variant
	If isMissing(x) Then
		out = oFn
	Else
		out = (typeOf(x) = &quot;Object/&quot; &amp; TPattern_tyname)
	End If
	isPattern = out
End Function

Function TPattern_toString(p As Object)
	Dim out As Variant
	Select Case p.which
		Case &quot;any&quot;:			out = &quot;_&quot;
		Case &quot;var&quot;:			out = p.a0
		Case &quot;val&quot;
			If isEmpty(p.a0) Then
				out = &quot;()&quot;
			Else
				out = toString(p.a0)
			End If
		Case &quot;List.nil&quot;:	out = &quot;[]&quot;
		Case &quot;List.cons&quot;
			out = &quot;(&quot; _
				&amp; TPattern_toString(car(p.a0)) _
				&amp; &quot;:&quot; _
				&amp; TPattern_toString(cadr(p.a0)) _
				&amp; &quot;)&quot;
		Case Else
			croak(&quot;TPattern_toString: unsupported pattern .which = &quot; &amp; toString(p.which))
	End Select
	TPattern_toString = out
End Function

Function patAny()
	Static out As Object : If isNull(out) Then
		out = newPattern(&quot;any&quot;, Empty)
	End If
	patAny = out
End Function

Function patVal(v As Variant)
	Dim out As Variant
	out = newPattern(&quot;val&quot;, v)
	patVal = out
End Function

Function patVar(s As String)
	Dim out As Variant
	out = newPattern(&quot;var&quot;, s)
	patVar = out
End Function

Function patList_nil()
	Static out As Object : If isNull(out) Then : out = newPattern(&quot;List.nil&quot;, nil) : End If
	patList_nil = out
End Function

Function patList_cons(hd As Variant, tl As Object)
	Dim out As Variant
	out = newPattern(&quot;List.cons&quot;, List(hd, tl))
	patList_cons = out
End Function

&apos; matches :: Pattern a -&gt; Maybe Env -&gt; a -&gt; Maybe Env
&apos; matches _          None     _ = None
&apos; matches Any        (Some e) x = Some e
&apos; matches (Val v)    (Some e) x = if x = v then Some e else None
&apos; matches (Var s)    (Some e) x = case (lookup s e) of
&apos;                              None   -&gt; Some (extend e s x)
&apos;                              Some y -&gt; matches (Val y) (Some e) x
&apos; matches (Dat c qs) (Some e) x = if (typeCtor x) != c
&apos;                                 then None
&apos;                                 else let f = (\acc q.let fs = fst acc
&apos;                                                          me = snd acc
&apos;                                                      in
&apos;                                                      case me of
&apos;                                                        None   -&gt; None
&apos;                                                        e&apos; -&gt; (matches q e&apos; (car fs), cdr fs)
&apos;									   in
&apos;                                      foldl f (fields x, Some e) qs
Function matches( _
	Optional ByRef p As Object, _
	Optional ByRef e As Variant, _
	Optional ByVal x As Variant _
)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.matches : End If
	Dim out As Variant
	If isMissing(e) Then 		: out = oFn
	ElseIf isMissing(p) Then 	: out = apply(oFn, e)
	ElseIf isMissing(x) Then	: out = apply(oFn, e, p)
	ElseIf isEmpty(e) Then		: out = Empty
	Else
		Select Case p.which
			Case &quot;any&quot;: 	out = e
			Case &quot;val&quot;
				If equ(x, p.a0) Then : out = e
				Else : out = Empty : End If
			Case &quot;var&quot;
				Dim s As String, y As Variant
				s = p.a0
				y = lookup(s, e)
				If isEmpty(y) Then
					out = extend(e, s, x)
				Else
					out = matches(patVal(y), e, x)
				End If
			Case &quot;List.nil&quot;
				If Not(isList(x)) Then
					out = Empty	&apos; TODO: maybe throw on type error?
				ElseIf isNil(x) Then
					out = e
				Else
					out = Empty
				End If
			Case &quot;List.cons&quot;
				If Not(isList(x)) Then
					out = Empty	&apos; TODO: maybe throw on type error?
				ElseIf isNil(x) Then
					out = Empty
				Else
					Dim patHd As Object, patTl As Object
					patHd = car(p.a0)
					patTl = cadr(p.a0)
					out = matches(patHd, e,   car(x))
					out = matches(patTl, out, cdr(x))
				End If
			Case Else
				croak(&quot;TPattern_matches: unsupported pattern .which = &quot; &amp; toString(p.which))
		End Select
	End If
	matches = out
End Function

Function [test_Pattern======================================]()
	test_Pattern_isPattern()
	test_Pattern_toString()
	test_Pattern_matches_any()
	test_Pattern_matches_val()
	test_Pattern_matches_var()
	test_Pattern_matches_list()
End Function

Function test_Pattern_newPattern()
	Dim p As Object
	p = newPattern()
	assertEqual(typeOf(p), &quot;Object/&quot; &amp; TPattern_tyname).x
End Function

Function test_Pattern_isPattern()
	assertEqual(isPattern(patAny), 			True).x
	
	assertEqual(isPattern(patVal(Empty)), 	True).x
	assertEqual(isPattern(patVal(Nothing)), True).x
	assertEqual(isPattern(patVal(&quot;&quot;)), 		True).x
	assertEqual(isPattern(patVal(&quot;a&quot;)),		True).x
	
	assertEqual(isPattern(patVar(&quot;a&quot;)),		True).x
	assertEqual(isPattern(patVar(&quot;b&quot;)),		True).x

	assertEqual(isPattern(patList_nil),						True).x
	assertEqual(isPattern(patList_cons(patAny, patAny)),	True).x

	assertEqual(isPattern(Empty),		False).x
	assertEqual(isPattern(Nothing),		False).x
	assertEqual(isPattern(True),		False).x
	assertEqual(isPattern(False),		False).x
	assertEqual(isPattern(&quot;&quot;),			False).x
	assertEqual(isPattern(&quot;foo&quot;),		False).x
	assertEqual(isPattern(0),			False).x
	assertEqual(isPattern(1),			False).x
	assertEqual(isPattern(4711),		False).x
	assertEqual(isPattern(CLng(4711)),	False).x
	assertEqual(isPattern(3.1415),		False).x
	
	Dim f As Object
	f = isPattern	&apos; &quot;partial&quot; application
	assertEqual(arity(f),				1).x
	
	assertEqual(apply(f, Empty),		False).x
	assertEqual(apply(f, Nothing),		False).x
	assertEqual(apply(f, True),			False).x
	assertEqual(apply(f, False),		False).x
	assertEqual(apply(f, &quot;&quot;),			False).x
	assertEqual(apply(f, &quot;foo&quot;),		False).x
	assertEqual(apply(f, 0),			False).x
	assertEqual(apply(f, 1),			False).x
	assertEqual(apply(f, 4711),			False).x
	assertEqual(apply(f, CLng(4711)),	False).x
	assertEqual(apply(f, 3.1415),		False).x
End Function

Function test_Pattern_toString()
	assertEqual(toString(patAny),   		      &quot;_&quot;).x

	assertEqual(toString(patVal(Empty)), 	     &quot;()&quot;).x

	assert_toString_equals(patVal(Nothing),   Nothing).x
	assert_toString_equals(patVal(True),	     True).x
	assert_toString_equals(patVal(False),	    False).x
	assert_toString_equals(patVal(&quot;&quot;), 		       &quot;&quot;).x
	assert_toString_equals(patVal(&quot;a&quot;), 	      &quot;a&quot;).x
	assert_toString_equals(patVal(&quot;foo&quot;), 	    &quot;foo&quot;).x
	assert_toString_equals(patVal(CR), 	  	       CR).x
	assert_toString_equals(patVal(LF), 	  	       LF).x
	assert_toString_equals(patVal(TAB),   	      TAB).x
	assert_toString_equals(patVal(    0),           0).x
	assert_toString_equals(patVal(    1),           1).x
	assert_toString_equals(patVal(    2),           2).x
	assert_toString_equals(patVal( 4711),        4711).x
	assert_toString_equals(patVal(3.1415),     3.1415).x
	assert_toString_equals(patVal(CLng(42)), CLng(42)).x
	assert_toString_equals(patVal(CLng(42)),       42).x
	
	assertEqual(toString(patVar(&quot;a&quot;)), &quot;a&quot;).x
	assertEqual(toString(patVar(&quot;b&quot;)), &quot;b&quot;).x
	
	assertEqual(toString(patList_nil), 					&quot;[]&quot;).x
	assertEqual(toString(patList_cons(patAny, patAny)), &quot;(_:_)&quot;).x
End Function

Function assert_matches(p As Object, env As Variant, ByVal vs As Variant)
	assert_matches = _match_assertions(p, env, vs, envEmpty) &apos; TODO: expect particular env
End Function

Function refute_matches(p As Object, env As Variant, ByVal vs As Variant)
	refute_matches = _match_assertions(p, env, vs, Empty)
End Function

Function _match_assertions(p As Object, env As Variant, ByVal vs As Variant, expected As Variant)
	If Not(isPattern(p)) Then
		croak(IIf(isEmpty(expected), &quot;refute&quot;, &quot;assert&quot;) &amp; &quot;_matches: invalid pattern &quot; &amp; toString(p))
	End If
	Dim testResult As Object
	Dim val As Variant, i As Integer, gotArray As Boolean
	gotArray = isArray(vs)
	If Not(gotArray) Then
		vs = Array(vs)
	End If
	For i = LBound(vs) To UBound(vs)
		testResult = _single_match_assertion(p, env, vs(i), expected, gotArray, i)
		If testResult.isFail Then
			Goto _match_assertions_end
		End If
	Next i
_match_assertions_end:
	_match_assertions = testResult
End Function

Function _single_match_assertion( _
	p As Object, _
	env As Variant, _
	val As Variant, _
	expected As Variant, _
	gotArray As Boolean, _
	i As Integer _
)
	Dim matchResult As Variant, testResult As Object
	matchResult = matches(p, env, val)
	If isEmpty(matchResult) = isEmpty(expected) Then &apos; don&apos;t use assertEqual in order to avoid stupid MsgBox
		testResult = assertEqual(True, True) &apos; inc assertionCount
	Else
		Dim msg As String, valStr As String, pStr As String, eStr As String, mStr As String
		valStr = toString(val)
		pStr = toString(p)
		If isEmpty(env) Then : eStr = &quot;Empty (None)&quot;
		Else : eStr = Env_toString(env) : End If
		If isEmpty(matchResult) Then : mStr = &quot;Empty (None)&quot;
		Else : mStr = Env_toString(matchResult) : End If
		msg = &quot;pattern&quot; _
			&amp; NL &amp; &quot;  &quot; &amp; pStr _
			&amp; NL &amp; &quot;under env&quot; _
			&amp; NL &amp; &quot;  &quot; &amp; eStr _
			&amp; NL &amp; NL &amp; &quot;expected &quot; &amp; IIf(isEmpty(expected), &quot;NOT &quot;, &quot;&quot;) &amp; &quot;to match:&quot; _
			&amp; NL &amp; &quot;  &quot; &amp; valStr _
			&amp; NL &amp; NL &amp; &quot;but returned env&quot; _
			&amp; NL &amp; mStr
		If gotArray Then
			msg = &quot;at index &quot; &amp; i &amp; &quot;: &quot; _
				&amp; NL &amp; msg
		End If
		testResult = mkFail(matchResult, expected, msg)
	End If
	_single_match_assertion = testResult
End Function

Function test_Pattern_matches_any()
	Dim p As TPattern, f As Object, e As Object
	f = matches
	e = envEmpty
	assertEqual(arity(f), 3).x
	
	p = patAny
	assert_matches(p, e, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	&apos; under env = Empty (None) it does not match anything:
	refute_matches(p, Empty, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
End Function

Function test_Pattern_matches_val()
	Dim p As TPattern, f As Object, e As Object
	f = matches
	e = envEmpty

	p = patVal(Empty)
	assert_matches(p, e, Empty).x
	refute_matches(p, e, Array( _
		       Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	&apos; under env = Empty (None) it does not match anything:
	refute_matches(p, Empty, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
		
	p = patVal(Nothing)
	assert_matches(p, e, Nothing).x
	refute_matches(p, e, Array( _
		Empty, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	f = matches(p, e)
	assertThrows(f, Array(      True)).x
	assertThrows(f, Array(     False)).x
	assertThrows(f, Array(         0)).x
	assertThrows(f, Array(         1)).x
	assertThrows(f, Array(         2)).x
	assertThrows(f, Array(      4711)).x
	assertThrows(f, Array(CLng(4711))).x
	assertThrows(f, Array(    3.1415)).x
	&apos; under env = Empty (None) it does not match anything:
	refute_matches(p, Empty, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	
	p = patVal(&quot;&quot;)
	assert_matches(p, e, &quot;&quot;).x
	refute_matches(p, e, Array( Empty, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot; )).x
	f = matches(p, e)
	assertThrows(f, Array(   Nothing)).x
	assertThrows(f, Array(      True)).x
	assertThrows(f, Array(     False)).x
	assertThrows(f, Array(         0)).x
	assertThrows(f, Array(         1)).x
	assertThrows(f, Array(         2)).x
	assertThrows(f, Array(      4711)).x
	assertThrows(f, Array(CLng(4711))).x
	assertThrows(f, Array(    3.1415)).x	
	&apos; under env = Empty (None) it does not match anything:
	refute_matches(p, Empty, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
End Function	
	
Function test_Pattern_matches_var()
	Dim p As TPattern, f As Object, e As Object
	f = matches
	e = envEmpty
	
	p = patVar(&quot;a&quot;)
	assert_matches(p, e, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	&apos; under env = Empty (None) it does not match anything:
	refute_matches(p, Empty, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	
	&apos; bind the var &quot;a&quot; to the value &quot;foo&quot;:
	e = matches(p, envEmpty, &quot;foo&quot;)
	&apos; under this env var-pattern &quot;a&quot; matches only &quot;foo&quot;:
	assert_matches(p, e, 		&quot;foo&quot;).x
	refute_matches(p, e, 		&quot;bar&quot;).x
	&apos; but under an env where &quot;a&quot; isn&apos;t bound it still matches anything
	e = extend(envEmpty, &quot;b&quot;, &quot;foo&quot;)
	assert_matches(p, e, &quot;foo&quot;).x
	assert_matches(p, e, &quot;bar&quot;).x
	f = matches(p, e)
	assertThrows(f, Array(   Nothing)).x
	assertThrows(f, Array(      True)).x
	assertThrows(f, Array(     False)).x
	assertThrows(f, Array(         0)).x
	assertThrows(f, Array(         1)).x
	assertThrows(f, Array(         2)).x
	assertThrows(f, Array(      4711)).x
	assertThrows(f, Array(CLng(4711))).x
	assertThrows(f, Array(    3.1415)).x	
End Function	
	
Function test_Pattern_matches_list()
	Dim p As TPattern, f As Object, e As Object
	f = matches
	e = envEmpty
	
	&apos; pattern of the empty list
	p = patList_nil
	assert_matches(p, e, nil).x
	refute_matches(p, e, List(nil)).x
	
	&apos; pattern of a non-empty list
	p = patList_cons(patVar(&quot;x&quot;), patVar(&quot;xs&quot;))
	refute_matches(p, e, nil).x
	assert_matches(p, e, List(nil)				).x
	assert_matches(p, e, List(nil, nil)			).x
	assert_matches(p, e, List(1)				).x
	assert_matches(p, e, List(1, 2, 3)			).x
	assert_matches(p, e, List(&quot;a&quot;)				).x
	assert_matches(p, e, List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)	).x
	
	&apos; pattern of a singleton list
	p = patList_cons(patVar(&quot;x&quot;), patList_nil)
	refute_matches(p, e, nil).x
	assert_matches(p, e, List(nil)				).x
	refute_matches(p, e, List(nil, nil)			).x
	assert_matches(p, e, List(1)				).x
	refute_matches(p, e, List(1, 2, 3)			).x
	assert_matches(p, e, List(&quot;a&quot;)				).x
	refute_matches(p, e, List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)	).x
	
	&apos; pattern of a list with head equal to tail (so head must be a list, too)
	p = patList_cons(patVar(&quot;x&quot;), patVar(&quot;x&quot;))
	refute_matches(p, e, nil).x
	assert_matches(p, e, List(nil)				).x
	refute_matches(p, e, List(nil, nil)			).x
	&apos;refute_matches(p, e, List(1)				).x	&apos; does not type-check (x:1 matched against a list)
	&apos;refute_matches(p, e, List(1, 2, 3)			).x &apos; -&quot;-
	&apos;assert_matches(p, e, List(&quot;a&quot;)				).x &apos; -&quot;-
	&apos;refute_matches(p, e, List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)	).x &apos; -&quot;-
	&apos;refute_matches(p, e, List(List(1), List(1))	).x &apos; does not type-check
	assert_matches(p, e, List(List(1), 1) ).x
	refute_matches(p, e, List(List(1), 2) ).x
	
	&apos; pattern of a list with first two elems equal
	p = patList_cons(patVar(&quot;x&quot;), patList_cons(patVar(&quot;x&quot;), patAny))
	refute_matches(p, e, nil).x
	refute_matches(p, e, List(nil)				).x
	assert_matches(p, e, List(nil, nil)			).x
	refute_matches(p, e, List(1)				).x
	assert_matches(p, e, List(1, 1)				).x
	refute_matches(p, e, List(1, 2)				).x
	assert_matches(p, e, List(1, 1, 3)			).x
	refute_matches(p, e, List(1, 2, 3)			).x
	assert_matches(p, e, List(1, 1, 2, 3)		).x
	
End Function


</script:module>