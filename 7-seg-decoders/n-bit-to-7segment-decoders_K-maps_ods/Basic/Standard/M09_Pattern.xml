<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M09_Pattern" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit

&apos; data Pattern = Any
&apos;              | Val Type.Any
&apos;              | Var Str
&apos;              | Dat TypeCtor [Pattern]

Const TPattern_tyname = &quot;TPattern&quot;
Type TPattern
	tyname	As String
	which	As String
	a0		As Variant
End Type


Sub Main
	TPattern
	[test_Pattern======================================]()
End Sub


Function TPattern()
	Static out As Object
	If isNull(out) Then
		Dim tcPat
		tcPat = _mkDataTypeCtor(&quot;Pattern&quot;, 0)
		out = tcPat
		Dim cAny, cVar, cVal, cData
		cAny  = _mkDataCtor(tcPat, &quot;Any&quot;, nil)
		cVar  = _mkDataCtor(tcPat, &quot;Var&quot;, List(Tp.Native_String))
		cVal  = _mkDataCtor(tcPat, &quot;Val&quot;, List(Tp.Native_Variant))
		cData = _mkDataCtor(tcPat, &quot;Data&quot;, List(TDataCtor, TList(tcPat)))
		&apos;msgbox(hasType(&quot;asdf&quot;, Tp.Native_Variant))
		show(cData.str)
	End If
	TPattern = out
End Function

Function newPattern(which As String, a0 As Variant)
	Dim out As New TPattern
	out.tyname = TPattern_tyname
	out.which  = which
	out.a0	   = a0
	newPattern = out
End Function

Function isPattern(Optional x As Variant)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.isPattern : End If
	Dim out As Variant
	If isMissing(x) Then
		out = oFn
	Else
		out = (typeStr(x) = &quot;Object/&quot; &amp; TPattern_tyname)
	End If
	isPattern = out
End Function

Function TPattern_toString(p As Object)
	Dim out As Variant
	Select Case p.which
		Case &quot;Any&quot;:			out = &quot;_&quot;
		Case &quot;Var&quot;:			out = p.a0
		Case &quot;Val&quot;
			If isEmpty(p.a0) Then
				out = &quot;()&quot;
			Else
				out = toString(p.a0)
			End If
		Case &quot;Dat&quot;:			out = getFnName(p.a0)
		Case &quot;App&quot;
			out = &quot;(&quot; &amp; TPattern_toString(p.a0) _
				&amp; &quot; &quot; &amp; TPattern_toString(p.a1) _
				&amp; &quot;)&quot;
		Case &quot;List.nil&quot;:	out = &quot;[]&quot;
		Case &quot;List.cons&quot;
			Dim patHd As Object, patTl As Object
			patHd = car(p.a0)
			patTl = cadr(p.a0)
			If (patTl.which = patList_nil.which) Then
				out = &quot;[&quot; _
					&amp; TPattern_toString(patHd) _
					&amp; &quot;]&quot;
			Else
				out = &quot;(&quot; _
					&amp; TPattern_toString(patHd) _
					&amp; &quot;:&quot; _
					&amp; TPattern_toString(patTl) _
					&amp; &quot;)&quot;
			End If
		Case &quot;ASN&quot;
			out = &quot;(ASN &quot; _
				&amp; TPattern_toString(car(p.a0)) _
				&amp; &quot; &quot; _
				&amp; TPattern_toString(cadr(p.a0)) _
				&amp; &quot; &quot; _
				&amp; TPattern_toString(caddr(p.a0)) _
				&amp; &quot;)&quot;
		Case Else
			croak(&quot;TPattern_toString: unsupported pattern .which = &quot; &amp; toString(p.which))
	End Select
	TPattern_toString = out
End Function

Function patAny()
	Static out As Object : If isNull(out) Then
		out = newPattern(&quot;Any&quot;, Empty)
	End If
	patAny = out
End Function

Function patVal(v As Variant)
	Dim out As Variant
	out = newPattern(&quot;Val&quot;, v)
	patVal = out
End Function

Function patVar(s As String)
	Dim out As Variant
	out = newPattern(&quot;Var&quot;, s)
	patVar = out
End Function

Function patList_nil()
	Static out As Object : If isNull(out) Then : out = newPattern(&quot;List.nil&quot;, nil) : End If
	patList_nil = out
End Function

Function patDat(ctor As Object)
	Dim out As Object
	out = newPattern(&quot;Dat&quot;, ctor)
	patDat = out
End Function

Function patList_cons(patHd As Variant, patTl As Object)
	Dim out As Variant
	&apos; TODO: make sure patHd and patTl are proper patterns
	out = newPattern(&quot;List.cons&quot;, List(patHd, patTl))
	patList_cons = out
End Function

Function patASN(patLabel As Variant, patValue As Object, patChildren As Object)
	Dim out As Variant
	&apos; TODO: make sure patLabel, patValue and patChildren are proper patterns
	out = newPattern(&quot;ASN&quot;, List(patLabel, patValue, patChildren))
	patASN = out
End Function

&apos; matches :: Pattern a -&gt; Maybe Env -&gt; a -&gt; Maybe Env
&apos; matches _          None     _ = None
&apos; matches Any        (Some e) x = Some e
&apos; matches (Val v)    (Some e) x = if x = v then Some e else None
&apos; matches (Var s)    (Some e) x = case (lookup s e) of
&apos;                              None   -&gt; Some (extend e s x)
&apos;                              Some y -&gt; matches (Val y) (Some e) x
&apos; matches (Dat c qs) (Some e) x = if (typeCtor x) != c
&apos;                                 then None
&apos;                                 else let f = (\acc q.let fs = fst acc
&apos;                                                          me = snd acc
&apos;                                                      in
&apos;                                                      case me of
&apos;                                                        None   -&gt; None
&apos;                                                        e&apos; -&gt; (matches q e&apos; (car fs), cdr fs)
&apos;									   in
&apos;                                      foldl f (fields x, Some e) qs
Function matches( _
	Optional ByRef p As Object, _
	Optional ByRef e As Variant, _
	Optional ByVal x As Variant _
)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.matches : End If
	Dim out As Variant
	If isMissing(e) Then 		: out = oFn
	ElseIf isMissing(p) Then 	: out = apply(oFn, e)
	ElseIf isMissing(x) Then	: out = apply(oFn, e, p)
	ElseIf isEmpty(e) Then		: out = Empty
	Else
		out = _matches(p, e, x, nil)
	End If
	matches = out
End Function

Function _matches( _
	ByVal p As Object, _
	ByVal e As Variant, _
	ByVal x As Variant, _
	ByVal args As Object _
)
	If isEmpty(e) Then
		_matches = Empty
		Exit Function
	End If
	Dim out As Variant, u As Variant
_matches_dispatch:
	Select Case p.which
		Case &quot;Any&quot;: 	out = e
		Case &quot;Val&quot;
			u = p.a0
_matches_Val_equalityTest:
			&apos;On Local Error Goto _matches_Val_equalityTest_threw
			If equ(x, u) Then
				out = e
			Else
				out = Empty
			End If
		Case &quot;Var&quot;
			Dim s As String, y As Variant
			s = p.a0
			y = lookup(s, e)
			If isEmpty(y) Then
				out = extend(e, s, x)
			Else
				&apos; tail-call:
				&apos;out = _matches(patVal(y), e, x, args)
				u = y
				Goto _matches_Val_equalityTest
			End If
		Case &quot;App&quot;
			Dim f As Object, a As Variant
_matches_descend_Apps:
			f = p.a0
			a = p.a1
			If (f.which = &quot;App&quot;) Then
				&apos; tail-call:
				&apos;out = _matches(f, e, x, cons(a, args))
				args = cons(a, args)
				p = f
				Goto _matches_descend_Apps
			Else
				&apos; tail-call:
				out = _matchApplication(f, e, x, cons(a, args))
			End If
		Case &quot;List.nil&quot;
			If Not(isList(x)) Then
				out = Empty	&apos; TODO: maybe throw on type error?
			ElseIf isNil(x) Then
				out = e
			Else
				out = Empty
			End If
		Case &quot;List.cons&quot;
			If Not(isList(x)) Then
				out = Empty	&apos; TODO: maybe throw on type error?
			ElseIf isNil(x) Then
				out = Empty
			Else
				Dim patHd As Object, patTl As Object
				patHd = car(p.a0)
				out = _matches(patHd, e,   car(x), args)
				If isEmpty(out) Then : Goto _matches_end : End If
				patTl = cadr(p.a0)
				&apos; tail-call:
				&apos;out = _matches(patTl, out, cdr(x), args)
			
				p = patTl
				e = out
				x = cdr(x)
				Goto _matches_dispatch
			End If
		Case &quot;ASN&quot;
			If Not(isASN(x)) Then
				out = Empty	&apos; TODO: maybe throw on type error?
			Else
				Dim patLabel As Object, patValue As Object, patChildren As Object
				patLabel    = car(p.a0)
				out = _matches(patLabel,    e,   asnLabel(x),    args)
				If isEmpty(out) Then : Goto _matches_end : End If
				patValue    = cadr(p.a0)
				out = _matches(patValue,    out, asnValue(x),    args)
				If isEmpty(out) Then : Goto _matches_end : End If
				patChildren = caddr(p.a0)
				&apos; tail-call:
				&apos;out = _matches(patChildren, out, asnChildren(x), args)
				p = patChildren
				e = out
				x = asnChildren(x)
				Goto _matches_dispatch
			End If
		Case Else
			croak(&quot;TPattern_matches: unsupported pattern .which = &quot; &amp; toString(p.which))
	End Select
_matches_end:
	_matches = out
End Function

Function _matchApplication( _
	ByVal ptOp  As Object, _
	ByVal env   As Variant, _
	ByVal val   As Variant, _
	ByVal args  As Object _
)
	Dim out As Variant
	out = Empty
	If ptOp.which &lt;&gt; &quot;Dat&quot; Then
		croak(&quot;_matchApplication: unsupported op pattern &quot; &amp; NL &amp; TPattern_toString(ptOp))
	End If
	Dim ctor As Variant
	ctor = ctorOf(val)
	If isEmpty(ctor) Then &apos; not a datatype value
		out = Empty	&apos; TODO: maybe throw on type error?
	Else
		Dim ctorName As String, opName As String
		ctorName = getFnName(ctor)
		opName = getFnName(ptOp.a0)
		If ctorName = opName Then
			Dim opArity As Integer, ctorArity As Integer
			opArity = arity(ptOp.a0)
			ctorArity = arity(ctor)
			If opArity &lt;&gt; ctorArity Then
				croak(&quot;_matchApplication/NYI: unequal arities of op &quot; _
					&amp; opName &amp; &quot; (&quot; &amp; opArity &amp; &quot;)&quot; _
					&amp; &quot; &lt;&gt; &quot; &amp; ctorName &amp; &quot; (&quot; &amp; ctorArity &amp; &quot;)&quot; _
				)
			End If
			show(&quot;_matchApplication/NYI: applyToList &quot; &amp; opName _
				&amp; &quot; &quot; &amp; toString(args) _
				&amp; NL &amp; &quot; matched against&quot;, val _
			)
		End If
	End If
	_matchApplication = out
End Function


Function [test_Pattern======================================]()
	test_Pattern_isPattern()
	test_Pattern_toString()
	test_Pattern_matches_Any()
	test_Pattern_matches_Val()
	test_Pattern_matches_Var()
	test_Pattern_matches_List()
	test_Pattern_matches_ASN()
End Function

Function test_Pattern_isPattern()
	assertEqual(isPattern(patAny), 			True).x
	
	assertEqual(isPattern(patVal(Empty)), 	True).x
	assertEqual(isPattern(patVal(Nothing)), True).x
	assertEqual(isPattern(patVal(&quot;&quot;)), 		True).x
	assertEqual(isPattern(patVal(&quot;a&quot;)),		True).x
	
	assertEqual(isPattern(patVar(&quot;a&quot;)),		True).x
	assertEqual(isPattern(patVar(&quot;b&quot;)),		True).x

	assertEqual(isPattern(patList_nil),						True).x
	assertEqual(isPattern(patList_cons(patAny, patAny)),	True).x

	assertEqual(isPattern(patASN(patAny, patAny, patAny)),	True).x

	assertEqual(isPattern(Empty),		False).x
	assertEqual(isPattern(Nothing),		False).x
	assertEqual(isPattern(True),		False).x
	assertEqual(isPattern(False),		False).x
	assertEqual(isPattern(&quot;&quot;),			False).x
	assertEqual(isPattern(&quot;foo&quot;),		False).x
	assertEqual(isPattern(0),			False).x
	assertEqual(isPattern(1),			False).x
	assertEqual(isPattern(4711),		False).x
	assertEqual(isPattern(CLng(4711)),	False).x
	assertEqual(isPattern(3.1415),		False).x
	
	Dim f As Object
	f = isPattern	&apos; &quot;partial&quot; application
	assertEqual(arity(f),				1).x
	
	assertEqual(apply(f, Empty),		False).x
	assertEqual(apply(f, Nothing),		False).x
	assertEqual(apply(f, True),			False).x
	assertEqual(apply(f, False),		False).x
	assertEqual(apply(f, &quot;&quot;),			False).x
	assertEqual(apply(f, &quot;foo&quot;),		False).x
	assertEqual(apply(f, 0),			False).x
	assertEqual(apply(f, 1),			False).x
	assertEqual(apply(f, 4711),			False).x
	assertEqual(apply(f, CLng(4711)),	False).x
	assertEqual(apply(f, 3.1415),		False).x
End Function

Function test_Pattern_toString()
	Dim p As Object
	assertEqual(toString(patAny),   		      &quot;_&quot;).x

	assertEqual(toString(patVal(Empty)), 	     &quot;()&quot;).x

	assert_toString_equals(patVal(Nothing),   Nothing).x
	assert_toString_equals(patVal(True),	     True).x
	assert_toString_equals(patVal(False),	    False).x
	assert_toString_equals(patVal(&quot;&quot;), 		       &quot;&quot;).x
	assert_toString_equals(patVal(&quot;a&quot;), 	      &quot;a&quot;).x
	assert_toString_equals(patVal(&quot;foo&quot;), 	    &quot;foo&quot;).x
	assert_toString_equals(patVal(CR), 	  	       CR).x
	assert_toString_equals(patVal(LF), 	  	       LF).x
	assert_toString_equals(patVal(TAB),   	      TAB).x
	assert_toString_equals(patVal(    0),           0).x
	assert_toString_equals(patVal(    1),           1).x
	assert_toString_equals(patVal(    2),           2).x
	assert_toString_equals(patVal( 4711),        4711).x
	assert_toString_equals(patVal(3.1415),     3.1415).x
	assert_toString_equals(patVal(CLng(42)), CLng(42)).x
	assert_toString_equals(patVal(CLng(42)),       42).x
	
	assertEqual(toString(patVar(&quot;a&quot;)), &quot;a&quot;).x
	assertEqual(toString(patVar(&quot;b&quot;)), &quot;b&quot;).x
	
	assertEqual(toString(patDat(cons)), &quot;cons&quot;).x
	&apos;assertEqual(toString(patDat(nil)),  &quot;nil&quot;).x &apos; TODO: handle 0-arity datactors
	
	p = xpApp(xpApp(patDat(cons), patVar(&quot;x&quot;)), patVar(&quot;xs&quot;))
	assertEqual(TPattern_toString(p), &quot;((cons x) xs)&quot;).x
	
	assertEqual(toString(patList_nil), 					&quot;[]&quot;).x
	assertEqual(toString(patList_cons(patAny, patAny)), &quot;(_:_)&quot;).x
	assertEqual(toString(patList_cons(patVar(&quot;x&quot;), patList_nil)), &quot;[x]&quot;).x
	
	assertEqual(toString(patASN(patVar(&quot;lbl&quot;), patVal(Empty), patList_nil)), &quot;(ASN lbl () [])&quot;).x
End Function

Function assert_matches(p As Object, env As Variant, ByVal vs As Variant)
	assert_matches = _match_assertions(p, env, vs, envEmpty) &apos; TODO: expect particular env
End Function

Function refute_matches(p As Object, env As Variant, ByVal vs As Variant)
	refute_matches = _match_assertions(p, env, vs, Empty)
End Function

Function _match_assertions(p As Object, env As Variant, ByVal vs As Variant, expected As Variant)
	If Not(isPattern(p)) Then
		croak(IIf(isEmpty(expected), &quot;refute&quot;, &quot;assert&quot;) &amp; &quot;_matches: invalid pattern &quot; &amp; toString(p))
	End If
	Dim testResult As Object
	Dim val As Variant, i As Integer, gotArray As Boolean
	gotArray = isArray(vs)
	If Not(gotArray) Then
		vs = Array(vs)
	End If
	For i = LBound(vs) To UBound(vs)
		testResult = _single_match_assertion(p, env, vs(i), expected, gotArray, i)
		If testResult.isFail Then
			Goto _match_assertions_end
		End If
	Next i
_match_assertions_end:
	_match_assertions = testResult
End Function

Function _single_match_assertion( _
	p As Object, _
	env As Variant, _
	val As Variant, _
	expected As Variant, _
	gotArray As Boolean, _
	i As Integer _
)
	Dim matchResult As Variant, testResult As Object
	matchResult = matches(p, env, val)
	If isEmpty(matchResult) = isEmpty(expected) Then &apos; don&apos;t use assertEqual in order to avoid stupid MsgBox
		testResult = assertEqual(True, True) &apos; inc assertionCount
	Else
		Dim msg As String, valStr As String, pStr As String, eStr As String, mStr As String
		valStr = toString(val)
		pStr = toString(p)
		If isEmpty(env) Then : eStr = &quot;Empty (None)&quot;
		Else : eStr = Env_toString(env) : End If
		If isEmpty(matchResult) Then : mStr = &quot;Empty (None)&quot;
		Else : mStr = Env_toString(matchResult) : End If
		msg = &quot;pattern&quot; _
			&amp; NL &amp; &quot;  &quot; &amp; pStr _
			&amp; NL &amp; &quot;under env&quot; _
			&amp; NL &amp; &quot;  &quot; &amp; eStr _
			&amp; NL &amp; NL &amp; &quot;expected &quot; &amp; IIf(isEmpty(expected), &quot;NOT &quot;, &quot;&quot;) &amp; &quot;to match:&quot; _
			&amp; NL &amp; &quot;  &quot; &amp; valStr _
			&amp; NL &amp; NL &amp; &quot;but returned env&quot; _
			&amp; NL &amp; mStr
		If gotArray Then
			msg = &quot;at index &quot; &amp; i &amp; &quot;: &quot; _
				&amp; NL &amp; msg
		End If
		testResult = mkFail(matchResult, expected, msg)
	End If
	_single_match_assertion = testResult
End Function

Function test_Pattern_matches_Any()
	Dim p As TPattern, f As Object, e As Object
	f = matches
	e = envEmpty
	assertEqual(arity(f), 3).x
	
	p = patAny
	assert_matches(p, e, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	&apos; under env = Empty (None) it does not match anything:
	refute_matches(p, Empty, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
End Function

Function test_Pattern_matches_Val()
	Dim p As TPattern, f As Object, e As Object
	f = matches
	e = envEmpty

	p = patVal(Empty)
	assert_matches(p, e, Empty).x
	refute_matches(p, e, Array( _
		       Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	&apos; under env = Empty (None) it does not match anything:
	refute_matches(p, Empty, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
		
	p = patVal(Nothing)
	assert_matches(p, e, Nothing).x
	
	&apos; TODO: decide what match should do if it wouldn&apos;t type-check
	&apos;refute_matches(p, e, Empty			).x
	&apos;refute_matches(p, e, nil			).x
	&apos;refute_matches(p, e, List(nil)		).x
	&apos;refute_matches(p, e, List(1, 2, 3)	).x
	&apos;refute_matches(p, e, Array( _
	&apos;	Empty, _
	&apos;	nil, List(nil), List(1, 2, 3) _
	&apos;)).x
	
	f = matches(p, e)
	assertThrows(f, Array(      True)).x
	assertThrows(f, Array(     False)).x
	assertThrows(f, Array(         0)).x
	assertThrows(f, Array(         1)).x
	assertThrows(f, Array(         2)).x
	assertThrows(f, Array(      4711)).x
	assertThrows(f, Array(CLng(4711))).x
	assertThrows(f, Array(    3.1415)).x
	&apos; under env = Empty (None) it does not match anything:
	refute_matches(p, Empty, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	
	p = patVal(&quot;&quot;)
	assert_matches(p, e, &quot;&quot;).x
	refute_matches(p, e, Array( Empty, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot; )).x
	f = matches(p, e)
	assertThrows(f, Array(   Nothing)).x
	assertThrows(f, Array(      True)).x
	assertThrows(f, Array(     False)).x
	assertThrows(f, Array(         0)).x
	assertThrows(f, Array(         1)).x
	assertThrows(f, Array(         2)).x
	assertThrows(f, Array(      4711)).x
	assertThrows(f, Array(CLng(4711))).x
	assertThrows(f, Array(    3.1415)).x	
	&apos; under env = Empty (None) it does not match anything:
	refute_matches(p, Empty, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
End Function	
	
Function test_Pattern_matches_Var()
	Dim p As TPattern, f As Object, e As Object
	f = matches
	e = envEmpty
	
	p = patVar(&quot;a&quot;)
	assert_matches(p, e, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	&apos; under env = Empty (None) it does not match anything:
	refute_matches(p, Empty, Array( _
		Empty, Nothing, _
		True, False, _
		&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;foo&quot;, _
		0, 1, 2, 3, 4711, CLng(4711), 3.1415, _
		nil, List(nil), List(1, 2, 3) _
	)).x
	
	&apos; bind the var &quot;a&quot; to the value &quot;foo&quot;:
	e = matches(p, envEmpty, &quot;foo&quot;)
	&apos; under this env var-pattern &quot;a&quot; matches only &quot;foo&quot;:
	assert_matches(p, e, 		&quot;foo&quot;).x
	refute_matches(p, e, 		&quot;bar&quot;).x
	&apos; but under an env where &quot;a&quot; isn&apos;t bound it still matches anything
	e = extend(envEmpty, &quot;b&quot;, &quot;foo&quot;)
	assert_matches(p, e, &quot;foo&quot;).x
	assert_matches(p, e, &quot;bar&quot;).x
	f = matches(p, e)
	assertThrows(f, Array(   Nothing)).x
	assertThrows(f, Array(      True)).x
	assertThrows(f, Array(     False)).x
	assertThrows(f, Array(         0)).x
	assertThrows(f, Array(         1)).x
	assertThrows(f, Array(         2)).x
	assertThrows(f, Array(      4711)).x
	assertThrows(f, Array(CLng(4711))).x
	assertThrows(f, Array(    3.1415)).x	
End Function	
	
Function test_Pattern_matches_List()
	Dim p As TPattern, f As Object, e As Object
	f = matches
	e = envEmpty
	
	&apos; pattern of the empty list
	p = patList_nil
	assert_matches(p, e, nil).x
	refute_matches(p, e, List(nil)).x
	
	&apos; pattern of a non-empty list
	p = patList_cons(patVar(&quot;x&quot;), patVar(&quot;xs&quot;))
	refute_matches(p, e, nil).x
	assert_matches(p, e, List(nil)				).x
	assert_matches(p, e, List(nil, nil)			).x
	assert_matches(p, e, List(1)				).x
	assert_matches(p, e, List(1, 2, 3)			).x
	assert_matches(p, e, List(&quot;a&quot;)				).x
	assert_matches(p, e, List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)	).x
	
	&apos; pattern of a singleton list
	p = patList_cons(patVar(&quot;x&quot;), patList_nil)
	refute_matches(p, e, nil).x
	assert_matches(p, e, List(nil)				).x
	refute_matches(p, e, List(nil, nil)			).x
	assert_matches(p, e, List(1)				).x
	refute_matches(p, e, List(1, 2, 3)			).x
	assert_matches(p, e, List(&quot;a&quot;)				).x
	refute_matches(p, e, List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)	).x
	
	&apos; pattern of a list with head equal to tail (so head must be a list, too)
	p = patList_cons(patVar(&quot;x&quot;), patVar(&quot;x&quot;))
	refute_matches(p, e, nil).x
	assert_matches(p, e, List(nil)				).x
	refute_matches(p, e, List(nil, nil)			).x
	&apos;refute_matches(p, e, List(1)				).x	&apos; does not type-check (x:1 matched against a list)
	&apos;refute_matches(p, e, List(1, 2, 3)			).x &apos; -&quot;-
	&apos;assert_matches(p, e, List(&quot;a&quot;)				).x &apos; -&quot;-
	&apos;refute_matches(p, e, List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)	).x &apos; -&quot;-
	&apos;refute_matches(p, e, List(List(1), List(1))	).x &apos; does not type-check
	assert_matches(p, e, List(List(1), 1) ).x
	refute_matches(p, e, List(List(1), 2) ).x
	
	&apos; pattern of a list with first two elems equal
	p = patList_cons(patVar(&quot;x&quot;), patList_cons(patVar(&quot;x&quot;), patAny))
	refute_matches(p, e, nil).x
	refute_matches(p, e, List(nil)				).x
	assert_matches(p, e, List(nil, nil)			).x
	refute_matches(p, e, List(1)				).x
	assert_matches(p, e, List(1, 1)				).x
	refute_matches(p, e, List(1, 2)				).x
	assert_matches(p, e, List(1, 1, 3)			).x
	refute_matches(p, e, List(1, 2, 3)			).x
	assert_matches(p, e, List(1, 1, 2, 3)		).x
End Function
	
Function test_Pattern_matches_ASN()
	Dim p As Object, f As Object, e As Object, v As Object
	Dim act As Variant
	Dim x As Object, w As Object
	f = matches
	e = envEmpty

	v = mkDtTerminal(&quot;Foo&quot;)
	p = patASN(patAny, patAny, patList_nil)
	assert_matches(p, e, v).x
	p = patASN(patVal(Empty), patVar(&quot;val&quot;), patList_nil)
	assert_matches(p, e, v).x
	e = matches(p, e, v)
	assertEqual(lookup(&quot;val&quot;, e), &quot;Foo&quot;).x
	

	&apos;ASN &quot;Alt&quot;  () [x]        -&gt; x
	p = patASN(patVal(&quot;Alt&quot;), patVal(Empty), patList_cons(patVar(&quot;x&quot;), patList_nil))
	v = mkDtNonterminal(&quot;Con&quot;, List(mkDtNonterminal(&quot;Atom&quot;, List(mkASN(&quot;Terminal&quot;, &quot;foo&quot;, nil)))))
	e = envEmpty
	refute_matches(p, e, v).x
	v = mkDtNonterminal(&quot;Alt&quot;, List(v))
	assert_matches(p, e, v).x
	e = matches(p, e, v)
	assertEqual(isASN(lookup(&quot;x&quot;, e)), True).x
	assert_toString_equals(lookup(&quot;x&quot;, e), asnChild(v, 0)).x
	
	&apos;ASN lbl    () [ASN () val []] -&gt; ASN lbl v []
	&apos;inner one first:
	p = patASN(patVal(Empty), patVar(&quot;val&quot;), patList_nil)
	p = patASN(patVar(&quot;lbl&quot;), patVal(Empty), patList_cons(p, patList_nil))
	v = mkDtNonTerminal(&quot;Foo&quot;, List(mkDtTerminal(&quot;bar&quot;)))
	e = envEmpty
	assert_matches(p, e, v).x
	e = matches(p, e, v)
	assertEqual(lookup(&quot;lbl&quot;, e), &quot;Foo&quot;).x
	assertEqual(lookup(&quot;val&quot;, e), &quot;bar&quot;).x
	
	w = xpApp( _
			xpApp( _
				xpApp( _
					xpBuiltin(mkASN), _
					xpVar(&quot;lbl&quot;) _
				), _
				xpVar(&quot;val&quot;) _
			), xpVal(nil) _
		)
	w = evalX(w, e)
	&apos;show(v)
	&apos;show(w)
	assert_toString_equals(w, mkASN(&quot;Foo&quot;, &quot;bar&quot;, nil)).x
		
	&apos;ASN &quot;Con&quot;  () [x]        -&gt; x
	&apos;ASN &quot;Atom&quot; () [x]        -&gt; x
	
End Function	


</script:module>