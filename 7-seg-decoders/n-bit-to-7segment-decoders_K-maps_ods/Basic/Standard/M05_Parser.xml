<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M05_Parser" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit


Type Parser
	tyname As String
	id As Integer
	tp As String
	st As Variant
	st1 As Variant
	str As String
End Type

Public applyP_callCount As Integer
Public _applyP_callCount As Integer
Public applyP_return As Integer
Public applyP_fail As Integer
Public applyP_item As Integer
Public applyP_bind As Integer
Public applyP_bind_K_x As Integer
Public applyP_bind_K_return As Integer
Public applyP_bind_B_f_g As Integer
Public applyP_bind_B_return_g As Integer
Public applyP_choice As Integer
Public applyP_many1 As Integer
Public applyP_str As Integer
Public applyP_seq As Integer
Public applyP_skip As Integer
Public applyP_sat As Integer
Public applyP_end As Integer
Public applyP_ind As Integer

Sub Main
	test_Parser()
	Stop
	Dim s As String
	Set pHexLit = pSeq(Array(pStr(&quot;0x&quot;), pHexNum), &quot;sndArg&quot;)
	Dim p As Parser 
	&apos;pChoice(pItem(), pReturn(&quot;bar&quot;))
	Set p = pSeq(Array(pHexLit, pMany(pWhite)), &quot;fstArg&quot;)
	s = &quot;FF 0x1F __µ 0&quot;

	MsgBox( _
		&quot;applying parser &apos;&quot; &amp; p.tp &amp; &quot;&apos; to &quot; &amp; toString(s) &amp; &quot;: &quot; &amp; chr(13) _
		&amp; toString(applyP(p, s)) _
	)
End Sub

&apos;==================================================================

Function TParser_toString(Optional ByVal p As Variant)
	Dim result As Variant
	If isMissing(p) Then
		result = Fn.TParser_toString
	Else
		If isString(p) Then
			p = lookupParser(p)
		End If
		Dim rules As Object
		rules = nil
		result = _TParser_toString(p, 0, &quot;&quot;, False, rules)
		If Not(isNil(rules)) Then
			Dim newLine As String
			newLine = chr(13) &amp; chr(10)
			result = result &amp; &quot; where&quot; &amp; newLine _
				   &amp; Join(toArray(rules), newLine)
		End If
	End If
	TParser_toString = result
End Function

Function _TParser_toString( _
	ByVal p As Object, _
	ByRef k As Integer, _
	ByVal indent As String, _
	ByVal isNewLines As Boolean, _
	ByRef rules As Object _
)
	Dim result As String, f As Object
	If p.str &lt;&gt; &quot;&quot; Then
		result = p.str
	Else : Select Case p.tp
		Case &quot;ind&quot;
			If isNull(p.st) Then &apos; yet uninitialized indirection
				result = &quot;(ind &quot; &amp; p.id &amp; &quot; Nothing)&quot;
			ElseIf isString(p.st1) Then &apos; seen it before
				result = p.st1 &apos; contains a name like P123
			Else &apos; initialized but not seen before
				p.st1 = &quot;P&quot; &amp; p.st.id
				result = p.st1 &amp; &quot; ::= &quot;
				&apos; In the new rule, start over fresh indent and var counter
				indent = Space(Len(result))
				Dim j As Integer
				j = 0
				result = result &amp; _TParser_toString(p.st, j, indent, True, rules)
				rules = cons(result, rules)
				result = p.st1
				p.st1 = Nothing
			End If
		Case &quot;sat&quot;
			result = &quot;(sat &quot;
			If isPartialApp(p.st) Then
				result = result &amp; &quot;(&quot; &amp; TFn_toString(p.st) &amp; &quot;)&quot;
			Else
				result = result &amp; getFnName(p.st)
			End If
			result = result &amp; &quot;)&quot;
		Case &quot;fail&quot;:		result = &quot;fail&quot;
		Case &quot;return&quot;:		result = &quot;(return &quot; &amp; toString(p.st) &amp; &quot;)&quot;
		Case &quot;item&quot;: 		result = &quot;item&quot;
		Case &quot;str&quot;:			result = &quot;(str &quot; &amp; toString(p.st(0)) &amp; &quot;)&quot;
		Case &quot;strXXX&quot;:			result = toString(p.st(0))
		Case &quot;skip&quot;
			result = &quot;(skip &quot; &amp; _TParser_toString(p.st, k, indent, False, rules) &amp; &quot;)&quot;
		Case &quot;many1&quot;
			If p.st.tp = &quot;choice&quot; Then
				result = &quot;(&quot; &amp; _TParser_toString(p.st, k, indent &amp; &quot; &quot;, False, rules) &amp; &quot;)&quot;
			Else
				result = _TParser_toString(p.st, k, indent, False, rules)
			End If
			result = result &amp; &quot;+&quot;
		Case &quot;choice&quot;
			Dim alts As Object
			alts = p.st
			If isPZeroOrOne(p) Then
				&apos; it has shape p +++ return Empty
				&apos; so it&apos;s effectively &quot;zero-or-one&quot; p, which can be written as &quot;p?&quot;
				
				If alts(0).tp = &quot;choice&quot; Then
					result = &quot;(&quot; &amp; _TParser_toString(alts(0), k, indent &amp; &quot; &quot;, False, rules) &amp; &quot;)&quot;
				Else
					result = _TParser_toString(alts(0), k, indent, False, rules)
				End If
				result = result &amp; &quot;?&quot;
			ElseIf isPMany(p) Then
				&apos; it has shape many1 p +++ return nil
				If alts(0).st.tp = &quot;choice&quot; Then
					result = &quot;(&quot; &amp; _TParser_toString(alts(0).st, k, indent &amp; &quot; &quot;, False, rules) &amp; &quot;)&quot;
				Else
					result = _TParser_toString(alts(0).st, k, indent, False, rules)
				End If
				result = result &amp; &quot;*&quot;
			Else
				If isNewLines Then
					result = _TParser_toString(alts(0), k, indent, isNewLines, rules) _
						   &amp; chr(13) &amp; chr(10) _
						   &amp; space(len(indent) - 2) _
						   &amp; &quot;| &quot; _
						   &amp; _TParser_toString(alts(1), k, indent, isNewLines, rules)
				Else
					result = _TParser_toString(alts(0), k, indent, isNewLines, rules) _
						   &amp; &quot; | &quot; _
						   &amp; _TParser_toString(alts(1), k, indent, isNewLines, rules)
				End If
			End If
		Case &quot;bind&quot;
			Dim q As Object
			q = p.st(0)
			f = p.st(1)
			result = _TParser_toString(q, k, indent, False, rules) _
					&amp; &quot; &gt;&gt;= &quot; &amp; TFn_toString(f)
		Case &quot;seq&quot;
			Dim ps As Variant, i As Integer
			Dim fName As String, args As String
			ps = p.st(0)
			f  = p.st(1)
			fName = getFnName(f)
			result = &quot;(do &quot;
			Dim addIndent As String, newLine As String, innerIndent As String
			addIndent = Space(Len(result))
			newLine = chr(13) &amp; chr(10) &amp; indent
			innerIndent = indent &amp; addIndent &amp; Space(Len(&quot;aX &lt;- &quot;))
			For i = LBound(ps) To UBound(ps)
				If isPSkip(ps(i)) Then
					result = result &amp; &quot; _ &lt;- &quot; _
									&amp; _TParser_toString(ps(i).st, k, innerIndent, False, rules)
				Else
					result = result &amp; &quot;a&quot; &amp; k
					args = args &amp; &quot; a&quot; &amp; k
					k = k + 1
					result = result &amp; &quot; &lt;- &quot; _
									&amp; _TParser_toString(ps(i), k, innerIndent, False, rules)
				End If
				result = result &amp; newLine
				If i &lt; UBound(ps) Then
					result = result &amp; addIndent
				End If
			Next i
			result = result &amp; &quot; return&quot;
			If isPartialApp(f) Then
				result = result &amp; &quot; (&quot; &amp; TFn_toString(f) &amp; args &amp; &quot;)&quot;
			Else
				If fName = &quot;id&quot; Then
					result = result &amp; args
				Else
					result = result &amp; &quot; (&quot; &amp; fName &amp; args &amp; &quot;)&quot;
				End If
			End If
			result = result &amp; newLine &amp; &quot;)&quot;
		Case Else
			croak(&quot;TParser_toString/NYI: .tp = &quot; &amp; toString(p.tp))
	End Select : End If
	_TParser_toString = result
End Function

Function mkParser(Optional tp As String, Optional st As Variant)
	Static oFn As Object
	Static instId As Long
	Dim result As Object
	If isMissing(st) Then
		If isNull(oFn) Then : Set oFn = Fn.mkParser : End If
		If isMissing(tp) Then
			result = oFn
		Else
			result = apply1(oFn, tp)
		End If
	Else
		Set result = New Parser
		result.tyname = &quot;TParser&quot;
		result.id = instId
		instId = instId + 1
		result.tp = tp
		result.st = st
	End If
	mkParser = result
End Function

Function parseFailure()
	parseFailure = Empty
End Function

Function isParseFailure(parseResult) As Boolean
	isParseFailure = isEmpty(parseResult)
&apos;	If typeOf(parseResult) &lt;&gt; typeOf(parseFailure) Then
&apos;		isParseFailure = False
&apos;	Else
&apos;		isParseFailure = equ(parseResult, parseFailure)
&apos;	End If
End Function

&apos; always fails on any string; failure is indicated by returning parseFailure()
Function pFail()
	Static result As Object
	If isNull(result) Then : result = mkParser(&quot;fail&quot;, Nothing) : End If
	pFail = result
End Function

&apos; always succeeds by returning the provided value; without increasing pos
Function pReturn(Optional v As Variant)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.pReturn : End If
	Static returnEmpty As Object : If isNull(returnEmpty) Then : returnEmpty = mkParser(&quot;return&quot;, Empty) : End If
	If isMissing(v) Then
		pReturn = oFn
	ElseIf isEmpty(v) Then
		pReturn = returnEmpty
	Else
		pReturn = mkParser(&quot;return&quot;, v)
	End If
End Function

&apos; monadic bind, aka &quot;&gt;&gt;=&quot;
&apos; for the Parser type that is the fn of type Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b
&apos; which applies the Parser p and if that succeeds feeds its result to the fn f
&apos; to give the overall result Parser b that f returns
Function pBind(Optional p As Parser, Optional f As Object)
	Dim oFn As Object : If isNull(oFn) Then : oFn = Fn.pBind : End If
	If isMissing(f) Then
		If isMissing(p) Then
			pBind = oFn
		Else
			&apos; TODO: pBind: check if p is proper Parser
			pBind = apply(oFn, p)
		End If
	Else
		bindStats(p, f)
		&apos; TODO: pBind: check if f is proper function
		pBind = mkParser(&quot;bind&quot;, Array(p, f))
	End If
End Function

Function isKsomething(f As Object) As Boolean
	isKsomething = (getFnName(f) = getFnName(Fn.fstArg)) And (arity(f) = 1)
End Function

Function isKreturn(f As Object) As Boolean
	Dim result As Boolean
	result = False
	If isKsomething(f) Then
		Dim v As Object
		v = car(partialArgs(f))
		If v.tp = &quot;return&quot; Then
			result = True
		End If
	End If
	isKreturn = result
End Function

Function isBsomething(f As Object) As Boolean
	isBsomething = (getFnName(f) = getFnName(Fn.compose)) And (arity(f) = 1)
End Function

Function isBreturn(f As Object) As Boolean
	Dim result As Boolean
	result = False
	If isBsomething(f) Then
		Dim v As Object
		v = cadr(partialArgs(f)) &apos; they&apos;re in reverse!
		If getFnName(v) = getFnName(Fn.pReturn) Then
			result = True
		End If
	End If
	isBreturn = result
End Function

Function bindFns(Optional f As Object)
	Static fns As Object : If isNull(fns) Then : fns = nil : End If
	If isMissing(f) Then
		Dim x As Object, xs As Object, out As Object, xStr As String
		xs = fns
		out = nil
		While Not(isNil(xs))
			x = car(xs)
			If isKsomething(x) Then
				x = car(partialArgs(x))
				If x.tp = &quot;ind&quot; Then
					If isNull(x.st) Then
						xStr = &quot;K P???&quot; &amp; x.id
					Else
						xStr = &quot;K P&quot; &amp; x.st.id
					End If
				Else
					xStr = &quot;K &quot; &amp; TParser_toString(x)
				End If
			ElseIf isBsomething(x) Then
				Dim g As Object, h As Object
				g = cadr(partialArgs(x)) &apos; they&apos;re in reverse order!
				h = car(partialArgs(x))
				xStr = &quot;B (&quot; &amp; getFnName(g) &amp; &quot;...) (&quot; &amp; getFnName(h) &amp; &quot;...)&quot;
			Else
				xStr = TFn_toString(x)
			End If
			out = cons(chr(10) &amp; &quot;  &quot; &amp; xStr, out)
			xs = cdr(xs)
		Wend
		bindFns = out
	Else
		fns = cons(f, fns)
		bindFns = fns
	End If
End Function

Function bindStats(p As Parser, f As Object)
	&apos;If isKsomething(f) Then
		bindFns(f)
	&apos;End If
End Function

&apos; fails on empty string but succeeds on all others
&apos; by returning the first character; and increasing pos by 1
Function pItem()
	Static result As Object
	If isNull(result) Then : result = mkParser(&quot;item&quot;, Nothing) : End If
	pItem = result
End Function

&apos; succeeds on empty string (by returning Empty) but fails on all others
Function pEnd()
	Static result As Object
	If isNull(result) Then : result = mkParser(&quot;end&quot;, Empty) : End If
	pEnd = result
End Function

Function pSat(predicate As Object)
&apos;	pSat = pBind( pItem, ite(predicate, pReturn, fstArg(pFail)) )
	pSat = mkParser(&quot;sat&quot;, predicate)
End Function

&apos; pattern-matches p against &quot;q &gt;&gt;= K (return Empty)&quot; where q any parser
Function isPSkip(p As Parser)
	Dim result As Boolean : result = False
	If p.tp = &quot;skip&quot; Then
		result = True
	&apos;ElseIf p.tp = &quot;bind&quot; Then
	&apos;	Dim f As Object
	&apos;	f = p.st(1)
	&apos;	If (getFnName(f) = getFnName(Fn.fstArg)) And (arity(f) = 1) Then
	&apos;		Dim innerP As Object
	&apos;		innerP = car(partialArgs(f))
	&apos;		result = (innerP.tp = &quot;return&quot;) And isEmpty(innerP.st)
	&apos;	End If
	End If
	isPSkip = result
End Function

Function pSkip(p As Object)
	Dim result As Variant
	Select Case p.tp
		Case &quot;fail&quot;:	result = p
		Case &quot;return&quot;:	result = pReturn(Empty)
		Case Else
			If isPSkip(p) Then
				result = p
			Else
				&apos;result = pBind(p, fstArg(pReturn(Empty)))
				result = mkParser(&quot;skip&quot;, p)
			End If
	End Select
	pSkip = result
End Function

&apos; succeeds on strings with the given prefix t by returning t,
&apos; and advancing pos by the length of t
Function pStr(Optional t As String)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.pStr : End If
	If isMissing(t) Then
		pStr = oFn
	Else
		If (Len(t) = 0) Then
			croak(&quot;pStr: cannot match &apos;exactly&apos; the empty string t=&apos;&apos;&quot;)
		Else
			pStr = mkParser(&quot;str&quot;, Array(t, Len(t)))
		End If	
	End If
End Function

&apos;Function pSat(predicate)
&apos;	pBind(pItem, ite(predicate, pReturn, fstArg(pFail))
&apos;End Function

&apos; succeeds if either p1 succeeds (then returning p1&apos;s result and pos)
&apos; or (and only if p1 fails) if p2 succeeds, returns p2&apos;s result and pos.
&apos; fails if both, p1 and p2 fail
Function pChoice(Optional p1 As Parser, Optional p2 As Parser)
	Dim oFn As Object
	If isNull(oFn) Then
		&apos;list1 = swap(cons, nil)
		&apos;      = \y.(swap cons) nil y
		&apos;      = \y.cons y nil
		&apos;      :: a -&gt; [a]
		&apos;list2 = (swap cons) ° list1 
		&apos;      =   \y.(swap cons) list1 y
		&apos;      =   \y.(swap cons) (\y.cons y nil) y
		&apos;      =   \y.(swap cons) (cons y nil)
		&apos;      = \x y.(swap cons) (cons y nil) x 
		&apos;      = \x y.cons x (cons y nil)
		&apos;      :: a -&gt; a -&gt; [a]
		Set oFn = Fn.pChoice
	End If
	If isMissing(p1) Then
		pChoice = oFn
	ElseIf isMissing(p2) Then
		pChoice = apply(oFn, p1)
	Else
		&apos; TODO: @pChoice: strip out always failing parsers
		&apos; TODO: @pChoice: if p1 always succeeds strip out p2
		&apos; linearize choice of choice:
		If (p1.tp = &quot;choice&quot;) Then
			pChoice = pChoice(p1.st(0), pChoice(p1.st(1), p2))
		Else
			If (p1.tp = &quot;ind&quot;) Then
				If isNull(p1.st) Then
					&apos;msgbox(&quot;pChoice: &quot; &amp; toString(mkParser(&quot;choice&quot;, Array(p1, p2)))
				ElseIf (p1.st.tp = &quot;choice&quot;) Then
					msgbox(&quot;pChoice!: &quot; &amp; toString(mkParser(&quot;choice&quot;, Array(p1, p2)))
				End If
			End If
			pChoice = mkParser(&quot;choice&quot;, Array(p1, p2))
		End If
	End If
End Function

&apos; pattern-matches p against &quot;q +++ return Empty&quot; where q any parser
Function isPZeroOrOne(p As Parser)
	Dim result As Boolean : result = False
	If p.tp = &quot;choice&quot; Then
		Dim sndAlt As Object &apos; 2nd alternative
		sndAlt = p.st(1)
		&apos; check if it has shape p +++ return Empty (which is effectively &quot;zero-or-one&quot; p)
		result = ((sndAlt.tp = &quot;return&quot;) And isEmpty(sndAlt.st))
	End If
	isPZeroOrOne = result
End Function

&apos; never fails: if p fails than pZeroOrOne(p) returns Empty + same pos as result,
&apos; otherwise returns whatever p returns as result (+ pos)
&apos; matches at most once
Function pZeroOrOne(p As Parser)
	If isPZeroOrOne(p) Then
		pZeroOrOne = p
	Else
		pZeroOrOne = pChoice(p, pReturn(Empty))
	End If
End Function

Function isPMany1(p As Parser) As Boolean
	isPMany1 = (p.tp = &quot;many1&quot;)
End Function

Function isPMany(p As Parser) As Boolean
	Dim result As Boolean
	result = False
	If p.tp = &quot;many&quot; Then
		result = True
	ElseIf p.tp = &quot;choice&quot; Then
		Dim sndAlt As Object
		sndAlt = p.st(1)
		&apos; check if it has shape p +++ return Empty (which is effectively &quot;zero-or-one&quot; p)
		If (sndAlt.tp = &quot;return&quot;) And isObject(sndAlt.st) Then
			If isNil(sndAlt.st) Then
				result = isPMany1(p.st(0))
			End If
		End If
	End If
	isPMany = result
End Function

&apos; pMany: never fails: if p fails then pMany(p) returns nil + same pos as result,
&apos; otherwise returns a of p results (in the order as in the parsed string) + last pos
&apos; matches as many as possible
Function pMany(p As Parser)
	&apos; Note: direct impl might give a little more perf (not worth it)
	pMany = pChoice(pMany1(p), pReturn(nil))
End Function

&apos; pMany1: same as pMany except that it fails if there is no match at all
&apos; matches as many as possible
Function pMany1(p As Parser)
	pMany1 = mkParser(&quot;many1&quot;, p)
End Function

&apos; pSeq: make a sequence of parsers, collect their results in a list 
&apos; and finally process that list by passing it to the given function
&apos; fails if any of the given parsers fails
&apos; if instead all succeed, collects their results in a list 
&apos; which is then passed on the the given function. The result
&apos; of this function application is then packed up with the last
&apos; parsers pos to give the overall result
Function pSeq(ps As Array, ByVal f As Variant)
	&apos;TODO: pSeq: check if ps is proper Array of Parsers
	f = asFn(f, &quot;pSeq: invalid 2nd arg &quot; &amp; toString(f))
	pSeq = mkParser(&quot;seq&quot;, Array(ps, f))
End Function

&apos; pInd: for building recursive parsers; returns a dummy Parser instance
&apos; which serves as an indirection to another Parser. This pointer later 
&apos; has to set calling fixIndirection with the dummy and the actual instance
Function pInd()
	pInd = mkParser(&quot;ind&quot;, Nothing)
End Function

Function fixIndirection(dummy As Parser, target As Parser)
	If dummy.tp &lt;&gt; &quot;ind&quot; Then
		croak(&quot;fixIndirection: invalid dummy - tp = &quot; &amp; dummy.tp
	End If
	If Not(isNull(dummy.st)) Then
		croak(&quot;fixIndirection: cannot set target &quot; &amp; target.id &amp; &quot; - already points to &quot; &amp; dummy.st.id)
	End If
	dummy.st = target
	fixIndirection = dummy
End Function


&apos;==================================================================


Function pWhite()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = pChoice(pStr(&quot; &quot;), pStr(Chr(9))
		result.str = &quot;[ \t]&quot;
	End If
	pWhite = result
End Function

Function pAlphaLower()
	Static result As Object
	If isNull(result) Then
		result = pSat(compose(inRange(Asc(&quot;a&quot;), Asc(&quot;z&quot;)), Fn.asc))
		result.str = &quot;[a-z]&quot;
	End If
	pAlphaLower = result
End Function

Function pAlphaUpper()
	Static result As Object
	If isNull(result) Then
		result = pSat(compose(inRange(Asc(&quot;A&quot;), Asc(&quot;Z&quot;)), Fn.asc))
		result.str = &quot;[A-Z]&quot;
	End If
	pAlphaUpper = result
End Function

Function pBinDigit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = pChoice(_
			pBind(pStr(&quot;0&quot;), fstArg(pReturn(0))), _
			pBind(pStr(&quot;1&quot;), fstArg(pReturn(1)))_
		)
		&apos;&apos;not paying off (yet):
&apos;		result = pBind(pItem, compose(ite(inRange(Asc(&quot;0&quot;), Asc(&quot;1&quot;)), compose(pReturn, add(-Asc(&quot;0&quot;))), fstArg(pFail)), Fn.asc)
	End If
	pBinDigit = result
End Function

Function pDecDigit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		&apos;result = pChoice(pBinDigit,	pBind(pStr(&quot;2&quot;), fstArg(pReturn(2))))
		&apos;result = pChoice(result,	pBind(pStr(&quot;3&quot;), fstArg(pReturn(3))))
		&apos;result = pChoice(result,	pBind(pStr(&quot;4&quot;), fstArg(pReturn(4))))
		&apos;result = pChoice(result,	pBind(pStr(&quot;5&quot;), fstArg(pReturn(5))))
		&apos;result = pChoice(result,	pBind(pStr(&quot;6&quot;), fstArg(pReturn(6))))
		&apos;result = pChoice(result,	pBind(pStr(&quot;7&quot;), fstArg(pReturn(7))))
		&apos;result = pChoice(result,	pBind(pStr(&quot;8&quot;), fstArg(pReturn(8))))
		&apos;result = pChoice(result,	pBind(pStr(&quot;9&quot;), fstArg(pReturn(9))))
		&apos;pDecDigit = result
		&apos;Exit Function

		&apos;&apos;not really paying off (yet):
		Dim f as Object
		&apos;Set f = compose(add(-Asc(&quot;0&quot;)), Fn.asc)
		&apos;MsgBox(TFn_toString(f))
		Set f = compose(ite(inRange(Asc(&quot;0&quot;), Asc(&quot;9&quot;)), compose(pReturn, add(-Asc(&quot;0&quot;))), fstArg(pFail)), Fn.asc)
		result = pBind(pItem, f)
	End If
	pDecDigit = result
End Function

Function pHexDigit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
&apos;		result = pChoice(pDecDigit,	pBind(pChoice(pStr(&quot;A&quot;), pStr(&quot;a&quot;)), fstArg(pReturn(10))) )
&apos;		result = pChoice(result,	pBind(pChoice(pStr(&quot;B&quot;), pStr(&quot;b&quot;)), fstArg(pReturn(11))) )
&apos;		result = pChoice(result,	pBind(pChoice(pStr(&quot;C&quot;), pStr(&quot;c&quot;)), fstArg(pReturn(12))) )
&apos;		result = pChoice(result,	pBind(pChoice(pStr(&quot;D&quot;), pStr(&quot;d&quot;)), fstArg(pReturn(13))) )
&apos;		result = pChoice(result,	pBind(pChoice(pStr(&quot;E&quot;), pStr(&quot;e&quot;)), fstArg(pReturn(14))) )
&apos;		result = pChoice(result,	pBind(pChoice(pStr(&quot;F&quot;), pStr(&quot;f&quot;)), fstArg(pReturn(15))) )
		&apos;pHexDigit = result
		&apos;Exit Function

		&apos;&apos;not really paying off (yet):
		Dim retZero As Object, retUpperA As Object, retLowerA As Object, Kfail As Object
		Set retZero   = compose(pReturn, add(  -Asc(&quot;0&quot;)))
		Set retUpperA = compose(pReturn, add(10-Asc(&quot;A&quot;)))
		Set retLowerA = compose(pReturn, add(10-Asc(&quot;a&quot;)))
		Set Kfail = fstArg(pFail)
		result = pBind(pItem, compose( _
			ite( inRange(Asc(&quot;0&quot;), Asc(&quot;9&quot;)), _
				retZero, _
				ite(inRange(Asc(&quot;A&quot;), Asc(&quot;F&quot;)), _
					retUpperA, _
					ite(inRange(Asc(&quot;a&quot;), Asc(&quot;f&quot;)), _
						retLowerA, _
						fstArg(pFail) _
					) _
				) _
			), Fn.asc) _
		)

	End If
	pHexDigit = result
End Function

Function pHexNum()
	Static result As Object
	If isNull(result) Then
		&apos;foldl1 compose(plus, mul 16)
		Set result = pSeq(Array(pMany1(pHexDigit)), apply(Fn.foldl1, compose(add, mul(16))))
	End If
	pHexNum = result
End Function

Function pHexLit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = pSeq(Array(pStr(&quot;0x&quot;), pHexNum), sndArg)
	End If
	pHexLit = result
End Function

&apos; Type expressions: base types (atomic/built-in types), arrow types (fns), and n-ary Type constructors
&apos; Grammar for type expressions:
&apos;   TypeExpr ::= ws* N ws* (&quot;-&gt;&quot; TypeExpr)?		; &quot;ws&quot; means whitespace, &quot;*&quot; means many and &quot;?&quot; zeroOrOne
&apos;          N ::= BaseType			; need extra rule &quot;N&quot; for &quot;-&gt;&quot; to bind most strongly
&apos;              | TypeVar
&apos;              | TypeCtor (ws+ N)*	; &quot;+&quot; means many1
&apos;              | &quot;(&quot; TypeExpr &quot;)&quot;
&apos;   BaseType ::= &quot;Bool&quot; | &quot;Str&quot; | &quot;Int&quot; | &quot;Long&quot; | ...
&apos;    TypeVar ::= [a-z]
&apos;   TypeCtor ::= &quot;List&quot; | &quot;Maybe&quot; | ...
&apos; This makes the binary (infix) type constructor &quot;-&gt;&quot; right-associative
&apos; and also make it bind more weakly than any other type constructor 
&apos; &quot;TypeCtor&quot;.
&apos; For example: &quot;Parser a -&gt; b&quot; = &quot;(Parser a) -&gt; b&quot;; NOT &quot;Parser (a -&gt; b)&quot;
&apos; Now, this grammar is tricky to implement because it contains both,
&apos; - simple recursion (TypeExpr in TypeExpr and N in N)
&apos; - mutual recursion (N in TypeExpr and TypeExpr in N)
Function pTypeExpr()
	Static result As Object
	If isNull(result) Then
		Dim pRight As Object
		Dim pS As Object
		Dim pParenS As Object
		Dim pTypeArg As Object
		Dim pCtor As Object
		Dim pN As Object
		Dim recDummy As Object
		
		pS = pInd
		pN = pInd

		&apos; Right ::= &quot;-&gt;&quot; S
		&apos; pRight = do _ &lt;- (str &quot;-&gt;&quot;)
		&apos;             s &lt;- S
		&apos;          return s
		&apos;pRight = pSeq(Array(pSkip(pStr(&quot;-&gt;&quot;)), pS), id)
		pRight = pBind(pStr(&quot;-&gt;&quot;), fstArg(pS))
		
		&apos; S ::= ws* N ws* ((str &quot;-&gt;&quot;) S)?
		&apos; pS = do   _ &lt;- many white
		&apos;		   in &lt;- S
		&apos;           _ &lt;- many white
		&apos;         out &lt;- zeroOrOne pRight
		&apos;      return (if (empty? out) in else (mkArrowType in out))
		pS = fixIndirection(pS, _
				pSeq(Array(pSkip(pMany(pWhite)), _
						   pN, _
						   pSkip(pMany(pWhite)), _
						   pZeroOrOne(pRight) _
				  	 ), Fn.maybeMakeArrowType _
			  )	)
		
		&apos; ParenS ::= &quot;(&quot; S &quot;)&quot;
		pParenS = pSeq(Array(pSkip(pStr(&quot;(&quot;)), _
							 pS, _
						     pSkip(pStr(&quot;)&quot;)) _
					   ), id)
		
		&apos; TypeArg ::= ws+ N
		&apos;pTypeArg = pSeq(Array(pSkip(pMany1(pWhite)), pN), id)
		pTypeArg = pBind(pSkip(pMany1(pWhite)), fstArg(pN))
		
		&apos; Ctor ::= TypeCtor pTypeArg*
		pCtor = pSeq(Array( _
						pTypeCtor, _
						pMany(pTypeArg) _
					), Fn.mkTypeCtor _
				)
		
		&apos; N ::= ParenS | BaseType | Ctor | TypeVar
		pN = fixIndirection( pN, _
			foldl1(pChoice, List(pBaseType, pTypeVar, pParenS, pCtor)) _
		)
			
		result = pS
		&apos;MsgBox(toString(result))
		&apos;Stop
	End If
	pTypeExpr = result
End Function

Function pBaseType()
	Static result As Object
	If isNull(result) Then
		result = foldl1(pChoice, _
						map(pStr, List(&quot;Bool&quot;, &quot;Str&quot;, &quot;Int&quot;, &quot;Long&quot;)) _
		)
		&apos;msgbox(toString(result))
	End If
	pBaseType = result
End Function

Function pTypeVar()
	pTypeVar = pBind(pAlphaLower, compose(pReturn, concat(&quot;&apos;&quot;)))
&apos;	pTypeVar = pSeq(Array(pAlphaLower), concat(&quot;&apos;&quot;))
End Function

Function pTypeCtor()
	Static result As Object
	If isNull(result) Then
&apos;		result = foldl1( pChoice, _
&apos;						 map(pStr, List(&quot;List&quot;, &quot;Maybe&quot;, &quot;Parser&quot;)) )

		&apos; \a bs.foldl1 concat (cons a bs)
		result = pSeq(_
					Array(pSeq(_
							Array(pAlphaUpper, pMany1(pAlphaLower)), _
							cons _
						  ) _
					), _
					foldl1(concat) _
		)
	End If
	pTypeCtor = result
End Function

Function mkArrowType(tIn, tOut)
	mkArrowType = &quot;(-&gt; &quot; &amp; tIn &amp; &quot; &quot; &amp; tOut &amp; &quot;)&quot;
End Function

Function maybeMakeArrowType(i, o)
	If isEmpty(o) Then
		maybeMakeArrowType = i
	Else
		maybeMakeArrowType = mkArrowType(i, o)
	End If
End Function

Function mkTypeCtor(ctorName As String, typeArgs As Object)
	Dim result As String
	result = &quot;(&quot; &amp; ctorName
	If isNil(typeArgs) Then
		result = result &amp; &quot; [])&quot;
	Else
		Dim toStr As Object
		&apos;  \acc a.concat acc (concat &quot;, &quot; a)
		&apos;= \acc a.(swap concat) (concat &quot;, &quot; a) acc
		&apos;= swap \a acc.(swap concat) (concat &quot;, &quot; a) acc
		&apos;= swap \a.(swap concat) (concat &quot;, &quot; a)
		&apos;= swap ((swap concat) ° (concat &quot;, &quot;))
		toStr = swap(compose(swap(concat) , concat(&quot;, &quot;)))
		result = result &amp; &quot; [&quot; &amp; foldl1(toStr, typeArgs) &amp; &quot;])&quot;
	End If
	mkTypeCtor = result
End Function


&apos; =============================================================================

Function lookupParser(pName As String) As Parser
	Dim result As Parser
	Select Case pName
		Case &quot;pWhite&quot;:		result = pWhite
		Case &quot;pBinDigit&quot;:	result = pBinDigit
		Case &quot;pDecDigit&quot;:	result = pDecDigit
		Case &quot;pHexDigit&quot;:	result = pHexDigit
		Case &quot;pHexNum&quot;:		result = pHexNum
		Case &quot;pTypeExpr&quot;:	result = pTypeExpr
		Case Else
			croak(&quot;unknown parser &quot; &amp; pName)
	End Select
	lookupParser = result
End Function

Function parse(pName As String, s As String)
	Dim result As String
	result = toString(applyP(lookupParser(pName), s))
	if (result = &quot;Empty&quot;) then
		MsgBox(pName &amp; &quot; on &quot; &amp; tostring(s) &amp; &quot; yielded &quot; &amp; result)
	end if
	parse = result
End Function

Function applyP(ByVal parser As Variant, s As String, Optional pos As Integer)
	applyP_callCount = applyP_callCount + 1
	Dim p As Parser
	If IsNull(parser) Or IsEmpty(parser) Then
		croak(&quot;applyP: invalid arg parser - &quot; &amp; toString(parser))
	ElseIf TypeName(parser) = &quot;Object&quot; Then
		Set p = parser
	Else
		croak(&quot;applyP: invalid arg parser - &quot; &amp; toString(parser))
	End If
	If IsMissing(pos) Then
		pos = 1
	End If
	Dim endPos As Integer, parseResult As Variant
	parseResult = _applyP(p, s, pos, endPos, False)
	If endPos &lt; 0 Then &apos; indicates failure
		applyP = parseFailure
	Else &apos; package up result and endPos for the outside world			
		applyP = Array(parseResult, endPos)
	End If
End Function

Function _applyP( _
	ByVal p As Parser, _
	ByRef s As String, _
	ByVal pos As Integer, _
	ByRef endPos As Integer, _
	ByVal isUnderSkip As Boolean _
)
	_applyP_callCount = _applyP_callCount + 1
	Dim result As Variant
	Dim i As Integer
	Dim innerParser As Parser
	Dim innerParsers As Variant
	Dim lst As Object
	
_applyP_begin:
	&apos;_applyP_stats(p, s, pos, endPos, isUnderSkip)
	Select Case p.tp
		Case &quot;str&quot;
			Dim match As String
			Dim matchLen As Integer
			match = p.st(0)
			matchLen = p.st(1)
			If (Mid(s, pos, matchLen) &lt;&gt; match) Then
				Goto _applyP_parseFailure
			End If
			endPos = pos + matchLen
			If Not(isUnderSkip) Then
				result = match
			End If
		Case &quot;choice&quot;	&apos; tail-recursive
			result = _applyP(p.st(0), s, pos, endPos, isUnderSkip)
			If endPos &lt; 0 Then
				&apos;result = _applyP(p.st(1), s, pos, endPos, isUnderSkip)
				p = p.st(1)
				Goto _applyP_begin
			End If
		Case &quot;item&quot;
			If pos &gt; Len(s) Then
				Goto _applyP_parseFailure
			End If
			endPos = pos + 1
			If Not(isUnderSkip) Then
				result = Mid(s, pos, 1)
			End If
		Case &quot;return&quot;
			If Not(isUnderSkip) Then
				result = p.st
			End If
			endPos = pos
		Case &quot;bind&quot;	&apos; tail-recursive
			&apos;ATTENTION: when applying the parser (bind&apos;s 1st arg)
			&apos;           we MUST NOT propagate down isUnderSkip
			&apos;           because the fn (bind&apos;s 2nd arg) might need it
			result = _applyP(p.st(0), s, pos, endPos, False)
			If endPos &lt; 0 Then : Exit Function : End If
			&apos;HOWEVER: when applying the parser produced by the fn
			&apos;         we must do this under the isUnderSkip:
			&apos;result = _applyP(apply1(p.st(1), result), s, endPos, endPos, isUnderSkip)
			p = apply1(p.st(1), result)
			pos = endPos
			If isUnderSkip Then : result = Empty : End If
			Goto _applyP_begin
		Case &quot;seq&quot;
			innerParsers = p.st(0)
			If isUnderSkip Then
				For i = LBound(innerParsers) To UBound(innerParsers)
					_applyP(innerParsers(i), s, pos, endPos, True)
					If endPos &lt; 0 Then : Exit Function : End If
					pos = endPos
				Next		
			Else
				lst = nil
				For i = LBound(innerParsers) To UBound(innerParsers)
					innerParser = innerParsers(i)
					result = _applyP(innerParser, s, pos, endPos, False)
					If endPos &lt; 0 Then : Exit Function : End If
					pos = endPos
					&apos; TODO: precalculate isPSkip check in pSeq
					If Not(isPSkip(innerParser)) Then
						lst = cons(result, lst)
					End If
				Next
				result = applyToList(p.st(1), reverse(lst))
			End If
		Case &quot;skip&quot;	&apos; tail-recursive
			p = p.st
			isUnderSkip = True
			Goto _applyP_begin
			&apos;result = _applyP(p.st, s, pos, endPos, True)
			&apos;If endPos &gt; 0 Then
			&apos;	assertEqual(result, Empty).x
			&apos;End If
		Case &quot;sat&quot;
			If pos &gt; Len(s) Then
				Goto _applyP_parseFailure
			End If
			result = Mid(s, pos, 1)
			If Not(apply(p.st, result)) Then
				Goto _applyP_parseFailure
			End If
			endPos = pos + 1
			If isUnderSkip Then
				result = Empty
			End If
		Case &quot;many1&quot;
			innerParser = p.st
			If isUnderSkip Then
				_applyP(innerParser, s, pos, endPos, True)
				If endPos &lt; 0 Then : Exit Function : End If
				Do
					pos = endPos
					_applyP(innerParser, s, pos, endPos, True)
				Loop Until (endPos &lt; 0)
				endPos = pos
			Else
				Set lst = nil
				result = _applyP(innerParser, s, pos, endPos, False)
				If endPos &lt; 0 Then : Exit Function : End If
				Do
					Set lst = cons(result, lst)
					pos = endPos
					result = _applyP(innerParser, s, pos, endPos, False)
				Loop Until (endPos &lt; 0)
				endPos = pos
				result = reverse(lst)
			End If
		Case &quot;fail&quot;
			Goto _applyP_parseFailure
		Case &quot;ind&quot;	&apos; tail-recursive
			p = p.st
			Goto _applyP_begin
&apos;			result = _applyP(p.st, s, pos, endPos, isUnderSkip)
		Case &quot;end&quot;
			If pos &lt;= Len(s) Then
				Goto _applyP_parseFailure
			End If
			endPos = pos
		Case Else
			result = &quot;unknown Parser &apos;&quot; &amp; p.tp &amp; &quot;&apos;&quot;
			MsgBox(&quot;Error in applyP: &quot; &amp; result)
	End Select
	&apos;If isUnderSkip And Not(isParseFailure(result)) Then
	&apos;	assertEqual(result(0), Empty).x
	&apos;End If
	_applyP = result
	Exit Function
_applyP_parseFailure:
	endPos = -1
End Function

Function _applyP_stats( _
	ByVal p As Parser, _
	ByRef s As String, _
	ByVal pos As Integer, _
	ByRef endPos As Integer, _
	ByVal isUnderSkip As Boolean _
)	
	Select Case p.tp
		Case &quot;str&quot;
			applyP_str = applyP_str + 1
		Case &quot;choice&quot;	&apos; tail-recursive
			applyP_choice = applyP_choice + 1
		Case &quot;item&quot;
			applyP_item = applyP_item + 1
		Case &quot;return&quot;
			applyP_return = applyP_return + 1
		Case &quot;bind&quot;	&apos; tail-recursive
			applyP_bind = applyP_bind + 1
			If isKsomething(p.st(1)) Then
				applyP_bind_K_x = applyP_bind_K_x + 1
				If isKreturn(p.st(1)) Then
					applyP_bind_K_return = applyP_bind_K_return + 1
				End If
			ElseIf isBsomething(p.st(1)) Then
				applyP_bind_B_f_g = applyP_bind_B_f_g + 1
				If isBreturn(p.st(1)) Then
					applyP_bind_B_return_g = applyP_bind_B_return_g + 1
				End If
			End If
		Case &quot;seq&quot;
			applyP_seq = applyP_seq + 1
		Case &quot;skip&quot;	&apos; tail-recursive
			applyP_skip = applyP_skip + 1
		Case &quot;sat&quot;
			applyP_sat = applyP_sat + 1
		Case &quot;many1&quot;
			applyP_many1 = applyP_many1 + 1
		Case &quot;fail&quot;
			applyP_fail = applyP_fail + 1
		Case &quot;ind&quot;	&apos; tail-recursive
			applyP_ind = applyP_ind + 1
		Case &quot;end&quot;
			applyP_end = applyP_end + 1
	End Select
End Function

&apos;= tests ======================================================================

Global refute_parses_pass As Object

Function [-----------------------------]()
End Function

Function test_Parser(Optional what)
&apos;	what = &quot;primitives&quot;
	Dim failure As String
	failure = toString(parseFailure)
	refute_parses_pass = assertEqual(failure, failure)
	
	Dim result As Variant
	Dim ticksPerSec As Long
	ticksPerSec = GetSystemTicks()
	Wait(100) &apos; wait a hundred milliseconds
	ticksPerSec = 10 * (GetSystemTicks() - ticksPerSec)

	Dim tm As Double, aCount As Integer, aPerSec As Double
	aCount = assertionCount
	tm = GetSystemTicks
	
	If isMissing(what) Or (what = &quot;all&quot;) Or (what = &quot;primitives&quot;) Then
		test_Parser_fail()
		test_Parser_return()
		test_Parser_item()
		test_Parser_end()
		test_Parser_str()
		test_Parser_choice()
		test_Parser_bind()
		test_Parser_sat()
		test_Parser_skip()
	End If
	If isMissing(what) Or (what = &quot;all&quot;) Or (what = &quot;multiplicity&quot;) Then
		test_Parser_zeroOrOne()
		test_Parser_skip_zeroOrOne()
		test_Parser_many()
		test_Parser_many1()
	End If
	If isMissing(what) Or (what = &quot;all&quot;) Or (what = &quot;basic&quot;) Then
		test_Parser_white()
		test_Parser_seq()
		test_Parser_alphaLower()
		test_Parser_alphaUpper()
	End If
	If isMissing(what) Or (what = &quot;all&quot;) Or (what = &quot;special&quot;) Then
		test_Parser_indirect()
		&apos;test_Parser_toString()
	End If
	If isMissing(what) Or (what = &quot;all&quot;) Or (what = &quot;numbers&quot;) Then
		test_Parser_binDigit()
		test_Parser_decDigit()
		test_Parser_hexDigit()
		test_Parser_hexNum()
		test_Parser_hexLit()
	End If	
	If isMissing(what) Or (what = &quot;all&quot;) Or (what = &quot;types&quot;) Then
		test_Parser_baseType()
		test_Parser_TypeVar()
		test_Parser_TypeCtor()
		test_Parser_TypeExpr()
	End If
	
end_of_Parser_tests:	
	aCount = assertionCount - aCount
	tm = CLng(10 * (GetSystemTicks() - tm) / ticksPerSec) / 10
	If tm = 0 Then : tm = 1 : End If &apos; avoid divide-by-zero
	If isMissing(what) Then
		aPerSec =  CLng(10 * aCount / tm) / 10
		Dim summary As String
		summary = tm &amp; &quot; sec for &quot; &amp; aCount &amp; &quot; assertions, &quot;_
		&amp; chr(13) &amp; &quot;that&apos;s ~&quot; &amp; aPerSec &amp; &quot; assertions/sec&quot;
		MsgBox(summary)
		result = summary
		Dim parserInstCount As Integer
		parserInstCount = pReturn(&quot;just something&quot;).id

		msgbox(parserInstCount &amp; &quot; Parser instances&quot; _
				&amp; chr(13) &amp; &quot;applyP_callCount: &quot; &amp; applyP_callCount _
				&amp; chr(13) &amp; &quot;_applyP_callCount: &quot; &amp; _applyP_callCount _
				&amp; chr(13) &amp; &quot;applyP_str: &quot; &amp; applyP_str _
				&amp; chr(13) &amp; &quot;applyP_choice: &quot; &amp; applyP_choice _
				&amp; chr(13) &amp; &quot;applyP_item: &quot; &amp; applyP_item _
				&amp; chr(13) &amp; &quot;applyP_end: &quot; &amp; applyP_end _
				&amp; chr(13) &amp; &quot;applyP_bind: &quot; &amp; applyP_bind _
				&amp; chr(13) &amp; &quot;  (applyP_bind_K_x: &quot; &amp; applyP_bind_K_x &amp; &quot;)&quot; _
				&amp; chr(13) &amp; &quot;  (applyP_bind_K_return: &quot; &amp; applyP_bind_K_return &amp; &quot;)&quot; _
				&amp; chr(13) &amp; &quot;  (applyP_bind_B_f_g: &quot; &amp; applyP_bind_B_f_g &amp; &quot;)&quot; _
				&amp; chr(13) &amp; &quot;  (applyP_bind_B_return_g: &quot; &amp; applyP_bind_B_return_g &amp; &quot;)&quot; _
				&amp; chr(13) &amp; &quot;applyP_return: &quot; &amp; applyP_return _
				&amp; chr(13) &amp; &quot;applyP_seq: &quot; &amp; applyP_seq _
				&amp; chr(13) &amp; &quot;applyP_skip: &quot; &amp; applyP_skip _
				&amp; chr(13) &amp; &quot;applyP_sat: &quot; &amp; applyP_sat _
				&amp; chr(13) &amp; &quot;applyP_many1: &quot; &amp; applyP_many1 _
				&amp; chr(13) &amp; &quot;applyP_fail: &quot; &amp; applyP_fail _
				&amp; chr(13) &amp; &quot;applyP_ind: &quot; &amp; applyP_ind _
				&amp; chr(13) &amp; length(bindFns) &amp; &quot; bindFns: &quot; &amp; toString(bindFns))
	Else
		result = Join(Array(&quot;test_Parser(&quot; &amp; what &amp; &quot;):&quot;, tm, aCount), &quot; &quot;)
	End If
	test_Parser = result
End Function

&apos;= test helpers ===============================================================

Function refute_parses(p As Parser, ByVal ss As Variant)
	Dim actual As Variant, testResult As Variant
	Dim actualS As String, expectedS As String
	If isArray(ss) Then
		Dim i As Integer
		For i = LBound(ss) To UBound(ss)
			actual = applyP(p, ss(i), 1)
			assertionCount = assertionCount + 1
			If Not(isParseFailure(actual)) Then
				Goto refute_parses_failed
			End If
		Next i
	Else
		actual = applyP(p, ss, 1)
		assertionCount = assertionCount + 1
		If Not(isParseFailure(actual)) Then
			Goto refute_parses_failed
		End If
	End If
	refute_parses = refute_parses_pass
	Exit Function
refute_parses_failed:
	actualS = toString(actual)
	expectedS = toString(parseFailure)
	testResult = assertEqual(actualS, expectedS)
	If isArray(ss) Then
		MsgBox(&quot;at index &quot; &amp; i &amp; &quot;: &quot; &amp; toString(ss(i)))
	End If
	refute_parses = testResult
End Function

Function assert_parses(p As Parser, ByVal ss As Variant, expVal As Variant, expPos As Integer)
&apos;	assertEqual(typeOf(p), &quot;Object/TParser&quot;).x
	Dim actual As Variant, testResult As Variant
	Dim actualS As String, expectedS As String
	
	If isArray(ss) Then
		Dim i As Integer
		For i = LBound(ss) To UBound(ss)
			actual = applyP(p, ss(i), 1)
			testResult = assertEqual(actual(1), expPos)
			If (testResult.isFail) Then
				MsgBox(toString(actual))
				Goto assert_parse_failed
			End If
			testResult = assertEqual(toString(actual(0)), toString(expVal))
			If (testResult.isFail) Then
				Goto assert_parse_failed
			End If
		Next i
	Else
		actual = applyP(p, ss, 1)
		testResult = assertEqual(actual(1), expPos)
		If (testResult.isFail) Then
			Goto assert_parse_failed
		End If
		testResult = assertEqual(toString(actual(0)), toString(expVal))
		If (testResult.isFail) Then
			Goto assert_parse_failed
		End If
	End If
	assert_parses = testResult
	Exit Function
assert_parse_failed:
	actualS = toString(actual)
	expectedS = toString(Array(expVal, expPos))
	testResult = assertEqual(actualS, expectedS)
	If isArray(ss) Then
		MsgBox(&quot;at index &quot; &amp; i &amp; &quot;: &quot; &amp; toString(ss(i)))
	End If
	assert_parses = testResult
End Function

&apos;= actual tests ===============================================================

Function test_Parser_fail()
	refute_parses(pFail, Array( _
		&quot;&quot;,	&quot; &quot;, &quot;   &quot;, chr(13), chr(9), &quot;a&quot;, &quot;1&quot;, &quot;[]&quot;, &quot;asdf&quot; _
	)).x
End Function

Function test_Parser_return()
	Dim p As Variant
	Dim expected As Variant
	
	p = pReturn
	assertEqual(isFn(p), True).x
	assertEqual(arity(p),  1).x

	p = pReturn(&quot;bar&quot;)
	assert_parses(p, &quot;&quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot; &quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot;a&quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot;1&quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot;[]&quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot;abcd&quot;,	&quot;bar&quot;, 1).x
	assert_parses(p, chr(13),	&quot;bar&quot;, 1).x

	p = pReturn(4711)	
	assert_parses(p, &quot;&quot;,		4711, 1).x
	assert_parses(p, &quot; &quot;,		4711, 1).x
	assert_parses(p, &quot;a&quot;,		4711, 1).x
	assert_parses(p, &quot;1&quot;,		4711, 1).x
	assert_parses(p, &quot;[]&quot;,		4711, 1).x
	assert_parses(p, &quot;abcd&quot;,	4711, 1).x
	assert_parses(p, chr(13),	4711, 1).x
End Function

Function test_Parser_item()
	Dim p As Parser
	Set p = pItem

	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;,		&quot; &quot;, 2).x
	assert_parses(p, &quot;a&quot;,		&quot;a&quot;, 2).x
	assert_parses(p, &quot;1&quot;,		&quot;1&quot;, 2).x
	assert_parses(p, &quot;[]&quot;,		&quot;[&quot;, 2).x
	assert_parses(p, &quot;abcd&quot;,	&quot;a&quot;, 2).x
	assert_parses(p, chr(13),	chr(13), 2).x
	assert_parses(p, chr( 9),	chr( 9), 2).x
End Function

Function test_Parser_end()
	Dim p As Object
	
	p = pEnd
	assert_parses(p, &quot;&quot;, Empty, 1).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;5&quot;).x
End Function

Function test_Parser_str()
	Dim p As Object
	
	p = pStr
	assertEqual(isFn(p), True).x
	assertEqual(arity(p),  1).x
	
&apos;	assertThrows(pStr, Array(&quot;&quot;)).x

	p = pStr(&quot;bar&quot;)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot; &quot; &amp; chr(13)).x
	refute_parses(p, &quot;asdf&quot;).x
	refute_parses(p, &quot; bar&quot;).x
	refute_parses(p, &quot;b&quot;).x
	refute_parses(p, &quot;ba&quot;).x
	assert_parses(p, &quot;bar&quot;,		&quot;bar&quot;, 4).x
	assert_parses(p, &quot;barb&quot;,	&quot;bar&quot;, 4).x
	assert_parses(p, &quot;barba&quot;,	&quot;bar&quot;, 4).x
	assert_parses(p, &quot;barbar&quot;,	&quot;bar&quot;, 4).x

	p = pStr(chr(13))
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot; &quot; &amp; chr(13)).x
	refute_parses(p, &quot;asdf&quot;).x
	refute_parses(p, &quot; bar&quot;).x
	refute_parses(p, &quot;b&quot;).x
	refute_parses(p, &quot;ba&quot;).x
	refute_parses(p, &quot;bar&quot;).x
	refute_parses(p, &quot;barb&quot;).x
	refute_parses(p, &quot;barba&quot;).x
	refute_parses(p, &quot;barbar&quot;).x
	assert_parses(p, chr(13),					&quot;\n&quot;, 2).x
	assert_parses(p, chr(13) &amp; &quot;bar&quot;,			&quot;\n&quot;, 2).x
	assert_parses(p, chr(13) &amp; chr(13),			&quot;\n&quot;, 2).x
	assert_parses(p, chr(13) &amp; chr(13) &amp; &quot;bar&quot;,	&quot;\n&quot;, 2).x
End Function

Function test_Parser_choice()
	Dim p As Object
	Dim data As Variant

	p = pChoice
	assertEqual(isFn(p), True).x
	assertEqual(arity(p),  2).x
	p = apply(p, pItem)
	assertEqual(isFn(p), True).x
	assertEqual(arity(p),  1).x
	p = apply(p, pReturn(7))
		
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	p = pChoice(pFail, pFail)
	refute_parses(p, data).x
	
	p = pChoice(pReturn(7), pFail)
	assert_parses(p, data, 7, 1).x
	
	p = pChoice(pFail, pReturn(7))
	assert_parses(p, data, 7, 1).x
	
	p = pChoice(pReturn(42), pReturn(7))
	assert_parses(p, data, 42, 1).x
	
	assert_parses(pChoice(pItem, pReturn(11)), 	&quot;&quot;, 11, 1	).x
	refute_parses(pChoice(pItem, pStr(&quot;x&quot;)),	&quot;&quot;).x
	assert_parses(pChoice(pReturn(11), pItem), 	&quot;&quot;, 11, 1	).x
	refute_parses(pChoice(pStr(&quot;x&quot;), pItem),	&quot;&quot;).x
	
	assert_parses(pChoice(pItem, pReturn(11)), 	&quot; &quot;, &quot; &quot;, 2	).x
	assert_parses(pChoice(pItem, pStr(&quot;x&quot;)), 	&quot; &quot;, &quot; &quot;, 2	).x
	assert_parses(pChoice(pReturn(11), pItem), 	&quot; &quot;, 11, 1	).x
	assert_parses(pChoice(pStr(&quot;x&quot;), pItem), 	&quot; &quot;, &quot; &quot;, 2	).x
	
	assert_parses(pChoice(pItem, pReturn(11)), 	&quot;x&quot;, &quot;x&quot;, 2	).x
	assert_parses(pChoice(pItem, pStr(&quot;x&quot;)), 	&quot;x&quot;, &quot;x&quot;, 2	).x
	assert_parses(pChoice(pReturn(11), pItem), 	&quot;x&quot;, 11, 1	).x
	assert_parses(pChoice(pStr(&quot;x&quot;), pItem), 	&quot;x&quot;, &quot;x&quot;, 2	).x
End Function

Function test_Parser_bind()
	Dim p As Object
	p = pBind
	assertEqual(isFn(p), True).x
	assertEqual(arity(p),   2).x
	
	p = pBind(pItem)
	assertEqual(isFn(p), True).x
	assertEqual(arity(p),   1).x
	
	p = apply(p, fstArg(pStr(&quot;y&quot;)))
	assert_parses(p, &quot;xy&quot;, &quot;y&quot;, 3).x
	refute_parses(p, &quot;xx&quot;).x
	refute_parses(p, &quot;yx&quot;).x
	assert_parses(p, &quot; yabcd&quot;, &quot;y&quot;, 3).x
	
&apos;	p = item &gt;&gt;= return ° (concat &quot;FOO&quot;)
	p = pBind(pItem, compose(pReturn, concat(&quot;FOO&quot;)))
	assert_parses(p, &quot;xy&quot;,		&quot;FOOx&quot;, 2).x
	assert_parses(p, &quot;xx&quot;,		&quot;FOOx&quot;, 2).x
	assert_parses(p, &quot;yx&quot;,		&quot;FOOy&quot;, 2).x
	assert_parses(p, &quot; yabcd&quot;,	&quot;FOO &quot;, 2).x
	
&apos;	p = item &gt;&gt;= \x.if (=? &quot;y&quot; x) then (return x) else fail 
&apos;     = item &gt;&gt;= \x.ite (=? &quot;y&quot;) return (K fail)
	p = pBind( pItem, ite(equ(&quot;y&quot;), pReturn, fstArg(pFail)) )
	refute_parses(p, &quot;xy&quot;).x
	refute_parses(p, &quot;xx&quot;).x
	assert_parses(p, &quot;yx&quot;,		&quot;y&quot;, 2).x
	assert_parses(p, &quot;yy&quot;,		&quot;y&quot;, 2).x
	refute_parses(p, &quot; yabcd&quot;).x	

	&apos; under-skip-status MUST NOT be passed down into the parser (bind&apos;s 1st arg)
	&apos; because the function (bind&apos;s 2nd arg) might need the parser&apos;s
	&apos; result in order to decide what other parser to produce:
&apos;	p = (skip ( item &gt;&gt;= \x.if (=? &quot;y&quot; x) then (return x) else fail ))
&apos;     = (skip ( item &gt;&gt;= \x.ite (=? &quot;y&quot;) return (K fail) ))
	p = pSkip(pBind( pItem, ite(equ(&quot;y&quot;), pReturn, fstArg(pFail)) ))
	refute_parses(p, &quot;xy&quot;).x
	refute_parses(p, &quot;xx&quot;).x
	assert_parses(p, &quot;yx&quot;,		Empty, 2).x	&apos; succeeds but skips result
	assert_parses(p, &quot;yy&quot;,		Empty, 2).x	&apos; succeeds but skips result
	refute_parses(p, &quot; yabcd&quot;).x
End Function

Function test_Parser_sat()
	Dim p As Parser, actual As Variant
	Set p = pSat(apply(Fn.equ, &quot;a&quot;)
	
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	assert_parses(p, &quot;a&quot;,		&quot;a&quot;, 2).x
	assert_parses(p, &quot;aa&quot;,		&quot;a&quot;, 2).x
	refute_parses(p, &quot;1&quot;).x
	refute_parses(p, &quot;[]&quot;).x
	assert_parses(p, &quot;abcd&quot;,	&quot;a&quot;, 2).x
	refute_parses(p, chr(13)).x
	refute_parses(p, chr( 9)).x
End Function

Function test_Parser_skip()
	Dim p As Parser, actual As Variant
	Set p = pSkip(pItem)
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;,		Empty, 2).x
	assert_parses(p, &quot;a&quot;,		Empty, 2).x
	assert_parses(p, &quot;1&quot;,		Empty, 2).x
	assert_parses(p, &quot;[]&quot;,		Empty, 2).x
	assert_parses(p, &quot;abcd&quot;,	Empty, 2).x
	assert_parses(p, chr(13),   Empty, 2).x
	assert_parses(p, chr( 9),	Empty, 2).x
	
	&apos; skip fail = fail
	Set p = pSkip(pFail)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;1&quot;).x
	refute_parses(p, &quot;[]&quot;).x
	refute_parses(p, &quot;abcd&quot;).x
	refute_parses(p, chr(13)).x
	refute_parses(p, chr( 9)).x
		
	Set p = pSkip(pBind(pItem, fstArg(pItem)))
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;1&quot;).x
	assert_parses(p, &quot;[]&quot;,				Empty, 3).x
	assert_parses(p, &quot;abcd&quot;,			Empty, 3).x
	refute_parses(p, chr(13)).x
	refute_parses(p, chr( 9)).x
	assert_parses(p, chr(13) &amp; chr(13),	Empty, 3).x
	assert_parses(p, chr( 9) &amp; chr( 9),	Empty, 3).x

	&apos; skip (return x) = return Empty
	Set p = pSkip(pReturn(&quot;foo&quot;))
	assert_parses(p, &quot;&quot;,		Empty, 1).x
	assert_parses(p, &quot; &quot;,		Empty, 1).x
	assert_parses(p, &quot;a&quot;,		Empty, 1).x
	assert_parses(p, &quot;1&quot;,		Empty, 1).x
	assert_parses(p, &quot;[]&quot;,		Empty, 1).x
	assert_parses(p, &quot;abcd&quot;,	Empty, 1).x
	assert_parses(p, chr(13),   Empty, 1).x
	assert_parses(p, chr( 9),	Empty, 1).x

	&apos; skip (skip x) = skip x
	Set p = pSkip(pSkip(pItem))
&apos;	msgbox(toString(p))
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;,		Empty, 2).x
	assert_parses(p, &quot;a&quot;,		Empty, 2).x
	assert_parses(p, &quot;1&quot;,		Empty, 2).x
	assert_parses(p, &quot;[]&quot;,		Empty, 2).x
	assert_parses(p, &quot;abcd&quot;,	Empty, 2).x
	assert_parses(p, chr(13),   Empty, 2).x
	assert_parses(p, chr( 9),	Empty, 2).x

	Set p = pSkip(pStr(&quot;foo&quot;))
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;1&quot;).x
	refute_parses(p, &quot;[]&quot;).x
	refute_parses(p, &quot;abcd&quot;).x
	refute_parses(p, chr(13)).x
	refute_parses(p, chr( 9)).x
	
	assert_parses(p, &quot;foo&quot;,				Empty, 4).x
	assert_parses(p, &quot;foo &quot;,			Empty, 4).x
	assert_parses(p, &quot;fooa&quot;,			Empty, 4).x
	assert_parses(p, &quot;foo1&quot;,			Empty, 4).x
	assert_parses(p, &quot;foo[]&quot;,			Empty, 4).x
	assert_parses(p, &quot;fooabcd&quot;,			Empty, 4).x
	assert_parses(p, &quot;foo&quot; &amp; chr(13),   Empty, 4).x
	assert_parses(p, &quot;foo&quot; &amp; chr( 9),	Empty, 4).x
	
	Set p = pSkip(pSeq(Array(pStr(&quot;f&quot;), pStr(&quot;oo&quot;)), concat)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;1&quot;).x
	refute_parses(p, &quot;[]&quot;).x
	refute_parses(p, &quot;abcd&quot;).x
	refute_parses(p, chr(13)).x
	refute_parses(p, chr( 9)).x
	
	assert_parses(p, &quot;foo&quot;,				Empty, 4).x
	assert_parses(p, &quot;foo &quot;,			Empty, 4).x
	assert_parses(p, &quot;fooa&quot;,			Empty, 4).x
	assert_parses(p, &quot;foo1&quot;,			Empty, 4).x
	assert_parses(p, &quot;foo[]&quot;,			Empty, 4).x
	assert_parses(p, &quot;fooabcd&quot;,			Empty, 4).x
	assert_parses(p, &quot;foo&quot; &amp; chr(13),   Empty, 4).x
	assert_parses(p, &quot;foo&quot; &amp; chr( 9),	Empty, 4).x
	
	Set p = pSkip(pMany(pItem))
&apos;	msgbox(toString(p))
	assert_parses(p, &quot;&quot;,		Empty, 1).x
	assert_parses(p, &quot; &quot;,		Empty, 2).x
	assert_parses(p, &quot;a&quot;,		Empty, 2).x
	assert_parses(p, &quot;1&quot;,		Empty, 2).x
	assert_parses(p, &quot;[]&quot;,		Empty, 3).x
	assert_parses(p, &quot;abcd&quot;,	Empty, 5).x
	assert_parses(p, chr(13),   Empty, 2).x
	assert_parses(p, chr( 9),	Empty, 2).x	
	
	Set p = pSkip(pMany1(pItem))
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;,		Empty, 2).x
	assert_parses(p, &quot;a&quot;,		Empty, 2).x
	assert_parses(p, &quot;1&quot;,		Empty, 2).x
	assert_parses(p, &quot;[]&quot;,		Empty, 3).x
	assert_parses(p, &quot;abcd&quot;,	Empty, 5).x
	assert_parses(p, chr(13),   Empty, 2).x
	assert_parses(p, chr( 9),	Empty, 2).x	

	Set p = pSkip(pMany(pWhite))
	assert_parses(p, &quot;&quot;,		Empty, 1).x
	assert_parses(p, &quot; &quot;,		Empty, 2).x
	assert_parses(p, &quot;  &quot;,		Empty, 3).x
	assert_parses(p, &quot;a&quot;,		Empty, 1).x
	assert_parses(p, &quot;1&quot;,		Empty, 1).x
	assert_parses(p, &quot; a&quot;,		Empty, 2).x
	assert_parses(p, &quot;  1&quot;,		Empty, 3).x
	assert_parses(p, &quot;[]&quot;,		Empty, 1).x
	assert_parses(p, &quot;abcd&quot;,	Empty, 1).x
	assert_parses(p, &quot;   d&quot;,	Empty, 4).x
	assert_parses(p, chr(13),   Empty, 1).x
	assert_parses(p, chr( 9),	Empty, 2).x	
	
	Set p = pBind(pSkip(pMany(pWhite)), fstArg(pStr(&quot;xx&quot;))
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;x&quot;).x
	assert_parses(p, &quot;xx&quot;,		&quot;xx&quot;,  3).x
	assert_parses(p, &quot;xxx&quot;,		&quot;xx&quot;,  3).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot; x&quot;).x
	assert_parses(p, &quot; xx&quot;,		&quot;xx&quot;,  4).x
	assert_parses(p, &quot; xxx&quot;,	&quot;xx&quot;,  4).x
	refute_parses(p, &quot;  &quot;).x
	refute_parses(p, &quot;  x&quot;).x
	assert_parses(p, &quot;  xx&quot;,	&quot;xx&quot;,  5).x
	assert_parses(p, &quot;  xxx&quot;,	&quot;xx&quot;,  5).x
	refute_parses(p, chr(9) &amp; &quot;  &quot;).x
	refute_parses(p, chr(9) &amp; &quot;  x&quot;).x
	assert_parses(p, chr(9) &amp; &quot;  xx&quot;,	&quot;xx&quot;,  6).x
	assert_parses(p, chr(9) &amp; &quot;  xxx&quot;,	&quot;xx&quot;,  6).x
	
	Dim mkList1 As Object, mkList2 As Object, expected As Object
	Set mkList1 = swap(cons, nil) &apos; \y.cons y nil
	Set mkList2 = swap(compose(swap(cons), mkList1)) &apos; \x y.cons x (cons y nil))
	Set expected = apply(mkList2, &quot;foo&quot;, &quot;bar&quot;)
	assertEqual(toString(expected), &quot;[&apos;foo&apos;, &apos;bar&apos;]&quot;).x
	Set p = pSeq(Array(pSkip(pMany(pWhite)), _
					   pStr(&quot;foo&quot;), _
					   pSkip(pMany(pWhite)), _
					   pStr(&quot;bar&quot;), _
					   pSkip(pMany(pWhite)) _
				 ), mkList2 _
	)
	assert_parses(p, &quot;foobar&quot;, 		expected,  7).x
	assert_parses(p, &quot;   foobar&quot;, 	expected, 10).x
	assert_parses(p, &quot;foobar   &quot;, 	expected, 10).x
	assert_parses(p, &quot;foo   bar&quot;, 	expected, 10).x
	assert_parses(p, &quot; foo  bar&quot;, 	expected, 10).x
	assert_parses(p, &quot;foo  bar &quot;, 	expected, 10).x
	assert_parses(p, &quot; foo bar &quot;, 	expected, 10).x
End Function

Function test_Parser_indirect()
	Dim p As Parser, q As Parser, r As Parser
	r = pInd
	&apos;Note: most of the parsers we create here don&apos;t actually make sense
	&apos;      the important thing for testing is their structure
	
	p = pInd : q = pInd
	assertEqual(p.id = q.id, False).x
	
	p = pInd : q = pReturn(&quot;foo&quot;)
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	
	p = pInd : q = pFail
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	
	p = pInd : q = pItem
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	
	p = pInd : q = pStr(&quot;bar&quot;)
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	
	p = pInd : q = pSat(compose(inRange(5, 7), Fn.asc))
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	
	p = pInd : q = pSkip(pItem)
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	
	p = pInd : q = pSkip(pStr(&quot;foo&quot;))
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	
	p = pInd : q = pSkip(p)
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	
	p = pInd : q = pChoice(pStr(&quot;foo&quot;), p)
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	Dim altsP As Object, altsQ As Object
	altsP = p.st.st : altsQ = q.st
	Dim alt1P As Object, alt1Q As Object
	alt1P = altsP(0) : alt1Q = altsQ(0)
	assertEqual(alt1P.tp, alt1Q.tp).x
	assertEqual(alt1P.id, alt1Q.id).x
	assertEqual(alt1P.st, alt1Q.st).x

	Dim alt2P As Object, alt2Q As Object
	alt2P = altsP(1) : alt2Q = altsQ(1)
	assertEqual(alt2P.tp, alt2Q.tp).x
	assertEqual(alt2P.id, alt2Q.id).x
	assertEqual(alt2P.tp, p.tp).x &apos; there is the recursion!
	assertEqual(alt2P.id, p.id).x &apos; there is the recursion!


	p = pInd : q = pZeroOrOne(p)
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x

	p = pInd : q = pMany1(p)
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x

	p = pInd : q = pMany(p)
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x

	p = pInd : q = pChoice( pStr(&quot;x&quot;), pSeq(Array(pSkip(pStr(&quot;(&quot;)), p, pSkip(pStr(&quot;)&quot;))), id) )
	p = fixIndirection(p, q)
	assertEqual(p.tp, r.tp).x		&apos; p points to q
	assertEqual(p.st.id, q.id).x
	
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;()&quot;).x
	refute_parses(p, &quot;(x&quot;).x
	assert_parses(p, &quot;x))&quot;, 		&quot;x&quot;,  2).x
	refute_parses(p, &quot;(())&quot;).x
	refute_parses(p, &quot;((x)&quot;).x
	assert_parses(p, &quot;(x))&quot;,		&quot;x&quot;,  4).x
	assert_parses(p, &quot;x&quot;, 			&quot;x&quot;,  2).x
	assert_parses(p, &quot;(x)&quot;, 		&quot;x&quot;,  4).x
	assert_parses(p, &quot;((x))&quot;, 		&quot;x&quot;,  6).x
	assert_parses(p, &quot;(((x)))&quot;, 	&quot;x&quot;,  8).x
	assert_parses(p, &quot;((((x))))&quot;, 	&quot;x&quot;, 10).x
	assert_parses(p, &quot;(((((x)))))&quot;,	&quot;x&quot;, 12).x
	
			
	&apos;TODO: test_Parser_ind: fixIndirection .. bind
	
End Function

Function test_Parser_zeroOrOne()
	Dim p As Parser
	Dim data As Variant
	Dim zeroMatches As Variant, oneMatch As Variant
	zeroMatches = Empty
	oneMatch    = &quot;x&quot;
		
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)

	p = pZeroOrOne(pStr(&quot;x&quot;))

	assert_parses(p, data,	zeroMatches, 1).x
	assert_parses(p, &quot;x&quot;, 	oneMatch, 2).x
	assert_parses(p, &quot;xx&quot;, 	oneMatch, 2).x
	assert_parses(p, &quot;xxx&quot;, oneMatch, 2).x
	assert_parses(p, &quot; x&quot;, 	zeroMatches, 1).x
	assert_parses(p, &quot; xx&quot;, zeroMatches, 1).x
	assert_parses(p, &quot; xxx&quot;,zeroMatches, 1).x
	
	&apos; double p?? is the same as p?:
	p = pZeroOrOne(pZeroOrOne(pStr(&quot;x&quot;)))
	assert_parses(p, data,	zeroMatches, 1).x
	assert_parses(p, &quot;x&quot;, 	oneMatch, 2).x
	assert_parses(p, &quot;xx&quot;, 	oneMatch, 2).x
	assert_parses(p, &quot;xxx&quot;, oneMatch, 2).x
	assert_parses(p, &quot; x&quot;, 	zeroMatches, 1).x
	assert_parses(p, &quot; xx&quot;, zeroMatches, 1).x
	assert_parses(p, &quot; xxx&quot;,zeroMatches, 1).x
End Function

Function test_Parser_skip_zeroOrOne()
	Dim p As Parser
	Dim data As Variant
			
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)

	p = pSkip(pZeroOrOne(pStr(&quot;x&quot;)))
	assert_parses(p, data,	Empty, 1).x
	assert_parses(p, &quot;x&quot;, 	Empty, 2).x
	assert_parses(p, &quot;xx&quot;, 	Empty, 2).x
	assert_parses(p, &quot;xxx&quot;, Empty, 2).x
	assert_parses(p, &quot; x&quot;, 	Empty, 1).x
	assert_parses(p, &quot; xx&quot;, Empty, 1).x
	assert_parses(p, &quot; xxx&quot;,Empty, 1).x
	
	&apos;TODO: is that what we want?: pZeroOrOne (pSkip p) = pSkip (pZeroOrOne p)  ...?
	p = pZeroOrOne(pSkip(pStr(&quot;x&quot;)))
	assert_parses(p, data,	Empty, 1).x
	assert_parses(p, &quot;x&quot;, 	Empty, 2).x
	assert_parses(p, &quot;xx&quot;, 	Empty, 2).x
	assert_parses(p, &quot;xxx&quot;, Empty, 2).x
	assert_parses(p, &quot; x&quot;, 	Empty, 1).x
	assert_parses(p, &quot; xx&quot;, Empty, 1).x
	assert_parses(p, &quot; xxx&quot;,Empty, 1).x
End Function

Function test_Parser_white()
	Dim p As Parser
	p = pWhite

	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;, 						&quot; &quot;, 2	).x
	assert_parses(p, chr(9), 					&quot;\t&quot;, 2	).x
	refute_parses(p, chr(13)).x
	refute_parses(p, &quot;asdf&quot;).x
	assert_parses(p, &quot; asdf&quot;, 					&quot; &quot;, 2).x
	assert_parses(p, chr(9) &amp; &quot;asdf&quot;, 			&quot;\t&quot;, 2).x
	refute_parses(p, chr(13) &amp; &quot;asdf&quot;).x
	assert_parses(p, &quot;  asdf&quot;, 					&quot; &quot;, 2).x
	assert_parses(p, chr(9) &amp; chr(9) &amp; &quot;asdf&quot;, 	&quot;\t&quot;, 2).x
	refute_parses(p, chr(13) &amp; chr(9) &amp; &quot;asdf&quot;).x
	assert_parses(p, chr(9) &amp; chr(13) &amp; &quot;asdf&quot;, 	&quot;\t&quot;, 2).x
	refute_parses(p, chr(13) &amp; chr(13) &amp; &quot;asdf&quot;).x
End Function

Function test_Parser_alphaLower()
	Dim p As Parser
	p = pAlphaLower

	refute_parses(p, Array(&quot; &quot;, chr(9), chr(13), &quot;_&quot;, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, _
		&quot;+&quot;, &quot;-&quot;, &quot;-&gt;&quot;, &quot;*&quot;, &quot;?&quot;, &quot;#&quot;,_
		&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, _
		&quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, _
		&quot;&quot;)).x
	assert_parses(p, &quot;asdf&quot;, &quot;a&quot;, 2).x
	assert_parses(p, &quot;a&quot;, &quot;a&quot;, 2).x
	assert_parses(p, &quot;b&quot;, &quot;b&quot;, 2).x
	assert_parses(p, &quot;c&quot;, &quot;c&quot;, 2).x
	assert_parses(p, &quot;d&quot;, &quot;d&quot;, 2).x
	assert_parses(p, &quot;e&quot;, &quot;e&quot;, 2).x
	assert_parses(p, &quot;f&quot;, &quot;f&quot;, 2).x
	assert_parses(p, &quot;g&quot;, &quot;g&quot;, 2).x
	assert_parses(p, &quot;h&quot;, &quot;h&quot;, 2).x
	assert_parses(p, &quot;i&quot;, &quot;i&quot;, 2).x
	assert_parses(p, &quot;j&quot;, &quot;j&quot;, 2).x
	assert_parses(p, &quot;k&quot;, &quot;k&quot;, 2).x
	assert_parses(p, &quot;l&quot;, &quot;l&quot;, 2).x
	assert_parses(p, &quot;m&quot;, &quot;m&quot;, 2).x
	assert_parses(p, &quot;n&quot;, &quot;n&quot;, 2).x
	assert_parses(p, &quot;o&quot;, &quot;o&quot;, 2).x
	assert_parses(p, &quot;p&quot;, &quot;p&quot;, 2).x
	assert_parses(p, &quot;q&quot;, &quot;q&quot;, 2).x
	assert_parses(p, &quot;r&quot;, &quot;r&quot;, 2).x
	assert_parses(p, &quot;s&quot;, &quot;s&quot;, 2).x
	assert_parses(p, &quot;t&quot;, &quot;t&quot;, 2).x
	assert_parses(p, &quot;u&quot;, &quot;u&quot;, 2).x
	assert_parses(p, &quot;v&quot;, &quot;v&quot;, 2).x
	assert_parses(p, &quot;w&quot;, &quot;w&quot;, 2).x
	assert_parses(p, &quot;x&quot;, &quot;x&quot;, 2).x
	assert_parses(p, &quot;y&quot;, &quot;y&quot;, 2).x
	assert_parses(p, &quot;z&quot;, &quot;z&quot;, 2).x
End Function

Function test_Parser_alphaUpper()
	Dim p As Parser
	p = pAlphaUpper

	refute_parses(p, Array(&quot; &quot;, chr(9), chr(13), &quot;_&quot;, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, _
		&quot;+&quot;, &quot;-&quot;, &quot;-&gt;&quot;, &quot;*&quot;, &quot;?&quot;, &quot;#&quot;,_
		&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, _
		&quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, _
		&quot;&quot;)).x
	assert_parses(p, &quot;ASDF&quot;, &quot;A&quot;, 2).x
	assert_parses(p, &quot;A&quot;, &quot;A&quot;, 2).x
	assert_parses(p, &quot;B&quot;, &quot;B&quot;, 2).x
	assert_parses(p, &quot;C&quot;, &quot;C&quot;, 2).x
	assert_parses(p, &quot;D&quot;, &quot;D&quot;, 2).x
	assert_parses(p, &quot;E&quot;, &quot;E&quot;, 2).x
	assert_parses(p, &quot;F&quot;, &quot;F&quot;, 2).x
	assert_parses(p, &quot;G&quot;, &quot;G&quot;, 2).x
	assert_parses(p, &quot;H&quot;, &quot;H&quot;, 2).x
	assert_parses(p, &quot;I&quot;, &quot;I&quot;, 2).x
	assert_parses(p, &quot;J&quot;, &quot;J&quot;, 2).x
	assert_parses(p, &quot;K&quot;, &quot;K&quot;, 2).x
	assert_parses(p, &quot;L&quot;, &quot;L&quot;, 2).x
	assert_parses(p, &quot;M&quot;, &quot;M&quot;, 2).x
	assert_parses(p, &quot;N&quot;, &quot;N&quot;, 2).x
	assert_parses(p, &quot;O&quot;, &quot;O&quot;, 2).x
	assert_parses(p, &quot;P&quot;, &quot;P&quot;, 2).x
	assert_parses(p, &quot;Q&quot;, &quot;Q&quot;, 2).x
	assert_parses(p, &quot;R&quot;, &quot;R&quot;, 2).x
	assert_parses(p, &quot;S&quot;, &quot;S&quot;, 2).x
	assert_parses(p, &quot;T&quot;, &quot;T&quot;, 2).x
	assert_parses(p, &quot;U&quot;, &quot;U&quot;, 2).x
	assert_parses(p, &quot;V&quot;, &quot;V&quot;, 2).x
	assert_parses(p, &quot;W&quot;, &quot;W&quot;, 2).x
	assert_parses(p, &quot;X&quot;, &quot;X&quot;, 2).x
	assert_parses(p, &quot;Y&quot;, &quot;Y&quot;, 2).x
	assert_parses(p, &quot;Z&quot;, &quot;Z&quot;, 2).x
End Function

Function test_Parser_baseType()
	Dim p As Parser
	p = pBaseType

	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;asdf&quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;b&quot;).x
	refute_parses(p, &quot;c&quot;).x
	
	assert_parses(p, &quot;Bool -&gt; Bool&quot;, &quot;Bool&quot;, 5).x
	assert_parses(p, &quot;Bool&quot;, &quot;Bool&quot;, 5).x
	refute_parses(p, &quot;bool&quot;).x

	assert_parses(p, &quot;Str&quot;, &quot;Str&quot;, 4).x
	refute_parses(p, &quot;str&quot;).x

	assert_parses(p, &quot;Int&quot;, &quot;Int&quot;, 4).x
	refute_parses(p, &quot;int&quot;).x

	assert_parses(p, &quot;Long&quot;, &quot;Long&quot;, 5).x
	refute_parses(p, &quot;long&quot;).x
End Function

Function test_Parser_TypeVar()
	Dim p As Parser
	p = pTypeVar

	refute_parses(p, Array(&quot; &quot;, chr(9), chr(13), &quot;_&quot;, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, _
		&quot;+&quot;, &quot;-&quot;, &quot;-&gt;&quot;, &quot;*&quot;, &quot;?&quot;, &quot;#&quot;,_
		&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, _
		&quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, _
		&quot;&quot;)).x
	assert_parses(p, &quot;asdf&quot;, &quot;&apos;a&quot;, 2).x
	assert_parses(p, &quot;a&quot;, &quot;&apos;a&quot;, 2).x
	assert_parses(p, &quot;b&quot;, &quot;&apos;b&quot;, 2).x
	assert_parses(p, &quot;c&quot;, &quot;&apos;c&quot;, 2).x
	assert_parses(p, &quot;d&quot;, &quot;&apos;d&quot;, 2).x
	assert_parses(p, &quot;e&quot;, &quot;&apos;e&quot;, 2).x
	assert_parses(p, &quot;f&quot;, &quot;&apos;f&quot;, 2).x
	assert_parses(p, &quot;g&quot;, &quot;&apos;g&quot;, 2).x
	assert_parses(p, &quot;h&quot;, &quot;&apos;h&quot;, 2).x
	assert_parses(p, &quot;i&quot;, &quot;&apos;i&quot;, 2).x
	assert_parses(p, &quot;j&quot;, &quot;&apos;j&quot;, 2).x
	assert_parses(p, &quot;k&quot;, &quot;&apos;k&quot;, 2).x
	assert_parses(p, &quot;l&quot;, &quot;&apos;l&quot;, 2).x
	assert_parses(p, &quot;m&quot;, &quot;&apos;m&quot;, 2).x
	assert_parses(p, &quot;n&quot;, &quot;&apos;n&quot;, 2).x
	assert_parses(p, &quot;o&quot;, &quot;&apos;o&quot;, 2).x
	assert_parses(p, &quot;p&quot;, &quot;&apos;p&quot;, 2).x
	assert_parses(p, &quot;q&quot;, &quot;&apos;q&quot;, 2).x
	assert_parses(p, &quot;r&quot;, &quot;&apos;r&quot;, 2).x
	assert_parses(p, &quot;s&quot;, &quot;&apos;s&quot;, 2).x
	assert_parses(p, &quot;t&quot;, &quot;&apos;t&quot;, 2).x
	assert_parses(p, &quot;u&quot;, &quot;&apos;u&quot;, 2).x
	assert_parses(p, &quot;v&quot;, &quot;&apos;v&quot;, 2).x
	assert_parses(p, &quot;w&quot;, &quot;&apos;w&quot;, 2).x
	assert_parses(p, &quot;x&quot;, &quot;&apos;x&quot;, 2).x
	assert_parses(p, &quot;y&quot;, &quot;&apos;y&quot;, 2).x
	assert_parses(p, &quot;z&quot;, &quot;&apos;z&quot;, 2).x
End Function

Function test_Parser_TypeCtor()
	Dim p As Parser
	p = pTypeCtor

	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;asdf&quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;b&quot;).x
	refute_parses(p, &quot;c&quot;).x
	
	assert_parses(p, &quot;List&quot;, &quot;List&quot;, 5).x
	assert_parses(p, &quot;Maybe&quot;, &quot;Maybe&quot;, 6).x

	&apos; any capitalized String with more than 2 chars does
	assert_parses(p, &quot;Bool&quot;, &quot;Bool&quot;, 5).x &apos; 
	refute_parses(p, &quot;bool&quot;).x

	assert_parses(p, &quot;Str&quot;, &quot;Str&quot;, 4).x
	refute_parses(p, &quot;str&quot;).x

	assert_parses(p, &quot;Int&quot;, &quot;Int&quot;, 4).x
	refute_parses(p, &quot;int&quot;).x

	assert_parses(p, &quot;Long&quot;, &quot;Long&quot;, 5).x
	refute_parses(p, &quot;long&quot;).x

	assert_parses(p, &quot;Avalidtypector&quot;, &quot;Avalidtypector&quot;, 15).x
	assert_parses(p, &quot;NotAValidTypeCtor&quot;, &quot;Not&quot;, 4).x
End Function

Function test_Parser_TypeExpr()
	Dim p As Parser
	p = pTypeExpr
	
	assert_parses(p, &quot;Bool&quot;, 			&quot;Bool&quot;, 5).x
	assert_parses(p, &quot;Int&quot;,	 			&quot;Int&quot;, 4).x
	assert_parses(p, &quot;Int-&gt;Int&quot;,	 	&quot;(-&gt; Int Int)&quot;, 9).x
	assert_parses(p, &quot;Int-&gt;Str-&gt;Bool&quot;,	&quot;(-&gt; Int (-&gt; Str Bool))&quot;, 15).x
	assert_parses(p, &quot;a-&gt;b-&gt;c&quot;,	 		&quot;(-&gt; &apos;a (-&gt; &apos;b &apos;c))&quot;, 8).x
	assert_parses(p, &quot;(a-&gt;b)-&gt;c&quot;,	 	&quot;(-&gt; (-&gt; &apos;a &apos;b) &apos;c)&quot;, 10).x
	assert_parses(p, &quot;(a-&gt;b)-&gt;(c)&quot;,	 	&quot;(-&gt; (-&gt; &apos;a &apos;b) &apos;c)&quot;, 12).x
	assert_parses(p, &quot;List&quot;,	 		&quot;(List [])&quot;, 5).x
	assert_parses(p, &quot;List a&quot;,	 		&quot;(List [&apos;a])&quot;, 7).x
	assert_parses(p, &quot;List a b&quot;,	 	&quot;(List [&apos;a, &apos;b])&quot;, 9).x
	assert_parses(p, &quot;List Int&quot;,	 	&quot;(List [Int])&quot;, 9).x
	assert_parses(p, &quot;List a-&gt;b&quot;,	 	&quot;(-&gt; (List [&apos;a]) &apos;b)&quot;, 10).x
	assert_parses(p, &quot;List (a-&gt;b)&quot;,	 	&quot;(List [(-&gt; &apos;a &apos;b)])&quot;, 12).x
	assert_parses(p, &quot;List Maybe a&quot;,	&quot;(List [(Maybe [&apos;a])])&quot;, 13).x
	assert_parses(p, &quot;List Maybe a b&quot;,	&quot;(List [(Maybe [&apos;a, &apos;b])])&quot;, 15).x
	assert_parses(p, &quot;List (Maybe a) b&quot;,&quot;(List [(Maybe [&apos;a]), &apos;b])&quot;, 17).x
	
	refute_parses(p, &quot;-&gt;a&quot;).x
	&apos;refute_parses(p, &quot;a-&gt;&quot;).x

	&apos; skips over trailing whitespace:
	assert_parses(p, &quot;Bool   &quot;, 				&quot;Bool&quot;, 8).x
	assert_parses(p, &quot;Int    &quot;,	 				&quot;Int&quot;,  8).x
	assert_parses(p, &quot;Int -&gt; Int            &quot;,	&quot;(-&gt; Int Int)&quot;, 23).x
	assert_parses(p, &quot;Int  -&gt; Str -&gt;   Bool &quot;,	&quot;(-&gt; Int (-&gt; Str Bool))&quot;, 23).x

	&apos; skips over leading whitespace:
	assert_parses(p, &quot; Bool  &quot;, 				&quot;Bool&quot;, 8).x
	assert_parses(p, &quot; Int   &quot;,	 				&quot;Int&quot;,  8).x
	assert_parses(p, &quot; Int -&gt; Int           &quot;,	&quot;(-&gt; Int Int)&quot;, 23).x
	assert_parses(p, &quot; Int  -&gt; Str -&gt;  Bool &quot;,	&quot;(-&gt; Int (-&gt; Str Bool))&quot;, 23).x

	assert_parses(p, getFnTypeStr(Fn.isNil), &quot;(-&gt; (List [&apos;a]) Bool)&quot;, 15).x
	assert_parses(p, getFnTypeStr(Fn.flatten), &quot;(-&gt; (List [(List [&apos;a])]) (List [&apos;a]))&quot;, 22).x

	Dim fns As Object, f As Object, fName As String, typStr As String
	fns = fnObjs
	While Not(isNil(fns))
		f = car(fns)
		typStr = getFnTypeStr(f)
		If typStr &lt;&gt; &quot;&quot; Then
			fName = getFnName(f)
&apos;			assert_parses(p, typStr, fName &amp; &quot; :: asdf&quot;, Len(typStr) + 1).x
		End If
		fns = cdr(fns)
	Wend
End Function

Function test_Parser_binDigit()
	Dim p As Parser
	p = pBinDigit

	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;sadf&quot;).x
	assert_parses(p, &quot;0sadf&quot;,	0, 2).x
	assert_parses(p, &quot;1sadf&quot;,	1, 2).x
	refute_parses(p, &quot;2sadf&quot;).x
	refute_parses(p, &quot;3sadf&quot;).x
	refute_parses(p, &quot;4sadf&quot;).x
	refute_parses(p, &quot;5sadf&quot;).x
	refute_parses(p, &quot;6sadf&quot;).x
	refute_parses(p, &quot;7sadf&quot;).x
	refute_parses(p, &quot;8sadf&quot;).x
	refute_parses(p, &quot;9sadf&quot;).x
	refute_parses(p, &quot;Asadf&quot;).x
	refute_parses(p, &quot;asadf&quot;).x
	refute_parses(p, &quot;Bsadf&quot;).x
	refute_parses(p, &quot;bsadf&quot;).x
	refute_parses(p, &quot;Csadf&quot;).x
	refute_parses(p, &quot;csadf&quot;).x
	refute_parses(p, &quot;Dsadf&quot;).x
	refute_parses(p, &quot;dsadf&quot;).x
	refute_parses(p, &quot;Esadf&quot;).x
	refute_parses(p, &quot;esadf&quot;).x
	refute_parses(p, &quot;Fsadf&quot;).x
	refute_parses(p, &quot;fsadf&quot;).x
	refute_parses(p, &quot;Gsadf&quot;).x
	refute_parses(p, &quot;gsadf&quot;).x
End Function

Function test_Parser_decDigit()
	Dim p As Parser
	p = pDecDigit

	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;sadf&quot;).x
	assert_parses(p, &quot;0sadf&quot;,	0, 2).x
	assert_parses(p, &quot;1sadf&quot;,	1, 2).x
	assert_parses(p, &quot;2sadf&quot;,	2, 2).x
	assert_parses(p, &quot;3sadf&quot;,	3, 2).x
	assert_parses(p, &quot;4sadf&quot;,	4, 2).x
	assert_parses(p, &quot;5sadf&quot;,	5, 2).x
	assert_parses(p, &quot;6sadf&quot;,	6, 2).x
	assert_parses(p, &quot;7sadf&quot;,	7, 2).x
	assert_parses(p, &quot;8sadf&quot;,	8, 2).x
	assert_parses(p, &quot;9sadf&quot;,	9, 2).x
	refute_parses(p, &quot;Asadf&quot;).x
	refute_parses(p, &quot;asadf&quot;).x
	refute_parses(p, &quot;Bsadf&quot;).x
	refute_parses(p, &quot;bsadf&quot;).x
	refute_parses(p, &quot;Csadf&quot;).x
	refute_parses(p, &quot;csadf&quot;).x
	refute_parses(p, &quot;Dsadf&quot;).x
	refute_parses(p, &quot;dsadf&quot;).x
	refute_parses(p, &quot;Esadf&quot;).x
	refute_parses(p, &quot;esadf&quot;).x
	refute_parses(p, &quot;Fsadf&quot;).x
	refute_parses(p, &quot;fsadf&quot;).x
	refute_parses(p, &quot;Gsadf&quot;).x
	refute_parses(p, &quot;gsadf&quot;).x
End Function

Function test_Parser_hexDigit()
	Dim p As Parser
	p = pHexDigit

	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;sadf&quot;).x
	assert_parses(p, &quot;0sadf&quot;,	 0, 2).x
	assert_parses(p, &quot;1sadf&quot;,	 1, 2).x
	assert_parses(p, &quot;2sadf&quot;,	 2, 2).x
	assert_parses(p, &quot;3sadf&quot;,	 3, 2).x
	assert_parses(p, &quot;4sadf&quot;,	 4, 2).x
	assert_parses(p, &quot;5sadf&quot;,	 5, 2).x
	assert_parses(p, &quot;6sadf&quot;,	 6, 2).x
	assert_parses(p, &quot;7sadf&quot;,	 7, 2).x
	assert_parses(p, &quot;8sadf&quot;,	 8, 2).x
	assert_parses(p, &quot;9sadf&quot;,	 9, 2).x
	assert_parses(p, &quot;Asadf&quot;,	10, 2).x
	assert_parses(p, &quot;asadf&quot;,	10, 2).x
	assert_parses(p, &quot;Bsadf&quot;,	11, 2).x
	assert_parses(p, &quot;bsadf&quot;,	11, 2).x
	assert_parses(p, &quot;Csadf&quot;,	12, 2).x
	assert_parses(p, &quot;csadf&quot;,	12, 2).x
	assert_parses(p, &quot;Dsadf&quot;,	13, 2).x
	assert_parses(p, &quot;dsadf&quot;,	13, 2).x
	assert_parses(p, &quot;Esadf&quot;,	14, 2).x
	assert_parses(p, &quot;esadf&quot;,	14, 2).x
	assert_parses(p, &quot;Fsadf&quot;,	15, 2).x
	assert_parses(p, &quot;fsadf&quot;,	15, 2).x
	refute_parses(p, &quot;Gsadf&quot;).x
	refute_parses(p, &quot;gsadf&quot;).x
End Function

Function test_Parser_many()
	Dim p As Parser
	Dim data As Variant
	Dim zeroMatches As Variant
	zeroMatches = nil
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	p = pMany(pFail)
	assert_parses(p, data, zeroMatches, 1).x
	
	&apos;p = pMany(pReturn(3)) - yields infite sequence of 3s, even on empty string
	
	p = pMany(pItem)
	assert_parses(p, &quot;&quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; chr(13),	List(&quot; &quot;, &quot;\n&quot;), 3).x
	assert_parses(p, &quot;asdf&quot;,		List(&quot;a&quot;, &quot;s&quot;, &quot;d&quot;, &quot;f&quot;), 5).x
	
	p = pMany(pStr(&quot; &quot;))
	assert_parses(p, &quot;&quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; chr(13),	List(&quot; &quot;), 2).x
	assert_parses(p, &quot;asdf&quot;,		zeroMatches, 1).x
	assert_parses(p, &quot;  &quot;,			List(&quot; &quot;, &quot; &quot;), 3).x
	assert_parses(p, &quot;   &quot;,			List(&quot; &quot;, &quot; &quot;, &quot; &quot;), 4).x
	assert_parses(p, &quot; x &quot;,			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; x  &quot;,		List(&quot; &quot;), 2).x
	assert_parses(p, &quot;  x &quot;,		List(&quot; &quot;, &quot; &quot;), 3).x
	
	p = pMany(pDecDigit)
	assert_parses(p, &quot;&quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot; &quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot;1&quot;, 			List(1), 2).x
	assert_parses(p, &quot;10 &quot;, 		List(1, 0), 3).x
	assert_parses(p, &quot;102345&quot;, 		List(1, 0, 2, 3, 4, 5), 7).x
End Function

Function test_Parser_many1()
	Dim p As Parser
	Dim data As Variant
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	p = pMany1(pFail)
	refute_parses(p, data).x
	
	&apos;p = pMany1(pReturn(3)) - yields infite sequence of 3s, except on empty string
	
	p = pMany1(pItem)
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; chr(13),	List(&quot; &quot;, &quot;\n&quot;), 3).x
	assert_parses(p, &quot;asdf&quot;,		List(&quot;a&quot;, &quot;s&quot;, &quot;d&quot;, &quot;f&quot;), 5).x
	
	p = pMany1(pStr(&quot; &quot;))
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; chr(13),	List(&quot; &quot;), 2).x
	refute_parses(p, &quot;asdf&quot;).x
	assert_parses(p, &quot;  &quot;,			List(&quot; &quot;, &quot; &quot;), 3).x
	assert_parses(p, &quot;   &quot;,			List(&quot; &quot;, &quot; &quot;, &quot; &quot;), 4).x
	assert_parses(p, &quot; x &quot;,			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; x  &quot;,		List(&quot; &quot;), 2).x
	assert_parses(p, &quot;  x &quot;,		List(&quot; &quot;, &quot; &quot;), 3).x
	
	p = pMany1(pDecDigit)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	assert_parses(p, &quot;1&quot;, 			List(1), 2).x
	assert_parses(p, &quot;10 &quot;, 		List(1, 0), 3).x
	assert_parses(p, &quot;102345&quot;, 		List(1, 0, 2, 3, 4, 5), 7).x
End Function

Function test_Parser_seq()
	Dim p As Parser, f As Variant
	Dim data As Variant
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	f = Fn.asc
	p = pSeq(Array(pFail), f)
	refute_parses(p, data).x
	
	f = Fn.asc
	p = pSeq(Array(pItem), f)
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot;0&quot;, 	asc(&quot;0&quot;), 2).x
	assert_parses(p, &quot;1&quot;, 	asc(&quot;1&quot;), 2).x
	assert_parses(p, &quot;A&quot;, 	asc(&quot;A&quot;), 2).x
	assert_parses(p, &quot;B&quot;, 	asc(&quot;B&quot;), 2).x
	assert_parses(p, &quot;AB&quot;,	asc(&quot;A&quot;), 2).x
	assert_parses(p, &quot;BA&quot;,	asc(&quot;B&quot;), 2).x
	
	f = &quot;concat&quot;
	p = pSeq(Array(pItem, pItem), f)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;A&quot;).x
	refute_parses(p, &quot;B&quot;).x
	assert_parses(p, &quot;AB&quot;,	&quot;AB&quot;, 3).x
	assert_parses(p, &quot;BA&quot;,	&quot;BA&quot;, 3).x
	
	p = pSeq(Array(pDecDigit, pDecDigit), f)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;A&quot;).x
	refute_parses(p, &quot;B&quot;).x
	refute_parses(p, &quot;AB&quot;).x
	refute_parses(p, &quot;BA&quot;).x
	refute_parses(p, &quot;0B&quot;).x		&apos; *ALL* in sequence must succeed!
	refute_parses(p, &quot;1A&quot;).x		&apos; *ALL* in sequence must succeed!
	assert_parses(p, &quot;01&quot;,	&quot;01&quot;, 3).x
	assert_parses(p, &quot;10&quot;,	&quot;10&quot;, 3).x
	
	f = Fn.asc
	p = pSeq(Array(pDecDigit), f)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;A&quot;).x
	refute_parses(p, &quot;B&quot;).x
	refute_parses(p, &quot;AB&quot;).x
	refute_parses(p, &quot;BA&quot;).x
	assert_parses(p, &quot;0&quot;, 			48, 2).x
	assert_parses(p, &quot;1&quot;, 			49, 2).x
	assert_parses(p, &quot;123456789&quot;,	49, 2).x
	
	p = pMany1(pSeq(Array(pDecDigit), f))
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;A&quot;).x
	refute_parses(p, &quot;B&quot;).x
	refute_parses(p, &quot;AB&quot;).x
	refute_parses(p, &quot;BA&quot;).x
	assert_parses(p, &quot;0&quot;, 			List(48), 2).x
	assert_parses(p, &quot;1&quot;, 			List(49), 2).x
	assert_parses(p, &quot;123456789&quot;,	List(49, 50, 51, 52, 53, 54, 55, 56, 57), 10).x
	assert_parses(p, &quot;123456789 0&quot;,	List(49, 50, 51, 52, 53, 54, 55, 56, 57), 10).x
End Function

Function assert_toStr(p As Object, expected As String)
	Dim testResult As Variant
	testResult = assertEqual(TParser_toString(p), expected)
	If testResult.isFail Then
		assert_toStr = testResult
		Exit Function
	End If
	&apos; try polymorphic dispatch:
	testResult = assertEqual(toString(p), expected)
	assert_toStr = testResult
End Function

Function test_Parser_toString()
	Dim f As Object
	f = TParser_toString
	assertEqual(isFn(f), True).x
	assertEqual(arity(f),   1).x
	
	MsgBox(toString(pTypeExpr))
	
	assert_toStr(pFail, 							&quot;fail&quot;).x
	assert_toStr(pReturn(7), 						&quot;(return 7)&quot;).x
	assert_toStr(pReturn(&quot;seven&quot;),					&quot;(return &apos;seven&apos;)&quot;).x
	assert_toStr(pItem,								&quot;item&quot;).x
	assert_toStr(pStr(&quot;a&quot;),							&quot;(str &apos;a&apos;)&quot;).x
	assert_toStr(pSkip(pItem), 						&quot;(skip item)&quot;).x
	assert_toStr(pSkip(pStr(&quot;a&quot;)),					&quot;(skip (str &apos;a&apos;))&quot;).x
	assert_toStr(pChoice(pStr(&quot;a&quot;), pStr(&quot;b&quot;)),		&quot;((str &apos;a&apos;) +++ (str &apos;b&apos;))&quot;).x
	assert_toStr(pChoice(pStr(&quot;b&quot;), pStr(&quot;a&quot;)),		&quot;((str &apos;b&apos;) +++ (str &apos;a&apos;))&quot;).x
	assert_toStr(pZeroOrOne(pStr(&quot;a&quot;)),				&quot;(str &apos;a&apos;)?&quot;).x
	&apos; double p?? is the same as p?:
	assert_toStr(pZeroOrOne(pZeroOrOne(pStr(&quot;a&quot;))),	&quot;(str &apos;a&apos;)?&quot;).x

	assert_toStr(pMany1(pItem),						&quot;item+&quot;).x
	assert_toStr(pSkip(pMany1(pItem)),				&quot;(skip item+)&quot;).x
	assert_toStr(pMany1(pWhite),					toString(pWhite) &amp; &quot;+&quot;).x
	assert_toStr(pSkip(pMany1(pWhite)),				&quot;(skip &quot; &amp; toString(pWhite) &amp; &quot;+)&quot;).x

	assert_toStr(pMany(pItem),						&quot;item*&quot;).x
	assert_toStr(pSkip(pMany(pItem)),				&quot;(skip item*)&quot;).x

	Dim p As Object, q As Object
	p = pInd
	assert_toStr(p,	&quot;(ind Nothing)&quot;).x
	q = pItem
	p = fixIndirection(p, q)
	assert_toStr(p,	&quot;(ind P&quot; &amp; q.id &amp; &quot; ::= &quot; &amp; toString(q) &amp; &quot;)&quot;).x

	p = pInd
	p = fixIndirection(p, pChoice(pStr(&quot;x&quot;), pSeq(Array(pSkip(pStr(&quot;(&quot;)), p, pSkip(pStr(&quot;)&quot;))), id))
&apos;	assert_toStr(p,	&quot;(str &apos;x&apos;) +++ ?????? )&quot;).x
	
End Function

Function test_Parser_hexNum()
	Dim p As Parser
	Dim data As Variant
	p = pHexNum

	refute_parses(p, &quot;&quot;).x
		
	data = Array(&quot; &quot;, &quot; &quot; &amp; chr(13), &quot;qasdf&quot;, &quot; bar&quot;, &quot;qb&quot;, &quot;qba&quot;, &quot;qbar&quot;, &quot;qbarb&quot;,_
		&quot;qbarba&quot;, &quot;qbarbar&quot;, chr(13), chr(13) &amp; &quot;qbar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	refute_parses(p, data).x

	assert_parses(p, &quot;0&quot;,	 0, 2).x
	assert_parses(p, &quot;1&quot;,	 1, 2).x
	assert_parses(p, &quot;2&quot;,	 2, 2).x
	assert_parses(p, &quot;3&quot;,	 3, 2).x
	assert_parses(p, &quot;4&quot;,	 4, 2).x
	assert_parses(p, &quot;5&quot;,	 5, 2).x
	assert_parses(p, &quot;6&quot;,	 6, 2).x
	assert_parses(p, &quot;7&quot;,	 7, 2).x
	assert_parses(p, &quot;8&quot;,	 8, 2).x
	assert_parses(p, &quot;9&quot;,	 9, 2).x

	assert_parses(p, &quot;a&quot;,	10, 2).x
	assert_parses(p, &quot;b&quot;, 	11, 2).x
	assert_parses(p, &quot;c&quot;, 	12, 2).x
	assert_parses(p, &quot;d&quot;, 	13, 2).x
	assert_parses(p, &quot;e&quot;, 	14, 2).x
	assert_parses(p, &quot;f&quot;, 	15, 2).x
	assert_parses(p, &quot;A&quot;, 	10, 2).x
	assert_parses(p, &quot;B&quot;, 	11, 2).x
	assert_parses(p, &quot;C&quot;, 	12, 2).x
	assert_parses(p, &quot;D&quot;, 	13, 2).x
	assert_parses(p, &quot;E&quot;, 	14, 2).x
	assert_parses(p, &quot;F&quot;, 	15, 2).x

	assert_parses(p, &quot;FF&quot;, 		readHex(&quot;FF&quot;), 	3).x
	assert_parses(p, &quot;123&quot;, 	readHex(&quot;123&quot;), 4).x

	assert_parses(p, &quot;0FF&quot;, 	readHex(&quot;FF&quot;), 	4).x	&apos; leading 0s don&apos;t matter
	assert_parses(p, &quot;0123&quot;, 	readHex(&quot;123&quot;), 5).x	&apos; leading 0s don&apos;t matter

	assert_parses(p, &quot;00FF&quot;, 	readHex(&quot;FF&quot;), 	5).x	&apos; leading 0s don&apos;t matter
	assert_parses(p, &quot;00123&quot;, 	readHex(&quot;123&quot;), 6).x	&apos; leading 0s don&apos;t matter

	&apos; 31 bit
	assert_parses(p, &quot;CAFEBAB&quot;, readHex(&quot;CAFEBAB&quot;), 	8).x
	assert_parses(p, &quot;DEADBEE&quot;, readHex(&quot;DEADBEE&quot;), 	8).x
	assert_parses(p, &quot;CAFEBAB&quot;, readHex(&quot;cafebab&quot;), 	8).x	&apos; case doesn&apos;t matter
	assert_parses(p, &quot;dEaDbEe&quot;, readHex(&quot;DeAdBeE&quot;), 	8).x	&apos; case doesn&apos;t matter

&apos;	&apos; 32 bit
&apos;	assert_parses(p, &quot;CAFEBABE&quot;, readHex(&quot;CAFEBABE&quot;), 	9).x
&apos;	assert_parses(p, &quot;DEADBEEF&quot;, readHex(&quot;DEADBEEF&quot;), 	9).x
&apos;	assert_parses(p, &quot;CAFEBABE&quot;, readHex(&quot;cafebabe&quot;), 	9).x	&apos; case doesn&apos;t matter
&apos;	assert_parses(p, &quot;dEaDbEeF&quot;, readHex(&quot;DeAdBeEf&quot;), 	9).x	&apos; case doesn&apos;t matter
End Function

Function test_Parser_hexLit()
	Dim p As Parser
	Dim data As Variant
	p = pHexLit

	refute_parses(p, &quot;&quot;).x
		
	data = Array(&quot; &quot;, &quot; &quot; &amp; chr(13), &quot;qasdf&quot;, &quot; bar&quot;, &quot;qb&quot;, &quot;qba&quot;, &quot;qbar&quot;, &quot;qbarb&quot;,_
		&quot;qbarba&quot;, &quot;qbarbar&quot;, chr(13), chr(13) &amp; &quot;qbar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;,_
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;,_
		&quot;a&quot;, &quot;A&quot;, &quot;b&quot;, &quot;B&quot;, &quot;c&quot;, &quot;C&quot;, &quot;d&quot;, &quot;D&quot;, &quot;e&quot;, &quot;E&quot;, &quot;f&quot;, &quot;F&quot;,_
		&quot;0x&quot;_
	)
	refute_parses(p, data).x

	assert_parses(p, &quot;0x0&quot;, 	 0, 4).x
	assert_parses(p, &quot;0x1&quot;, 	 1, 4).x
	assert_parses(p, &quot;0x2&quot;, 	 2, 4).x
	assert_parses(p, &quot;0x3&quot;, 	 3, 4).x
	assert_parses(p, &quot;0x4&quot;, 	 4, 4).x
	assert_parses(p, &quot;0x5&quot;, 	 5, 4).x
	assert_parses(p, &quot;0x6&quot;, 	 6, 4).x
	assert_parses(p, &quot;0x7&quot;, 	 7, 4).x
	assert_parses(p, &quot;0x8&quot;, 	 8, 4).x
	assert_parses(p, &quot;0x9&quot;,		 9, 4).x

	assert_parses(p, &quot;0xa&quot;,		10, 4).x
	assert_parses(p, &quot;0xb&quot;,		11, 4).x
	assert_parses(p, &quot;0xc&quot;, 	12, 4).x
	assert_parses(p, &quot;0xd&quot;, 	13, 4).x
	assert_parses(p, &quot;0xe&quot;, 	14, 4).x
	assert_parses(p, &quot;0xf&quot;, 	15, 4).x
	assert_parses(p, &quot;0xA&quot;, 	10, 4).x
	assert_parses(p, &quot;0xB&quot;, 	11, 4).x
	assert_parses(p, &quot;0xC&quot;, 	12, 4).x
	assert_parses(p, &quot;0xD&quot;, 	13, 4).x
	assert_parses(p, &quot;0xE&quot;, 	14, 4).x
	assert_parses(p, &quot;0xF&quot;, 	15, 4).x

	assert_parses(p, &quot;0xFF&quot;, 	readHex(&quot;FF&quot;), 	5).x
	assert_parses(p, &quot;0x123&quot;, 	readHex(&quot;123&quot;), 6).x

	assert_parses(p, &quot;0x0FF&quot;, 	readHex(&quot;FF&quot;), 	6).x	&apos; leading 0s don&apos;t matter
	assert_parses(p, &quot;0x0123&quot;, 	readHex(&quot;123&quot;), 7).x	&apos; leading 0s don&apos;t matter

	assert_parses(p, &quot;0x00FF&quot;, 	readHex(&quot;FF&quot;), 	7).x	&apos; leading 0s don&apos;t matter
	assert_parses(p, &quot;0x00123&quot;, readHex(&quot;123&quot;), 8).x	&apos; leading 0s don&apos;t matter

	&apos; 31 bit
	assert_parses(p, &quot;0xCAFEBAB&quot;, readHex(&quot;CAFEBAB&quot;), 	10).x
	assert_parses(p, &quot;0xDEADBEE&quot;, readHex(&quot;DEADBEE&quot;), 	10).x
	assert_parses(p, &quot;0xCAFEBAB&quot;, readHex(&quot;cafebab&quot;), 	10).x	&apos; case doesn&apos;t matter
	assert_parses(p, &quot;0xdEaDbEe&quot;, readHex(&quot;DeAdBeE&quot;), 	10).x	&apos; case doesn&apos;t matter

&apos;	&apos; 32 bit
&apos;	assert_parses(p, &quot;0xCAFEBABE&quot;, readHex(&quot;CAFEBABE&quot;), 	11).x
&apos;	assert_parses(p, &quot;0xDEADBEEF&quot;, readHex(&quot;DEADBEEF&quot;), 	11).x
&apos;	assert_parses(p, &quot;0xCAFEBABE&quot;, readHex(&quot;cafebabe&quot;), 	11).x	&apos; case doesn&apos;t matter
&apos;	assert_parses(p, &quot;0xdEaDbEeF&quot;, readHex(&quot;DeAdBeEf&quot;), 	11).x	&apos; case doesn&apos;t matter
End Function

</script:module>