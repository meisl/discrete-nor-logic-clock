<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M03_List" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit

Type TList
	tyname As String
	head As Variant
	tail As TList
	len As Integer
End Type

Sub Main
	test_List()
End Sub


Function TList_toString(xs As TList)
	Dim result As String
	If isNil(xs) Then
		result = &quot;[]&quot;
	Else
		result = &quot;[&quot; &amp; toString(car(xs))
		If length(xs) &gt; 1 Then
			result = result &amp; &quot;, &quot; &amp; Join(toArray(map(&quot;toString&quot;, cdr(xs))), &quot;, &quot;)
		End If
		result = result &amp; &quot;]&quot;
	End If
	TList_toString = result
End Function

Function TList_equ(xs As TList, ys As TList) As Boolean
	Dim result As Boolean
	If xs.len &lt;&gt; ys.len Then
		result = False
	ElseIf (isNil(xs) And isNil(ys)) Then
		result = True
	Else
		On Local Error Goto IncompatibleCars
		If equ(car(xs), car(ys)) Then
			result = TList_equ(cdr(xs), cdr(ys))
			TList_equ = result
			Exit Function
		End If
IncompatibleCars:
		result = False	
	End If
	TList_equ = result
End Function

Function nil()
	Static result As New TList	&apos; uninitialized instance at first
	result.tyname = &quot;TList&quot;
	nil = result
End Function

Function isNil(xs As TList)
	isNil = (xs.len = 0)
End Function

Function cons(x As Variant, xs As TList)
	Dim result As New TList
	result.tyname = xs.tyname
	result.head = x
	result.tail = xs
	result.len = xs.len + 1
	cons = result
End Function

Function snoc(xs As TList, x As Variant)
	snoc = cons(x, xs)
End Function

Function length(xs As TList)
	length = xs.len
End Function

Function car(xs As TList) As Variant
	If isNil(xs) Then
		croak(&quot;car: nil&quot;)
	Else
		car = xs.head
	End If
End Function

Function cdr(xs As TList) As TList
	If isNil(xs) Then
		croak(&quot;cdr: nil&quot;)
	Else
		cdr = xs.tail
	End If
End Function

Function cadr(xs As TList)
	cadr = car(cdr(xs))
End Function

Function caddr(xs As TList)
	caddr = cadr(cdr(xs))
End Function

Function map(fn As String, xs As Variant)
	Dim result As TList
	If isNil(xs) Then
		result = nil
	ElseIf isArray(xs) Then
		result = map(fn, toList(xs))
	Else
		result = cons(applyF(fn, Array(xs.head)), map(fn, xs.tail))
	End If
	map = result
End Function

Function foldl(fn As String, acc As Variant, xs As Variant)
	Dim result As Variant
	If isNil(xs) Then
		result = acc
	ElseIf IsArray(xs) Then
		result = foldl(fn, acc, toList(xs))
	Else
		result = foldl(fn, applyF(fn, Array(acc, xs.head)), xs.tail)
	End If
	foldl = result
End Function

Function foldr(fn As String, acc As Variant, xs As Variant)
	Dim result As Variant
	If IsNil(xs) Then
		result = acc
	ElseIf IsArray(xs) Then
		result = foldr(fn, acc, toList(xs))
	Else
		result = applyF(fn, Array(xs.head, foldr(fn, acc, xs.tail)))
	End If
	foldr = result
End Function

&apos; Cannot name this function &quot;append&quot;, seems to be a BASIC keyword(?)
Function adjoin(xs As TList, ys As TList)
	adjoin = foldr(&quot;cons&quot;, ys, xs)
End Function

&apos; Normally this is called &quot;concat&quot; but we already have that for Strings
Function flatten(xs As TList)
	flatten = foldl(&quot;adjoin&quot;, nil, xs)
End Function

Function reverse(xs As TList)
	Dim result As TList
	If xs.len &lt;= 1 Then
		result = xs
	Else
		result = foldl(&quot;snoc&quot;, nil, xs)
	End If
	reverse = result
End Function

Function toArray(xs As TList)
	Dim result(0 To xs.len - 1)
	Dim t As TList
	Set t = xs
	Dim i As Integer
	For i = 0 To xs.len - 1
		result(i) = t.head
		Set t = t.tail
	Next i
	toArray = result
End Function

Function List(Optional a0, Optional a1, Optional a2, Optional a3, Optional a4, Optional a5, Optional a6, Optional a7, Optional a8, Optional a9, Optional a10)
	If Not(IsMissing(a10)) Then
		croak(&quot;List(...): cannot handle more than 10 args&quot;)
	End If
	Dim result As TList
	If isMissing(a0) Then
		result = nil
	Else
		result = cons(a0, List(a1, a2, a3, a4, a5, a6, a7, a8, a9))
	End If
	List = result
End Function

Function toList(a As Array)
	Dim result As TList
	Set result = nil
	Dim i As Integer, k As Integer
	Select Case getDim(a)
		Case 1
			For i = UBound(a) To LBound(a) Step -1
				result = cons(a(i), result)
			Next i
		Case 2
			For i = UBound(a, 1) To LBound(a, 1) Step -1
				Dim inner As TList
				Set inner = nil
				For k = UBound(a, 2) To LBound(a, 2) Step -1
					inner = cons(a(i, k), inner)
				Next k
				result = cons(inner, result)
			Next i
		Case Else
			croak(&quot;cannot handle &quot; &amp; getDim(a) &amp; &quot;-dimensional arrays&quot;)
	End Select
	toList = result
End Function
				
&apos;= tests ============================================================

Function test_List()
	test_List_isNil_and_cons()
	test_List_fnApp()
	test_List_typeOfAndToString()
	test_List_List()
	test_List_car()
	test_List_cdr()
	test_List_adjoin()
	test_List_flatten()
	test_List_reverse()
	test_List_equ()
End Function

Function test_List_isNil_and_cons()
	assertEqual(isNil(nil), True).x
	assertThrows(&quot;isNil&quot;, Array()).x
	assertThrows(&quot;isNil&quot;, Array(Empty)).x
	assertThrows(&quot;isNil&quot;, Array(Nothing)).x
	assertEqual(isNil(cons(nil, nil)), False).x
	assertEqual(isNil(cons(0, nil)), False).x
	assertEqual(isNil(cons(&quot;&quot;, nil)), False).x
	
	&apos;assertEqual(toString(isNil(Empty)), &quot;[&apos;isNil&apos;, True, 1]&quot;).x
	assertEqual(apply(&quot;isNil&quot;, nil), True).x
	&apos;assertEqual(apply(isNil, Nothing), True).x
End Function

Function test_List_fnApp()
	assertEqual(arityF(&quot;TList_toString&quot;), 1).x
	assertEqual(arityF(&quot;cons&quot;), 2).x
	assertEqual(arityF(&quot;snoc&quot;), 2).x
	assertEqual(arityF(&quot;reverse&quot;), 1).x
End Function

Function test_List_typeOfAndToString()
	assertEqual(typeOf(nil), &quot;Object/TList&quot;).x
	assertEqual(toString(nil), &quot;[]&quot;).x
	
	Dim lst As TList
	Set lst = cons(5, nil)
	assertEqual(typeOf(lst), &quot;Object/TList&quot;).x
	assertEqual(toString(lst), &quot;[5]&quot;).x

	Dim a As Variant
	a = Array(7)
	assertEqual(Join(a, &quot;, &quot;), &quot;7&quot;)

	a = Array(7, 5)
	assertEqual(Join(a, &quot;, &quot;), &quot;7, 5&quot;)

	Set lst = cons(7, lst)
	assertEqual(toString(lst), &quot;[7, 5]&quot;).x
	Set lst = cons(&quot;a&quot;, lst)
	assertEqual(toString(lst), &quot;[&apos;a&apos;, 7, 5]&quot;).x
	Set lst = cons(&quot;xxx&quot;, nil)
	assertEqual(toString(lst), &quot;[&apos;xxx&apos;]&quot;).x

	Set lst = cons(nil, nil)
	assertEqual(toString(lst), &quot;[[]]&quot;).x
	Set lst = cons(&quot;b&quot;, lst)
	assertEqual(toString(lst), &quot;[&apos;b&apos;, []]&quot;).x
	Set lst = cons(cons(&quot;a&quot;, nil), lst)
	assertEqual(toString(lst), &quot;[[&apos;a&apos;], &apos;b&apos;, []]&quot;).x
End Function

Function test_List_foo(Optional a0, Optional a1)
	test_List_foo = List(a0, a1)
End Function

Function test_List_List()
	assertEqual(toString(List()), &quot;[]&quot;).x
	assertEqual(toString(List(0)), &quot;[0]&quot;).x
	assertEqual(toString(List(0, 1)), &quot;[0, 1]&quot;).x
	assertEqual(toString(List(0, 1, 2)), &quot;[0, 1, 2]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3)), &quot;[0, 1, 2, 3]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3, 4)), &quot;[0, 1, 2, 3, 4]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3, 4, 5)), &quot;[0, 1, 2, 3, 4, 5]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3, 4, 5, 6)), &quot;[0, 1, 2, 3, 4, 5, 6]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3, 4, 5, 6, 7)), &quot;[0, 1, 2, 3, 4, 5, 6, 7]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3, 4, 5, 6, 7, 8)), &quot;[0, 1, 2, 3, 4, 5, 6, 7, 8]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)), &quot;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&quot;).x
	&apos;assertThrows(&quot;List&quot;, Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)).x
	
	assertEqual(toString(test_List_foo(5)), &quot;[5]&quot;).x
	assertEqual(toString(test_List_foo(5, 7)), &quot;[5, 7]&quot;).x
End Function

Function test_List_car()
	assertThrows(&quot;car&quot;, nil).x
	assertEqual(car(List(1   )), 1).x
	assertEqual(car(List(2, 1)), 2).x
End Function

Function test_List_cdr()
	assertThrows(&quot;cdr&quot;, nil).x
	assertEqual(toString(cdr(List(1   ))), &quot;[]&quot;).x
	assertEqual(toString(cdr(List(2, 1))), &quot;[1]&quot;).x
End Function

Function test_List_adjoin()
	assertEqual(toString(adjoin(nil, nil)), &quot;[]&quot;).x
	Dim lst As TList
	Set lst = cons(1, nil)
	assertEqual(toString(adjoin(lst, nil)), &quot;[1]&quot;).x
	assertEqual(toString(adjoin(nil, lst)), &quot;[1]&quot;).x

	assertEqual(toString(adjoin(lst, lst)), &quot;[1, 1]&quot;).x
	Dim lst2 As TList
	Set lst2 = cons(2, nil)
	assertEqual(toString(adjoin(lst, lst2)), &quot;[1, 2]&quot;).x
	assertEqual(toString(adjoin(lst2, lst)), &quot;[2, 1]&quot;).x
	Set lst2 = cons(3, lst2)
	assertEqual(toString(adjoin(lst, lst2)), &quot;[1, 3, 2]&quot;).x
	assertEqual(toString(adjoin(lst2, lst)), &quot;[3, 2, 1]&quot;).x
	Set lst = cons(0, lst)
	assertEqual(toString(adjoin(lst, lst2)), &quot;[0, 1, 3, 2]&quot;).x
	assertEqual(toString(adjoin(lst2, lst)), &quot;[3, 2, 0, 1]&quot;).x
End Function

Function test_List_flatten()
	assertEqual(toString(flatten(nil)), &quot;[]&quot;).x
	Dim lst As TList
	Set lst = cons(1, nil)
	assertThrows(&quot;flatten&quot;, Array(lst)).x
	Set lst = cons(lst, nil)	&apos; [[1]]
	assertEqual(toString(flatten(lst)), &quot;[1]&quot;).x
	Set lst = cons(nil, lst)	&apos; [[], [1]]
	assertEqual(toString(flatten(lst)), &quot;[1]&quot;).x
	Dim lst2 As TList
	Set lst2 = cons(&quot;a&quot;, cons(&quot;b&quot;, nil))
	Set lst = cons(lst2, lst)	&apos; [[&apos;a&apos;, &apos;b&apos;], [], [1]]
	assertEqual(toString(flatten(lst)), &quot;[&apos;a&apos;, &apos;b&apos;, 1]&quot;).x
	Set lst2 = cons(lst2, nil)
	Set lst = cons(lst2, lst)	&apos; [[[&apos;a&apos;, &apos;b&apos;]], [&apos;a&apos;, &apos;b&apos;], [], [1]]
	assertEqual(toString(flatten(lst)), &quot;[[&apos;a&apos;, &apos;b&apos;], &apos;a&apos;, &apos;b&apos;, 1]&quot;).x
End Function

Function test_List_reverse()
	assertEqual(toString(reverse(nil)), toString(nil)).x
	Dim lst As TList
	Set lst = cons(1, nil)
	assertEqual(toString(reverse(lst)), toString(lst)).x
	Set lst = cons(2, lst)
	assertEqual(toString(reverse(lst)), &quot;[1, 2]&quot;).x
	Set lst = cons(3, lst)
	assertEqual(toString(reverse(lst)), &quot;[1, 2, 3]&quot;).x
End Function

Function test_List_equ()
	assertThrows(&quot;equ&quot;, Array(nil, Empty)).x	&apos; incompatible types Object/TList and Empty
	assertThrows(&quot;equ&quot;, Array(Empty, nil)).x	&apos; incompatible types Empty and Object/TList

	assertEqual(equ(nil,		Nothing),		False).x
	assertEqual(equ(Nothing,	nil),			False).x

	assertEqual(equ(nil,		nil),			True).x
	
	assertEqual(equ(List(1), 	nil),			False).x
	assertEqual(equ(nil, 		List(1)),		False).x
	
	assertEqual(equ(List(1), 	List(1)),		True).x
	assertEqual(equ(List(2), 	List(1)),		False).x
	assertEqual(equ(List(1), 	List(2)),		False).x
	
&apos;	assertEqual(equ(List(&quot;1&quot;), 	List(1)),		False).x
	assertEqual(equ(List(1, 2), List(1)),		False).x
	assertEqual(equ(List(1), 	List(1, 2)),	False).x
	assertEqual(equ(List(1, 2), List(1, 2)),	True).x
	assertEqual(equ(List(2, 2), List(1, 2)),	False).x
	assertEqual(equ(List(2, 1), List(1, 2)),	False).x

End Function

</script:module>