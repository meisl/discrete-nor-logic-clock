<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M12_Type" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit
		
Type DataValue
	str		 As String	&apos; debugger shows that in inspector
	id		 As Long
	ctor	 As DataValue
	fields   As Array
End Type

Const DataCtor_name     = 0
Const DataCtor_argTypes = 1
Const DataCtor_typeCtor = 2

Const DataTypeCtor_name  	 = 0
Const DataTypeCtor_arity 	 = 1
Const DataTypeCtor_dataCtors = 2


Sub Main
	[test_Type======================================]
End Sub


Function _newDataValue(ctor As DataValue, ByRef args As Array)
	Static instanceCount As Long
	Dim out As New DataValue
	out.ctor   = ctor
	out.fields = args
	out.id	   = instanceCount
	instanceCount = instanceCount + 1

	If Not(isNull(ctor)) Then
		_validate(out)
	End If
	_newDataValue = out
End Function


Function _validate(v As DataValue)
	Dim a As Integer : a = LBound(v.fields)
	If a &lt;&gt; 0 Then
		croak(&quot;_validate &quot; &amp; ctor.fields(DataCtor_name) &amp; &quot;:&quot; _
			&amp; NL &amp; &quot;expected 0-based args Array&quot; _
			&amp; NL &amp; &quot;but got a &quot; &amp; a &amp; &quot;-based one: &quot; _
			&amp; NL &amp; toString(v.fields) _
		)
	End If
	Goto _validate_check_count_only	&apos; can comment out
	&apos;Goto _validate_check_types		&apos; can comment out

_validate_end:	&apos; to make &quot;no-checks&quot; the shortest path
	Exit Function
	
_validate_check_types:
	croak(&quot;_validate/type-check: NYI&quot;)
	Goto _validate_end
	
_validate_check_count_only:
	Dim x As Integer, argTypes As Variant
	a = UBound(v.fields)
	argTypes = v.ctor.fields(DataCtor_argTypes)
	If isArray(argTypes) Then
		x = UBound(argTypes)
	Else
		x = a	&apos; TODO: argTypes as List
	End If
	If x &lt;&gt; a Then
		x = x + 1
		a = a + 1
		croak(&quot;_validate: DataCtor &quot; &amp; v.ctor.fields(DataCtor_name) _
			&amp; &quot; requires &quot; &amp; x &amp; IIf(x = 1, &quot; arg&quot;, &quot; args&quot;) _
			&amp; &quot; - got &quot; &amp; a _
		)
	End If
	Goto _validate_end
End Function


&apos; duck-type like test:
&apos; - does it have member .ctor of (BASIC) type Object?
&apos; - does it have member .fields of (BASIC) type Array?
Function isDataValue(x As Variant)
	Dim out
	out = False
	&apos; TODO: isDataValue: check isObject &amp; Not isNull first
	On Local Error Goto isDataValue_end
	If isObject(_ctor(x)) And isArray(_fields(x)) Then
		out = True
	End If
isDataValue_end:
	isDataValue = out
End Function

Function _ctor(o As Object)
	_ctor = o.ctor
End Function

Function _fields(o As Object)
	_fields = o.fields
End Function

Function field(idx As Integer, v As DataValue)
	field = v.fields(idx)
End Function

Function fieldCount(v As DataValue)
	fieldCount = CInt(UBound(v.fields) + 1)
End Function


Function DataValue_same(a As DataValue, b As DataValue)
	DataValue_same = (a.id = b.id)
End Function

Function DataValue_genericToString(v As DataValue)
	Dim seen As String : seen = &quot;&quot;
	DataValue_genericToString = _DataValue_genericToString(v, 0, seen)
End Function

Function _DataValue_genericToString( _
	ByVal v 	 As DataValue, _
	ByVal indent As Integer, _
	ByRef seen 	 As String _
)
	Dim out
	Dim ctor   As Variant : ctor   = v.ctor
	Dim fields As Variant : fields = v.fields
	Dim cStr   As String
	Dim fStr   As String
	
	If inStr(seen, v.id &amp; &quot;&quot;) &lt;&gt; 0 Then
		out = &quot;{ id: &quot; &amp; v.id &amp; &quot; }&quot;
	Else
		seen = v.id &amp; &quot; &quot; &amp; seen 
		If isDataValue(ctor) Then
			cStr = _DataValue_genericToString(ctor, indent + 2, seen)
		Else
			cStr = toString(ctor)
		End If
		If isArray(fields) Then
			fStr = _DataValue_genericToString_Array(fields, indent, seen)
		Else
			fStr = toString(fields)
		End If
		out = &quot;{ id: &quot; &amp; v.id &amp; &quot;,&quot;			&amp; NL &amp; space(indent) _
			&amp; &quot;  ctor: &quot; &amp; cStr &amp; &quot;,&quot; 		&amp; NL &amp; space(indent) _
			&amp; &quot;  fields: &quot; &amp; fStr 			&amp; NL &amp; space(indent) _
			&amp; &quot;}&quot;
	End If
	_DataValue_genericToString = out
End Function

Function _DataValue_genericToString_Array( _
	ByVal a 	 As Array, _
	ByVal indent As Integer, _
	ByRef seen 	 As String _
)
	Dim out
	out = &quot;Array(&quot;
	If UBound(a) &lt; 0 Then
		out = out &amp; &quot;)&quot;
	Else
		out = out &amp; NL &amp; space(indent + 4)
		Dim i As Integer, w As Variant
		For i = 0 To UBound(a)
			If i &gt; 0 Then
				out = out &amp; &quot;,&quot; &amp; NL &amp; space(indent + 4)
			End If
			w = a(i)
			If isArray(w) Then
				out = out &amp; _
				_DataValue_genericToString_Array(w, indent + 2, seen)
			ElseIf isDataValue(w) Then
				out = out &amp; _
				_DataValue_genericToString(w, indent + 4, seen)
			Else
				out = out &amp; toString(w)
			End If
		Next i
		out = out &amp; NL &amp; space(indent + 2) &amp; &quot;)&quot;
	End If	
	_DataValue_genericToString_Array = out
End Function

Function _mkValueFrom_lax(ctor As DataValue, args As Array)
	Dim x As Integer, a As Integer
	a = LBound(args)
	If a &lt;&gt; 0 Then
		croak(&quot;_mkValueFrom_lax &quot; &amp; ctor.fields(DataCtor_name) &amp; &quot;:&quot; _
			&amp; NL &amp; &quot;invalid &quot; &amp; a &amp; &quot;-based args Array&quot; _
			&amp; NL &amp; &quot;expected 0-based Array&quot;)
	Else
		x = UBound(ctor.fields(DataCtor_argTypes))
		a = UBound(args)
		If a &lt;&gt; x Then
			a = a + 1 : x = x + 1
			croak(&quot;_mkValueFrom_lax &quot; &amp; ctor.fields(DataCtor_name) _
				&amp; &quot;:&quot; _
				&amp; NL &amp; &quot;expected &quot; &amp; x &amp; &quot; arg&quot; &amp; IIf(x = 1, &quot;&quot;, &quot;s&quot;) _
				&amp; &quot; but got &quot; &amp; a _
				&amp; NL &amp; toString(args))
		End If
	End If
	_mkValueFrom_lax = _newDataValue(ctor, args)
End Function

Sub _setTypeCtor(dataCtor As DataValue, dataTypeCtor As DataValue)
	&apos; TODO: check that dataCtor really is a DataCtor
	&apos; TODO: check that dataTypeCtor really is a DatatypeCtor
	dataCtor.fields(DataCtor_typeCtor) = dataTypeCtor
End Sub


&apos; --------------------------------------------------------------

Function TType()
	Static out As Object &apos; DON&apos;T declare it as DataValue!
	If isNull(out) Then 
		out = bootstrapTypes()
	End If
	TType = out
End Function

&apos; String -&gt; Integer -&gt; (TypeApp List TDataCtor) -&gt; TDataTypeCtor
Function DataTypeCtor( _
	Optional _name As String, _
	Optional arity As Integer, _
	Optional dataCtors As Object _
)
	Static c As Object : If isNull(c) Then : c = ctorOf(TType) : End If
	Dim out As Variant
	If isMissing(_name) Then
		out = c
	&apos;ElseIf isMissing(arity) Then
	ElseIf isMissing(dataCtors) Then
		croak(&quot;DataTypeCtor/NYI: partial application&quot;)
	Else
		out = _newDataValue(c, Array(_name, arity, dataCtors))
	End If
	DataTypeCtor = out
End Function

Function TDataTypeCtor()
	Static out As Object &apos; DON&apos;T declare it as DataValue!
	If isNull(out) Then 
		out = field(DataCtor_typeCtor, DataTypeCtor)
	End If
	TDataTypeCtor = out
End Function

&apos; :: Str -&gt; (List TType) -&gt; TDataTypeCtor -&gt; TDataCtor
&apos;  = DataCtor &quot;DataCtor&quot; [Str (TypeApp List TType) TDataTypeCtor] TDataCtor
Function DataCtor()
	Static out As Object &apos; DON&apos;T declare as DataValue!
	If isNull(out) Then
		out = ctorOf(DataTypeCtor)
	End If
	DataCtor = out
End Function

Function TDataCtor()
	Static out As Object &apos; DON&apos;T declare as DataValue!
	If isNull(out) Then 
		out = field(DataCtor_typeCtor, DataCtor)
	End If
	TDataCtor = out
End Function

&apos; DataTypeCtor &quot;List&quot; 1 [Nil, Cons]
Function TList()
	Static out As Object &apos; DON&apos;T declare it as DataValue!
	If isNull(out) Then 
		out = field(DataCtor_argTypes, DataCtor)	&apos; a List value
		out = ctorOf(out)							&apos; a DataCtor value
		out = field(DataCtor_typeCtor, out)			&apos; a DataTypeCtor value
	End If
	TList = out
End Function

Function List_nil() &apos; singleton data ctor; returns the singleton value
	Static out As Object
	If isNull(out) Then
		&apos; The dataCtors field of TList is itself a List instance,
		&apos;  either (cCons cCons (cCons cNil  (vNil)))
		&apos;      or (cCons cNil  (cCons cCons (vNil)))
		&apos; In any case: the nil *value* is down at the very bottom!
		out = field(1, field(1, field(DataTypeCtor_dataCtors, TList)))
	End If
	List_nil = out
End Function

Function List_cons(Optional x As Variant, Optional xs As Variant)
	Static c As Object
	If isNull(c) Then
		&apos; The dataCtors field of TList is itself a List instance,
		&apos;  either (cCons cCons (cCons cNil  (vNil)))
		&apos;      or (cCons cNil  (cCons cCons (vNil)))
		&apos; In any case: the top data ctor is cons
		c = ctorOf(field(DataTypeCtor_dataCtors, TList))
	End If
	Dim out As Variant
	If isMissing(x) Then
		out = c
	ElseIf isMissing(xs) Then
		croak(&quot;List_cons/NYI: partial application&quot;)
	Else
		&apos; TODO: require xs to be of type List a and x of type a
		out = _newDataValue(c, Array(x, xs))
	End If
	List_cons = out
End Function

Function List_isNil(v As Variant)
	Dim out As Variant
	out = False
	If Not(isDataValue(v)) Then
		Goto isNil_typeError
	End If
	If DataValue_same(v, List_nil) Then
		out = True
	ElseIf Not(hasType(v, TList)) Then
		Goto isNil_typeError
	End If
	List_isNil = out
	Exit Function
isNil_typeError:
	croak(&quot;List_isNil: expected a List but got &quot; &amp; toString(v)
End Function

Function List_car(xs As Variant)
	List_car = field(0, xs)
End Function

Function List_cdr(xs As Variant)
	List_cdr = field(1, xs)
End Function

Function List_cadr(xs As Variant)
	List_cadr = List_car(List_cdr(xs))
End Function

Function List_cddr(xs As Variant)
	List_cddr = List_cdr(List_cdr(xs))
End Function

Function List_caddr(xs As Variant)
	List_caddr = List_car(List_cdr(List_cdr(xs)))
End Function

Function List_cdddr(xs As Variant)
	List_cdddr = List_cdr(List_cdr(List_cdr(xs)))
End Function

Function List_nth(ByVal n As Integer, ByVal xs As Variant)
	Do Until (n = 0)
		xs = List_cdr(xs)
		n = n - 1
	Loop
	List_nth = List_car(xs)
End Function

Function List_length(ByVal xs As Variant)
	Dim out As Integer
	Do Until List_isNil(xs)
		out = out + 1
		xs = List_cdr(xs)
	Loop
	List_length = out
End Function


Function TString() &apos; singleton data ctor; returns the singleton value
	Static out As Object
	If isNull(out) Then
		&apos; order of argTypes of DataTypeCtor is fixed:
		out = List_nth(0, field(DataCtor_argTypes, DataTypeCtor))
	End If
	TString = out
End Function

Function TInteger() &apos; singleton data ctor; returns the singleton value
	Static out As Object
	If isNull(out) Then
		&apos; order of argTypes of DataTypeCtor is fixed:
		out = List_nth(1, field(DataCtor_argTypes, DataTypeCtor))
	End If
	TInteger = out
End Function

Function TypeParam(Optional i As Integer)
	Static c As Object
	Dim out
	If isNull(c) Then
		&apos; Look for data ctor that has argTypes = [Integer]
		Dim ctors, argTypes
		ctors = field(DataTypeCtor_dataCtors, TType)
		Do While(True)
			c = List_car(ctors)
			argTypes = field(DataCtor_argTypes, c)
			If (List_length(argTypes) = 1) Then
				If DataValue_same(List_car(argTypes), TInteger) _
				Then : Exit Do : End If
			End If
			ctors = List_cdr(ctors)
		Loop
	End If
	If isMissing(i) Then
		out = c
	Else
		out = _newDataValue(c, Array(i))
	End If
	TypeParam = out
End Function

Function TypeApp(Optional tc As Object, Optional ta As Object)
	Static c As Object
	Dim out
	If isNull(c) Then
		&apos; Look for data ctor that has argTypes = [Type, Type]
		Dim ctors, argTypes
		ctors = field(DataTypeCtor_dataCtors, TType)
		Do While(True)
			c = List_car(ctors)
			argTypes = field(DataCtor_argTypes, c)
			If (List_length(argTypes) = 2) Then
				If  DataValue_same(List_car( argTypes), TDataTypeCtor) _
				And DataValue_same(List_cadr(argTypes), TType) _
				Then : Exit Do : End If
			End If
			ctors = List_cdr(ctors)
		Loop
	End If
	If isMissing(tc) Then
		out = c
	ElseIf isMissing(ta) Then
		croak(&quot;TypeApp/NYI: partial application&quot;)
	Else
		out = _newDataValue(c, Array(tc, ta))
	End If
	TypeApp = out
End Function





&apos; --------------------------------------------------------------

Function DataValue_toString(v As DataValue)
	Dim seen As String
	seen = &quot;&quot;
	DataValue_toString = _DataValue_toString(v, seen)
End Function

Function _DataValue_toString(v As DataValue, ByRef seen As String)
	Dim out As String
	Dim typeStr As String, ctorStr As String
	Dim ctor As DataValue, fields As Variant
	If inStr(seen, v.id &amp; &quot;&quot;) &lt;&gt; 0 Then
		out = &quot;{ id: &quot; &amp; v.id &amp; &quot; }&quot;
	Else
		seen = seen &amp; &quot; &quot; &amp; v.id
		ctor   = v.ctor
		fields = v.fields
		typeStr = field(DataTypeCtor_name, field(DataCtor_typeCtor, ctor))
		ctorStr = field(DataCtor_name, ctor)
		out = typeStr &amp; &quot;.&quot; &amp; ctorStr
		If UBound(fields) &gt;= 0 Then
			Dim argsStr As String, i As Integer, first As Boolean
			Dim tc As DataValue
					
			If typeStr = &quot;TDataTypeCtor&quot; Then
				argsStr = toString(field(DataTypeCtor_name, v)) &amp; &quot; &quot; &amp; field(DataTypeCtor_arity, v) &amp; &quot; &quot; 
				Dim dataCtors As Variant, dc As DataValue
				dataCtors = field(DataTypeCtor_dataCtors, v)
				If isArray(dataCtors) Then
					argsStr = argsStr &amp; &quot;Array(&quot;
					For i = 0 To UBound(dataCtors)
						If i &gt; 0 Then : argsStr = argsStr &amp; &quot;, &quot; : End If
						dc = dataCtors(i)
						argsStr = argsStr &amp; field(DataCtor_name, dc)
					Next i
					argsStr = argsStr &amp; &quot;)&quot;
				ElseIf isDataValue(dataCtors) Then
					ctor = ctorOf(dataCtors)
					tc = field(DataCtor_typeCtor, ctor)
					If field(DataTypeCtor_name, tc) = &quot;List&quot; Then
						argsStr = argsStr &amp; &quot;[&quot;
						first = True
						Do Until ctorName(dataCtors) = &quot;Nil&quot;
							If first Then
								first = False
							Else
								argsStr = argsStr &amp; &quot;, &quot;
							End If
							dc = field(0, dataCtors) &apos; &quot;car&quot;
							argsStr = argsStr &amp; field(DataCtor_name, dc)
							dataCtors = field(1, dataCtors) &apos; &quot;cdr&quot;
						Loop
						argsStr = argsStr &amp; &quot;]&quot; 
					Else
						argsStr = argsStr &amp; _DataValue_toString(dataCtors, seen)
					End If
				Else
					croak(&quot;DataValue_toString/non-array, non-dataValue dataCtors: NYI&quot;)
				End If
			ElseIf typeStr = &quot;TDataCtor&quot; Then
				argsStr = toString(field(DataTypeCtor_name, v)) &amp; &quot; &quot; 
				Dim argTypes As Variant, at As Variant
				argTypes = field(DataCtor_argTypes, v)
				If isArray(argTypes) Then
					argsStr = argsStr &amp; &quot;Array(&quot;
					For i = 0 To UBound(argTypes)
						If i &gt; 0 Then : argsStr = argsStr &amp; &quot;, &quot; : End If
						at = argTypes(i)
						If isDataValue(at) Then
							argsStr = argStr &amp; _DataValue_toString_Type(at, seen)	&apos; &lt;------ type-to-string here
						Else
							argsStr = argsStr &amp; toString(at)
						End If
					Next i
					argsStr = argsStr &amp; &quot;)&quot;
				ElseIf isDataValue(argTypes) Then
					ctor = ctorOf(argTypes)
					tc = field(DataCtor_typeCtor, ctor)
					If field(DataTypeCtor_name, tc) = &quot;List&quot; Then
						argsStr = argsStr &amp; &quot;[&quot;
						first = True
						Do Until ctorName(argTypes) = &quot;Nil&quot;
							If first Then
								first = False
							Else
								argsStr = argsStr &amp; &quot;, &quot;
							End If
							at = field(0, argTypes) &apos; &quot;car&quot;
							argsStr = argsStr &amp; _DataValue_toString_Type(at, seen)	&apos; &lt;------ type-to-string here
							argTypes = field(1, argTypes) &apos; &quot;cdr&quot;
						Loop
						argsStr = argsStr &amp; &quot;]&quot; 
					Else
						argsStr = argsStr &amp; _DataValue_toString(argTypes, seen)
					End If
				Else
					argsStr = argsStr &amp; toString(argTypes, seen)
					&apos;croak(&quot;DataValue_toString/non-array, non-dataValue argTypes: NYI&quot; &amp; NL &amp; NL &amp; toString(argTypes))
				End If
				argsStr = argsStr &amp; &quot; &quot; &amp; field(DataTypeCtor_name, field(DataCtor_typeCtor, v))
			Else
				argsStr = _DataValue_toString_Array(fields, seen)
			End If
			out = &quot;(&quot; &amp; out &amp; &quot; &quot; &amp; argsStr &amp; &quot;)&quot;
		End If
	End If
	_DataValue_toString = out
End Function

Function _DataValue_toString_Array(a As Array, ByRef seen As String)
	Dim out As String, i As Integer, x As Variant
	out = &quot;&quot;
	For i = 0 To UBound(a)
		If i &gt; 0 Then : out = out &amp; &quot; &quot; : End If
		x = a(i)
		If isDataValue(x) Then
			out = out &amp; _DataValue_toString(x, seen)
		ElseIf isArray(x) Then
			out = out &amp; &quot;Array(&quot; &amp; _DataValue_toString_Array(x, seen) &amp; &quot;)&quot;
		Else
			out = out &amp; toString(x)
		End If
	Next i
	
	_DataValue_toString_Array = out
End Function


Function _DataValue_toString_Type(v As DataValue, ByRef seen As String)
	Dim out As String : out = &quot;&quot;
	If isDataTypeCtor(v) Then
		out = field(DataTypeCtor_name, v)
	Else
		Dim c As DataValue : c = ctorOf(v)
		If ctorName(c) = &quot;DataCtor&quot; Then
			Dim t As DataValue : t = field(DataCtor_typeCtor, c)
			If field(DataTypeCtor_name, t) = &quot;Type&quot; Then
				Dim cName As String
				cName = ctorName(v)
				out = cName
				Dim args   As Variant, a As Variant
				Dim i As Integer, n As Integer
				args = _fields(v)
				n = UBound(args)
				If n &gt;= 0 Then
					out = out &amp; &quot; &quot;
					Select Case cName
						Case &quot;TypeParam&quot; &apos; TypeParam Integer
							out = out &amp; args(0)
						Case &quot;TypeApp&quot;	&apos; TypeApp TDataTypeCtor Type
							out = out &amp; field(DataTypeCtor_name, args(0)) _
								&amp; &quot; &quot; &amp; _DataValue_toString_Type(args(1), seen)
						Case Else
							croak(&quot;_DataValue_toString_Type/NYI: Type instance &quot; &amp; cName &amp; &quot; ...&quot;)
					End Select
					out = &quot;(&quot; &amp; out &amp; &quot;)&quot;
				End If
			End If
		End If
		If out = &quot;&quot; Then
			croak(&quot;_DataValue_toString_Type: invalid Type instance &quot; &amp; DataValue_toString(v))
		End If
	End If
	_DataValue_toString_Type = out
End Function


Function isDataTypeCtor(tc As DataValue)
	Dim out
	out = False
	Dim c As DataValue
	c = tc.ctor
	Dim cName As String
	cName = c.fields(DataCtor_name)
	If cName = &quot;DataTypeCtor&quot; Then
		Dim tcName As String
		tcName = c.fields(DataCtor_typeCtor).fields(DataTypeCtor_name) 
		If tcName = &quot;TDataTypeCtor&quot; Then
			out = True
		End If
	End If
	isDataTypeCtor = out
End Function

Function hasType(Optional v As Variant, Optional t As Object)
	Static oFn As Object
	Dim out As Variant
	If isMissing(t) Then
		If isNull(oFn) Then : 
			oFn = Fn.hasType
		End If
		If isMissing(v) Then
			out = oFn
		Else
			out = apply1(oFn, v)
		End If
	Else
		out = False
		Dim ct As Variant, cv As Variant
		ct = ctorOf(t)
		If isEmpty(ct) Then
			Goto hasType_invalidType
		ElseIf DataValue_same(ct, DataTypeCtor) Then
			cv = ctorOf(v)
			If Not(isEmpty(cv)) Then
				out = DataValue_same(field(DataCtor_typeCtor, cv), t)
			End If
		Else &apos; t is not a DataTypeCtor
			If DataValue_same(field(DataCtor_typeCtor, ct), TType) Then
				&apos; Note: TString and TInteger return the singleton
				&apos;       *value*, not the data ctor!
				If DataValue_same(t, TString) Then
					out = isString(v)
				ElseIf DataValue_same(t, TInteger) Then
					out = isInteger(v)
				Else
					croak(&quot;hasType/NYI: test against &quot; _
						&amp; DataValue_toString(t))
				End If
			Else &apos; t is not a TType data ctor either
				Goto hasType_invalidType
			End If
		End If
	End If	
		
	hasType = out
	Exit Function
hasType_invalidType:
	croak(&quot;hasType: not a type: &quot; &amp; toString(t))	
End Function

Function _newDataCtor( _
	typeCtor As TypeCtor, _
	name 	 As String, _
	argTypes As Array _
)
	Dim out As New DataCtor
	out.tag = &quot;DataCtor&quot;
	out._name = name
	out.typeCtor = typeCtor
	Dim lo As Integer : lo = LBound(argTypes)
	Dim hi As Integer : hi = UBound(argTypes)
	Dim n  As Integer : n = hi - lo + 1
	out.arity = n

	Dim typeStr As String, i As Integer
	typeStr = &quot;&quot;
	If n = 0 Then
		out.argTypes = Array()
	Else
		Dim ats(0 To n - 1)
		Dim t As Variant
		Dim k As Integer : k = 0
		For i = lo To hi
			t = argTypes(i)
			If isInteger(t) Then
				If (t &lt; 0) Or (t &gt;= typeCtor.arity) Then
					croak(&quot;_newDataCtor &quot; &amp; name &amp; &quot;: &quot; _
						&amp; &quot;invalid type var index &quot; &amp; t _
						&amp; &quot; - expected [0..&quot; &amp; (typeCtor.arity - 1) &amp; &quot;]&quot;_
					)
				End If
				typeStr = typeStr &amp; &quot;a&quot; &amp; t &amp; &quot; -&gt; &quot;
			ElseIf isType(t) Then
				If isArrowType(t) Then
					typeStr = typeStr &amp; &quot;(&quot; &amp; t.str &amp; &quot;)&quot;
				Else
					typeStr = typeStr &amp; t.str
				End If
				typeStr = typeStr &amp; &quot; -&gt; &quot;
			Else
				croak(&quot;_newDataCtor &quot; &amp; name &amp; &quot;: &quot; _
					&amp; &quot;invalid type arg &quot; &amp; toString(t) _
				)
			End If
			ats(k) = t
			k = k + 1
		Next i
	End If
	
	typeStr = typeStr &amp; typeCtor._name
	For i = 0 To typeCtor.arity - 1
		typeStr = typeStr &amp; &quot; a&quot; &amp; i
	Next i

	out.str = typeCtor._name &amp; &quot;.&quot; &amp; name &amp; &quot; :: &quot; &amp; typeStr
	_newDataCtor = out
End Function

Function _newTypeCtor( _
	name As String, _
	arity As Integer, _
	dataCtorDefs As Array _
) As TypeCtor
	Dim out As New TypeCtor
	out._name = name
	out.arity = arity
	Dim lo As Integer : lo = LBound(dataCtorDefs)
	Dim hi As Integer : hi = UBound(dataCtorDefs)
	Dim n  As Integer : n = hi - lo + 1
	If n = 0 Then
		out.dataCtors = Array()
	Else
		n = CInt(n / 2)
		Dim dataCtors(0 To n - 1)
		Dim c As Object
		Dim i As Integer : i = lo
		Dim k As Integer : k = 0
		Dim argTypes &apos; the types of the ctors arguments - NOT typeArgs!
		Do Until i &gt; hi
			c = _newDataCtor(out, dataCtorDefs(i), dataCtorDefs(i + 1))
			dataCtors(k) = c
			i = i + 2
			k = k + 1
		Loop
		out.dataCtors = dataCtors
	End If
	_newTypeCtor = out
End Function

Function isDataType(x As Variant)
	Dim out
	out = False
	On Local Error Goto isDataType_end
	out = _isDataType(x) &apos; DON&apos;T .-access x here!! (simpler this way anyhow)
isDataType_end:
	isDataType = out
End Function

&apos; provokes an error if x isn&apos;t a DataType
Function _isDataType(x As DataType) As Boolean
	_isDataType = Not(isNull(x.typeCtor)) And isArray(x.typeArgs)
End Function

Function isType(t As Variant)
	isType = isDataType(t) Or False
End Function

Function isArrowType(x As Variant)
	Dim out
	out = False
	&apos; TODO: implent isArrowType
	isArrowType = out
End Function

&apos; that&apos;s how to make a DataType: apply a typeCtor to some types
Function applyTC(tc As TypeCtor, typeArgs As Array) As DataType
	Dim out, n As Integer, k As Integer
	k = LBound(typeArgs)
	n = UBound(typeArgs) - k + 1
	If (n &lt;&gt; tc.arity) Then
		croak(&quot;applyTC &quot; &amp; tc._name &amp; &quot;: expected &quot; &amp; tc.arity _
			&amp; &quot; type arg&quot; &amp; IIf(tc.arity = 1, &quot;&quot;, &quot;s&quot;) &amp; &quot; but got &quot; &amp; n _
			&amp; &quot;: &quot; &amp; NL &amp; toString(typeArgs) _
		)
	End If
	out = New DataType
	out.typeCtor = tc
	Dim str As String
	str = tc._name
	If n = 0 Then
		out.typeArgs = Array()
	Else
		Dim tas(0 To n - 1)
		Dim a
		Dim i As Integer
		For i = 0 To n - 1
			a = typeArgs(k)
			If isType(a) Then
				If isDataType(a) Then
					If a.typeCtor.arity = 0 Then
						str = str &amp; &quot; &quot; &amp; a.str
					Else
						str = str &amp; &quot; (&quot; &amp; a.str &amp; &quot;)&quot;
					End If
				&apos;ElseIf isBaseType(a) Or isTypeVar(a) Then
				&apos;	str = str &amp; &quot; &quot; a._name
				End If
			Else
				croak(&quot;applyTc: invalid type arg &quot; _
					&amp; &quot;- expected a Type, not &quot; &amp; typeOf(a) _
					&amp; &quot;: &quot; &amp; NL &amp; toString(a) _
				)
			End If
			tas(i) = a
			k = k + 1
		Next i
		out.typeArgs = tas
	End If
	out.str = str
	applyTC = out
End Function

&apos; --- equ ---

Function TypeCtor_equ(a As TypeCtor, b As TypeCtor)
	Dim out
	out = (a._name = b._name)
	TypeCtor_equ = out
End Function

Function DataType_equ(a As DataType, b As DataType)
	Dim out
	out = False
	If TypeCtor_equ(a.typeCtor, b.typeCtor) Then
		Dim aArgs : aArgs = a.typeArgs
		Dim bArgs : bArgs = b.typeArgs
		Dim i As Integer
		For i = 0 To UBound(aArgs)
			If Not(Type_equ(aArgs(i), bArgs(i))) Then
				Goto DataType_equ_end
			End If
		Next i
		out = True
	End If
DataType_equ_end:
	DataType_equ = out
End Function

Function DataCtor_equ(a As DataCtor, b As DataCtor)
	Dim out
	out = False
	If a._name = b._name Then
		out = TypeCtor_equ(a.typeCtor, b.typeCtor)
	End If
	DataCtor_equ = out
End Function

Function Type_equ(a As Object, b As Object)
	Dim out
	out = False
	If isType(a) And isType(b) Then
		If isDataType(a) And isDataType(b) Then
			out = DataType_equ(a, b)
		&apos;ElseIf ... &apos;TODO: Type_equ for other Types
		End If
	Else
		croak(&quot;Type_equ: cannot compare &quot; &amp; typeOf(a) _
			&amp; &quot; and &quot; &amp; typeOf(b))
	End If
	Type_equ = out
End Function






Function applyDC(c As DataCtor, _
	Optional a0, _
	Optional a1, _
	Optional a2, _
	Optional a3, _
	Optional a4 _
)
	Dim out As Object
	If     isMissing(a0) Then :	out = _newDataValue(c, emptyArray)
	ElseIf isMissing(a1) Then :	out = _newDataValue(c, Array(a0))
	ElseIf isMissing(a2) Then :	out = _newDataValue(c, Array(a0, a1))
	ElseIf isMissing(a3) Then :	out = _newDataValue(c, Array(a0, a1, a2))
	ElseIf isMissing(a4) Then :	out = _newDataValue(c, Array(a0, a1, a2, a3))
	Else
		croak(&quot;applyDC &quot; &amp; ctor.name &amp; &quot;: &quot; _
			&amp; &quot; only up to 4 args supported - got 5&quot; _
		)
	End If
	applyDC = out
End Function


Function typeOf(x As Variant)
	Dim out As String
	out = TypeName(x)
	If out = &quot;Object&quot; Then &apos; DONT dot-access fields in here!
		Dim c
		c = ctorOf(x)
		If isEmpty(c) Then &apos; x is not a DataValue
			out = _typeOf(x)
		Else &apos; x is a DataValue
			out = &quot;Data/&quot; &amp; _
				field(DataTypeCtor_name, field(DataCtor_typeCtor, c))
		End If
	ElseIf IsArray(x) Then
		out = &quot;Array&quot;
	End If
	typeOf = out
End Function

Function _typeOf(o As Object)
	Dim out As String
	out = &quot;Object&quot;
	On Local Error Goto _typeOf_end
	out = out &amp; &quot;/&quot; &amp; _tyname(o)
_typeOf_end:
	_typeOf = out
End Function

Function _tyname(o As Object)
	_tyname = o.tyname
End Function

Function ctorOf(Optional x As Variant)
	Static oFn As Object
	Dim out As Variant
	If isMissing(x) Then 
		If isNull(oFn) Then : oFn = Fn.ctorOf : End If
		out = oFn
	Else
		out = Empty
		If isObject(x) Then
			If Not(isNull(x)) Then
				On Local Error Goto ctorOf_end
				out = _ctor(x) &apos; DONT access fields in here!
				If Not(isDataValue(out)) Then
					On Local Error Goto ctorOf_error
					Dim null As Object
					null.provoke_an_error
				End If
			End If
		End If
	End If
ctorOf_end:
	ctorOf = out
	Exit Function
ctorOf_error:
	croak(&quot;ctorOf: object with invalid .ctor :: &quot; _
	    &amp; typeOf(out) &amp; NL &amp; toString(out))
End Function

Function ctorName(v As DataValue)
	Dim out
	out = v.ctor.fields(DataCtor_name)
	ctorName = out
End Function

Function typeCtorOf(c)
	&apos;require(hasType, c, TDataCtor)
	typeCtorOf = c.fields(DataCtor_typeCtor)
End Function

Function typeCtorName(c)
	&apos;require(hasType, c, TDataCtor)
	typeCtorName = field(DataTypeCtor_name, typeCtorOf(c))
End Function


Function isString(Optional x As Variant)
	If isMissing(x) Then
		isString = Fn.isString
	Else
		isString = (typeOf(x) = typeOf(&quot;&quot;))
	End If
End Function

Function isInteger(Optional x As Variant)
	Dim out As Variant
	If isMissing(x) Then : out = Fn.isInteger
	Else 				 : out = (typeOf(x) = typeOf(0))
	End If
	isInteger = out
End Function


Function [test_Type======================================]
	test_Type_typeOf()
	test_Type_isObject()
	test_Type_isString()
	test_Type_isInteger()
	
	test_Type_isDataValue()
	test_Type_DataValue()
	test_Type_ctorOf()
	
	test_bootstrapTypes()
	test_Type_hasType()
		
	&apos;test_Type_isDataType()
	&apos;test_Type_TypeCtor()
	&apos;test_Type_DataCtor()
End Function

&apos; some dummy (BASIC) Type s used in tests
&apos; ---------------------------------------

Type TTest_NoTyname
End Type

Type TTest_Tyname
	tyname As String
End Type

Type TTest_Foo
	bar As Integer
End Type

Type TTest_Ctor
	ctor As Variant
End Type

&apos; test helpers
&apos; --------------------------------------------------


Function test_same(x As Variant, y As Variant, exp As Boolean)
	If Not(isDataValue(x)) Or Not(isDataValue(y)) Then
		Goto test_same_invalid_args
	End If
	Dim out, lvl As Integer, msg As String
	testLevel = testLevel + 1
	out = assertEqual(DataValue_same(x, y), exp)
	testLevel = testLevel - 1
	If out.isFail Then
		msg = &quot;expected .id &quot; &amp; x.id _
			&amp; IIf(exp, &quot;&quot;, &quot;NOT&quot;) _
			&amp; &quot; to be same as .id &quot; &amp; y.id &amp; &quot;:&quot; _
			&amp; NL &amp; &quot;.id &quot; &amp; x.id &amp; &quot;: &quot; &amp; DataValue_toString(x) _
			&amp; NL _
			&amp; NL &amp; &quot;.id &quot; &amp; y.id &amp; &quot;: &quot; &amp; DataValue_toString(y)
		out = mkFail(x, y, msg)
	End If
	test_same = out
	Exit Function
test_same_invalid_args:
	msg = IIf(exp, &quot;assert&quot;, &quot;refute&quot;) _
		&amp; &quot;_same: invalid args &quot; &amp; NL &amp; toString(x) _
		&amp; NL &amp; NL &amp; toString(y)
	croak(msg)
End Function

Function assert_same(act As Variant, exp As Variant)
	assert_same = test_same(act, exp, True)
End Function

Function refute_same(act As Variant, exp As Variant)
	refute_same = test_same(act, exp, False)
End Function

Function assert_hasCtor(v As Variant, c As Variant)
	If Not(isDataValue(c)) Or Not(isDataValue(c)) Then
		Goto assert_hasCtor_invalid_args
	End If
	If assert_same(ctorOf(c), DataCtor).isFail Then
		Goto assert_hasCtor_invalid_args
	End If
	assert_hasCtor = assert_same(ctorOf(v), c)
	Exit Function
assert_hasCtor_invalid_args:
	croak(&quot;assert_hasCtor: invalid args &quot; &amp; NL &amp; toString(v) _
		&amp; NL &amp; NL &amp; toString(c)
End Function

Function assert_hasTypeCtor(c As Variant, tc As Variant)
	If Not(isDataValue(c)) Or Not(isDataValue(tc)) Then
		Goto assert_hasTypeCtor_invalid_args
	End If
	If assert_same(ctorOf(c),  DataCtor    ).isFail _
	Or assert_same(ctorOf(tc), DataTypeCtor).isFail Then
		Goto assert_hasTypeCtor_invalid_args
	End If
	assert_hasTypeCtor = assert_same(field(DataCtor_typeCtor, c), tc)
	Exit Function
assert_hasTypeCtor_invalid_args:
		croak(&quot;assert_hasTypeCtor: invalid args &quot; &amp; NL &amp; toString(c) _
			&amp; NL &amp; NL &amp; toString(tc)
End Function

&apos; actual tests
&apos; ----------------------------------------------------

Function test_Type_typeOf()
	assertEqual(typeOf(0), &quot;Integer&quot;).x
	assertEqual(typeOf(1), &quot;Integer&quot;).x
	assertEqual(typeOf(-42), &quot;Integer&quot;).x
	
	assertEqual(typeOf(&quot;&quot;), &quot;String&quot;).x
	assertEqual(typeOf(&quot;1&quot;), &quot;String&quot;).x
	
	assertEqual(typeOf(3.14), &quot;Double&quot;).x

	assertEqual(typeOf(Array()), &quot;Array&quot;).x

	assertEqual(typeOf(Empty), &quot;Empty&quot;).x
	assertEqual(typeOf(Nothing), &quot;Object&quot;).x


	Dim t1 As New TTest_NoTyName
	assertEqual(typeOf(t1), &quot;Object&quot;).x

	Dim t2 As New TTest_TyName
	t2.tyname = &quot;foobar&quot;
	assertEqual(typeOf(t2), &quot;Object/foobar&quot;).x
	
	Dim a
	a = DataCtor
	assertEqual(typeOf(a), &quot;Data/TDataCtor&quot;).x
	a = TDataCtor
	assertEqual(typeOf(a), &quot;Data/TDataTypeCtor&quot;).x
	a = TDataTypeCtor
	assertEqual(typeOf(a), &quot;Data/TDataTypeCtor&quot;).x
	a = DataTypeCtor
	assertEqual(typeOf(a), &quot;Data/TDataCtor&quot;).x
	
	a = TList
	assertEqual(typeOf(a), &quot;Data/TDataTypeCtor&quot;).x
	
	a = List_nil	&apos; returns the singleton *value*
	assertEqual(typeOf(a), &quot;Data/List&quot;).x
	a = List_cons
	assertEqual(typeOf(a), &quot;Data/TDataCtor&quot;).x
	a = List_cons(List_nil, List_nil)
	assertEqual(typeOf(a), &quot;Data/List&quot;).x
	
End Function


&apos; isObject is a BASIC function:
&apos; make sure we know exactly what it does
Function test_Type_isObject()
	Dim o As Object

	assertEqual(isObject(Nothing),	True).x

	assertEqual(isObject(Empty),	False).x
	assertEqual(isObject(True),		False).x
	assertEqual(isObject(False),	False).x
	assertEqual(isObject(&quot;&quot;),		False).x
	assertEqual(isObject(&quot;foobar&quot;),	False).x
	assertEqual(isObject( 0),		False).x
	assertEqual(isObject( 1),		False).x
	assertEqual(isObject(-1),		False).x
	assertEqual(isObject(3.1415),	False).x
	assertEqual(isObject(Array()),	False).x

	o = New TTest_Foo
	assertEqual(isObject(o), True).x
	o.bar = 4711
	assertEqual(isObject(o), True).x
End Function

&apos; isString: implemented above
Function test_Type_isString()
	assertEqual(isString(&quot;&quot;),                  True).x
	assertEqual(isString(&quot;a&quot;),                 True).x
	assertEqual(isString(&quot;foobar&quot;),            True).x
	assertEqual(isString(Nothing),            False).x
	assertEqual(isString(Empty),              False).x
	assertEqual(isString(True),               False).x
	assertEqual(isString(False),              False).x
	assertEqual(isString(0),                  False).x
	assertEqual(isString(1),                  False).x
	assertEqual(isString(3.14),               False).x
	assertEqual(isString(Array()),            False).x
	assertEqual(isString(Array(42)),          False).x
	assertEqual(isString(Array(42)),          False).x
	
	assertEqual(arity(Fn.isString),	1).x &apos; from Fn object
	assertEqual(arity(isString),	1).x &apos; from 0-arg call
	
	assertEqual(apply(isString, &quot;&quot;),         True).x
	assertEqual(apply(isString, &quot;a&quot;),        True).x
	assertEqual(apply(isString, &quot;foobar&quot;),   True).x
	assertEqual(apply(isString, Nothing),   False).x
	assertEqual(apply(isString, Empty),     False).x
	assertEqual(apply(isString, True),      False).x
	assertEqual(apply(isString, False),     False).x
	assertEqual(apply(isString, 0),         False).x
	assertEqual(apply(isString, 1),         False).x
	assertEqual(apply(isString, 3.14),      False).x
	assertEqual(apply(isString, Array()),   False).x
	assertEqual(apply(isString, Array(42)), False).x
	assertEqual(apply(isString, Array(42)), False).x
End Function

&apos; isInteger: implemented above
Function test_Type_isInteger()
	assertEqual(isInteger(&quot;&quot;),                 False).x
	assertEqual(isInteger(&quot;a&quot;),                False).x
	assertEqual(isInteger(&quot;foobar&quot;),           False).x
	assertEqual(isInteger(Nothing),            False).x
	assertEqual(isInteger(Empty),              False).x
	assertEqual(isInteger(True),               False).x
	assertEqual(isInteger(False),              False).x
	assertEqual(isInteger( 0),                  True).x
	assertEqual(isInteger( 1),                  True).x
	assertEqual(isInteger(-1),                  True).x
	assertEqual(isInteger( 32766),              True).x &apos;0x7FFE
	assertEqual(isInteger( 32767),              True).x &apos;0x7FFF
	assertEqual(isInteger( 32768),             False).x &apos;0x8000 (!)
	assertEqual(isInteger( 65534),             False).x &apos;0xFFFE
	assertEqual(isInteger( 65535),             False).x &apos;0xFFFF
	assertEqual(isInteger( 65536),             False).x &apos;0x80000
	assertEqual(isInteger(-32766),              True).x &apos;0x8002
	assertEqual(isInteger(-32767),              True).x &apos;0x8001
	assertEqual(isInteger(-32768),              True).x &apos;0x8000
	assertEqual(isInteger(-32769),             False).x &apos;0x17FFF (!)
	assertEqual(isInteger(-65534),             False).x &apos;0xFFFE
	assertEqual(isInteger(-65535),             False).x &apos;0xFFFF
	assertEqual(isInteger(-65536),             False).x &apos;0x80000
	assertEqual(isInteger(3.14),               False).x
	assertEqual(isInteger(Array()),            False).x
	assertEqual(isInteger(Array(42)),          False).x
	assertEqual(isInteger(Array(42)),          False).x
End Function

Function test_Type_isDataValue()
	&apos; positive tests below
	assertEqual(isDataValue(&quot;&quot;),                 False).x
	assertEqual(isDataValue(&quot;a&quot;),                False).x
	assertEqual(isDataValue(&quot;foobar&quot;),           False).x
	assertEqual(isDataValue(Nothing),            False).x
	assertEqual(isDataValue(Empty),              False).x
	assertEqual(isDataValue(True),               False).x
	assertEqual(isDataValue(False),              False).x
	assertEqual(isDataValue( 0),                 False).x
	assertEqual(isDataValue( 1),                 False).x
	assertEqual(isDataValue(-1),                 False).x
	assertEqual(isDataValue( 32766),             False).x &apos;0x7FFE
	assertEqual(isDataValue( 32767),             False).x &apos;0x7FFF
	assertEqual(isDataValue( 32768),             False).x &apos;0x8000 (!)
	assertEqual(isDataValue( 65534),             False).x &apos;0xFFFE
	assertEqual(isDataValue( 65535),             False).x &apos;0xFFFF
	assertEqual(isDataValue( 65536),             False).x &apos;0x80000
	assertEqual(isDataValue(-32766),             False).x &apos;0x8002
	assertEqual(isDataValue(-32767),             False).x &apos;0x8001
	assertEqual(isDataValue(-32768),             False).x &apos;0x8000
	assertEqual(isDataValue(-32769),             False).x &apos;0x17FFF (!)
	assertEqual(isDataValue(-65534),             False).x &apos;0xFFFE
	assertEqual(isDataValue(-65535),             False).x &apos;0xFFFF
	assertEqual(isDataValue(-65536),             False).x &apos;0x80000
	assertEqual(isDataValue(3.14),               False).x
	assertEqual(isDataValue(Array()),            False).x
	assertEqual(isDataValue(Array(42)),          False).x
	assertEqual(isDataValue(Array(42)),          False).x
End Function

Function test_Type_DataValue()
	Dim v, c
	v = _newDataValue(Nothing, emptyArray)
	assertEqual(v.ctor, Nothing)
	assertEqual(LBound(v.fields),  0).x
	assertEqual(UBound(v.fields), -1).x
	assertEqual(isDataValue(v), True).x

	v = _newDataValue(Nothing, Array(42))
	assertEqual(v.ctor, Nothing)
	assertEqual(UBound(v.fields), 0).x
	assertEqual(v.fields(0), 42).x 
	assertEqual(isDataValue(v), True).x

	v = _newDataValue(Nothing, Array(&quot;foo&quot;, 4711))
	assertEqual(v.ctor, Nothing)
	assertEqual(UBound(v.fields), 1).x
	assertEqual(v.fields(0), &quot;foo&quot;).x 
	assertEqual(v.fields(1), 4711).x 
	assertEqual(isDataValue(v), True).x
End Function

	
Function test_Type_ctorOf()
	assertEqual(ctorOf(Nothing),	Empty).x
	assertEqual(ctorOf(Empty),		Empty).x
	assertEqual(ctorOf(True),		Empty).x
	assertEqual(ctorOf(False),		Empty).x
	assertEqual(ctorOf(&quot;&quot;),			Empty).x
	assertEqual(ctorOf(&quot;blah&quot;),		Empty).x
	assertEqual(ctorOf( 0),			Empty).x
	assertEqual(ctorOf( 1),			Empty).x
	assertEqual(ctorOf(-1),			Empty).x
	assertEqual(ctorOf(3.1415),		Empty).x

	Dim o As Object, act As Variant
	
	&apos; an object without member .ctor:
	o = New TTest_TyName
	assertEqual(ctorOf(o), Empty).x
	o.tyname = &quot;foo&quot;
	assertEqual(ctorOf(o), Empty).x

	&apos; an object with a member .ctor:
	o = New TTest_Ctor
	o.ctor = Empty		: assertThrows(ctorOf, Array(o)).x
	o.ctor = Nothing	: assertThrows(ctorOf, Array(o)).x
	o.ctor = True		: assertThrows(ctorOf, Array(o)).x
	o.ctor = False		: assertThrows(ctorOf, Array(o)).x
	o.ctor = &quot;&quot;			: assertThrows(ctorOf, Array(o)).x
	o.ctor = &quot;foo&quot;		: assertThrows(ctorOf, Array(o)).x
	o.ctor =  0			: assertThrows(ctorOf, Array(o)).x
	o.ctor =  1			: assertThrows(ctorOf, Array(o)).x
	o.ctor = -1			: assertThrows(ctorOf, Array(o)).x
	o.ctor = 3.1415		: assertThrows(ctorOf, Array(o)).x
	o.ctor = Array()	: assertThrows(ctorOf, Array(o)).x
	&apos; even a fn object:
	o.ctor = ctorOf		: assertThrows(ctorOf, Array(o)).x
End Function

Function bootstrapTypes()
	Dim vNil
	&apos; The most simple DataValue is one without any fields.
	&apos; Since we don&apos;t have data ctors yet we&apos;ll leave the
	&apos; .ctor member empty.
	vNil = _newDataValue(Nothing, emptyArray)
	&apos; The function DataValue_genericToString provides a way to
	&apos; see what&apos;s inside a DataValue:
	Dim vNilStr As String
	vNilStr = DataValue_genericToString(vNil)
	assertEqual( _
		vNilStr, _
		&quot;{ id: &quot; &amp; vNil.id &amp; &quot;,&quot;	&amp; NL &amp; _
		&quot;  ctor: Nothing,&quot;			&amp; NL &amp; _
		&quot;  fields: Array()&quot;			&amp; NL &amp; _
		&quot;}&quot;							       _
	).x
	&apos; We can see that there&apos;s another member: .id, which is unique
	&apos; to the particular DataValue instance. This gives rise to a 
	&apos; notion of sameness. The function `DataValue_same` provides a
	&apos; means of testing for sameness:
	assertEqual(DataValue_same(vNil, vNil), True).x
	&apos; Even if we provide the very same values, we&apos;ll get a
	&apos; different instance:
	Dim x
	x = _newDataValue(Nothing, emptyArray)
	assertEqual(DataValue_same(x, vNil), False).x
	&apos; To make the tests more readable we&apos;ll abbreviate that to
	refute_same(x, vNil).x
	&apos; and for a positive test:
	assert_same(x,    x).x
	assert_same(vNil, vNil).x
	&apos; ...which simply means that &quot;sameness&quot; is of course
	&apos; reflexive, ie for all x, y: if x = y then x same y.
	&apos; It is - again of course - 
	&apos; symmetric, ie forall x, y: x same y iff y same x.
	assertEqual(_
		DataValue_same(vNil, x), _
		DataValue_same(x, vNil) _
	).x
	
	&apos; Now we have to fill in the .ctor member of vNil, which should
	&apos; point to vNil&apos;s data ctor.
	&apos; A data ctor has
	&apos;   - a name (a String)
	&apos;   - a list of argument types (tbd)
	&apos;   - a pointer to its datatype ctor (tbd)
	&apos; ...and we&apos;ll consider DataValue s with a .ctor member pointing
	&apos; to it as having been &quot;created&quot; from that data ctor.
	&apos; We already can provide a name, and for the particular data ctor
	&apos; of vNil - which has no fields whatsoever - we can also provide
	&apos; the list of argument types: it&apos;s just the empty list, represented
	&apos; by vNil.
	&apos; If we want to represent data ctors as DataValue as well,
	&apos; then they in turn need a .ctor member. For now we&apos;ll leave it
	&apos; empty.
	Dim cNil
	cNil = _newDataValue(Nothing, Array( _
		&quot;Nil&quot;, _
		vNil, _
		Nothing _
	)
	assertEqual(isDataValue(cNil), True).x
	&apos; The data ctor is different from the value, even if the data ctor
	&apos; takes no arguments:
	refute_same(cNil, vNil).x
	&apos; Let&apos;s make sure that cNil has an empty argument list.
	&apos; We&apos;ll use the fn `field` and constants to index into a
	&apos; DataValue&apos;s fields:
	assert_same(field(DataCtor_argTypes, cNil), vNil).x
	&apos; Fill in cNil as vNil&apos;s .ctor and see what it looks like then:
	vNil.ctor = cNil
	vNilStr = DataValue_genericToString(vNil)
	assertEqual( vNilStr, _
		&quot;{ id: &quot; &amp; vNil.id &amp; &quot;,&quot;			&amp; NL &amp; _
		&quot;  ctor: { id: &quot; &amp; cNil.id &amp; &quot;,&quot;	&amp; NL &amp; _
		&quot;    ctor: Nothing,&quot;				&amp; NL &amp; _
		&quot;    fields: Array(&quot;				&amp; NL &amp; _
		&quot;      &apos;Nil&apos;,&quot;						&amp; NL &amp; _ 
		&quot;      { id: &quot; &amp; vNil.id &amp; &quot; },&quot;	&amp; NL &amp; _ 
		&quot;      Nothing&quot;						&amp; NL &amp; _
		&quot;    )&quot;								&amp; NL &amp; _
		&quot;  },&quot;								&amp; NL &amp; _
		&quot;  fields: Array()&quot;					&amp; NL &amp; _
		&quot;}&quot;										   _
	).x
	&apos; We&apos;ve just created a circular structure:
	&apos; vNil refers to cNil via .ctor and cNil refers to vNil
	&apos; via field argTypes. DataValue_genericToString resolves
	&apos; the problem by showing only the .id member of previously
	&apos; encountered DataValue s.
	&apos; Looking at cNil (first):
	Dim cNilStr
	cNilStr = DataValue_genericToString(cNil)
	assertEqual(cNilStr, _
		&quot;{ id: &quot; &amp; cNil.id &amp; &quot;,&quot;				&amp; NL &amp; _
		&quot;  ctor: Nothing,&quot;						&amp; NL &amp; _
		&quot;  fields: Array(&quot;						&amp; NL &amp; _
		&quot;    &apos;Nil&apos;,&quot;							&amp; NL &amp; _ 
		&quot;    { id: &quot; &amp; vNil.id &amp; &quot;,&quot;			&amp; NL &amp; _ 
		&quot;      ctor: { id: &quot; &amp; cNil.id &amp; &quot; },&quot;	&amp; NL &amp; _
		&quot;      fields: Array()&quot;					&amp; NL &amp; _
		&quot;    },&quot;								&amp; NL &amp; _
		&quot;    Nothing&quot;							&amp; NL &amp; _
		&quot;  )&quot;									&amp; NL &amp; _
		&quot;}&quot;											   _
	).x

	&apos; access ctor fields:
	&apos; TODO: why not .fields ?
	Dim c
	c = ctorOf(vNil)
	assertEqual(field(DataCtor_name,     c), &quot;Nil&quot;).x
	assert_same(field(DataCtor_argTypes, c), vNil).x
	assertEqual(field(DataCtor_typeCtor, c), Nothing).x
	
	
	
	
	
	
	
	&apos; Since the ctor is itself a DataValue - what&apos;s the ctor of that ctor?
	Dim cDataCtor As DataValue
	&apos; it&apos;ll be a DataValue again, and it&apos;ll be a data ctor with
	&apos; - name: &quot;DataCtor&quot;
	&apos; - argTypes: a list of argument types
	&apos; - and as the third field typeCtor: a DataTypeCtor
	&apos; The typeCtor field will be left empty for now, but we must mention
	&apos; it in the definition of DataCtor. Therefore there are not only
	&apos; two entries in argTypes - &quot;String&quot; and &quot;List_of_TypeExpr&quot; - but three: the
	&apos; third must be &quot;TDataTypeCtor&quot;.
	Dim cName As String, argTypes As Variant
	cName    = &quot;DataCtor&quot;
	&apos; The argTypes should be types (type expressions), which we don&apos;t
	&apos; have yet.
	&apos; But types (type expressions) may also be type variables. Let&apos;s
	&apos; just use plain strings and pretend they&apos;re type vars.
	&apos; Similarly, since we don&apos;t have the List data type yet, we&apos;ll
	&apos; use a native Array instead for argTypes and pretend it were a
	&apos; List.
	argTypes = Array(&quot;String&quot;, &quot;List_of_TypeExpr&quot;, &quot;TDataTypeCtor&quot;)
	cDataCtor = _newDataValue(Nothing, Array(cName, argTypes, Nothing))
	c = cDataCtor
	assertEqual(           field(DataCtor_name,     c), cName).x
	assert_toString_equals(field(DataCtor_argTypes, c), argTypes).x
	assertEqual(           field(DataCtor_typeCtor, c), Nothing).x

	&apos; What does it look like?
	Dim cDataCtorStr As String
	cDataCtorStr = DataValue_genericToString(cDataCtor)
	&apos;msgbox(cDataCtorStr)
	assertEqual( _
		cDataCtorStr, _
		&quot;{ id: &quot; &amp; cDataCtor.id &amp; &quot;,&quot;	&amp; NL &amp; _
		&quot;  ctor: Nothing,&quot;				&amp; NL &amp; _
		&quot;  fields: Array(&quot;				&amp; NL &amp; _
		&quot;    &apos;DataCtor&apos;,&quot;				&amp; NL &amp; _ 
		&quot;    Array(&quot;					&amp; NL &amp; _
		&quot;      &apos;String&apos;,&quot;				&amp; NL &amp; _
		&quot;      &apos;List_of_TypeExpr&apos;,&quot;		&amp; NL &amp; _
		&quot;      &apos;TDataTypeCtor&apos;&quot;			&amp; NL &amp; _
		&quot;    ),&quot;						&amp; NL &amp; _
		&quot;    Nothing&quot;					&amp; NL &amp; _
		&quot;  )&quot;							&amp; NL &amp; _
		&quot;}&quot;							           _
	).x

	&apos; Let&apos;s put this in as cNil&apos;s .ctor:
	cNil.ctor = cDataCtor
	&apos; Now cNil looks like this:
	cNilStr = DataValue_genericToString(cNil)
	assertEqual( _
		cNilStr, _
		&quot;{ id: &quot; &amp; cNil.id &amp; &quot;,&quot;				&amp; NL &amp; _
		&quot;  ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot;,&quot;	&amp; NL &amp; _
		&quot;    ctor: Nothing,&quot;					&amp; NL &amp; _
		&quot;    fields: Array(&quot;					&amp; NL &amp; _
		&quot;      &apos;DataCtor&apos;,&quot;						&amp; NL &amp; _ 
		&quot;      Array(&quot;							&amp; NL &amp; _ 
		&quot;        &apos;String&apos;,&quot;						&amp; NL &amp; _ 
		&quot;        &apos;List_of_TypeExpr&apos;,&quot;			&amp; NL &amp; _ 
		&quot;        &apos;TDataTypeCtor&apos;&quot;				&amp; NL &amp; _ 
		&quot;      ),&quot;								&amp; NL &amp; _
		&quot;      Nothing&quot;							&amp; NL &amp; _
		&quot;    )&quot;									&amp; NL &amp; _
		&quot;  },&quot;									&amp; NL &amp; _
		&quot;  fields: Array(&quot;						&amp; NL &amp; _
		&quot;    &apos;Nil&apos;,&quot;							&amp; NL &amp; _
		&quot;    { id: &quot; &amp; vNil.id &amp; &quot;,&quot;			&amp; NL &amp; _
		&quot;      ctor: { id: &quot; &amp; cNil.id &amp; &quot; },&quot;	&amp; NL &amp; _
		&quot;      fields: Array()&quot;					&amp; NL &amp; _
		&quot;    },&quot;								&amp; NL &amp; _
		&quot;    Nothing&quot;							&amp; NL &amp; _
		&quot;  )&quot;									&amp; NL &amp; _
		&quot;}&quot; _
	).x
	
	
	&apos; What&apos;s the ctor of cDataCtor?
	&apos; Since again, cDataCtor is just a DataValue, it&apos;s constructor
	&apos; must be a data ctor as we have just described, ie have fields:
	&apos; - 1st a String for the name - which we don&apos;t care about
	&apos; - 2nd a three-elem list with types &quot;String&quot;, &quot;List_of_Type_Expr&quot;
	&apos;       and &quot;TDataTypeCtor&quot;
	&apos; - 3rd a a value of type &quot;TDataTypeCtor&quot; (still left empty)
	&apos; But that&apos;s just cDataCtor itself!
	cDataCtor.ctor = cDataCtor
	&apos; Also: once we worked out the typeCtor field (left empty but we
	&apos; already &quot;know&quot; it must be a value of type &quot;TDataTypeCtor&quot;)
	&apos; - it&apos;ll work just fine as the typeCtor for both cDataCtor, and
	&apos; its constructor. Proof: if it works for cDataCtor then it will
	&apos; work for cDataCtor :)
	
	&apos; But we&apos;ve created a problem with traversing the structure
	&apos; in order to create a string representation. 
	&apos; TODO: infinite regression in toString(cDataCtor) via .ctor
	&apos; In the special case at hand, DataCtor, it&apos;s enough to not
	&apos; go down the .ctor member if it&apos;s the same as the current
	&apos; instance. This is indicated by &quot;-&gt;self&quot;:
	cDataCtorStr = DataValue_genericToString(cDataCtor)
	assertEqual( _
		cDataCtorStr, _
		&quot;{ id: &quot; &amp; cDataCtor.id &amp; &quot;,&quot;			&amp; NL &amp; _
		&quot;  ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot; },&quot;	&amp; NL &amp; _
		&quot;  fields: Array(&quot;						&amp; NL &amp; _
		&quot;    &apos;DataCtor&apos;,&quot;						&amp; NL &amp; _
		&quot;    Array(&quot;							&amp; NL &amp; _
		&quot;      &apos;String&apos;,&quot;						&amp; NL &amp; _
		&quot;      &apos;List_of_TypeExpr&apos;,&quot;				&amp; NL &amp; _
		&quot;      &apos;TDataTypeCtor&apos;&quot;					&amp; NL &amp; _
		&quot;    ),&quot;								&amp; NL &amp; _
		&quot;    Nothing&quot;							&amp; NL &amp; _
		&quot;  )&quot;									&amp; NL &amp; _
		&quot;}&quot; _
	).x
	
	
	&apos; So what&apos;s the type of cDataCtor, ie what should we put it&apos;s 
	&apos; typeCtor field?
	&apos; It&apos;s the very simple data type
	&apos;   TDataCtor = DataCtor Str (List TypeExpr)
	&apos; The &quot;DataCtor&quot; on the rhs is just a data ctor as we have defined,
	&apos; and its name is &quot;DataCtor&quot;.
	&apos; On the lhs, however, it&apos;s a DataTypeCtor and there&apos;s &quot;T&quot; as a name
	&apos; prefix. We *could* have given it just the same name, but the &quot;T&quot; may
	&apos; help to reduce confusion (a little bit...).
	&apos; Now, a DataTypeCtor has
	&apos; - a name (a String)
	&apos; - an arity (an Integer), which is the nr of it&apos;s type parameters
	&apos; - zero or more DataCtors
	&apos; We can describe that by defining another data ctor - which itself,
	&apos; as we saw, has DataCtor as it&apos;s (data) constructor:
	Dim cDataTypeCtor As DataValue, arity As Integer
	cDataTypeCtor = _newDataValue(cDataCtor, Array( _
		&quot;DataTypeCtor&quot;, _
		Array(&quot;String&quot;, &quot;Integer&quot;, &quot;List_of_DataCtor&quot;), _
		Nothing _
	))
	&apos; Except for the typeCtor field - again left empty -
	&apos; what we&apos;ve just done will be bread-and-butter: create a value
	&apos; from a data ctor where the value&apos;s fields are filled with the
	&apos; argument values - provided they comply with the data ctor&apos;s
	&apos; argTypes.
	&apos; However, we cannot factor this pattern out until we&apos;ve completed
	&apos; the bootstrap.
	cDataTypeCtor = _newDataValue(cDataCtor, Array( _
		&quot;DataTypeCtor&quot;, _
		Array(&quot;String&quot;, &quot;Integer&quot;, &quot;List_of_DataCtor&quot;), _
		Nothing _
	))
	assertEqual(DataValue_same(ctorOf(cDataTypeCtor), cDataCtor), True).x

	&apos;TODO: Another repeated pattern is that of making DataValues that serve
	&apos; serve as DataCtor s:
	&apos;cTypeCtor = _mkDataCtor(&quot;DataTypeCtor&quot;, Nothing)
	&apos; This will stick in the repeated cDataCtor as .ctor member and
	&apos; Array(&quot;String&quot;, &quot;Integer&quot;, &quot;List_of_DataCtor&quot;) as argType field
	
	&apos; Let&apos;s inspect cDataTypeCtor.
	Dim cDataTypeCtorStr As String
	cDataTypeCtorStr = DataValue_genericToString(cDataTypeCtor)
	assertEqual( _
		cDataTypeCtorStr, _
		&quot;{ id: &quot; &amp; cDataTypeCtor.id &amp; &quot;,&quot;			&amp; NL &amp; _
		&quot;  ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot;,&quot;		&amp; NL &amp; _
		&quot;    ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot; },&quot;	&amp; NL &amp; _
		&quot;    fields: Array(&quot;						&amp; NL &amp; _
		&quot;      &apos;DataCtor&apos;,&quot;							&amp; NL &amp; _
		&quot;      Array(&quot;								&amp; NL &amp; _
		&quot;        &apos;String&apos;,&quot;							&amp; NL &amp; _
		&quot;        &apos;List_of_TypeExpr&apos;,&quot;				&amp; NL &amp; _
		&quot;        &apos;TDataTypeCtor&apos;&quot;					&amp; NL &amp; _
		&quot;      ),&quot;									&amp; NL &amp; _
		&quot;      Nothing&quot;								&amp; NL &amp; _
		&quot;    )&quot;										&amp; NL &amp; _
		&quot;  },&quot;										&amp; NL &amp; _
		&quot;  fields: Array(&quot;							&amp; NL &amp; _
		&quot;    &apos;DataTypeCtor&apos;,&quot;						&amp; NL &amp; _
		&quot;    Array(&quot;								&amp; NL &amp; _
		&quot;      &apos;String&apos;,&quot;							&amp; NL &amp; _
		&quot;      &apos;Integer&apos;,&quot;							&amp; NL &amp; _
		&quot;      &apos;List_of_DataCtor&apos;&quot;					&amp; NL &amp; _
		&quot;    ),&quot;									&amp; NL &amp; _
		&quot;    Nothing&quot;								&amp; NL &amp; _
		&quot;  )&quot;										&amp; NL &amp; _
		&quot;}&quot; _
	).x
	
	
	&apos; Now we&apos;ll make a value from that cDataTypeCtor, and that value
	&apos; will serve as the typeCtor for DataCtor:
	Dim tcDataCtor As DataValue
	tcDataCtor = _newDataValue(cDataTypeCtor, Array( _
		&quot;TDataCtor&quot;, _
		0, _
		Array(cDataCtor) _
	)
	&apos; Since cDataCtor is a (the only) data ctor of tcDataCtor, cDataCtor&apos;s
	&apos; &quot;typeCtor&quot; field points back to tcDataCtor. We could do this by indexing
	&apos; into the .fields member and writing it there, like so:
	&apos; cDataCtor.fields(DataCtor_typeCtor) = tcDataCtor
	&apos; But again, this pointer-fixing will occur everytime we create a new
	&apos; data type (and its constructors), so:
 	assertEqual(field(DataCtor_typeCtor, cDataCtor), Nothing).x
	&apos; was empty, now set it:
	_setTypeCtor(cDataCtor, tcDataCtor)
	&apos; now it&apos;s set:
	Dim it
	it = field(DataCtor_typeCtor, cDataCtor)
	assertEqual(DataValue_same(it, tcDataCtor), True).x
	&apos; we also have constants for accessing a DataTypeCtor&apos;s fields:	
	assertEqual( _
		field(DataTypeCtor_name, it), _
		field(DataTypeCtor_name, tcDataCtor) ).x
	assertEqual( _
		field(DataTypeCtor_arity, it), _
		field(DataTypeCtor_arity, tcDataCtor) ).x
	
	it = field(DataTypeCtor_dataCtors, tcDataCtor)
	assertEqual(isArray(it), True).x
	assertEqual(DataValue_same(it(0), cDataCtor), True).x
	
	Dim tcDatStr As String
	tcDatStr = DataValue_genericToString(tcDataCtor)
	
	&apos;msgbox(tcDatStr &amp; NL &amp; NL &amp; _
	assertEqual(tcDatStr, _
		&quot;{ id: &quot; &amp; tcDataCtor.id &amp; &quot;,&quot;				&amp; NL &amp; _
		&quot;  ctor: { id: &quot; &amp; cDataTypeCtor.id &amp; &quot;,&quot;	&amp; NL &amp; _
		&quot;    ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot;,&quot;		&amp; NL &amp; _
		&quot;      ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot; },&quot;	&amp; NL &amp; _
		&quot;      fields: Array(&quot;						&amp; NL &amp; _
		&quot;        &apos;DataCtor&apos;,&quot;						&amp; NL &amp; _
		&quot;        Array(&quot;							&amp; NL &amp; _
		&quot;          &apos;String&apos;,&quot;						&amp; NL &amp; _
		&quot;          &apos;List_of_TypeExpr&apos;,&quot;				&amp; NL &amp; _
		&quot;          &apos;TDataTypeCtor&apos;&quot;					&amp; NL &amp; _
		&quot;        ),&quot;								&amp; NL &amp; _
		&quot;        { id: &quot; &amp; tcDataCtor.id &amp; &quot; }&quot;		&amp; NL &amp; _
		&quot;      )&quot;									&amp; NL &amp; _
		&quot;    },&quot;									&amp; NL &amp; _
		&quot;    fields: Array(&quot;						&amp; NL &amp; _
		&quot;      &apos;DataTypeCtor&apos;,&quot;						&amp; NL &amp; _
		&quot;      Array(&quot;								&amp; NL &amp; _
		&quot;        &apos;String&apos;,&quot;							&amp; NL &amp; _
		&quot;        &apos;Integer&apos;,&quot;						&amp; NL &amp; _
		&quot;        &apos;List_of_DataCtor&apos;&quot;				&amp; NL &amp; _
		&quot;      ),&quot;									&amp; NL &amp; _
		&quot;      Nothing&quot;								&amp; NL &amp; _
		&quot;    )&quot;										&amp; NL &amp; _
		&quot;  },&quot;										&amp; NL &amp; _
		&quot;  fields: Array(&quot;							&amp; NL &amp; _
		&quot;    &apos;TDataCtor&apos;,&quot;							&amp; NL &amp; _
		&quot;    0,&quot;									&amp; NL &amp; _
		&quot;    Array(&quot;								&amp; NL &amp; _
		&quot;      { id: &quot; &amp; cDataCtor.id &amp; &quot; }&quot;		&amp; NL &amp; _
		&quot;    )&quot;										&amp; NL &amp; _
		&quot;  )&quot;										&amp; NL &amp; _
		&quot;}&quot; _
	).x
	
	&apos; What&apos;s still missing is a typeCtor for cDataTypeCtor. We already
	&apos; have a ctor to construct DataTypeCtor s: cDataTypeCtor. It&apos;ll
	&apos; be quite simple again, with only one data ctor (cDataTypeCtor),
	&apos; and name &quot;TDataTypeCtor&quot;:
	&apos; TDataTypeCtor = DataTypeCtor String Int (List DataCtor)
	Dim tcDataTypeCtor As DataValue
	tcDataTypeCtor = _newDataValue(cDataTypeCtor, Array( _
		&quot;TDataTypeCtor&quot;, _
		0, _
		Array(cDataTypeCtor) _
	))
	&apos; and fill in the back-pointer:
	_setTypeCtor(cDataTypeCtor, tcDataTypeCtor)
	assertEqual(DataValue_same( _
		field(DataCtor_typeCtor, cDataTypeCtor), _
		tcDataTypeCtor), True).x
	
	Dim tcDataTypeCtorStr As String
	tcDataTypeCtorStr = DataValue_genericToString(tcDataTypeCtor)
	
	&apos;msgbox(tcDataTypeCtorStr &amp; NL &amp; NL &amp; _
	assertEqual(tcDataTypeCtorStr, _
		&quot;{ id: &quot; &amp; tcDataTypeCtor.id &amp; &quot;,&quot;					&amp; NL &amp; _
		&quot;  ctor: { id: &quot; &amp; cDataTypeCtor.id &amp; &quot;,&quot;			&amp; NL &amp; _
		&quot;    ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot;,&quot;				&amp; NL &amp; _
		&quot;      ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot; },&quot;			&amp; NL &amp; _
		&quot;      fields: Array(&quot;								&amp; NL &amp; _
		&quot;        &apos;DataCtor&apos;,&quot;								&amp; NL &amp; _
		&quot;        Array(&quot;									&amp; NL &amp; _
		&quot;          &apos;String&apos;,&quot;								&amp; NL &amp; _
		&quot;          &apos;List_of_TypeExpr&apos;,&quot;						&amp; NL &amp; _
		&quot;          &apos;TDataTypeCtor&apos;&quot;							&amp; NL &amp; _
		&quot;        ),&quot;										&amp; NL &amp; _
		&quot;        { id: &quot; &amp; tcDataCtor.id &amp; &quot;,&quot;				&amp; NL &amp; _
		&quot;          ctor: { id: &quot; &amp; cDataTypeCtor.id &amp; &quot; },&quot;	&amp; NL &amp; _
		&quot;          fields: Array(&quot;							&amp; NL &amp; _
		&quot;            &apos;TDataCtor&apos;,&quot;							&amp; NL &amp; _
		&quot;            0,&quot;									&amp; NL &amp; _
		&quot;            Array(&quot;								&amp; NL &amp; _
		&quot;              { id: &quot; &amp; cDataCtor.id &amp; &quot; }&quot;		&amp; NL &amp; _
		&quot;            )&quot;										&amp; NL &amp; _
		&quot;          )&quot;										&amp; NL &amp; _
		&quot;        }&quot;											&amp; NL &amp; _
		&quot;      )&quot;											&amp; NL &amp; _
		&quot;    },&quot;											&amp; NL &amp; _
		&quot;    fields: Array(&quot;								&amp; NL &amp; _
		&quot;      &apos;DataTypeCtor&apos;,&quot;								&amp; NL &amp; _
		&quot;      Array(&quot;										&amp; NL &amp; _
		&quot;        &apos;String&apos;,&quot;									&amp; NL &amp; _
		&quot;        &apos;Integer&apos;,&quot;								&amp; NL &amp; _
		&quot;        &apos;List_of_DataCtor&apos;&quot;						&amp; NL &amp; _
		&quot;      ),&quot;											&amp; NL &amp; _
		&quot;      { id: &quot; &amp; tcDataTypeCtor.id &amp; &quot; }&quot;			&amp; NL &amp; _
		&quot;    )&quot;												&amp; NL &amp; _
		&quot;  },&quot;												&amp; NL &amp; _
		&quot;  fields: Array(&quot;									&amp; NL &amp; _
		&quot;    &apos;TDataTypeCtor&apos;,&quot;								&amp; NL &amp; _
		&quot;    0,&quot;											&amp; NL &amp; _
		&quot;    Array(&quot;										&amp; NL &amp; _
		&quot;      { id: &quot; &amp; cDataTypeCtor.id &amp; &quot; }&quot;			&amp; NL &amp; _
		&quot;    )&quot;												&amp; NL &amp; _
		&quot;  )&quot;												&amp; NL &amp; _
		&quot;}&quot; _
	).x
	
	&apos; We have now established a structure of DataValue s where every
	&apos; DataValue has a
	&apos;   - a .ctor member which was made by &quot;applying&quot; cDataCtor to some arguments 
	&apos;   - a type ctor associated to it, and that is the .ctor&apos;s typeCtor field
	&apos; With that we can make more concise String representations of DataValue s.
	assertEqual(DataValue_toString(tcDataTypeCtor), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;TDataTypeCtor&apos; 0 Array(DataTypeCtor))&quot;).x
	assertEqual(DataValue_toString(tcDataCtor), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;TDataCtor&apos; 0 Array(DataCtor))&quot;).x
	assertEqual(DataValue_toString(cDataTypeCtor), _
		&quot;(TDataCtor.DataCtor &apos;DataTypeCtor&apos; Array(&apos;String&apos;, &apos;Integer&apos;, &apos;List_of_DataCtor&apos;) TDataTypeCtor)&quot;).x
	assertEqual(DataValue_toString(cDataCtor), _
		&quot;(TDataCtor.DataCtor &apos;DataCtor&apos; Array(&apos;String&apos;, &apos;List_of_TypeExpr&apos;, &apos;TDataTypeCtor&apos;) TDataCtor)&quot;).x
	
	&apos; The List data type
	&apos; ------------------
	
	&apos; Let&apos;s go back to old data ctor cNil. It itself has got a proper
	&apos; constructor (cDataCtor) but no DataTypeCtor in field typeCtor:
	assertEqual(field(DataCtor_typeCtor, cNil), Nothing).x
	
	&apos; So let&apos;s make one:
	Dim tcList As DataValue
	tcList = _newDataValue(cDataTypeCtor, Array( _
		&quot;List&quot;, 1, Nothing _
	))
	_setTypeCtor(cNil, tcList)
	&apos; There are two things that are different from what we did before:
	&apos;   - the arity field is set to 1, rather than 0
	&apos;   - the dataCtors field is left empty
	&apos; The former is to say that List will have a type parameter,
	&apos; and the latter is because we will be using *a List* again
	&apos; for this field - and once we have it do the same to the other
	&apos; TDataTypeCtor s we have.
	&apos; But before we can do so we need another data ctor for List:
	Dim cCons As DataValue
	cCons = _newDataValue(cDataCtor, Array( _
		&quot;Cons&quot;, vNil, tcList _
	))
	&apos; There we have left empty the argTypes field, again because we
	&apos; a List itself there. But we already filled in the type ctor:
	assertEqual(DataValue_same(field(DataCtor_typeCtor, cCons), tcList), True).x
	
	&apos; With those two data ctors we can now make List values.
	&apos; We already made one from cNil : vNil. It represents the 
	&apos; empty List. But that is exactly the argTypes list that 
	&apos; we want for the 0-arity data ctor cNil.
	cNil.fields(DataCtor_argTypes) = vNil
	&apos; A singleton list that contains just the data ctor cCons is this:
	x = _newDataValue(cCons, Array(cCons, vNil))
	&apos; ...and the two-elem list that contains both data ctors, cNil and
	&apos; and cCons - which we want for tcList&apos;s dataCtors field:
	tcList.fields(DataTypeCtor_dataCtors) = _newDataValue( _
		cCons, Array(cNil, x) _
	)

	assertEqual(DataValue_toString(tcList), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;List&apos; 1 [Nil, Cons])&quot;).x
	assertEqual(DataValue_toString(cCons), _
		&quot;(TDataCtor.DataCtor &apos;Cons&apos; [] List)&quot;).x
	assertEqual(DataValue_toString(cNil), _
		&quot;(TDataCtor.DataCtor &apos;Nil&apos; [] List)&quot;).x
	
	
	&apos; Now, we had given cCons an empty argTypes list, which needs to be fixed.
	&apos; We will express Types as yet another data type:
	Dim tcType As DataValue
	tcType = _newDataValue(cDataTypeCtor, Array(&quot;Type&quot;, 0, vNil))
	Dim cStr As DataValue, vStr As DataValue
	cStr = _newDataValue(cDataCtor, Array(&quot;String&quot;, vNil, tcType))
	&apos; add to dataCtors
	tcType.fields(DataTypeCtor_dataCtors) = _newDataValue(cCons, Array( _
		cStr, _
		field(DataTypeCtor_dataCtors, tcType) _
	))
	assertEqual(DataValue_toString(tcType), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;Type&apos; 0 [String])&quot;).x
	assertEqual(DataValue_toString(cStr), _
		&quot;(TDataCtor.DataCtor &apos;String&apos; [] Type)&quot;).x
	vStr = _newDataValue(cStr, Array())
	assertEqual(DataValue_toString(vStr), _
		&quot;Type.String&quot;).x
	
	
	Dim cInt As DataValue, vInt As DataValue
	cInt = _newDataValue(cDataCtor, Array(&quot;Integer&quot;, vNil, tcType))
	&apos; add to dataCtors
	tcType.fields(DataTypeCtor_dataCtors) = _newDataValue(cCons, Array( _
		cInt, _
		field(DataTypeCtor_dataCtors, tcType) _
	))
	assertEqual(DataValue_toString(tcType), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;Type&apos; 0 [Integer, String])&quot;).x
	assertEqual(DataValue_toString(cInt), _
		&quot;(TDataCtor.DataCtor &apos;Integer&apos; [] Type)&quot;).x
	vInt = _newDataValue(cInt, Array())
	assertEqual(DataValue_toString(vInt), _
		&quot;Type.Integer&quot;).x
	
	
	Dim cParam As DataValue
	cParam = _newDataValue(cDataCtor, Array( _
		&quot;TypeParam&quot;, _
		_newDataValue(cCons, Array(vInt, vNil)), _
		tcType _
	))
	&apos; add to dataCtors
	tcType.fields(DataTypeCtor_dataCtors) = _newDataValue(cCons, Array( _
		cParam, _
		field(DataTypeCtor_dataCtors, tcType) _
	))
	assertEqual(DataValue_toString(tcType), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;Type&apos; 0 [TypeParam, Integer, String])&quot;).x
	Dim vParam As DataValue
	vParam = _newDataValue(cParam, Array(0))
	assertEqual(DataValue_toString(vParam), _
		&quot;(Type.TypeParam 0)&quot;).x
	
	Dim cApp As DataValue
	cApp = _newDataValue(cDataCtor, Array( _
		&quot;TypeApp&quot;, _
		_newDataValue(cCons, Array(tcDataTypeCtor, _newDataValue(cCons, Array(tcType, vNil)))), _
		tcType _
	))
	&apos; add to dataCtors
	tcType.fields(DataTypeCtor_dataCtors) = _newDataValue(cCons, Array( _
		cApp, _
		field(DataTypeCtor_dataCtors, tcType) _
	))
	assertEqual(DataValue_toString(tcType), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;Type&apos; 0 [TypeApp, TypeParam, Integer, String])&quot;).x
	assertEqual(DataValue_toString(cApp), _
		&quot;(TDataCtor.DataCtor &apos;TypeApp&apos; [TDataTypeCtor, Type] Type)&quot;).x
	Dim vApp As DataValue
	vApp = _newDataValue(cApp, Array(tcList, vParam))
	assertEqual(DataValue_toString(vApp), _
		&quot;(Type.TypeApp (TDataTypeCtor.DataTypeCtor &apos;List&apos; 1 [Nil, Cons]) (Type.TypeParam 0))&quot;).x
	
	&apos; With vParam and vApp we can fix the argTypes List of cCons:
	argTypes = _
		_newDataValue(cCons, Array(vParam, _
		_newDataValue(cCons, Array(vApp, _
		vNil))))
	cCons.fields(DataCtor_argTypes) = argTypes
	assertEqual(DataValue_toString(cCons), _
		&quot;(TDataCtor.DataCtor &apos;Cons&apos; [(TypeParam 0), (TypeApp List (TypeParam 0))] List)&quot;).x
	
	
	&apos; fix the rest
	vApp = _newDataValue(cApp, Array(tcList, tcType))
	argTypes = vNil
	argTypes = _newDataValue(cCons, Array(tcDataTypeCtor, argTypes))
	argTypes = _newDataValue(cCons, Array(vApp,  argTypes))
	argTypes = _newDataValue(cCons, Array(vStr,  argTypes))
	cDataCtor.fields(DataCtor_argTypes) = argTypes
	assertEqual(DataValue_toString(cDataCtor), _
		&quot;(TDataCtor.DataCtor &apos;DataCtor&apos; [String, (TypeApp List Type), TDataTypeCtor] TDataCtor)&quot;).x
	
	
	tcDataCtor.fields(DataTypeCtor_dataCtors) = _newDataValue( _
		cCons, Array(cDataCtor , vNil))
	assertEqual(DataValue_toString(tcDataCtor), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;TDataCtor&apos; 0 [DataCtor])&quot;).x


	vApp = _newDataValue(cApp, Array(tcList, tcDataCtor))
	argTypes = vNil
	argTypes = _newDataValue(cCons, Array(vApp, argTypes))
	argTypes = _newDataValue(cCons, Array(vInt,  argTypes))
	argTypes = _newDataValue(cCons, Array(vStr,  argTypes))
	cDataTypeCtor.fields(DataCtor_argTypes) = argTypes
	assertEqual(DataValue_toString(cDataTypeCtor), _
		&quot;(TDataCtor.DataCtor &apos;DataTypeCtor&apos; [String, Integer, (TypeApp List TDataCtor)] TDataTypeCtor)&quot;).x
	
	
	tcDataTypeCtor.fields(DataTypeCtor_dataCtors) = _newDataValue( _
		cCons, Array(cDataTypeCtor , vNil))
	assertEqual(DataValue_toString(tcDataTypeCtor), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;TDataTypeCtor&apos; 0 [DataTypeCtor])&quot;).x
	
	&apos; from that we can reach everything in the object graph:
	bootstrapTypes = tcType
End Function	


Function test_bootstrapTypes()
	Dim tcType As Variant
	tcType = TType
	assertEqual(isDataValue(tcType), True).x
	assertEqual(fieldCount( tcType), 3).x
	assertEqual(field(DataTypeCtor_name,  tcType), &quot;Type&quot;).x
	assertEqual(field(DataTypeCtor_arity, tcType), 0).x
	&apos; field dataCtors later

	Dim cDataTypeCtor As Variant
	cDataTypeCtor = DataTypeCtor
	assertEqual(isDataValue(cDataTypeCtor), True).x
	assertEqual(fieldCount( cDataTypeCtor), 3).x
	assertEqual(field(DataTypeCtor_name, cDataTypeCtor), &quot;DataTypeCtor&quot;).x
	&apos; field argTypes later
	assert_hasCtor(tcType, cDataTypeCtor).x
	&apos; different from anything else so far:
	refute_same(cDataTypeCtor, tcType).x

	Dim tcDataTypeCtor As Variant
	tcDataTypeCtor = TDataTypeCtor
	assertEqual(isDataValue(tcDataTypeCtor), True).x
	assertEqual(fieldCount( tcDataTypeCtor), 3).x
	assertEqual(field(DataTypeCtor_name, tcDataTypeCtor), &quot;TDataTypeCtor&quot;).x
	assertEqual(field(DataTypeCtor_arity, tcDataTypeCtor), 0).x
	&apos; field dataCtors later
	assert_hasCtor(    tcDataTypeCtor,	cDataTypeCtor).x
	assert_hasTypeCtor(cDataTypeCtor,	tcDataTypeCtor).x
	&apos; TODO: confirm that tcDataTypeCtor dataCtors(0) = cDataTypeCtor
	&apos; different from anything else so far:
	refute_same(tcDataTypeCtor, tcType).x
	refute_same(tcDataTypeCtor, cDataTypeCtor).x

	Dim cDataCtor As Variant
	cDataCtor = DataCtor
	assertEqual(isDataValue(cDataCtor), True).x
	assertEqual(fieldCount( cDataCtor), 3).x
	assertEqual(field(DataCtor_name, cDataCtor), &quot;DataCtor&quot;).x
	&apos; field argTypes later
	assert_hasCtor(cDataCtor, 	cDataCtor).x
	assert_hasCtor(cDataTypeCtor,	cDataCtor).x
	&apos; different from anything else so far:
	refute_same(cDataCtor, tcType).x
	refute_same(cDataCtor, cDataTypeCtor).x
	refute_same(cDataCtor, tcDataTypeCtor).x
	
	Dim tcDataCtor As Variant
	tcDataCtor = TDataCtor
	assertEqual(isDataValue(tcDataCtor), True).x
	assertEqual(fieldCount( tcDataCtor), 3).x
	assertEqual(field(DataTypeCtor_name,  tcDataCtor), &quot;TDataCtor&quot;).x
	assertEqual(field(DataTypeCtor_arity, tcDataCtor), 0).x
	&apos; field dataCtors later
	assert_hasCtor(tcDataCtor, 		cDataTypeCtor).x
	assert_hasCtor(cDataTypeCtor, 	cDataCtor).x
	assert_hasTypeCtor(cDataCtor, 	tcDataCtor).x
	&apos; TODO: confirm that tcDataCtor dataCtors(0) = cDataCtor
	&apos; different from anything else so far:
	refute_same(tcDataCtor, tcType).x
	refute_same(tcDataCtor, cDataTypeCtor).x
	refute_same(tcDataCtor, tcDataTypeCtor).x
	refute_same(tcDataCtor, cDataCtor).x
	
	Dim tcList As Variant
	tcList = TList
	assertEqual(isDataValue(tcList), True).x
	assertEqual(fieldCount(tcList), 3).x
	assertEqual(field(DataTypeCtor_name,  tcList), &quot;List&quot;).x
	assertEqual(field(DataTypeCtor_arity, tcList), 1).x
	&apos; its dataCtors field is a List instance:
	assert_hasTypeCtor(ctorOf(field(DataTypeCtor_dataCtors, tcList)), tcList).x
	assert_hasCtor(    tcList, cDataTypeCtor).x
	&apos; different from anything else so far:
	refute_same(tcList, tcType).x
	refute_same(tcList, cDataTypeCtor).x
	refute_same(tcList, tcDataTypeCtor).x
	refute_same(tcList, cDataCtor).x
	refute_same(tcList, tcDataCtor).x

	&apos; dataCtors fields of the other type ctors so far:
	assert_hasTypeCtor(ctorOf(field(DataTypeCtor_dataCtors, tcType)), 			tcList).x
	assert_hasTypeCtor(ctorOf(field(DataTypeCtor_dataCtors, tcDataTypeCtor)), 	tcList).x
	assert_hasTypeCtor(ctorOf(field(DataTypeCtor_dataCtors, tcDataCtor)), 		tcList).x

	&apos; argTypes fields of the data ctors so far:
	assert_hasTypeCtor(ctorOf(field(DataCtor_argTypes, cDataTypeCtor)),			tcList).x
	assert_hasTypeCtor(ctorOf(field(DataCtor_argTypes, cDataCtor)),				tcList).x
	

	&apos;---- data ctors of TList
	
	Dim vNil As Variant, cNil As Variant
	vNil = List_nil
	assertEqual(isDataValue(vNil), True).x
	&apos; List_nil returns the same instance again
	assertEqual(DataValue_same(List_nil, vNil), True).x
	cNil = ctorOf(vNil)
	assertEqual(isDataValue(cNil), True).x
	assertEqual(fieldCount(vNil),  0).x
	assertEqual(fieldCount(cNil),  3).x
	assert_hasCtor(    vNil, cNil		).x
	assert_hasCtor(    cNil, cDataCtor	).x
	assert_hasTypeCtor(cNil, tcList		).x
	&apos; Let&apos;s not test the name, rather confirm that cNil is a
	&apos; singleton data ctor: its argTypes field is the same as vNil!
	assert_same(field(DataCtor_argTypes, cNil), vNil).x
	&apos; TList&apos;s dataCtors field is non-nil:
	Dim ListCtors
	ListCtors = field(DataTypeCtor_dataCtors, tcList)
	refute_same(ListCtors, vNil).x

	&apos; vNil is different from anything else so far:
	refute_same(vNil, tcType).x
	refute_same(vNil, cDataTypeCtor).x
	refute_same(vNil, tcDataTypeCtor).x
	refute_same(vNil, cDataCtor).x
	refute_same(vNil, tcDataCtor).x
	refute_same(vNil, tcList).x
	&apos; cNil is different from anything else so far:
	refute_same(cNil, vNil).x
	refute_same(cNil, tcType).x
	refute_same(cNil, cDataTypeCtor).x
	refute_same(cNil, tcDataTypeCtor).x
	refute_same(cNil, cDataCtor).x
	refute_same(cNil, tcDataCtor).x
	refute_same(cNil, tcList).x
	
	Dim cCons As Variant
	cCons = List_cons
	assertEqual(isDataValue(cCons), True).x
	assert_hasCtor(    cCons, cDataCtor	).x
	assert_hasTypeCtor(cCons, tcList	).x
	&apos; Let&apos;s not test the name, rather confirm that it has 
	&apos; a non-nil argTypes field and is itself the data ctor of that!
	refute_same(field(DataCtor_argTypes, cCons), vNil).x
	assert_hasCtor(field(DataCtor_argTypes, cCons), cCons).x
	&apos; TList&apos;s dataCtors field is a cons value:
	assert_hasCtor(ListCtors, cCons).x

	&apos; cCons is different from anything else so far:
	refute_same(cCons, tcType).x
	refute_same(cCons, cDataTypeCtor).x
	refute_same(cCons, tcDataTypeCtor).x
	refute_same(cCons, cDataCtor).x
	refute_same(cCons, tcDataCtor).x
	refute_same(cCons, tcList).x
	refute_same(cCons, vNil).x
	refute_same(cCons, cNil).x
	
	&apos;--- apply List_cons, test List_isNil
	Dim xs As Variant, ys As Variant
	xs = vNil
	assertEqual(List_isNil(xs), True).x
	
	xs = List_cons(vNil, vNil)
	assertEqual(isDataValue(xs), True).x
	assert_hasCtor(xs, cCons).x
	assertEqual(List_isNil(xs), False).x
	ys = List_cons(vNil, ys)
	assertEqual(isDataValue(ys), True).x
	assert_hasCtor(ys, cCons).x
	assertEqual(List_isNil(ys), False).x
	
	&apos;--- List_car, List_cdr, List_nth
	xs = List_cons(vNil, List_cons(vNil, vNil))
	ys = List_cons(vNil, xs)
	assert_same(List_car(ys), vNil).x
	assert_same(List_cdr(ys), xs).x
	assert_same(List_car(xs), vNil).x
	xs = List_cons(2, List_cons(3, vNil))
	ys = List_cons(1, xs)
	assertEqual(                             List_car(ys),		1).x
	assert_same(              				 List_cdr(ys),	   xs).x
	assertEqual(                             List_car(xs),		2).x	
	assertEqual(                    List_car(List_cdr(ys)),		2).x	
	assertEqual(                    List_car(List_cdr(xs)),		3).x	
	assertEqual(           List_car(List_cdr(List_cdr(ys))),	3).x	
	assertEqual(List_isNil(List_cdr(List_cdr(List_cdr(ys)))), 		True).x	

	assertEqual(            List_cadr(ys),	2).x	
	assertEqual(            List_cadr(xs),	3).x	
	assertEqual(List_isNil( List_cddr(xs)),	True).x	
	assertEqual(           List_caddr(ys),	3).x	
	assertEqual(List_isNil(List_cdddr(ys)),	True).x	

	assertEqual(List_nth(0, xs), 2).x
	assertEqual(List_nth(1, xs), 3).x
	assertEqual(List_nth(0, ys), 1).x
	assertEqual(List_nth(1, ys), 2).x
	assertEqual(List_nth(2, ys), 3).x

	&apos;--- List_length
	assertEqual(List_length(						  vNil), 	0).x
	assertEqual(List_length(			 List_cons(0, vNil)), 	1).x
	assertEqual(List_length(List_cons(0, List_cons(0, vNil))), 	2).x

	&apos;assertEqual(isFn(Fn.length), 	True).x	&apos; from Fn object
	&apos;assertEqual(isFn(List_length), 	True).x	&apos; from 0-arg call
	&apos;assertEqual(arity(List_length), 1).x
	
	&apos;assertEqual(apply(List_length,							  vNil), 	0).x
	&apos;assertEqual(apply(List_length,				 List_cons(0, vNil)), 	1).x
	&apos;assertEqual(apply(List_length,	List_cons(0, List_cons(0, vNil))), 2).x

	
	&apos;--- with List_length and List_nth, 
	&apos;    check dataCtors fields of data type ctors so far (TType later)
	Dim dataCtors
	dataCtors = field(DataTypeCtor_dataCtors,         tcDataTypeCtor)
	assertEqual(List_length(dataCtors), 1).x
	assert_same(List_nth(0, dataCtors), cDataTypeCtor).x
	
	dataCtors = field(DataTypeCtor_dataCtors,         tcDataCtor)
	assertEqual(List_length(dataCtors), 1).x
	assert_same(List_nth(0, dataCtors), cDataCtor).x
	
	dataCtors = field(DataTypeCtor_dataCtors,         tcList)
	assertEqual(List_length(dataCtors), 2).x
	assert_same(List_nth(0, dataCtors), cNil).x
	assert_same(List_nth(1, dataCtors), cCons).x


	&apos;--- fix argument order for DataTypeCtor
	Dim argTypes, at
	argTypes = field(DataCtor_argTypes, cDataTypeCtor)
	assertEqual(List_length(argTypes), 3).x
	
	at = List_nth(0, argTypes)
	assert_hasTypeCtor(ctorOf(at), tcType).x
	assertEqual(fieldCount(at), 0).x &apos; singleton value
	assertEqual(ctorName(at), &quot;String&quot;).x
	
	at = List_nth(1, argTypes)
	assert_hasTypeCtor(ctorOf(at), tcType).x
	assertEqual(fieldCount(at), 0).x &apos; singleton value
	assertEqual(ctorName(at), &quot;Integer&quot;).x
	
	&apos; third arg should be (TypeApp TList TDataCtor) - later


	&apos;--- data ctors of TType
	
	&apos;--- TType data ctor: String
	Dim vString As Variant, cString As Variant &apos; singleton data ctor, returns the singleton value
	vString = TString
	assertEqual(isDataValue(vString), True).x
	assertEqual( fieldCount(vString), 0).x	&apos; singleton value
	&apos; TString returns the same instance again
	assert_same(TString, vString).x
	cString = ctorOf(vString)
	assertEqual(isDataValue(cString), True).x
	assertEqual( fieldCount(cString), 3).x
	assertEqual(           field(DataCtor_name,     cString),  &quot;String&quot;).x
	argTypes = field(DataCtor_argTypes, cString)
	assertEqual(List_length(argTypes), 0).x &apos; singleton ctor
	assert_hasTypeCtor(cString,		tcType).x
	assert_hasCtor(	   cString,		cDataCtor).x
	
	&apos;--- TType data ctor: Integer
	Dim vInt As Variant, cInt As Variant &apos; singleton data ctor, returns the singleton value
	vInt = TInteger
	assertEqual(isDataValue(vInt), True).x
	assertEqual( fieldCount(vInt), 0).x	&apos; singleton value
	&apos; TInteger returns the same instance again
	assert_same(TInteger, vInt).x
	cInt = ctorOf(vInt)
	assertEqual(isDataValue(cInt), True).x
	assertEqual( fieldCount(cInt), 3).x
	assertEqual(           field(DataCtor_name,     cInt),  &quot;Integer&quot;).x
	argTypes = field(DataCtor_argTypes, cInt)
	assertEqual(List_length(argTypes), 0).x &apos; singleton ctor
	assert_hasTypeCtor(cInt,		tcType).x
	assert_hasCtor(	   cInt,		cDataCtor).x

	&apos;--- TType data ctor: TypeParam Integer
	Dim cParam As Variant
	cParam = TypeParam
	assertEqual(isDataValue(cParam), True		).x
	assertEqual( fieldCount(cParam), 3			).x
	assert_hasTypeCtor(     cParam,  tcType		).x
	assert_hasCtor(			cParam,  cDataCtor	).x
	assertEqual(field(DataCtor_name,     cParam),  &quot;TypeParam&quot;).x
	argTypes =  field(DataCtor_argTypes, cParam)
	assertEqual(List_length(argTypes), 1).x
	assert_same(List_nth(0, argTypes), vInt).x

	&apos;--- apply data ctor TypeParam
	Dim vParam As Variant
	vParam = TypeParam(42)
	assertEqual(isDataValue(vParam),	True	).x
	assertEqual( fieldCount(vParam),	1		).x
	assert_hasCtor(         vParam,		cParam	).x
	assertEqual(field(0,	vParam),	42).x

	&apos;--- TType data ctor: TypeApp TDataTypeCtor Type
	Dim cApp As Variant
	cApp = TypeApp
	assertEqual(isDataValue(cApp), True		).x
	assertEqual( fieldCount(cApp), 3			).x
	assert_hasTypeCtor(     cApp,  tcType		).x
	assert_hasCtor(			cApp,  cDataCtor	).x
	assertEqual(field(DataCtor_name,     cApp),  &quot;TypeApp&quot;).x
	argTypes =  field(DataCtor_argTypes, cApp)
	assertEqual(List_length(argTypes), 2).x
	assert_same(List_nth(1, argTypes), tcType).x
	&apos; TODO: really only TDataTypeCtor? - it means only 1 type param ever!
	assert_same(List_nth(0, argTypes), tcDataTypeCtor).x

	&apos;--- apply data ctor TypeApp
	Dim vApp As Variant
	vApp = TypeApp(tcList, vInt)
	assertEqual(isDataValue(vApp),	True	).x
	assertEqual( fieldCount(vApp),	2		).x
	assert_hasCtor(         vApp,	cApp	).x	

	assert_same(field(0,	vApp),	tcList).x
	assert_same(field(1,	vApp),	vInt).x
	
	
	&apos;--- apply data ctor DataTypeCtor
	Dim tcUnit

End Function

Function test_Type_hasType
	assertEqual(hasType(DataTypeCtor,	TDataCtor), 	True).x
	assertEqual(hasType(DataCtor,		TDataCtor), 	True).x
	assertEqual(hasType(TDataCtor,		TDataTypeCtor), True).x
	assertEqual(hasType(TDataTypeCtor,	TDataTypeCtor), True).x
	assertEqual(hasType(TType, 			TDataTypeCtor), True).x
	assertEqual(hasType(TList, 			TDataTypeCtor), True).x
	
	assertEqual(hasType(DataCtor,		TDataTypeCtor), False).x
	assertEqual(hasType(DataTypeCtor,	TDataTypeCtor), False).x

	assertThrows(hasType, Array(TDataCtor, DataCtor)).x
	
	assertEqual(hasType(             List_nil,			TList), True).x
	assertEqual(hasType(List_cons(1, List_nil),			TList), True).x
		
	assertEqual(hasType(TString,						TType), True).x
	assertEqual(hasType(TInteger,						TType), True).x
	assertEqual(hasType(TypeParam(0),					TType), True).x
	assertEqual(hasType(TypeApp(TList, TypeParam(0)),	TType), True).x
	
	&apos; NYI
	&apos;assertEqual(hasType(3, TypeParam(0)), True).x
	&apos; NYI
	&apos;assertEqual(hasType(3, TypeApp(TList TString)), True).x
	
	assertEqual(hasType(&quot;&quot;,				TString),	 True).x
	assertEqual(hasType(&quot;a&quot;,			TString),	 True).x
	assertEqual(hasType(&quot;foobar&quot;,		TString),	 True).x
	assertEqual(hasType(Nothing,		TString),	False).x
	assertEqual(hasType(Empty,			TString),	False).x
	assertEqual(hasType(True,			TString),	False).x
	assertEqual(hasType(False,			TString),	False).x
	assertEqual(hasType(0,				TString),	False).x
	assertEqual(hasType(1,				TString),	False).x
	assertEqual(hasType(3.14,			TString),	False).x
	assertEqual(hasType(Array(),		TString),	False).x
	assertEqual(hasType(Array(42),		TString),	False).x
	assertEqual(hasType(Array(42),		TString),	False).x
	assertEqual(hasType(List,			TString),	False).x
	assertEqual(hasType(List_nil,		TString),	False).x
	assertEqual(hasType(List_cons,		TString),	False).x

	assertEqual(hasType(&quot;&quot;,				TInteger),	False).x
	assertEqual(hasType(&quot;a&quot;,			TInteger),	False).x
	assertEqual(hasType(&quot;foobar&quot;,		TInteger),	False).x
	assertEqual(hasType(Nothing,		TInteger),	False).x
	assertEqual(hasType(Empty,			TInteger),	False).x
	assertEqual(hasType(True,			TInteger),	False).x
	assertEqual(hasType(False,			TInteger),	False).x
	assertEqual(hasType( 0,				TInteger),	 True).x
	assertEqual(hasType( 1,				TInteger),	 True).x
	assertEqual(hasType(-1,				TInteger),	 True).x
	assertEqual(hasType( 32766,			TInteger),	 True).x &apos;0x7FFE
	assertEqual(hasType( 32767,			TInteger),	 True).x &apos;0x7FFF
	assertEqual(hasType( 32768,			TInteger),	False).x &apos;0x8000 (!)
	assertEqual(hasType( 65534,			TInteger),	False).x &apos;0xFFFE
	assertEqual(hasType( 65535,			TInteger),	False).x &apos;0xFFFF
	assertEqual(hasType( 65536,			TInteger),	False).x &apos;0x80000
	assertEqual(hasType(-32766,			TInteger),	 True).x &apos;0x8002
	assertEqual(hasType(-32767,			TInteger),	 True).x &apos;0x8001
	assertEqual(hasType(-32768,			TInteger),	 True).x &apos;0x8000
	assertEqual(hasType(-32769,			TInteger),	False).x &apos;0x17FFF (!)
	assertEqual(hasType(-65534,			TInteger),	False).x &apos;0xFFFE
	assertEqual(hasType(-65535,			TInteger),	False).x &apos;0xFFFF
	assertEqual(hasType(-65536,			TInteger),	False).x &apos;0x80000
	assertEqual(hasType(3.14,			TInteger),	False).x
	assertEqual(hasType(Array(),		TInteger),	False).x
	assertEqual(hasType(Array(42),		TInteger),	False).x
	assertEqual(hasType(Array(42),		TInteger),	False).x
	assertEqual(hasType(List,			TInteger),	False).x
	assertEqual(hasType(List_nil,		TInteger),	False).x
	assertEqual(hasType(List_cons,		TInteger),	False).x


	&apos;assertEqual(hasType(), True).x

End Function

Function asdf
	&apos; But before we go on to make one, let&apos;s make things a bit more 
	&apos; interesting. Why not give him a brother:
	Dim cBar As DataValue
	cBar = _mkValueFrom_lax(cDataCtor, Array( _
		&quot;Bar&quot;, _
		emptyArray, _
		Nothing _
	)
	&apos; Bar just looks like his twin Foo, only the names are different.
	&apos; Of course they have the same &quot;parent&quot;:
	Dim tcFooOrBar As DataValue
	tcFooOrBar = _mkValueFrom_lax(cDataTypeCtor, Array( _
		&quot;FooOrBar&quot;, _
		0, _
		Array(cFoo, cBar) _
	)
	_setTypeCtor(cFoo, tcFooOrBar)
	_setTypeCtor(cBar, tcFooOrBar)
	&apos; FooOrBar = Foo | Bar
	&apos; We can now make values of type FooOrBar
	Dim y, z
	x = _mkValueFrom_lax(cFoo, Array())
	y = _mkValueFrom_lax(cBar, Array())
	z = _mkValueFrom_lax(cFoo, Array())
	&apos; the function istypeOf takes a type and a value, and tests
	&apos; whether the value has the given type:
	assertEqual(istypeOf(tcFooOrBar, x), True).x
	assertEqual(istypeOf(tcFooOrBar, y), True).x
	assertEqual(istypeOf(tcFooOrBar, z), True).x
	&apos; But of course, FooOrBar itself is NOT a FooOrBar
	assertEqual(istypeOf(tcFooOrBar, tcFooOrBar), False).x
	&apos; Rather it is a TDataTypeCtor
	assertEqual(istypeOf(tcDataTypeCtor, tcFooOrBar), True).x
	&apos; Similarly, neither cFoo nor cBar are FooBar s:
	assertEqual(istypeOf(tcFooOrBar, cFoo), False).x
	assertEqual(istypeOf(tcFooOrBar, cBar), False).x
	&apos; They&apos;re data constructors:
	assertEqual(istypeOf(tcDataCtor, cFoo), True).x
	assertEqual(istypeOf(tcDataCtor, cBar), True).x
	
	&apos; We can also dispatch on the values&apos; ctors (names).
	&apos; Since extracting the ctor&apos;s name will be common, we&apos;ll
	&apos; extract that into another helper function:
	assertEqual(ctorName(x), field(DataCtor_name, cFoo)).x
	assertEqual(ctorName(y), field(DataCtor_name, cBar)).x
	assertEqual(ctorName(z), field(DataCtor_name, cFoo)).x
	&apos; With that in place:
	Dim what As String, i As Integer, vs As Variant
	what = &quot;&quot;
	vs = Array(x, y, z)
	For i = 0 To 2
		Select Case ctorName(vs(i))
			Case &quot;Foo&quot;: what = what &amp; &quot;aFoo &quot;
			Case &quot;Bar&quot;: what = what &amp; &quot;aBar &quot;
		End Select
	Next i
	assertEqual(what, &quot;aFoo aBar aFoo &quot;).x
	

		
End Function



&apos; ##############################################


Function test_Type_TypeCtor()
	Dim tc0, tc1
	tc0 = _newTypeCtor(&quot;TC0&quot;, 0, Array())
	assertEqual(isDataType(tc0),           False).x
	assertEqual(tc0._name, &quot;TC0&quot;).x
	assertEqual(tc0.arity, 	  0 ).x
	assertEqual(TypeCtor_equ(tc0, tc0), 	True).x
	
	tc1 = _newTypeCtor(&quot;TC1&quot;, 1, Array())
	assertEqual(tc1._name, &quot;TC1&quot;).x
	assertEqual(tc1.arity, 	  1 ).x
	assertEqual(TypeCtor_equ(tc1, tc1), 	True).x

	assertEqual(TypeCtor_equ(tc0, tc1), 	False).x
	assertEqual(TypeCtor_equ(tc1, tc0), 	False).x
	
	Dim dt0, args
	args = Array()
	dt0 = applyTC(tc0, args)
	assertEqual(isDataType(dt0), True).x
	assertEqual(LBound(dt0.typeArgs),  0).x
	assertEqual(UBound(dt0.typeArgs), -1).x
	assertEqual(TypeCtor_equ(tc0, dt0.typeCtor), True).x
	
	Redim args(0 To 1)
	assertEqual(UBound(dt0.typeArgs), -1).x

	Dim dt1
	&apos;assertThrows(Fn.applyTC, Array(tc1, Array(tc1)) ).x
	args = Array(dt0)
	dt1 = applyTC(tc1, args)
	assertEqual(LBound(dt1.typeArgs),  0).x
	assertEqual(UBound(dt1.typeArgs),  0).x
	assertEqual(TypeCtor_equ(tc1, dt1.typeCtor), True).x
	assertEqual(DataType_equ(dt1.typeArgs(0), dt0), True).x

	&apos; the typeArgs array cannot be changed via ByRef var:
	args(0) = dt1
	assertEqual(DataType_equ(dt1.typeArgs(0), dt0), True).x

	Dim dt1b
	args = Array(dt0)
	dt1b = applyTC(tc1, args)
	assertEqual(DataType_equ(dt1b, dt1), True).x
	
	args = Array(dt1) &apos; TC1 (TC1 TC0) is also a proper DataType
	dt1b = applyTC(tc1, args) &apos; but different from TC1 TC0:
	assertEqual(DataType_equ(dt1b, dt1), False).x
End Function

Function test_Type_DataCtor()
	Dim tc
	Dim c1, c2
	Dim dtUnit, dtBool, dtMaybeUnit, dtMaybeBool
	
	&apos; no type args, only 1 zero-arg data ctor ~ Unit
	tc = _newTypeCtor(&quot;TC_Unit&quot;, 0, _
		Array( _
			&quot;_Unit&quot;, Array() _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_Unit&quot;).x
	assertEqual(c1.arity,       0).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	dtUnit = applyTC(tc, Array())
	
	&apos; no type args, 2 zero-arg data ctors ~ Bool
	tc = _newTypeCtor(&quot;TC_Bool&quot;, 0, _
		Array( _
			&quot;_False&quot;, Array(), _
			&quot;_True&quot;,  Array() _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_False&quot;).x
	assertEqual(c1.arity,        0).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	c2 = tc.dataCtors(1)
	assertEqual(c2._name, &quot;_True&quot;).x
	assertEqual(c2.arity,       0).x
	assertEqual(TypeCtor_equ(c2.typeCtor, tc), True).x
	dtBool = applyTC(tc, Array())
	
	&apos; one type args, 2 data ctors ~ Maybe
	tc = _newTypeCtor(&quot;TC_Maybe&quot;, 1, _
		Array( _
			&quot;_None&quot;, Array(), _
			&quot;_Some&quot;, Array(0) _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_None&quot;).x
	assertEqual(c1.arity,      0).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	c2 = tc.dataCtors(1)
	assertEqual(c2._name, &quot;_Some&quot;).x
	assertEqual(c2.arity,       1).x
	assertEqual(TypeCtor_equ(c2.typeCtor, tc), True).x

	&apos;show(c1.str, c2.str)

	dtMaybeUnit = applyTC(tc, Array(dtUnit))
	dtMaybeBool = applyTC(tc, Array(dtBool))
	
	&apos;show(dtMaybeUnit.str)

	&apos; dataCtors may only refer to typeVars with index &lt; typeCtor.arity:
	&apos;assertThrows(_newTypeCtor(&quot;TC_Foo&quot;, 0, Array(&quot;_Bar&quot;, Array(0)))).x
	&apos;assertThrows(_newTypeCtor(&quot;TC_Foo&quot;, 1, Array(&quot;_Bar&quot;, Array(1)))).x
		
	&apos; two type args, one 2-arg data ctors ~ Pair
	tc = _newTypeCtor(&quot;TC_Pair&quot;, 2, _
		Array( _
			&quot;_Pair&quot;, Array(0, 1) _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_Pair&quot;).x
	assertEqual(c1.arity,       2).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x

	&apos; two type args, two 1-arg data ctors ~ Either
	tc = _newTypeCtor(&quot;TC_Either&quot;, 2, _
		Array( _
			&quot;_Left&quot;,  Array(0), _
			&quot;_Right&quot;, Array(1) _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_Left&quot;).x
	assertEqual(c1.arity,       1).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	c2 = tc.dataCtors(1)
	assertEqual(c2._name, &quot;_Right&quot;).x
	assertEqual(c2.arity,       1).x
	assertEqual(TypeCtor_equ(c2.typeCtor, tc), True).x
	
	
	&apos;-- data ctors with non-var argument types:

	&apos; one type arg, 1 data ctors ~ package together something and a Bool
	tc = _newTypeCtor(&quot;TC_Foo&quot;, 1, _
		Array( _
			&quot;_Bar&quot;, Array(0, dtMaybeBool) _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_Bar&quot;).x
	assertEqual(c1.arity,      2).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	
	&apos;show(c1.str)
	
	&apos; List a b = Nil
	&apos;          | Cons a List b a

	&apos; Now for *recursive* dataTypes, such as List a
	tc = _newTypeCtor(&quot;TC_List&quot;, 1, _
		Array( _
			&quot;_Nil&quot;,  Array(), _
			&quot;_Cons&quot;, Array(0, tc), _
		) _
	)
	c1 = tc.dataCtors(0)
	c2 = tc.dataCtors(1)
	show(c2.str)
	&apos; close the loop:
	c2.argTypes(1) = tc
	show(c2.str)
	
	assertEqual(c1._name, &quot;_Nil&quot;).x
	assertEqual(c1.arity,      0).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	assertEqual(c2._name, &quot;_Cons&quot;).x
	assertEqual(c2.arity,       2).x
	assertEqual(TypeCtor_equ(c2.typeCtor, tc), True).x
	
	show(applyTC(tc, Array(dtBool)).str)
End Function



</script:module>