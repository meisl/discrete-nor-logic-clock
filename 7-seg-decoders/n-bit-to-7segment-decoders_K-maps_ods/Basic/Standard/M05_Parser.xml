<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M05_Parser" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit


Type Parser
	tyname As String
	tp As String
	st As Variant
End Type


Sub Main
	test_Parser()
	Stop
	Dim s As String
	Set pHexLit = pSeq(Array(pStr(&quot;0x&quot;), pHexNum), &quot;sndArg&quot;)
	Dim p As Parser 
	&apos;pChoice(pItem(), pReturn(&quot;bar&quot;))
	Set p = pSeq(Array(pHexLit, pMany(pWhite)), &quot;fstArg&quot;)
	s = &quot;FF 0x1F __Âµ 0&quot;

	MsgBox( _
		&quot;applying parser &apos;&quot; &amp; p.tp &amp; &quot;&apos; to &quot; &amp; toString(s) &amp; &quot;: &quot; &amp; chr(13) _
		&amp; toString(applyP(p, s)) _
	)

End Sub

&apos;==================================================================

Function mkParser(Optional tp As String, Optional st As Variant)
	Static oFn As Object
	Dim result As Object
	If isMissing(st) Then
		If isNull(oFn) Then : Set oFn = lookupFn(&quot;mkParser&quot;) : End If
		If isMissing(tp) Then
			result = oFn
		Else
			result = apply1(oFn, tp)
		End If
	Else
		Set result = New Parser
		result.tyname = &quot;TParser&quot;
		result.tp = tp
		result.st = st
	End If
	mkParser = result
End Function

Function parseFailure()
	parseFailure = Empty
End Function

Function isParseFailure(parseResult) As Boolean
	If typeOf(parseResult) &lt;&gt; typeOf(parseFailure) Then
		isParseFailure = False
	Else
		isParseFailure = equ(parseResult, parseFailure)
	End If
End Function

&apos; always fails on any string; failure is indicated by returning parseFailure()
Function pFail()
	Static result As Object
	If isNull(result) Then : result = mkParser(&quot;fail&quot;, Nothing) : End If
	pFail = result
End Function

&apos; always succeeds by returning the provided value; without increasing pos
Function pReturn(Optional v As Variant)
	Static oFn As Object
	If isMissing(v) Then
		If isNull(oFn) Then
			oFn = mkParser(&quot;return&quot;)
		End If
		pReturn = oFn
	Else
		pReturn = mkParser(&quot;return&quot;, v)
	End If
End Function

&apos; fails on empty string but succeeds on all others
&apos; by returning the first character; and increasing pos by 1
Function pItem()
	Static result As Object
	If isNull(result) Then : result = mkParser(&quot;item&quot;, Nothing) : End If
	pItem = result
End Function

Function pNextAsc()
	Static result As Object
	If isNull(result) Then : Set result = pBind(pItem, compose(pReturn, &quot;asc&quot;)) : End If
	pNextAsc = result
End Function

&apos; succeeds on strings with the given prefix t by returning t,
&apos; and advancing pos by the length of t
Function pStr(t As String)
	If (Len(t) = 0) Then
		croak(&quot;pStr: cannot match &apos;exactly&apos; the empty string t=&apos;&apos;&quot;)
	Else
		pStr = mkParser(&quot;str&quot;, t)
	End If
End Function

&apos;Function pSat(ByVal predicate As Variant)
&apos;	pBind(pItem, apply1(&quot;ite&quot;, compose(predicate, &quot;asc&quot;), pReturn
&apos;End Function

&apos; succeeds if either p1 succeeds (then returning p1&apos;s result and pos)
&apos; or (and only if p1 fails) if p2 succeeds, returns p2&apos;s result and pos.
&apos; fails if both, p1 and p2 fail
Function pChoice(p1 As Parser, p2 As Parser)
	&apos; TODO: @pChoice: strip out always failing parsers
	&apos; TODO: @pChoice: if p1 always succeeds strip out p2
&apos;	pChoice = mkParser(&quot;choice&quot;, List(p1, p2))
&apos;	Exit Function
	Dim choices As Variant
	If p2.tp = &quot;choice&quot; Then
		If p1.tp = &quot;choice&quot; Then
			choices = adjoin(p1.st, p2.st)
		Else
			choices = cons(p1,  p2.st)
		End If
	Else
		If p1.tp = &quot;choice&quot; Then
			choices = adjoin(p1.st, List(p2))
		Else
			choices = List(p1, p2)
		End If
	End If
	pChoice = mkParser(&quot;choice&quot;, choices)
End Function

&apos; never fails: if p fails than pZeroOrOne(p) returns nil + same pos as result,
&apos; otherwise returns a singleton list of p&apos;s result + pos
&apos; matches at most once
Function pZeroOrOne(p As Parser)
	pZeroOrOne = mkParser(&quot;zeroOrOne&quot;, p)
	Exit Function
	
&apos;	Dim singletonList As Object
&apos;	Set singletonList = swap(&quot;cons&quot;, nil)
&apos;	pZeroOrOne = pChoice( pSeq(Array(p), singletonList), pReturn(nil))
&apos;	pZeroOrOne = pChoice( pBind(p, compose(pReturn, singletonList)), pReturn(nil))
End Function

&apos; never fails: if p fails than pMany(p) returns nil + same pos as result,
&apos; otherwise returns a *REVERSED list* of p results + last pos
&apos; matches as many as possible
Function pManyRev(p As Parser)
	pManyRev = pChoice( pMany1Rev(p), pReturn(nil) )
End Function

&apos; same as pManyRev but with the list in the order as in the parsed string
Function pMany(p As Parser)
	&apos; Note: direct impl might give a little more perf
	pMany = pSeq(Array(pManyRev(p)), &quot;reverse&quot;)
End Function

&apos; same as pManyRev but fails if there is no match at all
&apos; matches as many as possible
Function pMany1Rev(p As Parser)
	pMany1Rev = mkParser(&quot;many1Rev&quot;, p)
End Function

&apos; same as pMany but fails if there is no match at all
&apos; matches as many as possible
Function pMany1(p As Parser)
	pMany1 = pSeq(Array(pMany1Rev(p)), &quot;reverse&quot;)
End Function

&apos; pSeq - make a sequence of parsers, collect their results in a list 
&apos; and finally process that list by passing it to the given function
&apos; fails if any of the given parsers fails
&apos; if instead all succeed, collects their results in a list 
&apos; which is then passed on the the given function. The result
&apos; of this function application is then packed up with the last
&apos; parsers pos to give the overall result
Function pSeq(ps As Array, ByVal f As Variant)
	&apos;TODO: pSeq: check if ps is proper Array of Parsers
	f = asFn(f, &quot;pSeq: invalid 2nd arg&quot;)
	pSeq = mkParser(&quot;seq&quot;, Array(ps, f))
End Function

Function pBind(p As Parser, ByVal f As Variant)
	&apos; TODO: pBind: check if p is proper Parser
	f = asFn(f, &quot;pBind: invalid 2nd arg&quot;)
	pBind = mkParser(&quot;bind&quot;, Array(p, f))
End Function


&apos;==================================================================


Function pWhite()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = pChoice(pStr(&quot; &quot;), pStr(Chr(9))
	End If
	pWhite = result
End Function

Function pBinDigit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = pChoice(_
			pBind(pStr(&quot;0&quot;), apply(&quot;fstArg&quot;, pReturn(0))), _
			pBind(pStr(&quot;1&quot;), apply(&quot;fstArg&quot;, pReturn(1)))_
		)
	End If
	pBinDigit = result
End Function

Function pDecDigit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = pChoice(pBinDigit,	pBind(pStr(&quot;2&quot;), apply(&quot;fstArg&quot;, pReturn(2))))
		result = pChoice(result,	pBind(pStr(&quot;3&quot;), apply(&quot;fstArg&quot;, pReturn(3))))
		result = pChoice(result,	pBind(pStr(&quot;4&quot;), apply(&quot;fstArg&quot;, pReturn(4))))
		result = pChoice(result,	pBind(pStr(&quot;5&quot;), apply(&quot;fstArg&quot;, pReturn(5))))
		result = pChoice(result,	pBind(pStr(&quot;6&quot;), apply(&quot;fstArg&quot;, pReturn(6))))
		result = pChoice(result,	pBind(pStr(&quot;7&quot;), apply(&quot;fstArg&quot;, pReturn(7))))
		result = pChoice(result,	pBind(pStr(&quot;8&quot;), apply(&quot;fstArg&quot;, pReturn(8))))
		result = pChoice(result,	pBind(pStr(&quot;9&quot;), apply(&quot;fstArg&quot;, pReturn(9))))
	End If
	pDecDigit = result
End Function

Function pHexDigit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = pChoice(pDecDigit,	pBind(pChoice(pStr(&quot;A&quot;), pStr(&quot;a&quot;)), apply(&quot;fstArg&quot;, pReturn(10))) )
		result = pChoice(result,	pBind(pChoice(pStr(&quot;B&quot;), pStr(&quot;b&quot;)), apply(&quot;fstArg&quot;, pReturn(11))) )
		result = pChoice(result,	pBind(pChoice(pStr(&quot;C&quot;), pStr(&quot;c&quot;)), apply(&quot;fstArg&quot;, pReturn(12))) )
		result = pChoice(result,	pBind(pChoice(pStr(&quot;D&quot;), pStr(&quot;d&quot;)), apply(&quot;fstArg&quot;, pReturn(13))) )
		result = pChoice(result,	pBind(pChoice(pStr(&quot;E&quot;), pStr(&quot;e&quot;)), apply(&quot;fstArg&quot;, pReturn(14))) )
		result = pChoice(result,	pBind(pChoice(pStr(&quot;F&quot;), pStr(&quot;f&quot;)), apply(&quot;fstArg&quot;, pReturn(15))) )
	End If
	pHexDigit = result
End Function

Function pHexNum()
	Static result As Object
	If isNull(result) Then
		&apos;foldl1 compose(plus, mul 16)
		Set result = pSeq(Array(pMany1(pHexDigit)), apply(&quot;foldl1&quot;, compose(add, mul(16))))
	End If
	pHexNum = result
End Function

Function pHexLit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = pSeq(Array(pStr(&quot;0x&quot;), pHexNum), &quot;sndArg&quot;)
	End If
	pHexLit = result
End Function


&apos; =============================================================================

Function lookupParser(pName As String) As Parser
	Dim result As Parser
	Select Case pName
		Case &quot;pWhite&quot;:		result = pWhite
		Case &quot;pBinDigit&quot;:	result = pBinDigit
		Case &quot;pDecDigit&quot;:	result = pDecDigit
		Case Else
			croak(&quot;unknown parser &quot; &amp; pName)
	End Select
	lookupParser = result
End Function

Function parse(pName As String, s As String)
	Dim result As String
	result = toString(applyP(lookupParser(pName), s))
	if (result = &quot;Empty&quot;) then
		MsgBox(pName &amp; &quot; on &quot; &amp; tostring(s) &amp; &quot; yielded &quot; &amp; result)
	end if
	parse = result
End Function

Function applyP(ByVal parser As Variant, s As String, Optional pos As Integer)
	Dim p As Parser
	Dim fResult As Variant
	If IsNull(parser) Or IsEmpty(parser) Then
		croak(&quot;applyP: parser p = &quot; &amp; toString(parser))
	ElseIf TypeName(parser) = &quot;Object&quot; Then
		Set p = parser
	Else
		croak(&quot;applyP: invalid arg parser - &quot; &amp; toString(parser))
	End If
	If IsMissing(pos) Then
		pos = 1
	End If

	Dim result As Variant
	Dim nxtPos As Integer
	Dim i As Integer, j As Integer, k As Integer
	Dim innerParser As Parser
	Dim innerParsers As Variant
	Dim lst As Object
	nxtPos = pos
	If p.tp = &quot;return&quot; Then
		result = Array(p.st, nxtPos)
	ElseIf p.tp = &quot;fail&quot; Then
		result = parseFailure
	ElseIf p.tp = &quot;item&quot; Then
		If pos &lt;= Len(s) Then
			nxtPos = pos + 1
			result = Array(Mid(s, pos, 1), nxtPos)
		Else
			result = parseFailure
		End If
	ElseIf p.tp = &quot;str&quot; Then
		Dim match As String
		Dim matchLen As Integer
		match = p.st
		matchLen = Len(match)
		If (Mid(s, pos, matchLen) = match) Then
			nxtPos = pos + matchLen
			result = Array(match, nxtPos)
		Else
			result = parseFailure
		End If
		&apos;MsgBox(&quot;str(&quot; &amp; toString(match) &amp; &quot;), s=&quot; &amp; toString(s) &amp; &quot;, pos=&quot; &amp; toString(pos) &amp; &quot;, matchLen=&quot; &amp; toString(matchLen)_
		&apos;	&amp; chr(13) &amp; &quot;~&gt;&quot; &amp; toString(result))
	ElseIf p.tp = &quot;choice&quot; Then
		innerParsers = p.st
		k = length(innerParsers)
		If k = 2 Then	&apos; if there are two alternatives
			result = applyP(car(innerParsers), s, pos)
			If isParseFailure(result) Then
				result = applyP(cadr(innerParsers), s, pos)
			End If
		ElseIf k &gt; 2 Then	&apos; more than 2 alternatives
			Do
				innerParser = car(innerParsers)
				result = applyP(innerParser, s, pos)
				innerParsers = cdr(innerParsers)
			Loop Until (isNil(innerParsers) Or Not(isParseFailure(result)))
		Else
			croak(&quot;applying pChoice: invalid list of alternatives &quot; &amp; chr(13) &amp; toString(innerParsers))
		End If
	ElseIf p.tp = &quot;zeroOrOne&quot; Then
		result = applyP(p.st, s, pos)
		If isParseFailure(result) Then
			result = Array(nil, pos)
		Else
			result = Array(List(result(0)), result(1))
		End If
	ElseIf (p.tp = &quot;many1Rev&quot;) Then
		Dim lstLen As Integer
		nxtPos = pos
		lstLen = 0
		Set lst = nil
		innerParser = p.st
		result = applyP(innerParser, s, nxtPos)
		While Not(isParseFailure(result))
			nxtPos = result(1)
			Set lst = cons(result(0), lst)
			lstLen = lstLen + 1
			result = applyP(innerParser, s, nxtPos)
		Wend
		If isNil(lst) Then
			result = parseFailure
		Else
			result = Array(lst, nxtPos)
		End If
	ElseIf p.tp = &quot;bind&quot; Then
		result = applyP(p.st(0), s, pos)
		If Not isParseFailure(result) Then
			nxtPos = result(1)
			fResult = apply1(p.st(1), result(0))
			result = applyP(fResult, s, nxtPos)
		End If
	ElseIf p.tp = &quot;seq&quot; Then
		Dim t As Variant
		innerParsers = p.st(0)
		i = LBound(innerParsers)
		k = UBound(innerParsers)
		j = 0
		nxtPos = pos
		Dim iResults(0 To k-i) As Variant
		Do
			t = applyP(innerParsers(i), s, nxtPos)
			If Not isParseFailure(t) Then
				iResults(j) = t(0)
				nxtPos = t(1)
				i = i + 1
				j = j + 1
			End If
		Loop Until (i &gt; k) Or isParseFailure(t)
		If isParseFailure(t) Then
			result = t
		Else
			fResult = applyToList(p.st(1), toList(iResults))
			&apos; ATTENTION: do not reuse t, type of result value may not match
			&apos;            and an implicit conversion might happen!
			result = Array(fResult, t(1))
		End If
		&apos;MsgBox(&quot;seq/&quot; &amp; p.st(1) &amp; &quot;: &quot; &amp; toString(result))
	Else
		result = &quot;unknown Parser &apos;&quot; &amp; p.tp &amp; &quot;&apos;&quot;
		MsgBox(&quot;Error in applyP: &quot; &amp; result)
	End If
	applyP = result
End Function


&apos;= tests ======================================================================

Global refute_parses_pass As Object

Function test_Parser()
	Dim tm As Date, tmSecs As Long, aPerSec As Integer
	tm = TimeValue(Time)
	
	&apos;Dim lTick As Long
	&apos;lTick = GetSystemTicks()
	&apos;wait 2000
	&apos;lTick = (GetSystemTicks() - lTick)
	&apos;MsgBox &quot;&quot; &amp; lTick &amp; &quot; Ticks&quot; ,0,&quot;Die Pause dauerte&quot;

	Dim aCount As Integer
	aCount = assertionCount
	
	Dim failure As String
	failure = toString(parseFailure)
	refute_parses_pass = assertEqual(failure, failure)
	
	test_Parser_fail()
	test_Parser_return()
	test_Parser_item()
	test_Parser_nextAsc()
	test_Parser_str()
	test_Parser_choice()
	test_Parser_zeroOrOne()
&apos; 1 sec for 273 ~&gt; &gt;273 aPerSec
	test_Parser_white()
	test_Parser_binDigit()
&apos; 1 sec for 322 ~&gt; 322 aPerSec
	test_Parser_decDigit()
&apos; 2 sec for 359 ~&gt; 180 aPerSec
	test_Parser_hexDigit()
&apos; 3 sec for 408 ~&gt; 136 aPerSec
	test_Parser_manyRev()
	test_Parser_many()
&apos; 5 sec for 540 ~&gt; 108 aPerSec
	test_Parser_many1Rev()
	test_Parser_many1()
&apos; 7 sec for 632 ~&gt; 90 aPerSec
	test_Parser_seq()
&apos; 8 sec for 702 ~&gt; 88 aPerSec
	test_Parser_hexNum()
Goto end_of_Parser_tests
&apos; 12 sec for 781 ~&gt; 65 aPerSec
	test_Parser_hexLit()
&apos; 16 sec for 883 ~&gt; 55 aPerSec
end_of_Parser_tests:	
	aCount = assertionCount - aCount
	tm = TimeValue(Time) - tm
	tmSecs = Second(tm) + 60 * (Minute(tm) + 60 * Hour(tm))
	If (tmSecs = 0) Then
		aPerSec = aCount
	Else
		aPerSec = aCount/tmSecs
	End If
	MsgBox(TimeSerial(Hour(tm), Minute(tm), Second(tm)) &amp; &quot; for &quot; &amp; aCount &amp; &quot; assertions&quot;_
		&amp; chr(13) &amp; &quot;that&apos;s ~&quot; &amp; aPerSec &amp; &quot; assertions/sec&quot;_
	)
End Function

&apos;= test helpers ===============================================================

Function refute_parses(p As Parser, ByVal ss As Variant)
	Dim actual As Variant, testResult As Variant
	Dim actualS As String, expectedS As String
	If isArray(ss) Then
		Dim i As Integer
		For i = LBound(ss) To UBound(ss)
			actual = applyP(p, ss(i), 1)
			assertionCount = assertionCount + 1
			If Not(isParseFailure(actual)) Then
				Goto refute_parses_failed
			End If
		Next i
	Else
		actual = applyP(p, ss, 1)
		assertionCount = assertionCount + 1
		If Not(isParseFailure(actual)) Then
			Goto refute_parses_failed
		End If
	End If
	refute_parses = refute_parses_pass
	Exit Function
refute_parses_failed:
	actualS = toString(actual)
	expectedS = toString(parseFailure)
	testResult = assertEqual(actualS, expectedS)
	If isArray(ss) Then
		MsgBox(&quot;at index &quot; &amp; i &amp; &quot;: &quot; &amp; toString(ss(i)))
	End If
	refute_parses = testResult
End Function

Function assert_parses(p As Parser, ByVal ss As Variant, expVal As Variant, expPos As Integer)
&apos;	assertEqual(typeOf(p), &quot;Object/TParser&quot;).x
	Dim actual As Variant, testResult As Variant
	Dim actualS As String, expectedS As String
	
	If isArray(ss) Then
		Dim i As Integer
		For i = LBound(ss) To UBound(ss)
			actual = applyP(p, ss(i), 1)
			testResult = assertEqual(actual(1), expPos)
			If (testResult.isFail) Then
				MsgBox(toString(actual))
				Goto assert_parse_failed
			End If
			testResult = assertEqual(toString(actual(0)), toString(expVal))
			If (testResult.isFail) Then
				Goto assert_parse_failed
			End If
		Next i
	Else
		actual = applyP(p, ss, 1)
		testResult = assertEqual(actual(1), expPos)
		If (testResult.isFail) Then
			Goto assert_parse_failed
		End If
		testResult = assertEqual(toString(actual(0)), toString(expVal))
		If (testResult.isFail) Then
			Goto assert_parse_failed
		End If
	End If
	assert_parses = testResult
	Exit Function
assert_parse_failed:
	actualS = toString(actual)
	expectedS = toString(Array(expVal, expPos))
	testResult = assertEqual(actualS, expectedS)
	If isArray(ss) Then
		MsgBox(&quot;at index &quot; &amp; i &amp; &quot;: &quot; &amp; toString(ss(i)))
	End If
	assert_parses = testResult
End Function

&apos;= actual tests ===============================================================

Function test_Parser_fail()
	refute_parses(pFail, Array( _
		&quot;&quot;,	&quot; &quot;, &quot;   &quot;, chr(13), chr(9), &quot;a&quot;, &quot;1&quot;, &quot;[]&quot;, &quot;asdf&quot; _
	)).x
End Function

Function test_Parser_return()
	Dim p As Variant
	Dim expected As Variant
	
	p = pReturn
	assertEqual(typeOf(p), typeOf(nil)).x
	assertEqual(arity(p),  1).x

	p = pReturn(&quot;bar&quot;)
	assert_parses(p, &quot;&quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot; &quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot;a&quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot;1&quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot;[]&quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot;abcd&quot;,	&quot;bar&quot;, 1).x
	assert_parses(p, chr(13),	&quot;bar&quot;, 1).x

	p = pReturn(4711)	
	assert_parses(p, &quot;&quot;,		4711, 1).x
	assert_parses(p, &quot; &quot;,		4711, 1).x
	assert_parses(p, &quot;a&quot;,		4711, 1).x
	assert_parses(p, &quot;1&quot;,		4711, 1).x
	assert_parses(p, &quot;[]&quot;,		4711, 1).x
	assert_parses(p, &quot;abcd&quot;,	4711, 1).x
	assert_parses(p, chr(13),	4711, 1).x
End Function

Function test_Parser_item()
	Dim p As Parser
	Set p = pItem
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;,		&quot; &quot;, 2).x
	assert_parses(p, &quot;a&quot;,		&quot;a&quot;, 2).x
	assert_parses(p, &quot;1&quot;,		&quot;1&quot;, 2).x
	assert_parses(p, &quot;[]&quot;,		&quot;[&quot;, 2).x
	assert_parses(p, &quot;abcd&quot;,	&quot;a&quot;, 2).x
	assert_parses(p, chr(13),	chr(13), 2).x
	assert_parses(p, chr( 9),	chr( 9), 2).x
End Function

Function test_Parser_nextAsc()
	Dim p As Parser
	Set p = pNextAsc
	
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;,		asc(&quot; &quot;), 2).x
	assert_parses(p, &quot;a&quot;,		asc(&quot;a&quot;), 2).x
	assert_parses(p, &quot;1&quot;,		asc(&quot;1&quot;), 2).x
	assert_parses(p, &quot;[]&quot;,		asc(&quot;[&quot;), 2).x
	assert_parses(p, &quot;abcd&quot;,	asc(&quot;a&quot;), 2).x
	assert_parses(p, chr(13),	      13, 2).x
	assert_parses(p, chr( 9),	       9, 2).x
End Function


Function test_Parser_str()
	Dim p As Parser
	
&apos;	assertThrows(pStr, Array(&quot;&quot;)).x

	p = pStr(&quot;bar&quot;)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot; &quot; &amp; chr(13)).x
	refute_parses(p, &quot;asdf&quot;).x
	refute_parses(p, &quot; bar&quot;).x
	refute_parses(p, &quot;b&quot;).x
	refute_parses(p, &quot;ba&quot;).x
	assert_parses(p, &quot;bar&quot;,		&quot;bar&quot;, 4).x
	assert_parses(p, &quot;barb&quot;,	&quot;bar&quot;, 4).x
	assert_parses(p, &quot;barba&quot;,	&quot;bar&quot;, 4).x
	assert_parses(p, &quot;barbar&quot;,	&quot;bar&quot;, 4).x

	p = pStr(chr(13))
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot; &quot; &amp; chr(13)).x
	refute_parses(p, &quot;asdf&quot;).x
	refute_parses(p, &quot; bar&quot;).x
	refute_parses(p, &quot;b&quot;).x
	refute_parses(p, &quot;ba&quot;).x
	refute_parses(p, &quot;bar&quot;).x
	refute_parses(p, &quot;barb&quot;).x
	refute_parses(p, &quot;barba&quot;).x
	refute_parses(p, &quot;barbar&quot;).x
	assert_parses(p, chr(13),					&quot;\n&quot;, 2).x
	assert_parses(p, chr(13) &amp; &quot;bar&quot;,			&quot;\n&quot;, 2).x
	assert_parses(p, chr(13) &amp; chr(13),			&quot;\n&quot;, 2).x
	assert_parses(p, chr(13) &amp; chr(13) &amp; &quot;bar&quot;,	&quot;\n&quot;, 2).x
End Function

Function test_Parser_choice()
	Dim p As Parser
	Dim data As Variant
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	p = pChoice(pFail, pFail)
	refute_parses(p, data).x
	
	p = pChoice(pReturn(7), pFail)
	assert_parses(p, data, 7, 1).x
	
	p = pChoice(pFail, pReturn(7))
	assert_parses(p, data, 7, 1).x
	
	p = pChoice(pReturn(42), pReturn(7))
	assert_parses(p, data, 42, 1).x
	
	assert_parses(pChoice(pItem, pReturn(11)), 	&quot;&quot;, 11, 1	).x
	refute_parses(pChoice(pItem, pStr(&quot;x&quot;)),	&quot;&quot;).x
	assert_parses(pChoice(pReturn(11), pItem), 	&quot;&quot;, 11, 1	).x
	refute_parses(pChoice(pStr(&quot;x&quot;), pItem),	&quot;&quot;).x
	
	assert_parses(pChoice(pItem, pReturn(11)), 	&quot; &quot;, &quot; &quot;, 2	).x
	assert_parses(pChoice(pItem, pStr(&quot;x&quot;)), 	&quot; &quot;, &quot; &quot;, 2	).x
	assert_parses(pChoice(pReturn(11), pItem), 	&quot; &quot;, 11, 1	).x
	assert_parses(pChoice(pStr(&quot;x&quot;), pItem), 	&quot; &quot;, &quot; &quot;, 2	).x
	
	assert_parses(pChoice(pItem, pReturn(11)), 	&quot;x&quot;, &quot;x&quot;, 2	).x
	assert_parses(pChoice(pItem, pStr(&quot;x&quot;)), 	&quot;x&quot;, &quot;x&quot;, 2	).x
	assert_parses(pChoice(pReturn(11), pItem), 	&quot;x&quot;, 11, 1	).x
	assert_parses(pChoice(pStr(&quot;x&quot;), pItem), 	&quot;x&quot;, &quot;x&quot;, 2	).x
End Function


Function test_Parser_zeroOrOne()
	Dim p As Parser
	Dim data As Variant
	Dim zeroMatches As Variant, oneMatch As Variant
	zeroMatches = nil
	oneMatch    = List(&quot;x&quot;)
		
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)

	p = pZeroOrOne(pStr(&quot;x&quot;))

	assert_parses(p, data,	zeroMatches, 1).x
	assert_parses(p, &quot;x&quot;, 	oneMatch, 2).x
	assert_parses(p, &quot;xx&quot;, 	oneMatch, 2).x
	assert_parses(p, &quot;xxx&quot;, oneMatch, 2).x
	assert_parses(p, &quot; x&quot;, 	zeroMatches, 1).x
	assert_parses(p, &quot; xx&quot;, zeroMatches, 1).x
	assert_parses(p, &quot; xxx&quot;,zeroMatches, 1).x
End Function

Function test_Parser_white()
	Dim p As Parser
	p = pWhite

	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;, 						&quot; &quot;, 2	).x
	assert_parses(p, chr(9), 					&quot;\t&quot;, 2	).x
	refute_parses(p, chr(13)).x
	refute_parses(p, &quot;asdf&quot;).x
	assert_parses(p, &quot; asdf&quot;, 					&quot; &quot;, 2).x
	assert_parses(p, chr(9) &amp; &quot;asdf&quot;, 			&quot;\t&quot;, 2).x
	refute_parses(p, chr(13) &amp; &quot;asdf&quot;).x
	assert_parses(p, &quot;  asdf&quot;, 					&quot; &quot;, 2).x
	assert_parses(p, chr(9) &amp; chr(9) &amp; &quot;asdf&quot;, 	&quot;\t&quot;, 2).x
	refute_parses(p, chr(13) &amp; chr(9) &amp; &quot;asdf&quot;).x
	assert_parses(p, chr(9) &amp; chr(13) &amp; &quot;asdf&quot;, 	&quot;\t&quot;, 2).x
	refute_parses(p, chr(13) &amp; chr(13) &amp; &quot;asdf&quot;).x
End Function

Function test_Parser_binDigit()
	Dim p As Parser
	p = pBinDigit

	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;sadf&quot;).x
	assert_parses(p, &quot;0sadf&quot;,	0, 2).x
	assert_parses(p, &quot;1sadf&quot;,	1, 2).x
	refute_parses(p, &quot;2sadf&quot;).x
	refute_parses(p, &quot;3sadf&quot;).x
	refute_parses(p, &quot;4sadf&quot;).x
	refute_parses(p, &quot;5sadf&quot;).x
	refute_parses(p, &quot;6sadf&quot;).x
	refute_parses(p, &quot;7sadf&quot;).x
	refute_parses(p, &quot;8sadf&quot;).x
	refute_parses(p, &quot;9sadf&quot;).x
	refute_parses(p, &quot;Asadf&quot;).x
	refute_parses(p, &quot;asadf&quot;).x
	refute_parses(p, &quot;Bsadf&quot;).x
	refute_parses(p, &quot;bsadf&quot;).x
	refute_parses(p, &quot;Csadf&quot;).x
	refute_parses(p, &quot;csadf&quot;).x
	refute_parses(p, &quot;Dsadf&quot;).x
	refute_parses(p, &quot;dsadf&quot;).x
	refute_parses(p, &quot;Esadf&quot;).x
	refute_parses(p, &quot;esadf&quot;).x
	refute_parses(p, &quot;Fsadf&quot;).x
	refute_parses(p, &quot;fsadf&quot;).x
	refute_parses(p, &quot;Gsadf&quot;).x
	refute_parses(p, &quot;gsadf&quot;).x
End Function

Function test_Parser_decDigit()
	Dim p As Parser
	p = pDecDigit

	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;sadf&quot;).x
	assert_parses(p, &quot;0sadf&quot;,	0, 2).x
	assert_parses(p, &quot;1sadf&quot;,	1, 2).x
	assert_parses(p, &quot;2sadf&quot;,	2, 2).x
	assert_parses(p, &quot;3sadf&quot;,	3, 2).x
	assert_parses(p, &quot;4sadf&quot;,	4, 2).x
	assert_parses(p, &quot;5sadf&quot;,	5, 2).x
	assert_parses(p, &quot;6sadf&quot;,	6, 2).x
	assert_parses(p, &quot;7sadf&quot;,	7, 2).x
	assert_parses(p, &quot;8sadf&quot;,	8, 2).x
	assert_parses(p, &quot;9sadf&quot;,	9, 2).x
	refute_parses(p, &quot;Asadf&quot;).x
	refute_parses(p, &quot;asadf&quot;).x
	refute_parses(p, &quot;Bsadf&quot;).x
	refute_parses(p, &quot;bsadf&quot;).x
	refute_parses(p, &quot;Csadf&quot;).x
	refute_parses(p, &quot;csadf&quot;).x
	refute_parses(p, &quot;Dsadf&quot;).x
	refute_parses(p, &quot;dsadf&quot;).x
	refute_parses(p, &quot;Esadf&quot;).x
	refute_parses(p, &quot;esadf&quot;).x
	refute_parses(p, &quot;Fsadf&quot;).x
	refute_parses(p, &quot;fsadf&quot;).x
	refute_parses(p, &quot;Gsadf&quot;).x
	refute_parses(p, &quot;gsadf&quot;).x
End Function

Function test_Parser_hexDigit()
	Dim p As Parser
	p = pHexDigit

	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;sadf&quot;).x
	assert_parses(p, &quot;0sadf&quot;,	 0, 2).x
	assert_parses(p, &quot;1sadf&quot;,	 1, 2).x
	assert_parses(p, &quot;2sadf&quot;,	 2, 2).x
	assert_parses(p, &quot;3sadf&quot;,	 3, 2).x
	assert_parses(p, &quot;4sadf&quot;,	 4, 2).x
	assert_parses(p, &quot;5sadf&quot;,	 5, 2).x
	assert_parses(p, &quot;6sadf&quot;,	 6, 2).x
	assert_parses(p, &quot;7sadf&quot;,	 7, 2).x
	assert_parses(p, &quot;8sadf&quot;,	 8, 2).x
	assert_parses(p, &quot;9sadf&quot;,	 9, 2).x
	assert_parses(p, &quot;Asadf&quot;,	10, 2).x
	assert_parses(p, &quot;asadf&quot;,	10, 2).x
	assert_parses(p, &quot;Bsadf&quot;,	11, 2).x
	assert_parses(p, &quot;bsadf&quot;,	11, 2).x
	assert_parses(p, &quot;Csadf&quot;,	12, 2).x
	assert_parses(p, &quot;csadf&quot;,	12, 2).x
	assert_parses(p, &quot;Dsadf&quot;,	13, 2).x
	assert_parses(p, &quot;dsadf&quot;,	13, 2).x
	assert_parses(p, &quot;Esadf&quot;,	14, 2).x
	assert_parses(p, &quot;esadf&quot;,	14, 2).x
	assert_parses(p, &quot;Fsadf&quot;,	15, 2).x
	assert_parses(p, &quot;fsadf&quot;,	15, 2).x
	refute_parses(p, &quot;Gsadf&quot;).x
	refute_parses(p, &quot;gsadf&quot;).x
End Function


Function test_Parser_manyRev()
	Dim p As Parser
	Dim data As Variant
	Dim zeroMatches As Variant
	zeroMatches = nil
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	p = pManyRev(pFail)
	assert_parses(p, data, zeroMatches, 1).x
	
	&apos;p = pMany(pReturn(3)) - yields infite sequence of 3s, even on empty string
	
	p = pManyRev(pItem)
	assert_parses(p, &quot;&quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; chr(13),	List(&quot;\n&quot;, &quot; &quot;), 3).x
	assert_parses(p, &quot;asdf&quot;,		List(&quot;f&quot;, &quot;d&quot;, &quot;s&quot;, &quot;a&quot;), 5).x
	
	p = pManyRev(pStr(&quot; &quot;))
	assert_parses(p, &quot;&quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; chr(13),	List(&quot; &quot;), 2).x
	assert_parses(p, &quot;asdf&quot;,		zeroMatches, 1).x
	assert_parses(p, &quot;  &quot;,			List(&quot; &quot;, &quot; &quot;), 3).x
	assert_parses(p, &quot;   &quot;,			List(&quot; &quot;, &quot; &quot;, &quot; &quot;), 4).x
	assert_parses(p, &quot; x &quot;,			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; x  &quot;,		List(&quot; &quot;), 2).x
	assert_parses(p, &quot;  x &quot;,		List(&quot; &quot;, &quot; &quot;), 3).x
	
	p = pManyRev(pDecDigit)
	assert_parses(p, &quot;&quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot; &quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot;1&quot;, 			List(1), 2).x
	assert_parses(p, &quot;10 &quot;, 		List(0, 1), 3).x
	assert_parses(p, &quot;102345&quot;, 		List(5, 4, 3, 2, 0, 1), 7).x
End Function

Function test_Parser_many()
	Dim p As Parser
	Dim data As Variant
	Dim zeroMatches As Variant
	zeroMatches = nil
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	p = pMany(pFail)
	assert_parses(p, data, zeroMatches, 1).x
	
	&apos;p = pMany(pReturn(3)) - yields infite sequence of 3s, even on empty string
	
	p = pMany(pItem)
	assert_parses(p, &quot;&quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; chr(13),	List(&quot; &quot;, &quot;\n&quot;), 3).x
	assert_parses(p, &quot;asdf&quot;,		List(&quot;a&quot;, &quot;s&quot;, &quot;d&quot;, &quot;f&quot;), 5).x
	
	p = pMany(pStr(&quot; &quot;))
	assert_parses(p, &quot;&quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; chr(13),	List(&quot; &quot;), 2).x
	assert_parses(p, &quot;asdf&quot;,		zeroMatches, 1).x
	assert_parses(p, &quot;  &quot;,			List(&quot; &quot;, &quot; &quot;), 3).x
	assert_parses(p, &quot;   &quot;,			List(&quot; &quot;, &quot; &quot;, &quot; &quot;), 4).x
	assert_parses(p, &quot; x &quot;,			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; x  &quot;,		List(&quot; &quot;), 2).x
	assert_parses(p, &quot;  x &quot;,		List(&quot; &quot;, &quot; &quot;), 3).x
	
	p = pMany(pDecDigit)
	assert_parses(p, &quot;&quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot; &quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot;1&quot;, 			List(1), 2).x
	assert_parses(p, &quot;10 &quot;, 		List(1, 0), 3).x
	assert_parses(p, &quot;102345&quot;, 		List(1, 0, 2, 3, 4, 5), 7).x
End Function


Function test_Parser_many1Rev()
	Dim p As Parser
	Dim data As Variant
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	p = pMany1Rev(pFail)
	refute_parses(p, data).x
	
	&apos;p = pMany1(pReturn(3)) - yields infite sequence of 3s, except on empty string
	
	p = pMany1Rev(pItem)
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; chr(13),	List(&quot;\n&quot;, &quot; &quot;), 3).x
	assert_parses(p, &quot;asdf&quot;,		List(&quot;f&quot;, &quot;d&quot;, &quot;s&quot;, &quot;a&quot;), 5).x
	
	p = pMany1Rev(pStr(&quot; &quot;))
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; chr(13),	List(&quot; &quot;), 2).x
	refute_parses(p, &quot;asdf&quot;).x
	assert_parses(p, &quot;  &quot;,			List(&quot; &quot;, &quot; &quot;), 3).x
	assert_parses(p, &quot;   &quot;,			List(&quot; &quot;, &quot; &quot;, &quot; &quot;), 4).x
	assert_parses(p, &quot; x &quot;,			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; x  &quot;,		List(&quot; &quot;), 2).x
	assert_parses(p, &quot;  x &quot;,		List(&quot; &quot;, &quot; &quot;), 3).x
	
	p = pMany1Rev(pDecDigit)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	assert_parses(p, &quot;1&quot;, 			List(1), 2).x
	assert_parses(p, &quot;10 &quot;, 		List(0, 1), 3).x
	assert_parses(p, &quot;102345&quot;, 		List(5, 4, 3, 2, 0, 1), 7).x
End Function

Function test_Parser_many1()
	Dim p As Parser
	Dim data As Variant
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	p = pMany1(pFail)
	refute_parses(p, data).x
	
	&apos;p = pMany1(pReturn(3)) - yields infite sequence of 3s, except on empty string
	
	p = pMany1(pItem)
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; chr(13),	List(&quot; &quot;, &quot;\n&quot;), 3).x
	assert_parses(p, &quot;asdf&quot;,		List(&quot;a&quot;, &quot;s&quot;, &quot;d&quot;, &quot;f&quot;), 5).x
	
	p = pMany1(pStr(&quot; &quot;))
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; chr(13),	List(&quot; &quot;), 2).x
	refute_parses(p, &quot;asdf&quot;).x
	assert_parses(p, &quot;  &quot;,			List(&quot; &quot;, &quot; &quot;), 3).x
	assert_parses(p, &quot;   &quot;,			List(&quot; &quot;, &quot; &quot;, &quot; &quot;), 4).x
	assert_parses(p, &quot; x &quot;,			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; x  &quot;,		List(&quot; &quot;), 2).x
	assert_parses(p, &quot;  x &quot;,		List(&quot; &quot;, &quot; &quot;), 3).x
	
	p = pMany1(pDecDigit)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	assert_parses(p, &quot;1&quot;, 			List(1), 2).x
	assert_parses(p, &quot;10 &quot;, 		List(1, 0), 3).x
	assert_parses(p, &quot;102345&quot;, 		List(1, 0, 2, 3, 4, 5), 7).x
End Function

Function test_Parser_seq()
	Dim p As Parser, f As Variant
	Dim data As Variant
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	f = &quot;asc&quot;
	p = pSeq(Array(pFail), f)
	refute_parses(p, data).x
	
	f = &quot;asc&quot;
	p = pSeq(Array(pItem), f)
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot;0&quot;, 	asc(&quot;0&quot;), 2).x
	assert_parses(p, &quot;1&quot;, 	asc(&quot;1&quot;), 2).x
	assert_parses(p, &quot;A&quot;, 	asc(&quot;A&quot;), 2).x
	assert_parses(p, &quot;B&quot;, 	asc(&quot;B&quot;), 2).x
	assert_parses(p, &quot;AB&quot;,	asc(&quot;A&quot;), 2).x
	assert_parses(p, &quot;BA&quot;,	asc(&quot;B&quot;), 2).x
	
	f = &quot;concat&quot;
	p = pSeq(Array(pItem, pItem), f)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;A&quot;).x
	refute_parses(p, &quot;B&quot;).x
	assert_parses(p, &quot;AB&quot;,	&quot;AB&quot;, 3).x
	assert_parses(p, &quot;BA&quot;,	&quot;BA&quot;, 3).x
	
	p = pSeq(Array(pDecDigit, pDecDigit), f)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;A&quot;).x
	refute_parses(p, &quot;B&quot;).x
	refute_parses(p, &quot;AB&quot;).x
	refute_parses(p, &quot;BA&quot;).x
	refute_parses(p, &quot;0B&quot;).x		&apos; *ALL* in sequence must succeed!
	refute_parses(p, &quot;1A&quot;).x		&apos; *ALL* in sequence must succeed!
	assert_parses(p, &quot;01&quot;,	&quot;01&quot;, 3).x
	assert_parses(p, &quot;10&quot;,	&quot;10&quot;, 3).x
	
	f = &quot;asc&quot;
	p = pSeq(Array(pDecDigit), f)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;A&quot;).x
	refute_parses(p, &quot;B&quot;).x
	refute_parses(p, &quot;AB&quot;).x
	refute_parses(p, &quot;BA&quot;).x
	assert_parses(p, &quot;0&quot;, 			48, 2).x
	assert_parses(p, &quot;1&quot;, 			49, 2).x
	assert_parses(p, &quot;123456789&quot;,	49, 2).x
	
	p = pMany1(pSeq(Array(pDecDigit), f))
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;A&quot;).x
	refute_parses(p, &quot;B&quot;).x
	refute_parses(p, &quot;AB&quot;).x
	refute_parses(p, &quot;BA&quot;).x
	assert_parses(p, &quot;0&quot;, 			List(48), 2).x
	assert_parses(p, &quot;1&quot;, 			List(49), 2).x
	assert_parses(p, &quot;123456789&quot;,	List(49, 50, 51, 52, 53, 54, 55, 56, 57), 10).x
	assert_parses(p, &quot;123456789 0&quot;,	List(49, 50, 51, 52, 53, 54, 55, 56, 57), 10).x
End Function

Function test_Parser_hexNum()
	Dim p As Parser
	Dim data As Variant
	p = pHexNum

	refute_parses(p, &quot;&quot;).x
		
	data = Array(&quot; &quot;, &quot; &quot; &amp; chr(13), &quot;qasdf&quot;, &quot; bar&quot;, &quot;qb&quot;, &quot;qba&quot;, &quot;qbar&quot;, &quot;qbarb&quot;,_
		&quot;qbarba&quot;, &quot;qbarbar&quot;, chr(13), chr(13) &amp; &quot;qbar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	refute_parses(p, data).x

	assert_parses(p, &quot;0&quot;,	 0, 2).x
	assert_parses(p, &quot;1&quot;,	 1, 2).x
	assert_parses(p, &quot;2&quot;,	 2, 2).x
	assert_parses(p, &quot;3&quot;,	 3, 2).x
	assert_parses(p, &quot;4&quot;,	 4, 2).x
	assert_parses(p, &quot;5&quot;,	 5, 2).x
	assert_parses(p, &quot;6&quot;,	 6, 2).x
	assert_parses(p, &quot;7&quot;,	 7, 2).x
	assert_parses(p, &quot;8&quot;,	 8, 2).x
	assert_parses(p, &quot;9&quot;,	 9, 2).x

	assert_parses(p, &quot;a&quot;,	10, 2).x
	assert_parses(p, &quot;b&quot;, 	11, 2).x
	assert_parses(p, &quot;c&quot;, 	12, 2).x
	assert_parses(p, &quot;d&quot;, 	13, 2).x
	assert_parses(p, &quot;e&quot;, 	14, 2).x
	assert_parses(p, &quot;f&quot;, 	15, 2).x
	assert_parses(p, &quot;A&quot;, 	10, 2).x
	assert_parses(p, &quot;B&quot;, 	11, 2).x
	assert_parses(p, &quot;C&quot;, 	12, 2).x
	assert_parses(p, &quot;D&quot;, 	13, 2).x
	assert_parses(p, &quot;E&quot;, 	14, 2).x
	assert_parses(p, &quot;F&quot;, 	15, 2).x

	assert_parses(p, &quot;FF&quot;, 		readHex(&quot;FF&quot;), 	3).x
	assert_parses(p, &quot;123&quot;, 	readHex(&quot;123&quot;), 4).x

	assert_parses(p, &quot;0FF&quot;, 	readHex(&quot;FF&quot;), 	4).x	&apos; leading 0s don&apos;t matter
	assert_parses(p, &quot;0123&quot;, 	readHex(&quot;123&quot;), 5).x	&apos; leading 0s don&apos;t matter

	assert_parses(p, &quot;00FF&quot;, 	readHex(&quot;FF&quot;), 	5).x	&apos; leading 0s don&apos;t matter
	assert_parses(p, &quot;00123&quot;, 	readHex(&quot;123&quot;), 6).x	&apos; leading 0s don&apos;t matter

	&apos; 31 bit
	assert_parses(p, &quot;CAFEBAB&quot;, readHex(&quot;CAFEBAB&quot;), 	8).x
	assert_parses(p, &quot;DEADBEE&quot;, readHex(&quot;DEADBEE&quot;), 	8).x
	assert_parses(p, &quot;CAFEBAB&quot;, readHex(&quot;cafebab&quot;), 	8).x	&apos; case doesn&apos;t matter
	assert_parses(p, &quot;dEaDbEe&quot;, readHex(&quot;DeAdBeE&quot;), 	8).x	&apos; case doesn&apos;t matter

&apos;	&apos; 32 bit
&apos;	assert_parses(p, &quot;CAFEBABE&quot;, readHex(&quot;CAFEBABE&quot;), 	9).x
&apos;	assert_parses(p, &quot;DEADBEEF&quot;, readHex(&quot;DEADBEEF&quot;), 	9).x
&apos;	assert_parses(p, &quot;CAFEBABE&quot;, readHex(&quot;cafebabe&quot;), 	9).x	&apos; case doesn&apos;t matter
&apos;	assert_parses(p, &quot;dEaDbEeF&quot;, readHex(&quot;DeAdBeEf&quot;), 	9).x	&apos; case doesn&apos;t matter
End Function

Function test_Parser_hexLit()
	Dim p As Parser
	Dim data As Variant
	p = pHexLit

	refute_parses(p, &quot;&quot;).x
		
	data = Array(&quot; &quot;, &quot; &quot; &amp; chr(13), &quot;qasdf&quot;, &quot; bar&quot;, &quot;qb&quot;, &quot;qba&quot;, &quot;qbar&quot;, &quot;qbarb&quot;,_
		&quot;qbarba&quot;, &quot;qbarbar&quot;, chr(13), chr(13) &amp; &quot;qbar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;,_
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;,_
		&quot;a&quot;, &quot;A&quot;, &quot;b&quot;, &quot;B&quot;, &quot;c&quot;, &quot;C&quot;, &quot;d&quot;, &quot;D&quot;, &quot;e&quot;, &quot;E&quot;, &quot;f&quot;, &quot;F&quot;,_
		&quot;0x&quot;_
	)
	refute_parses(p, data).x

	assert_parses(p, &quot;0x0&quot;, 	 0, 4).x
	assert_parses(p, &quot;0x1&quot;, 	 1, 4).x
	assert_parses(p, &quot;0x2&quot;, 	 2, 4).x
	assert_parses(p, &quot;0x3&quot;, 	 3, 4).x
	assert_parses(p, &quot;0x4&quot;, 	 4, 4).x
	assert_parses(p, &quot;0x5&quot;, 	 5, 4).x
	assert_parses(p, &quot;0x6&quot;, 	 6, 4).x
	assert_parses(p, &quot;0x7&quot;, 	 7, 4).x
	assert_parses(p, &quot;0x8&quot;, 	 8, 4).x
	assert_parses(p, &quot;0x9&quot;,		 9, 4).x

	assert_parses(p, &quot;0xa&quot;,		10, 4).x
	assert_parses(p, &quot;0xb&quot;,		11, 4).x
	assert_parses(p, &quot;0xc&quot;, 	12, 4).x
	assert_parses(p, &quot;0xd&quot;, 	13, 4).x
	assert_parses(p, &quot;0xe&quot;, 	14, 4).x
	assert_parses(p, &quot;0xf&quot;, 	15, 4).x
	assert_parses(p, &quot;0xA&quot;, 	10, 4).x
	assert_parses(p, &quot;0xB&quot;, 	11, 4).x
	assert_parses(p, &quot;0xC&quot;, 	12, 4).x
	assert_parses(p, &quot;0xD&quot;, 	13, 4).x
	assert_parses(p, &quot;0xE&quot;, 	14, 4).x
	assert_parses(p, &quot;0xF&quot;, 	15, 4).x

	assert_parses(p, &quot;0xFF&quot;, 	readHex(&quot;FF&quot;), 	5).x
	assert_parses(p, &quot;0x123&quot;, 	readHex(&quot;123&quot;), 6).x

	assert_parses(p, &quot;0x0FF&quot;, 	readHex(&quot;FF&quot;), 	6).x	&apos; leading 0s don&apos;t matter
	assert_parses(p, &quot;0x0123&quot;, 	readHex(&quot;123&quot;), 7).x	&apos; leading 0s don&apos;t matter

	assert_parses(p, &quot;0x00FF&quot;, 	readHex(&quot;FF&quot;), 	7).x	&apos; leading 0s don&apos;t matter
	assert_parses(p, &quot;0x00123&quot;, readHex(&quot;123&quot;), 8).x	&apos; leading 0s don&apos;t matter

	&apos; 31 bit
	assert_parses(p, &quot;0xCAFEBAB&quot;, readHex(&quot;CAFEBAB&quot;), 	10).x
	assert_parses(p, &quot;0xDEADBEE&quot;, readHex(&quot;DEADBEE&quot;), 	10).x
	assert_parses(p, &quot;0xCAFEBAB&quot;, readHex(&quot;cafebab&quot;), 	10).x	&apos; case doesn&apos;t matter
	assert_parses(p, &quot;0xdEaDbEe&quot;, readHex(&quot;DeAdBeE&quot;), 	10).x	&apos; case doesn&apos;t matter

&apos;	&apos; 32 bit
&apos;	assert_parses(p, &quot;0xCAFEBABE&quot;, readHex(&quot;CAFEBABE&quot;), 	11).x
&apos;	assert_parses(p, &quot;0xDEADBEEF&quot;, readHex(&quot;DEADBEEF&quot;), 	11).x
&apos;	assert_parses(p, &quot;0xCAFEBABE&quot;, readHex(&quot;cafebabe&quot;), 	11).x	&apos; case doesn&apos;t matter
&apos;	assert_parses(p, &quot;0xdEaDbEeF&quot;, readHex(&quot;DeAdBeEf&quot;), 	11).x	&apos; case doesn&apos;t matter
End Function

</script:module>