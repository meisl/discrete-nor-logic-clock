<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M05_Parser" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit


Type Parser
	tyname As String
	tp As String
	st As Variant
End Type

Public bindFns As Object
Public applyP_callCount As Integer
Public _applyP_callCount As Integer
Public applyP_return As Integer
Public applyP_fail As Integer
Public applyP_item As Integer
Public applyP_bind As Integer
Public apply_bind_K_return As Integer
Public applyP_choice As Integer
Public applyP_many1 As Integer
Public applyP_str As Integer
Public applyP_seq As Integer
Public applyP_skip As Integer

Sub Main
	test_Parser()
	Stop
	Dim s As String
	Set pHexLit = pSeq(Array(pStr(&quot;0x&quot;), pHexNum), &quot;sndArg&quot;)
	Dim p As Parser 
	&apos;pChoice(pItem(), pReturn(&quot;bar&quot;))
	Set p = pSeq(Array(pHexLit, pMany(pWhite)), &quot;fstArg&quot;)
	s = &quot;FF 0x1F __µ 0&quot;

	MsgBox( _
		&quot;applying parser &apos;&quot; &amp; p.tp &amp; &quot;&apos; to &quot; &amp; toString(s) &amp; &quot;: &quot; &amp; chr(13) _
		&amp; toString(applyP(p, s)) _
	)

End Sub

&apos;==================================================================

Function TParser_toString(Optional p As Object)
	If isMissing(p) Then
		TParser_toString = Fn.TParser_toString
	Else
		Dim result As String, f As Object
		Select Case p.tp
			Case &quot;fail&quot;:		result = &quot;fail&quot;
			Case &quot;return&quot;:		result = &quot;(return &quot; &amp; toString(p.st) &amp; &quot;)&quot;
			Case &quot;item&quot;: 		result = &quot;item&quot;
			Case &quot;str&quot;:			result = &quot;(str &quot; &amp; toString(p.st) &amp; &quot;)&quot;
			Case &quot;choice&quot;
				Dim alts As Object
				alts = p.st
				If isPZeroOrOne(p) Then
					&apos; it has shape p +++ return Empty
					&apos; so it&apos;s effectively &quot;zero-or-one&quot; p, which can be written as &quot;p?&quot;
					result = TParser_toString(car(alts)) &amp; &quot;?&quot;
				Else
					result = &quot;(&quot; &amp; TParser_toString(car(alts))
					alts = cdr(alts)
					While Not(isNil(alts))
						result = result &amp; &quot; +++ &quot; + TParser_toString(car(alts))
						alts = cdr(alts)
					Wend
					result = result &amp; &quot;)&quot;
				End If
			Case &quot;bind&quot;
				Dim q As Object
				q = p.st(0)
				f = p.st(1)
				result = toString(q) &amp; &quot; &gt;&gt;= &quot; &amp; TFn_toString(f)
			Case &quot;seq&quot;
				Dim ps As Variant, i As Integer, args As String
				ps = p.st(0)
				f  = p.st(1)
				result = &quot;(&quot;
				For i = LBound(ps) To UBound(ps)
					result = result &amp; &quot;a&quot; &amp; i &amp; &quot; &lt;- &quot; &amp; toString(ps(i)) &amp; chr(13) &amp; &quot; &quot;
					args = args &amp; &quot; a&quot; &amp; i
				Next i
				result = result &amp; &quot;return someFn&quot; &amp; args
				result = result &amp; &quot;)&quot;
			Case Else
				croak(&quot;TParser_toString/NYI: .tp = &quot; &amp; toString(p.tp))
		End Select
		TParser_toString = result
	End If
End Function

Function mkParser(Optional tp As String, Optional st As Variant)
	Static oFn As Object
	Dim result As Object
	If isMissing(st) Then
		If isNull(oFn) Then : Set oFn = Fn.mkParser : End If
		If isMissing(tp) Then
			result = oFn
		Else
			result = apply1(oFn, tp)
		End If
	Else
		Set result = New Parser
		result.tyname = &quot;TParser&quot;
		result.tp = tp
		result.st = st
	End If
	mkParser = result
End Function

Function parseFailure()
	parseFailure = Empty
End Function

Function isParseFailure(parseResult) As Boolean
	isParseFailure = isEmpty(parseResult)
&apos;	If typeOf(parseResult) &lt;&gt; typeOf(parseFailure) Then
&apos;		isParseFailure = False
&apos;	Else
&apos;		isParseFailure = equ(parseResult, parseFailure)
&apos;	End If
End Function

&apos; always fails on any string; failure is indicated by returning parseFailure()
Function pFail()
	Static result As Object
	If isNull(result) Then : result = mkParser(&quot;fail&quot;, Nothing) : End If
	pFail = result
End Function

&apos; always succeeds by returning the provided value; without increasing pos
Function pReturn(Optional v As Variant)
	Static oFn As Object : If isNull(oFn) Then : oFn = mkParser(&quot;return&quot;) : End If
	Static returnEmpty As Object : If isNull(returnEmpty) Then : returnEmpty = mkParser(&quot;return&quot;, Empty) : End If
	If isMissing(v) Then
		pReturn = oFn
	ElseIf isEmpty(v) Then
		pReturn = returnEmpty
	Else
		pReturn = mkParser(&quot;return&quot;, v)
	End If
End Function

&apos; monadic bind, aka &quot;&gt;&gt;=&quot;
&apos; for the Parser type that is the fn of type Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b
&apos; which applies the Parser p and if that succeeds feeds its result to the fn f
&apos; to give the overall result Parser b that f returns
Function pBind(Optional p As Parser, Optional f As Object)
	Dim oFn As Object : If isNull(oFn) Then : oFn = Fn.pBind : End If
	If isMissing(f) Then
		If isMissing(p) Then
			pBind = oFn
		Else
			&apos; TODO: pBind: check if p is proper Parser
			pBind = apply(oFn, p)
		End If
	Else
		bindStats(p, f)
		&apos; TODO: pBind: check if f is proper function
		pBind = mkParser(&quot;bind&quot;, Array(p, f))
	End If
End Function

Function isKreturn(f As Object) As Boolean
	Dim result As Boolean
	result = False
	If (getFnName(f) = getFnName(Fn.fstArg)) And (arity(f) = 1) Then
		Dim v As Parser
		v = car(partialArgs(f))
		If v.tp = &quot;return&quot; Then &apos; 40 of the above 43 are of shape (K return x)
			result = True
		End If
	End If
	isKreturn = result
End Function

Function bindStats(p As Parser, f As Object)
	&apos; 43 of 51 are of shape (K p)
	&apos; 40 of those 43 are of shape (K return x)
	If isKreturn(f) Then
		bindFns = cons(car(partialArgs(f)).st, bindFns)
	End If
End Function

&apos; fails on empty string but succeeds on all others
&apos; by returning the first character; and increasing pos by 1
Function pItem()
	Static result As Object
	If isNull(result) Then : result = mkParser(&quot;item&quot;, Nothing) : End If
	pItem = result
End Function

&apos; pattern-matches p against &quot;q &gt;&gt;= K (return Empty)&quot; where q any parser
Function isPSkip(p As Parser)
	Dim result As Boolean : result = False
	If p.tp = &quot;skip&quot; Then
		result = True
	ElseIf p.tp = &quot;bind&quot; Then
		Dim f As Object
		f = p.st(1)
		If (getFnName(f) = getFnName(Fn.fstArg)) And (arity(f) = 1) Then
			Dim innerP As Object
			innerP = car(partialArgs(f))
			result = (innerP.tp = &quot;return&quot;) And isEmpty(innerP.st)
		End If
	End If
	isPSkip = result
End Function

Function pSkip(p As Object)
	Dim result As Variant
	Select Case p.tp
		Case &quot;fail&quot;:	result = p
		Case &quot;return&quot;:	result = pReturn(Empty)
		Case Else
			If isPSkip(p) Then
				result = p
			Else
				&apos;result = pBind(p, fstArg(pReturn(Empty)))
				result = mkParser(&quot;skip&quot;, p)
			End If
	End Select
	pSkip = result
End Function

&apos; succeeds on strings with the given prefix t by returning t,
&apos; and advancing pos by the length of t
Function pStr(Optional t As String)
	Static oFn As Object : If isNull(oFn) Then : oFn = mkParser(&quot;str&quot;) : End If
	If isMissing(t) Then
		pStr = oFn
	Else
		If (Len(t) = 0) Then
			croak(&quot;pStr: cannot match &apos;exactly&apos; the empty string t=&apos;&apos;&quot;)
		Else
			pStr = mkParser(&quot;str&quot;, t)
		End If	
	End If
End Function

&apos;Function pSat(predicate)
&apos;	pBind(pItem, ite(predicate, pReturn, fstArg(pFail))
&apos;End Function

&apos; succeeds if either p1 succeeds (then returning p1&apos;s result and pos)
&apos; or (and only if p1 fails) if p2 succeeds, returns p2&apos;s result and pos.
&apos; fails if both, p1 and p2 fail
Function pChoice(Optional p1 As Parser, Optional p2 As Parser)
	Dim oFn As Object
	If isNull(oFn) Then
		&apos;list1 = swap(cons, nil)
		&apos;      = \y.(swap cons) nil y
		&apos;      = \y.cons y nil
		&apos;      :: a -&gt; [a]
		&apos;list2 = (swap cons) ° list1 
		&apos;      =   \y.(swap cons) list1 y
		&apos;      =   \y.(swap cons) (\y.cons y nil) y
		&apos;      =   \y.(swap cons) (cons y nil)
		&apos;      = \x y.(swap cons) (cons y nil) x 
		&apos;      = \x y.cons x (cons y nil)
		&apos;      :: a -&gt; a -&gt; [a]
		Set oFn = Fn.pChoice
	End If
	If isMissing(p1) Then
		pChoice = oFn
	ElseIf isMissing(p2) Then
		pChoice = apply(oFn, p1)
	Else
		&apos; TODO: @pChoice: strip out always failing parsers
		&apos; TODO: @pChoice: if p1 always succeeds strip out p2
	&apos;	pChoice = mkParser(&quot;choice&quot;, List(p1, p2))
	&apos;	Exit Function
		Dim choices As Variant
		If p2.tp = &quot;choice&quot; Then
			If p1.tp = &quot;choice&quot; Then
				choices = adjoin(p1.st, p2.st)
			Else
				choices = cons(p1,  p2.st)
			End If
		Else
			If p1.tp = &quot;choice&quot; Then
				choices = adjoin(p1.st, List(p2))
			Else
				choices = List(p1, p2)
			End If
		End If
		pChoice = mkParser(&quot;choice&quot;, choices)
	End If
End Function

&apos; pattern-matches p against &quot;q +++ return Empty&quot; where q any parser
Function isPZeroOrOne(p As Parser)
	Dim result As Boolean : result = False
	If p.tp = &quot;choice&quot; Then
		If length(p.st) = 2 Then
			Dim sndAlt As Parser &apos; 2nd alternative
			sndAlt = cadr(p.st)
			&apos; check if it has shape p +++ return Empty (which is effectively &quot;zero-or-one&quot; p)
			result = ((sndAlt.tp = &quot;return&quot;) And isEmpty(sndAlt.st))
		End If
	End If
	isPZeroOrOne = result
End Function

&apos; never fails: if p fails than pZeroOrOne(p) returns Empty + same pos as result,
&apos; otherwise returns whatever p returns as result (+ pos)
&apos; matches at most once
Function pZeroOrOne(p As Parser)
	If isPZeroOrOne(p) Then
		pZeroOrOne = p
	Else
		pZeroOrOne = pChoice(p, pReturn(Empty))
	End If
End Function

&apos; pMany: never fails: if p fails then pMany(p) returns nil + same pos as result,
&apos; otherwise returns a of p results (in the order as in the parsed string) + last pos
&apos; matches as many as possible
Function pMany(p As Parser)
	&apos; Note: direct impl might give a little more perf (not worth it)
	pMany = pChoice(pMany1(p), pReturn(nil))
End Function

&apos; pMany1: same as pMany except that it fails if there is no match at all
&apos; matches as many as possible
Function pMany1(p As Parser)
	pMany1 = mkParser(&quot;many1&quot;, p)
End Function

&apos; pSeq: make a sequence of parsers, collect their results in a list 
&apos; and finally process that list by passing it to the given function
&apos; fails if any of the given parsers fails
&apos; if instead all succeed, collects their results in a list 
&apos; which is then passed on the the given function. The result
&apos; of this function application is then packed up with the last
&apos; parsers pos to give the overall result
Function pSeq(ps As Array, ByVal f As Variant)
	&apos;TODO: pSeq: check if ps is proper Array of Parsers
	f = asFn(f, &quot;pSeq: invalid 2nd arg &quot; &amp; toString(f))
	pSeq = mkParser(&quot;seq&quot;, Array(ps, f))
End Function



&apos;==================================================================


Function pWhite()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = pChoice(pStr(&quot; &quot;), pStr(Chr(9))
	End If
	pWhite = result
End Function

Function pAlphaLower()
	Static result As Object
	If isNull(result) Then
		result = pBind(pItem, _
					ite(compose(inRange(Asc(&quot;a&quot;), Asc(&quot;z&quot;)), Fn.asc), _
						pReturn, _
						fstArg(pFail) _
				 )	)
	End If
	pAlphaLower = result
End Function

Function pAlphaUpper()
	Static result As Object
	If isNull(result) Then
		result = pBind(pItem, _
					ite(compose(inRange(Asc(&quot;A&quot;), Asc(&quot;Z&quot;)), Fn.asc), _
						pReturn, _
						fstArg(pFail) _
				 )	)
	End If
	pAlphaUpper = result
End Function

Function pBinDigit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
&apos;		result = pChoice(_
&apos;			pBind(pStr(&quot;0&quot;), fstArg(pReturn(0))), _
&apos;			pBind(pStr(&quot;1&quot;), fstArg(pReturn(1)))_
&apos;		)
		&apos;&apos;not paying off (yet):
		result = pBind(pItem, compose(ite(inRange(Asc(&quot;0&quot;), Asc(&quot;1&quot;)), compose(pReturn, add(-Asc(&quot;0&quot;))), fstArg(pFail)), Fn.asc)
	End If
	pBinDigit = result
End Function

Function pDecDigit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
&apos;		result = pChoice(pBinDigit,	pBind(pStr(&quot;2&quot;), fstArg(pReturn(2))))
&apos;		result = pChoice(result,	pBind(pStr(&quot;3&quot;), fstArg(pReturn(3))))
&apos;		result = pChoice(result,	pBind(pStr(&quot;4&quot;), fstArg(pReturn(4))))
&apos;		result = pChoice(result,	pBind(pStr(&quot;5&quot;), fstArg(pReturn(5))))
&apos;		result = pChoice(result,	pBind(pStr(&quot;6&quot;), fstArg(pReturn(6))))
&apos;		result = pChoice(result,	pBind(pStr(&quot;7&quot;), fstArg(pReturn(7))))
&apos;		result = pChoice(result,	pBind(pStr(&quot;8&quot;), fstArg(pReturn(8))))
&apos;		result = pChoice(result,	pBind(pStr(&quot;9&quot;), fstArg(pReturn(9))))
		&apos;pDecDigit = result
		&apos;Exit Function

		&apos;&apos;not really paying off (yet):
		Dim f as Object
		&apos;Set f = compose(add(-Asc(&quot;0&quot;)), Fn.asc)
		&apos;MsgBox(TFn_toString(f))
		Set f = compose(ite(inRange(Asc(&quot;0&quot;), Asc(&quot;9&quot;)), compose(pReturn, add(-Asc(&quot;0&quot;))), fstArg(pFail)), Fn.asc)
		result = pBind(pItem, f)
	End If
	pDecDigit = result
End Function

Function pHexDigit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
&apos;		result = pChoice(pDecDigit,	pBind(pChoice(pStr(&quot;A&quot;), pStr(&quot;a&quot;)), fstArg(pReturn(10))) )
&apos;		result = pChoice(result,	pBind(pChoice(pStr(&quot;B&quot;), pStr(&quot;b&quot;)), fstArg(pReturn(11))) )
&apos;		result = pChoice(result,	pBind(pChoice(pStr(&quot;C&quot;), pStr(&quot;c&quot;)), fstArg(pReturn(12))) )
&apos;		result = pChoice(result,	pBind(pChoice(pStr(&quot;D&quot;), pStr(&quot;d&quot;)), fstArg(pReturn(13))) )
&apos;		result = pChoice(result,	pBind(pChoice(pStr(&quot;E&quot;), pStr(&quot;e&quot;)), fstArg(pReturn(14))) )
&apos;		result = pChoice(result,	pBind(pChoice(pStr(&quot;F&quot;), pStr(&quot;f&quot;)), fstArg(pReturn(15))) )
		&apos;pHexDigit = result
		&apos;Exit Function

		&apos;&apos;not really paying off (yet):
		Dim retZero As Object, retUpperA As Object, retLowerA As Object, Kfail As Object
		Set retZero   = compose(pReturn, add(  -Asc(&quot;0&quot;)))
		Set retUpperA = compose(pReturn, add(10-Asc(&quot;A&quot;)))
		Set retLowerA = compose(pReturn, add(10-Asc(&quot;a&quot;)))
		Set Kfail = fstArg(pFail)
		result = pBind(pItem, compose( _
			ite( inRange(Asc(&quot;0&quot;), Asc(&quot;9&quot;)), _
				retZero, _
				ite(inRange(Asc(&quot;A&quot;), Asc(&quot;F&quot;)), _
					retUpperA, _
					ite(inRange(Asc(&quot;a&quot;), Asc(&quot;f&quot;)), _
						retLowerA, _
						fstArg(pFail) _
					) _
				) _
			), Fn.asc) _
		)

	End If
	pHexDigit = result
End Function

Function pHexNum()
	Static result As Object
	If isNull(result) Then
		&apos;foldl1 compose(plus, mul 16)
		Set result = pSeq(Array(pMany1(pHexDigit)), apply(Fn.foldl1, compose(add, mul(16))))
	End If
	pHexNum = result
End Function

Function pHexLit()
	Static result As Parser	&apos; an uninitialized instance of Parser at first
	If result.tp = &quot;&quot; Then
		result = pSeq(Array(pStr(&quot;0x&quot;), pHexNum), sndArg)
	End If
	pHexLit = result
End Function

&apos; Type expressions: base types (atomic/built-in types), arrow types (fns), and n-ary Type constructors
&apos; Grammar for type expressions:
&apos;   TypeExpr ::= ws* N ws* (&quot;-&gt;&quot; TypeExpr)?		; &quot;ws&quot; means whitespace, &quot;*&quot; means many and &quot;?&quot; zeroOrOne
&apos;          N ::= BaseType			; need extra rule &quot;N&quot; for &quot;-&gt;&quot; to bind most strongly
&apos;              | TypeVar
&apos;              | TypeCtor (ws+ N)*	; &quot;+&quot; means many1
&apos;              | &quot;(&quot; TypeExpr &quot;)&quot;
&apos;   BaseType ::= &quot;Bool&quot; | &quot;Str&quot; | &quot;Int&quot; | &quot;Long&quot; | ...
&apos;    TypeVar ::= [a-z]
&apos;   TypeCtor ::= &quot;List&quot; | &quot;Maybe&quot; | ...
&apos; This makes the binary (infix) type constructor &quot;-&gt;&quot; right-associative
&apos; and also make it bind more weakly than any other type constructor 
&apos; &quot;TypeCtor&quot;.
&apos; For example: &quot;Parser a -&gt; b&quot; = &quot;(Parser a) -&gt; b&quot;; NOT &quot;Parser (a -&gt; b)&quot;
&apos; Now, this grammar is tricky to implement because it contains both,
&apos; - simple recursion (TypeExpr in TypeExpr and N in N)
&apos; - mutual recursion (N in TypeExpr and TypeExpr in N)
Function pTypeExpr()
	Static result As Object
	If isNull(result) Then
		Dim pLeft As Object
		Dim pRight As Object
		Dim pS As Object
		Dim pParenS As Object
		Dim pTypeArg As Object
		Dim pCtor As Object
		Dim pN
		Dim recDummy As Object
		
		&apos; Left ::= ws* N
		&apos; pLeft = do _ &lt;- many white
		&apos;            n &lt;- N
		&apos;         return n
		&apos;pLeft = pSeq(Array(pMany(pWhite), recDummy), sndArg)
		pLeft = pSeq(Array(pSkip(pMany(pWhite)), recDummy), id)
		
		&apos; Right ::= &quot;-&gt;&quot; S
		&apos; pRight = do _ &lt;- (str &quot;-&gt;&quot;)
		&apos;             s &lt;- S
		&apos;          return s
		&apos;pRight = pSeq(Array(pStr(&quot;-&gt;&quot;), recDummy), sndArg)
		pRight = pSeq(Array(pSkip(pStr(&quot;-&gt;&quot;)), recDummy), id)
		
		&apos; S ::= Left ws* Right?
		&apos; pS = do lft &lt;- pLeft
		&apos;           _ &lt;- many white
		&apos;         rgt &lt;- zeroOrOne pRight
		&apos;      return (if (empty? rgt) left else (mkArrowType lft rgt))
		&apos;pS = pSeq(Array(pLeft,_
		&apos;				pSeq(Array(pMany(pWhite), pZeroOrOne(pRight)),_
		&apos;				sndArg),_
		&apos;		  ), Fn.maybeMakeArrowType)
		&apos;
		pS = pSeq(Array(pLeft,_
						pSkip(pMany(pWhite)),_
						pZeroOrOne(pRight)_
				  ), Fn.maybeMakeArrowType)
		pRight.st(0)(1) = pS &apos; fix up recursive call to S in Right
		
		&apos; ParenS ::= &quot;(&quot; S &quot;)&quot;
		&apos;pParenS = pSeq(Array(pSeq(Array(pStr(&quot;(&quot;), pS), sndArg),_
		&apos;				     pStr(&quot;)&quot;)_
		&apos;			   ), fstArg)
		
		pParenS = pSeq(Array(pSkip(pStr(&quot;(&quot;)), _
							 pS, _
						     pSkip(pStr(&quot;)&quot;)) _
					   ), id)
		
		&apos; TypeArg ::= ws+ N
		&apos;pTypeArg = pSeq(Array(pMany1(pWhite), recDummy), sndArg)
		pTypeArg = pSeq(Array(pSkip(pMany1(pWhite)), recDummy), id)
		
		&apos; Ctor ::= TypeCtor TypeArg*
		pCtor = pSeq(Array(pTypeCtor, pMany(pTypeArg)), Fn.mkTypeCtor)
		
		&apos; N ::= ParenS | BaseType | Ctor | TypeVar
		pN = foldl1(pChoice, List(pParenS, pBaseType, pCtor, pTypeVar))
		
		pLeft.st(0)(1) = pN &apos; fix up recursive call to N in Left
		pTypeArg.st(0)(1) = pN &apos; fix up recursive call to N in TypeArg
			
		result = pS

		&apos;msgbox(toString(pLeft))
	End If
	pTypeExpr = result
End Function

Function pBaseType()
	Static result As Object
	If isNull(result) Then
		result = foldl1(pChoice, _
						map(pStr, List(&quot;Bool&quot;, &quot;Str&quot;, &quot;Int&quot;, &quot;Long&quot;))_
		)
	End If
	pBaseType = result
End Function

Function pTypeVar()
&apos;	pTypeVar = pBind(pAlphaLower, compose(pReturn, concat(&quot;&apos;&quot;)))
	pTypeVar = pSeq(Array(pAlphaLower), concat(&quot;&apos;&quot;))
End Function

Function pTypeCtor()
	Static result As Object
	If isNull(result) Then
&apos;		result = foldl1( pChoice, _
&apos;						 map(pStr, List(&quot;List&quot;, &quot;Maybe&quot;, &quot;Parser&quot;)) )
		result = pSeq(_
			Array(pSeq(Array(pAlphaUpper, pMany1(pAlphaLower)), cons)), _
			foldl1(concat) _
		)
	End If
	pTypeCtor = result
End Function

Function mkArrowType(tIn, tOut)
	mkArrowType = &quot;(-&gt; &quot; &amp; tIn &amp; &quot; &quot; &amp; tOut &amp; &quot;)&quot;
End Function

Function maybeMakeArrowType(i, o)
	If isEmpty(o) Then
		maybeMakeArrowType = i
	Else
		maybeMakeArrowType = mkArrowType(i, o)
	End If
End Function

Function mkTypeCtor(ctorName As String, typeArgs As Object)
	Dim result As String
	result = &quot;(&quot; &amp; ctorName
	If isNil(typeArgs) Then
		result = result &amp; &quot; [])&quot;
	Else
		Dim toStr As Object
		&apos;  \acc a.concat acc (concat &quot;, &quot; a)
		&apos;= \acc a.(swap concat) (concat &quot;, &quot; a) acc
		&apos;= swap \a acc.(swap concat) (concat &quot;, &quot; a) acc
		&apos;= swap \a.(swap concat) (concat &quot;, &quot; a)
		&apos;= swap ((swap concat) ° (concat &quot;, &quot;))
		toStr = swap(compose(swap(concat) , concat(&quot;, &quot;)))
		result = result &amp; &quot; [&quot; &amp; foldl1(toStr, typeArgs) &amp; &quot;])&quot;
	End If
	mkTypeCtor = result
End Function


&apos; =============================================================================

Function lookupParser(pName As String) As Parser
	Dim result As Parser
	Select Case pName
		Case &quot;pWhite&quot;:		result = pWhite
		Case &quot;pBinDigit&quot;:	result = pBinDigit
		Case &quot;pDecDigit&quot;:	result = pDecDigit
		Case Else
			croak(&quot;unknown parser &quot; &amp; pName)
	End Select
	lookupParser = result
End Function

Function parse(pName As String, s As String)
	Dim result As String
	result = toString(applyP(lookupParser(pName), s))
	if (result = &quot;Empty&quot;) then
		MsgBox(pName &amp; &quot; on &quot; &amp; tostring(s) &amp; &quot; yielded &quot; &amp; result)
	end if
	parse = result
End Function

Function applyP(ByVal parser As Variant, s As String, Optional pos As Integer)
	applyP_callCount = applyP_callCount + 1
	Dim p As Parser
	If IsNull(parser) Or IsEmpty(parser) Then
		croak(&quot;applyP: invalid arg parser - &quot; &amp; toString(parser))
	ElseIf TypeName(parser) = &quot;Object&quot; Then
		Set p = parser
	Else
		croak(&quot;applyP: invalid arg parser - &quot; &amp; toString(parser))
	End If
	If IsMissing(pos) Then
		pos = 1
	End If
	If 0 = 1 Then
		Dim endPos As Integer, parseResult As Variant
		parseResult = _applyP2(p, s, pos, endPos, False)
		If endPos &lt; 0 Then &apos; indicates failure
			applyP = parseFailure
		Else &apos; package up result and endPos for the outside world			
			applyP = Array(parseResult, endPos)
		End If
	Else
		applyP = _applyP(p, s, pos, False)
	End If
End Function

Function _applyP2(p As Parser, s As String, pos As Integer, endPos As Integer, ByVal isUnderSkip As Boolean)
	_applyP_callCount = _applyP_callCount + 1
	Dim result As Variant
	Dim i As Integer
	Dim innerParser As Parser
	Dim innerParsers As Variant
	Dim lst As Object
	
	Select Case p.tp
		Case &quot;str&quot;
			applyP_str = applyP_str + 1
			Dim match As String
			Dim matchLen As Integer
			match = p.st
			matchLen = Len(match)	&apos; TODO: pre-calculate Len(match)
			If (Mid(s, pos, matchLen) &lt;&gt; match) Then
				Goto _applyP2_parseFailure
			End If
			endPos = pos + matchLen
			If Not(isUnderSkip) Then
				result = match
			End If
		Case &quot;choice&quot;
			applyP_choice = applyP_choice + 1
			innerParsers = p.st
			Do
				innerParser = car(innerParsers)
				result = _applyP2(innerParser, s, pos, endPos, isUnderSkip)
				innerParsers = cdr(innerParsers)
			Loop Until (isNil(innerParsers) Or (endPos &gt; 0))
		Case &quot;item&quot;
			applyP_item = applyP_item + 1
			If pos &gt; Len(s) Then
				Goto _applyP2_parseFailure
			End If
			endPos = pos + 1
			If Not(isUnderSkip) Then
				result = Mid(s, pos, 1)
			End If
		Case &quot;bind&quot;
			applyP_bind = applyP_bind + 1
			If isKreturn(p.st(1)) Then
				apply_bind_K_return = apply_bind_K_return + 1
			End If
			result = _applyP2(p.st(0), s, pos, endPos, isUnderSkip)
			If endPos &lt; 0 Then : Exit Function : End If
			result = _applyP2(apply1(p.st(1), result), s, endPos, endPos, isUnderSkip)
		Case &quot;return&quot;
			applyP_return = applyP_return + 1
			If Not(isUnderSkip) Then
				result = p.st
			End If
			endPos = pos
		Case &quot;seq&quot;
			applyP_seq = applyP_seq + 1
			innerParsers = p.st(0)
			If isUnderSkip Then
				For i = LBound(innerParsers) To UBound(innerParsers)
					_applyP2(innerParsers(i), s, pos, endPos, True)
					If endPos &lt; 0 Then : Exit Function : End If
					pos = endPos
				Next		
			Else
				lst = nil
				For i = LBound(innerParsers) To UBound(innerParsers)
					innerParser = innerParsers(i)
					result = _applyP2(innerParser, s, pos, endPos, False)
					If endPos &lt; 0 Then : Exit Function : End If
					pos = endPos
					&apos; TODO: precalculate isPSkip check in pSeq
					If Not(isPSkip(innerParser)) Then
						lst = cons(result, lst)
					End If
				Next
				result = applyToList(p.st(1), reverse(lst))
			End If
		Case &quot;skip&quot;
			applyP_skip = applyP_skip + 1
			result = _applyP2(p.st, s, pos, endPos, True)
			If endPos &gt; 0 Then
				assertEqual(result, Empty).x
			End If
		Case &quot;many1&quot;
			applyP_many1 = applyP_many1 + 1
			innerParser = p.st
			If isUnderSkip Then
				_applyP2(innerParser, s, pos, endPos, True)
				If endPos &lt; 0 Then : Exit Function : End If
				Do
					pos = endPos
					_applyP2(innerParser, s, pos, endPos, True)
				Loop Until (endPos &lt; 0)
				endPos = pos
			Else
				Set lst = nil
				result = _applyP2(innerParser, s, pos, endPos, False)
				If endPos &lt; 0 Then : Exit Function : End If
				Do
					Set lst = cons(result, lst)
					pos = endPos
					result = _applyP2(innerParser, s, pos, endPos, False)
				Loop Until (endPos &lt; 0)
				endPos = pos
				result = reverse(lst)
			End If
		Case &quot;fail&quot;
			applyP_fail = applyP_fail + 1
			Goto _applyP2_parseFailure
		Case Else
			result = &quot;unknown Parser &apos;&quot; &amp; p.tp &amp; &quot;&apos;&quot;
			MsgBox(&quot;Error in applyP: &quot; &amp; result)
	End Select
	&apos;If isUnderSkip And Not(isParseFailure(result)) Then
	&apos;	assertEqual(result(0), Empty).x
	&apos;End If
	_applyP2 = result
	Exit Function
_applyP2_parseFailure:
	endPos = -1
End Function

Function _applyP(p As Parser, s As String, pos As Integer, isUnderSkip As Boolean)
	_applyP_callCount = _applyP_callCount + 1
	Dim result As Variant
	Dim fResult As Variant
	Dim nxtPos As Integer
	Dim i As Integer, j As Integer, k As Integer
	Dim innerParser As Parser
	Dim innerParsers As Variant
	Dim lst As Object
	nxtPos = pos
	If p.tp = &quot;skip&quot; Then
		applyP_skip = applyP_skip + 1
		result = _applyP(p.st, s, pos, True)
		If Not(isParseFailure(result)) Then
			assertEqual(result(0), Empty).x
		End If
	ElseIf p.tp = &quot;return&quot; Then
		applyP_return = applyP_return + 1
		If isUnderSkip Then
			result = Array(Empty, nxtPos)
		Else
			result = Array(p.st, nxtPos)
		End If
	ElseIf p.tp = &quot;fail&quot; Then
		applyP_fail = applyP_fail + 1
		result = parseFailure
	ElseIf p.tp = &quot;item&quot; Then
		applyP_item = applyP_item + 1
		If pos &lt;= Len(s) Then
			nxtPos = pos + 1
			If isUnderSkip Then
				result = Array(Empty, nxtPos)
			Else
				result = Array(Mid(s, pos, 1), nxtPos)
			End If
		Else
			result = parseFailure
		End If
	ElseIf p.tp = &quot;str&quot; Then
		applyP_str = applyP_str + 1
		Dim match As String
		Dim matchLen As Integer
		match = p.st
		matchLen = Len(match)
		If (Mid(s, pos, matchLen) = match) Then
			nxtPos = pos + matchLen
			If isUnderSkip Then
				result = Array(Empty, nxtPos)
			Else
				result = Array(match, nxtPos)
			End If
		Else
			result = parseFailure
		End If
	ElseIf p.tp = &quot;choice&quot; Then
		applyP_choice = applyP_choice + 1
		innerParsers = p.st
		Do
			innerParser = car(innerParsers)
			result = _applyP(innerParser, s, pos, isUnderSkip)
			innerParsers = cdr(innerParsers)
		Loop Until (isNil(innerParsers) Or Not(isParseFailure(result)))
	ElseIf (p.tp = &quot;many1&quot;) Then
		applyP_many1 = applyP_many1 + 1
		innerParser = p.st
		If isUnderSkip Then
			result = _applyP(innerParser, s, nxtPos, isUnderSkip)
			If Not(isParseFailure(result)) Then
				Dim dummyResult As Variant
				dummyResult = result
				Do
					nxtPos = dummyResult(1)
					dummyResult = _applyP(innerParser, s, nxtPos, isUnderSkip)
				Loop Until isParseFailure(dummyResult)
				result(1) = nxtPos
			End If
		Else
			Set lst = nil
			result = _applyP(innerParser, s, nxtPos, isUnderSkip)
			While Not(isParseFailure(result))
				nxtPos = result(1)
				Set lst = cons(result(0), lst)
				result = _applyP(innerParser, s, nxtPos, isUnderSkip)
			Wend
			If isNil(lst) Then
				result = parseFailure
			Else
				result = Array(reverse(lst), nxtPos)
			End If
		End If
	ElseIf p.tp = &quot;bind&quot; Then
		applyP_bind = applyP_bind + 1
		If isKreturn(p.st(1)) Then
			apply_bind_K_return = apply_bind_K_return + 1
		End If
		result = _applyP(p.st(0), s, pos, isUnderSkip)
		If Not(isParseFailure(result)) Then
			nxtPos = result(1)
			fResult = apply1(p.st(1), result(0))
			&apos; do NOT access .tp on fResult - it&apos;s effectively as fixing fResult&apos;s type to Object...!
			result = _applyP(fResult, s, nxtPos, isUnderSkip)
		End If
	ElseIf p.tp = &quot;seq&quot; Then
		applyP_seq = applyP_seq + 1
		innerParsers = p.st(0)
		nxtPos = pos
		If isUnderSkip Then
			For i = LBound(innerParsers) To UBound(innerParsers)
				result = _applyP(innerParsers(i), s, nxtPos, isUnderSkip)
				If isParseFailure(result) Then
					Exit For
				End If
				nxtPos = result(1)
			Next		
		Else
			Dim iResults As Object
			iResults = nil
			For i = LBound(innerParsers) To UBound(innerParsers)
				result = _applyP(innerParsers(i), s, nxtPos, isUnderSkip)
				If isParseFailure(result) Then
					Exit For
				End If
				nxtPos = result(1)
				If Not(isPSkip(innerParsers(i))) Then
					iResults = cons(result(0), iResults)
				End If
			Next
			If Not(isParseFailure(result)) Then
				fResult = applyToList(p.st(1), reverse(iResults))
				&apos; ATTENTION: do not reuse result, type of result value may not match
				&apos;            and an implicit conversion might happen!
				result = Array(fResult, nxtPos)
			End If
		End If
	Else
		result = &quot;unknown Parser &apos;&quot; &amp; p.tp &amp; &quot;&apos;&quot;
		MsgBox(&quot;Error in applyP: &quot; &amp; result)
	End If
	&apos;If isUnderSkip And Not(isParseFailure(result)) Then
	&apos;	assertEqual(result(0), Empty).x
	&apos;End If
	_applyP = result
End Function


&apos;= tests ======================================================================

Global refute_parses_pass As Object

Function [-----------------------------]()
End Function

Function test_Parser(Optional what)
&apos;	what = &quot;primitives&quot;
	Dim failure As String
	failure = toString(parseFailure)
	refute_parses_pass = assertEqual(failure, failure)
	
	Dim result As Variant
	Dim ticksPerSec As Long
	ticksPerSec = GetSystemTicks()
	Wait(100) &apos; wait a hundred milliseconds
	ticksPerSec = 10 * (GetSystemTicks() - ticksPerSec)

	Dim tm As Double, aCount As Integer, aPerSec As Double
	aCount = assertionCount
	tm = GetSystemTicks
	
	bindFns = nil
	
	If isMissing(what) Or (what = &quot;all&quot;) Or (what = &quot;primitives&quot;) Then
		test_Parser_fail()
		test_Parser_return()
		test_Parser_item()
		test_Parser_str()
		test_Parser_choice()
		test_Parser_bind()
		test_Parser_skip()
	End If
	If isMissing(what) Or (what = &quot;all&quot;) Or (what = &quot;multiplicity&quot;) Then
		test_Parser_zeroOrOne()
		test_Parser_skip_zeroOrOne()
		test_Parser_many()
		test_Parser_many1()
	End If
	If isMissing(what) Or (what = &quot;all&quot;) Or (what = &quot;basic&quot;) Then
		test_Parser_white()
		test_Parser_seq()
		test_Parser_alphaLower()
		test_Parser_alphaUpper()
		test_Parser_toString()
	End If
	If isMissing(what) Or (what = &quot;all&quot;) Or (what = &quot;numbers&quot;) Then
		test_Parser_binDigit()
		test_Parser_decDigit()
		test_Parser_hexDigit()
		test_Parser_hexNum()
		test_Parser_hexLit()
	End If	
	If isMissing(what) Or (what = &quot;all&quot;) Or (what = &quot;types&quot;) Then
		test_Parser_baseType()
		test_Parser_TypeVar()
		test_Parser_TypeCtor()
		test_Parser_TypeExpr()
	End If
	
end_of_Parser_tests:	
	aCount = assertionCount - aCount
	tm = CLng(10 * (GetSystemTicks() - tm) / ticksPerSec) / 10
	If tm = 0 Then : tm = 1 : End If &apos; avoid divide-by-zero
	If isMissing(what) Then
		aPerSec =  CLng(10 * aCount / tm) / 10
		Dim summary As String
		summary = tm &amp; &quot; sec for &quot; &amp; aCount &amp; &quot; assertions, &quot;_
		&amp; chr(13) &amp; &quot;that&apos;s ~&quot; &amp; aPerSec &amp; &quot; assertions/sec&quot;
		MsgBox(summary)
		result = summary

		msgbox(&quot;applyP_callCount: &quot; &amp; applyP_callCount _
				&amp; chr(13) &amp; &quot;_applyP_callCount: &quot; &amp; _applyP_callCount _
				&amp; chr(13) &amp; &quot;apply_str: &quot; &amp; applyP_str _
				&amp; chr(13) &amp; &quot;apply_choice: &quot; &amp; applyP_choice _
				&amp; chr(13) &amp; &quot;apply_item: &quot; &amp; applyP_item _
				&amp; chr(13) &amp; &quot;apply_bind: &quot; &amp; applyP_bind _
				&amp; chr(13) &amp; &quot;  (apply_bind_K_return: &quot; &amp; apply_bind_K_return &amp; &quot;)&quot; _
				&amp; chr(13) &amp; &quot;apply_return: &quot; &amp; applyP_return _
				&amp; chr(13) &amp; &quot;apply_seq: &quot; &amp; applyP_seq _
				&amp; chr(13) &amp; &quot;apply_skip: &quot; &amp; applyP_skip _
				&amp; chr(13) &amp; &quot;apply_many1: &quot; &amp; applyP_many1 _
				&amp; chr(13) &amp; &quot;apply_fail: &quot; &amp; applyP_fail _
				&amp; chr(13) &amp; length(bindFns) &amp; &quot; bindFns: &quot; &amp; toString(bindFns))
	Else
		result = Join(Array(&quot;test_Parser(&quot; &amp; what &amp; &quot;):&quot;, tm, aCount), &quot; &quot;)
	End If
	test_Parser = result
End Function

&apos;= test helpers ===============================================================

Function refute_parses(p As Parser, ByVal ss As Variant)
	Dim actual As Variant, testResult As Variant
	Dim actualS As String, expectedS As String
	If isArray(ss) Then
		Dim i As Integer
		For i = LBound(ss) To UBound(ss)
			actual = applyP(p, ss(i), 1)
			assertionCount = assertionCount + 1
			If Not(isParseFailure(actual)) Then
				Goto refute_parses_failed
			End If
		Next i
	Else
		actual = applyP(p, ss, 1)
		assertionCount = assertionCount + 1
		If Not(isParseFailure(actual)) Then
			Goto refute_parses_failed
		End If
	End If
	refute_parses = refute_parses_pass
	Exit Function
refute_parses_failed:
	actualS = toString(actual)
	expectedS = toString(parseFailure)
	testResult = assertEqual(actualS, expectedS)
	If isArray(ss) Then
		MsgBox(&quot;at index &quot; &amp; i &amp; &quot;: &quot; &amp; toString(ss(i)))
	End If
	refute_parses = testResult
End Function

Function assert_parses(p As Parser, ByVal ss As Variant, expVal As Variant, expPos As Integer)
&apos;	assertEqual(typeOf(p), &quot;Object/TParser&quot;).x
	Dim actual As Variant, testResult As Variant
	Dim actualS As String, expectedS As String
	
	If isArray(ss) Then
		Dim i As Integer
		For i = LBound(ss) To UBound(ss)
			actual = applyP(p, ss(i), 1)
			testResult = assertEqual(actual(1), expPos)
			If (testResult.isFail) Then
				MsgBox(toString(actual))
				Goto assert_parse_failed
			End If
			testResult = assertEqual(toString(actual(0)), toString(expVal))
			If (testResult.isFail) Then
				Goto assert_parse_failed
			End If
		Next i
	Else
		actual = applyP(p, ss, 1)
		testResult = assertEqual(actual(1), expPos)
		If (testResult.isFail) Then
			Goto assert_parse_failed
		End If
		testResult = assertEqual(toString(actual(0)), toString(expVal))
		If (testResult.isFail) Then
			Goto assert_parse_failed
		End If
	End If
	assert_parses = testResult
	Exit Function
assert_parse_failed:
	actualS = toString(actual)
	expectedS = toString(Array(expVal, expPos))
	testResult = assertEqual(actualS, expectedS)
	If isArray(ss) Then
		MsgBox(&quot;at index &quot; &amp; i &amp; &quot;: &quot; &amp; toString(ss(i)))
	End If
	assert_parses = testResult
End Function

&apos;= actual tests ===============================================================

Function test_Parser_fail()
	refute_parses(pFail, Array( _
		&quot;&quot;,	&quot; &quot;, &quot;   &quot;, chr(13), chr(9), &quot;a&quot;, &quot;1&quot;, &quot;[]&quot;, &quot;asdf&quot; _
	)).x
End Function

Function test_Parser_return()
	Dim p As Variant
	Dim expected As Variant
	
	p = pReturn
	assertEqual(isFn(p), True).x
	assertEqual(arity(p),  1).x

	p = pReturn(&quot;bar&quot;)
	assert_parses(p, &quot;&quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot; &quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot;a&quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot;1&quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot;[]&quot;,		&quot;bar&quot;, 1).x
	assert_parses(p, &quot;abcd&quot;,	&quot;bar&quot;, 1).x
	assert_parses(p, chr(13),	&quot;bar&quot;, 1).x

	p = pReturn(4711)	
	assert_parses(p, &quot;&quot;,		4711, 1).x
	assert_parses(p, &quot; &quot;,		4711, 1).x
	assert_parses(p, &quot;a&quot;,		4711, 1).x
	assert_parses(p, &quot;1&quot;,		4711, 1).x
	assert_parses(p, &quot;[]&quot;,		4711, 1).x
	assert_parses(p, &quot;abcd&quot;,	4711, 1).x
	assert_parses(p, chr(13),	4711, 1).x
End Function

Function test_Parser_item()
	Dim p As Parser
	Set p = pItem

	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;,		&quot; &quot;, 2).x
	assert_parses(p, &quot;a&quot;,		&quot;a&quot;, 2).x
	assert_parses(p, &quot;1&quot;,		&quot;1&quot;, 2).x
	assert_parses(p, &quot;[]&quot;,		&quot;[&quot;, 2).x
	assert_parses(p, &quot;abcd&quot;,	&quot;a&quot;, 2).x
	assert_parses(p, chr(13),	chr(13), 2).x
	assert_parses(p, chr( 9),	chr( 9), 2).x
End Function

Function test_Parser_str()
	Dim p As Object
	
	p = pStr
	assertEqual(isFn(p), True).x
	assertEqual(arity(p),  1).x
	
&apos;	assertThrows(pStr, Array(&quot;&quot;)).x

	p = pStr(&quot;bar&quot;)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot; &quot; &amp; chr(13)).x
	refute_parses(p, &quot;asdf&quot;).x
	refute_parses(p, &quot; bar&quot;).x
	refute_parses(p, &quot;b&quot;).x
	refute_parses(p, &quot;ba&quot;).x
	assert_parses(p, &quot;bar&quot;,		&quot;bar&quot;, 4).x
	assert_parses(p, &quot;barb&quot;,	&quot;bar&quot;, 4).x
	assert_parses(p, &quot;barba&quot;,	&quot;bar&quot;, 4).x
	assert_parses(p, &quot;barbar&quot;,	&quot;bar&quot;, 4).x

	p = pStr(chr(13))
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot; &quot; &amp; chr(13)).x
	refute_parses(p, &quot;asdf&quot;).x
	refute_parses(p, &quot; bar&quot;).x
	refute_parses(p, &quot;b&quot;).x
	refute_parses(p, &quot;ba&quot;).x
	refute_parses(p, &quot;bar&quot;).x
	refute_parses(p, &quot;barb&quot;).x
	refute_parses(p, &quot;barba&quot;).x
	refute_parses(p, &quot;barbar&quot;).x
	assert_parses(p, chr(13),					&quot;\n&quot;, 2).x
	assert_parses(p, chr(13) &amp; &quot;bar&quot;,			&quot;\n&quot;, 2).x
	assert_parses(p, chr(13) &amp; chr(13),			&quot;\n&quot;, 2).x
	assert_parses(p, chr(13) &amp; chr(13) &amp; &quot;bar&quot;,	&quot;\n&quot;, 2).x
End Function

Function test_Parser_choice()
	Dim p As Object
	Dim data As Variant

	p = pChoice
	assertEqual(isFn(p), True).x
	assertEqual(arity(p),  2).x
	p = apply(p, pItem)
	assertEqual(isFn(p), True).x
	assertEqual(arity(p),  1).x
	p = apply(p, pReturn(7))
		
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	p = pChoice(pFail, pFail)
	refute_parses(p, data).x
	
	p = pChoice(pReturn(7), pFail)
	assert_parses(p, data, 7, 1).x
	
	p = pChoice(pFail, pReturn(7))
	assert_parses(p, data, 7, 1).x
	
	p = pChoice(pReturn(42), pReturn(7))
	assert_parses(p, data, 42, 1).x
	
	assert_parses(pChoice(pItem, pReturn(11)), 	&quot;&quot;, 11, 1	).x
	refute_parses(pChoice(pItem, pStr(&quot;x&quot;)),	&quot;&quot;).x
	assert_parses(pChoice(pReturn(11), pItem), 	&quot;&quot;, 11, 1	).x
	refute_parses(pChoice(pStr(&quot;x&quot;), pItem),	&quot;&quot;).x
	
	assert_parses(pChoice(pItem, pReturn(11)), 	&quot; &quot;, &quot; &quot;, 2	).x
	assert_parses(pChoice(pItem, pStr(&quot;x&quot;)), 	&quot; &quot;, &quot; &quot;, 2	).x
	assert_parses(pChoice(pReturn(11), pItem), 	&quot; &quot;, 11, 1	).x
	assert_parses(pChoice(pStr(&quot;x&quot;), pItem), 	&quot; &quot;, &quot; &quot;, 2	).x
	
	assert_parses(pChoice(pItem, pReturn(11)), 	&quot;x&quot;, &quot;x&quot;, 2	).x
	assert_parses(pChoice(pItem, pStr(&quot;x&quot;)), 	&quot;x&quot;, &quot;x&quot;, 2	).x
	assert_parses(pChoice(pReturn(11), pItem), 	&quot;x&quot;, 11, 1	).x
	assert_parses(pChoice(pStr(&quot;x&quot;), pItem), 	&quot;x&quot;, &quot;x&quot;, 2	).x
End Function

Function test_Parser_bind()
	Dim p As Object
	p = pBind
	assertEqual(isFn(p), True).x
	assertEqual(arity(p),   2).x
	
	p = pBind(pItem)
	assertEqual(isFn(p), True).x
	assertEqual(arity(p),   1).x
	
	p = apply(p, fstArg(pStr(&quot;y&quot;)))
	assert_parses(p, &quot;xy&quot;, &quot;y&quot;, 3).x
	refute_parses(p, &quot;xx&quot;).x
	refute_parses(p, &quot;yx&quot;).x
	assert_parses(p, &quot; yabcd&quot;, &quot;y&quot;, 3).x
	
&apos;	p = pBind(pItem, \a.return (concat &quot;FOO&quot; a))
	p = pBind(pItem, compose(pReturn, concat(&quot;FOO&quot;)))
	assert_parses(p, &quot;xy&quot;,		&quot;FOOx&quot;, 2).x
	assert_parses(p, &quot;xx&quot;,		&quot;FOOx&quot;, 2).x
	assert_parses(p, &quot;yx&quot;,		&quot;FOOy&quot;, 2).x
	assert_parses(p, &quot; yabcd&quot;,	&quot;FOO &quot;, 2).x
End Function

Function test_Parser_skip()
	Dim p As Parser, actual As Variant
	Set p = pSkip(pItem)
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;,		Empty, 2).x
	assert_parses(p, &quot;a&quot;,		Empty, 2).x
	assert_parses(p, &quot;1&quot;,		Empty, 2).x
	assert_parses(p, &quot;[]&quot;,		Empty, 2).x
	assert_parses(p, &quot;abcd&quot;,	Empty, 2).x
	assert_parses(p, chr(13),   Empty, 2).x
	assert_parses(p, chr( 9),	Empty, 2).x
	
	&apos; skip fail = fail
	Set p = pSkip(pFail)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;1&quot;).x
	refute_parses(p, &quot;[]&quot;).x
	refute_parses(p, &quot;abcd&quot;).x
	refute_parses(p, chr(13)).x
	refute_parses(p, chr( 9)).x
		
	Set p = pSkip(pBind(pItem, fstArg(pItem)))
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;1&quot;).x
	assert_parses(p, &quot;[]&quot;,				Empty, 3).x
	assert_parses(p, &quot;abcd&quot;,			Empty, 3).x
	refute_parses(p, chr(13)).x
	refute_parses(p, chr( 9)).x
	assert_parses(p, chr(13) &amp; chr(13),	Empty, 3).x
	assert_parses(p, chr( 9) &amp; chr( 9),	Empty, 3).x

	&apos; skip (return x) = return Empty
	Set p = pSkip(pReturn(&quot;foo&quot;))
	assert_parses(p, &quot;&quot;,		Empty, 1).x
	assert_parses(p, &quot; &quot;,		Empty, 1).x
	assert_parses(p, &quot;a&quot;,		Empty, 1).x
	assert_parses(p, &quot;1&quot;,		Empty, 1).x
	assert_parses(p, &quot;[]&quot;,		Empty, 1).x
	assert_parses(p, &quot;abcd&quot;,	Empty, 1).x
	assert_parses(p, chr(13),   Empty, 1).x
	assert_parses(p, chr( 9),	Empty, 1).x

	&apos; skip (skip x) = skip x
	Set p = pSkip(pSkip(pItem))
&apos;	msgbox(toString(p))
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;,		Empty, 2).x
	assert_parses(p, &quot;a&quot;,		Empty, 2).x
	assert_parses(p, &quot;1&quot;,		Empty, 2).x
	assert_parses(p, &quot;[]&quot;,		Empty, 2).x
	assert_parses(p, &quot;abcd&quot;,	Empty, 2).x
	assert_parses(p, chr(13),   Empty, 2).x
	assert_parses(p, chr( 9),	Empty, 2).x

	Set p = pSkip(pStr(&quot;foo&quot;))
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;1&quot;).x
	refute_parses(p, &quot;[]&quot;).x
	refute_parses(p, &quot;abcd&quot;).x
	refute_parses(p, chr(13)).x
	refute_parses(p, chr( 9)).x
	
	assert_parses(p, &quot;foo&quot;,				Empty, 4).x
	assert_parses(p, &quot;foo &quot;,			Empty, 4).x
	assert_parses(p, &quot;fooa&quot;,			Empty, 4).x
	assert_parses(p, &quot;foo1&quot;,			Empty, 4).x
	assert_parses(p, &quot;foo[]&quot;,			Empty, 4).x
	assert_parses(p, &quot;fooabcd&quot;,			Empty, 4).x
	assert_parses(p, &quot;foo&quot; &amp; chr(13),   Empty, 4).x
	assert_parses(p, &quot;foo&quot; &amp; chr( 9),	Empty, 4).x
	
	Set p = pSkip(pSeq(Array(pStr(&quot;f&quot;), pStr(&quot;oo&quot;)), concat)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;1&quot;).x
	refute_parses(p, &quot;[]&quot;).x
	refute_parses(p, &quot;abcd&quot;).x
	refute_parses(p, chr(13)).x
	refute_parses(p, chr( 9)).x
	
	assert_parses(p, &quot;foo&quot;,				Empty, 4).x
	assert_parses(p, &quot;foo &quot;,			Empty, 4).x
	assert_parses(p, &quot;fooa&quot;,			Empty, 4).x
	assert_parses(p, &quot;foo1&quot;,			Empty, 4).x
	assert_parses(p, &quot;foo[]&quot;,			Empty, 4).x
	assert_parses(p, &quot;fooabcd&quot;,			Empty, 4).x
	assert_parses(p, &quot;foo&quot; &amp; chr(13),   Empty, 4).x
	assert_parses(p, &quot;foo&quot; &amp; chr( 9),	Empty, 4).x
	
	Set p = pSkip(pMany(pItem))
&apos;	msgbox(toString(p))
	assert_parses(p, &quot;&quot;,		Empty, 1).x
	assert_parses(p, &quot; &quot;,		Empty, 2).x
	assert_parses(p, &quot;a&quot;,		Empty, 2).x
	assert_parses(p, &quot;1&quot;,		Empty, 2).x
	assert_parses(p, &quot;[]&quot;,		Empty, 3).x
	assert_parses(p, &quot;abcd&quot;,	Empty, 5).x
	assert_parses(p, chr(13),   Empty, 2).x
	assert_parses(p, chr( 9),	Empty, 2).x	
	
	Set p = pSkip(pMany1(pItem))
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;,		Empty, 2).x
	assert_parses(p, &quot;a&quot;,		Empty, 2).x
	assert_parses(p, &quot;1&quot;,		Empty, 2).x
	assert_parses(p, &quot;[]&quot;,		Empty, 3).x
	assert_parses(p, &quot;abcd&quot;,	Empty, 5).x
	assert_parses(p, chr(13),   Empty, 2).x
	assert_parses(p, chr( 9),	Empty, 2).x	

	Set p = pSkip(pMany(pWhite))
	assert_parses(p, &quot;&quot;,		Empty, 1).x
	assert_parses(p, &quot; &quot;,		Empty, 2).x
	assert_parses(p, &quot;  &quot;,		Empty, 3).x
	assert_parses(p, &quot;a&quot;,		Empty, 1).x
	assert_parses(p, &quot;1&quot;,		Empty, 1).x
	assert_parses(p, &quot; a&quot;,		Empty, 2).x
	assert_parses(p, &quot;  1&quot;,		Empty, 3).x
	assert_parses(p, &quot;[]&quot;,		Empty, 1).x
	assert_parses(p, &quot;abcd&quot;,	Empty, 1).x
	assert_parses(p, &quot;   d&quot;,	Empty, 4).x
	assert_parses(p, chr(13),   Empty, 1).x
	assert_parses(p, chr( 9),	Empty, 2).x	
	
	Set p = pBind(pSkip(pMany(pWhite)), fstArg(pStr(&quot;xx&quot;))
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;x&quot;).x
	assert_parses(p, &quot;xx&quot;,		&quot;xx&quot;,  3).x
	assert_parses(p, &quot;xxx&quot;,		&quot;xx&quot;,  3).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot; x&quot;).x
	assert_parses(p, &quot; xx&quot;,		&quot;xx&quot;,  4).x
	assert_parses(p, &quot; xxx&quot;,	&quot;xx&quot;,  4).x
	refute_parses(p, &quot;  &quot;).x
	refute_parses(p, &quot;  x&quot;).x
	assert_parses(p, &quot;  xx&quot;,	&quot;xx&quot;,  5).x
	assert_parses(p, &quot;  xxx&quot;,	&quot;xx&quot;,  5).x
	refute_parses(p, chr(9) &amp; &quot;  &quot;).x
	refute_parses(p, chr(9) &amp; &quot;  x&quot;).x
	assert_parses(p, chr(9) &amp; &quot;  xx&quot;,	&quot;xx&quot;,  6).x
	assert_parses(p, chr(9) &amp; &quot;  xxx&quot;,	&quot;xx&quot;,  6).x
	
	Dim mkList1 As Object, mkList2 As Object, expected As Object
	Set mkList1 = swap(cons, nil) &apos; \y.cons y nil
	Set mkList2 = swap(compose(swap(cons), mkList1)) &apos; \x y.cons x (cons y nil))
	Set expected = apply(mkList2, &quot;foo&quot;, &quot;bar&quot;)
	assertEqual(toString(expected), &quot;[&apos;foo&apos;, &apos;bar&apos;]&quot;).x
	Set p = pSeq(Array(pSkip(pMany(pWhite)), _
					   pStr(&quot;foo&quot;), _
					   pSkip(pMany(pWhite)), _
					   pStr(&quot;bar&quot;), _
					   pSkip(pMany(pWhite)) _
				 ), mkList2 _
	)
	assert_parses(p, &quot;foobar&quot;, 		expected,  7).x
	assert_parses(p, &quot;   foobar&quot;, 	expected, 10).x
	assert_parses(p, &quot;foobar   &quot;, 	expected, 10).x
	assert_parses(p, &quot;foo   bar&quot;, 	expected, 10).x
	assert_parses(p, &quot; foo  bar&quot;, 	expected, 10).x
	assert_parses(p, &quot;foo  bar &quot;, 	expected, 10).x
	assert_parses(p, &quot; foo bar &quot;, 	expected, 10).x
End Function

Function test_Parser_zeroOrOne()
	Dim p As Parser
	Dim data As Variant
	Dim zeroMatches As Variant, oneMatch As Variant
	zeroMatches = Empty
	oneMatch    = &quot;x&quot;
		
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)

	p = pZeroOrOne(pStr(&quot;x&quot;))

	assert_parses(p, data,	zeroMatches, 1).x
	assert_parses(p, &quot;x&quot;, 	oneMatch, 2).x
	assert_parses(p, &quot;xx&quot;, 	oneMatch, 2).x
	assert_parses(p, &quot;xxx&quot;, oneMatch, 2).x
	assert_parses(p, &quot; x&quot;, 	zeroMatches, 1).x
	assert_parses(p, &quot; xx&quot;, zeroMatches, 1).x
	assert_parses(p, &quot; xxx&quot;,zeroMatches, 1).x
	
	&apos; double p?? is the same as p?:
	p = pZeroOrOne(pZeroOrOne(pStr(&quot;x&quot;)))
	assert_parses(p, data,	zeroMatches, 1).x
	assert_parses(p, &quot;x&quot;, 	oneMatch, 2).x
	assert_parses(p, &quot;xx&quot;, 	oneMatch, 2).x
	assert_parses(p, &quot;xxx&quot;, oneMatch, 2).x
	assert_parses(p, &quot; x&quot;, 	zeroMatches, 1).x
	assert_parses(p, &quot; xx&quot;, zeroMatches, 1).x
	assert_parses(p, &quot; xxx&quot;,zeroMatches, 1).x
End Function

Function test_Parser_skip_zeroOrOne()
	Dim p As Parser
	Dim data As Variant
			
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)

	p = pSkip(pZeroOrOne(pStr(&quot;x&quot;)))
	assert_parses(p, data,	Empty, 1).x
	assert_parses(p, &quot;x&quot;, 	Empty, 2).x
	assert_parses(p, &quot;xx&quot;, 	Empty, 2).x
	assert_parses(p, &quot;xxx&quot;, Empty, 2).x
	assert_parses(p, &quot; x&quot;, 	Empty, 1).x
	assert_parses(p, &quot; xx&quot;, Empty, 1).x
	assert_parses(p, &quot; xxx&quot;,Empty, 1).x
	
	&apos;TODO: is that what we want?: pZeroOrOne (pSkip p) = pSkip (pZeroOrOne p)  ...?
	p = pZeroOrOne(pSkip(pStr(&quot;x&quot;)))
	assert_parses(p, data,	Empty, 1).x
	assert_parses(p, &quot;x&quot;, 	Empty, 2).x
	assert_parses(p, &quot;xx&quot;, 	Empty, 2).x
	assert_parses(p, &quot;xxx&quot;, Empty, 2).x
	assert_parses(p, &quot; x&quot;, 	Empty, 1).x
	assert_parses(p, &quot; xx&quot;, Empty, 1).x
	assert_parses(p, &quot; xxx&quot;,Empty, 1).x
End Function

Function test_Parser_white()
	Dim p As Parser
	p = pWhite

	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;, 						&quot; &quot;, 2	).x
	assert_parses(p, chr(9), 					&quot;\t&quot;, 2	).x
	refute_parses(p, chr(13)).x
	refute_parses(p, &quot;asdf&quot;).x
	assert_parses(p, &quot; asdf&quot;, 					&quot; &quot;, 2).x
	assert_parses(p, chr(9) &amp; &quot;asdf&quot;, 			&quot;\t&quot;, 2).x
	refute_parses(p, chr(13) &amp; &quot;asdf&quot;).x
	assert_parses(p, &quot;  asdf&quot;, 					&quot; &quot;, 2).x
	assert_parses(p, chr(9) &amp; chr(9) &amp; &quot;asdf&quot;, 	&quot;\t&quot;, 2).x
	refute_parses(p, chr(13) &amp; chr(9) &amp; &quot;asdf&quot;).x
	assert_parses(p, chr(9) &amp; chr(13) &amp; &quot;asdf&quot;, 	&quot;\t&quot;, 2).x
	refute_parses(p, chr(13) &amp; chr(13) &amp; &quot;asdf&quot;).x
End Function

Function test_Parser_alphaLower()
	Dim p As Parser
	p = pAlphaLower

	refute_parses(p, Array(&quot; &quot;, chr(9), chr(13), &quot;_&quot;, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, _
		&quot;+&quot;, &quot;-&quot;, &quot;-&gt;&quot;, &quot;*&quot;, &quot;?&quot;, &quot;#&quot;,_
		&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, _
		&quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, _
		&quot;&quot;)).x
	assert_parses(p, &quot;asdf&quot;, &quot;a&quot;, 2).x
	assert_parses(p, &quot;a&quot;, &quot;a&quot;, 2).x
	assert_parses(p, &quot;b&quot;, &quot;b&quot;, 2).x
	assert_parses(p, &quot;c&quot;, &quot;c&quot;, 2).x
	assert_parses(p, &quot;d&quot;, &quot;d&quot;, 2).x
	assert_parses(p, &quot;e&quot;, &quot;e&quot;, 2).x
	assert_parses(p, &quot;f&quot;, &quot;f&quot;, 2).x
	assert_parses(p, &quot;g&quot;, &quot;g&quot;, 2).x
	assert_parses(p, &quot;h&quot;, &quot;h&quot;, 2).x
	assert_parses(p, &quot;i&quot;, &quot;i&quot;, 2).x
	assert_parses(p, &quot;j&quot;, &quot;j&quot;, 2).x
	assert_parses(p, &quot;k&quot;, &quot;k&quot;, 2).x
	assert_parses(p, &quot;l&quot;, &quot;l&quot;, 2).x
	assert_parses(p, &quot;m&quot;, &quot;m&quot;, 2).x
	assert_parses(p, &quot;n&quot;, &quot;n&quot;, 2).x
	assert_parses(p, &quot;o&quot;, &quot;o&quot;, 2).x
	assert_parses(p, &quot;p&quot;, &quot;p&quot;, 2).x
	assert_parses(p, &quot;q&quot;, &quot;q&quot;, 2).x
	assert_parses(p, &quot;r&quot;, &quot;r&quot;, 2).x
	assert_parses(p, &quot;s&quot;, &quot;s&quot;, 2).x
	assert_parses(p, &quot;t&quot;, &quot;t&quot;, 2).x
	assert_parses(p, &quot;u&quot;, &quot;u&quot;, 2).x
	assert_parses(p, &quot;v&quot;, &quot;v&quot;, 2).x
	assert_parses(p, &quot;w&quot;, &quot;w&quot;, 2).x
	assert_parses(p, &quot;x&quot;, &quot;x&quot;, 2).x
	assert_parses(p, &quot;y&quot;, &quot;y&quot;, 2).x
	assert_parses(p, &quot;z&quot;, &quot;z&quot;, 2).x
End Function

Function test_Parser_alphaUpper()
	Dim p As Parser
	p = pAlphaUpper

	refute_parses(p, Array(&quot; &quot;, chr(9), chr(13), &quot;_&quot;, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, _
		&quot;+&quot;, &quot;-&quot;, &quot;-&gt;&quot;, &quot;*&quot;, &quot;?&quot;, &quot;#&quot;,_
		&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, _
		&quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, _
		&quot;&quot;)).x
	assert_parses(p, &quot;ASDF&quot;, &quot;A&quot;, 2).x
	assert_parses(p, &quot;A&quot;, &quot;A&quot;, 2).x
	assert_parses(p, &quot;B&quot;, &quot;B&quot;, 2).x
	assert_parses(p, &quot;C&quot;, &quot;C&quot;, 2).x
	assert_parses(p, &quot;D&quot;, &quot;D&quot;, 2).x
	assert_parses(p, &quot;E&quot;, &quot;E&quot;, 2).x
	assert_parses(p, &quot;F&quot;, &quot;F&quot;, 2).x
	assert_parses(p, &quot;G&quot;, &quot;G&quot;, 2).x
	assert_parses(p, &quot;H&quot;, &quot;H&quot;, 2).x
	assert_parses(p, &quot;I&quot;, &quot;I&quot;, 2).x
	assert_parses(p, &quot;J&quot;, &quot;J&quot;, 2).x
	assert_parses(p, &quot;K&quot;, &quot;K&quot;, 2).x
	assert_parses(p, &quot;L&quot;, &quot;L&quot;, 2).x
	assert_parses(p, &quot;M&quot;, &quot;M&quot;, 2).x
	assert_parses(p, &quot;N&quot;, &quot;N&quot;, 2).x
	assert_parses(p, &quot;O&quot;, &quot;O&quot;, 2).x
	assert_parses(p, &quot;P&quot;, &quot;P&quot;, 2).x
	assert_parses(p, &quot;Q&quot;, &quot;Q&quot;, 2).x
	assert_parses(p, &quot;R&quot;, &quot;R&quot;, 2).x
	assert_parses(p, &quot;S&quot;, &quot;S&quot;, 2).x
	assert_parses(p, &quot;T&quot;, &quot;T&quot;, 2).x
	assert_parses(p, &quot;U&quot;, &quot;U&quot;, 2).x
	assert_parses(p, &quot;V&quot;, &quot;V&quot;, 2).x
	assert_parses(p, &quot;W&quot;, &quot;W&quot;, 2).x
	assert_parses(p, &quot;X&quot;, &quot;X&quot;, 2).x
	assert_parses(p, &quot;Y&quot;, &quot;Y&quot;, 2).x
	assert_parses(p, &quot;Z&quot;, &quot;Z&quot;, 2).x
End Function

Function test_Parser_baseType()
	Dim p As Parser
	p = pBaseType

	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;asdf&quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;b&quot;).x
	refute_parses(p, &quot;c&quot;).x
	
	assert_parses(p, &quot;Bool -&gt; Bool&quot;, &quot;Bool&quot;, 5).x
	assert_parses(p, &quot;Bool&quot;, &quot;Bool&quot;, 5).x
	refute_parses(p, &quot;bool&quot;).x

	assert_parses(p, &quot;Str&quot;, &quot;Str&quot;, 4).x
	refute_parses(p, &quot;str&quot;).x

	assert_parses(p, &quot;Int&quot;, &quot;Int&quot;, 4).x
	refute_parses(p, &quot;int&quot;).x

	assert_parses(p, &quot;Long&quot;, &quot;Long&quot;, 5).x
	refute_parses(p, &quot;long&quot;).x
End Function

Function test_Parser_TypeVar()
	Dim p As Parser
	p = pTypeVar

	refute_parses(p, Array(&quot; &quot;, chr(9), chr(13), &quot;_&quot;, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, _
		&quot;+&quot;, &quot;-&quot;, &quot;-&gt;&quot;, &quot;*&quot;, &quot;?&quot;, &quot;#&quot;,_
		&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, _
		&quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, _
		&quot;&quot;)).x
	assert_parses(p, &quot;asdf&quot;, &quot;&apos;a&quot;, 2).x
	assert_parses(p, &quot;a&quot;, &quot;&apos;a&quot;, 2).x
	assert_parses(p, &quot;b&quot;, &quot;&apos;b&quot;, 2).x
	assert_parses(p, &quot;c&quot;, &quot;&apos;c&quot;, 2).x
	assert_parses(p, &quot;d&quot;, &quot;&apos;d&quot;, 2).x
	assert_parses(p, &quot;e&quot;, &quot;&apos;e&quot;, 2).x
	assert_parses(p, &quot;f&quot;, &quot;&apos;f&quot;, 2).x
	assert_parses(p, &quot;g&quot;, &quot;&apos;g&quot;, 2).x
	assert_parses(p, &quot;h&quot;, &quot;&apos;h&quot;, 2).x
	assert_parses(p, &quot;i&quot;, &quot;&apos;i&quot;, 2).x
	assert_parses(p, &quot;j&quot;, &quot;&apos;j&quot;, 2).x
	assert_parses(p, &quot;k&quot;, &quot;&apos;k&quot;, 2).x
	assert_parses(p, &quot;l&quot;, &quot;&apos;l&quot;, 2).x
	assert_parses(p, &quot;m&quot;, &quot;&apos;m&quot;, 2).x
	assert_parses(p, &quot;n&quot;, &quot;&apos;n&quot;, 2).x
	assert_parses(p, &quot;o&quot;, &quot;&apos;o&quot;, 2).x
	assert_parses(p, &quot;p&quot;, &quot;&apos;p&quot;, 2).x
	assert_parses(p, &quot;q&quot;, &quot;&apos;q&quot;, 2).x
	assert_parses(p, &quot;r&quot;, &quot;&apos;r&quot;, 2).x
	assert_parses(p, &quot;s&quot;, &quot;&apos;s&quot;, 2).x
	assert_parses(p, &quot;t&quot;, &quot;&apos;t&quot;, 2).x
	assert_parses(p, &quot;u&quot;, &quot;&apos;u&quot;, 2).x
	assert_parses(p, &quot;v&quot;, &quot;&apos;v&quot;, 2).x
	assert_parses(p, &quot;w&quot;, &quot;&apos;w&quot;, 2).x
	assert_parses(p, &quot;x&quot;, &quot;&apos;x&quot;, 2).x
	assert_parses(p, &quot;y&quot;, &quot;&apos;y&quot;, 2).x
	assert_parses(p, &quot;z&quot;, &quot;&apos;z&quot;, 2).x
End Function

Function test_Parser_TypeCtor()
	Dim p As Parser
	p = pTypeCtor

	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;asdf&quot;).x
	refute_parses(p, &quot;a&quot;).x
	refute_parses(p, &quot;b&quot;).x
	refute_parses(p, &quot;c&quot;).x
	
	assert_parses(p, &quot;List&quot;, &quot;List&quot;, 5).x
	assert_parses(p, &quot;Maybe&quot;, &quot;Maybe&quot;, 6).x

	&apos; any capitalized String with more than 2 chars does
	assert_parses(p, &quot;Bool&quot;, &quot;Bool&quot;, 5).x &apos; 
	refute_parses(p, &quot;bool&quot;).x

	assert_parses(p, &quot;Str&quot;, &quot;Str&quot;, 4).x
	refute_parses(p, &quot;str&quot;).x

	assert_parses(p, &quot;Int&quot;, &quot;Int&quot;, 4).x
	refute_parses(p, &quot;int&quot;).x

	assert_parses(p, &quot;Long&quot;, &quot;Long&quot;, 5).x
	refute_parses(p, &quot;long&quot;).x

	assert_parses(p, &quot;Avalidtypector&quot;, &quot;Avalidtypector&quot;, 15).x
&apos;	refute_parses(p, &quot;NotAValidTypeCtor&quot;).x
End Function

Function test_Parser_TypeExpr()
	Dim p As Parser
	p = pTypeExpr
	
	assert_parses(p, &quot;Bool&quot;, 			&quot;Bool&quot;, 5).x
	assert_parses(p, &quot;Int&quot;,	 			&quot;Int&quot;, 4).x
	assert_parses(p, &quot;Int-&gt;Int&quot;,	 	&quot;(-&gt; Int Int)&quot;, 9).x
	assert_parses(p, &quot;Int-&gt;Str-&gt;Bool&quot;,	&quot;(-&gt; Int (-&gt; Str Bool))&quot;, 15).x
	assert_parses(p, &quot;a-&gt;b-&gt;c&quot;,	 		&quot;(-&gt; &apos;a (-&gt; &apos;b &apos;c))&quot;, 8).x
	assert_parses(p, &quot;(a-&gt;b)-&gt;c&quot;,	 	&quot;(-&gt; (-&gt; &apos;a &apos;b) &apos;c)&quot;, 10).x
	assert_parses(p, &quot;(a-&gt;b)-&gt;(c)&quot;,	 	&quot;(-&gt; (-&gt; &apos;a &apos;b) &apos;c)&quot;, 12).x
	assert_parses(p, &quot;List&quot;,	 		&quot;(List [])&quot;, 5).x
	assert_parses(p, &quot;List a&quot;,	 		&quot;(List [&apos;a])&quot;, 7).x
	assert_parses(p, &quot;List a b&quot;,	 	&quot;(List [&apos;a, &apos;b])&quot;, 9).x
	assert_parses(p, &quot;List Int&quot;,	 	&quot;(List [Int])&quot;, 9).x
	assert_parses(p, &quot;List a-&gt;b&quot;,	 	&quot;(-&gt; (List [&apos;a]) &apos;b)&quot;, 10).x
	assert_parses(p, &quot;List (a-&gt;b)&quot;,	 	&quot;(List [(-&gt; &apos;a &apos;b)])&quot;, 12).x
	assert_parses(p, &quot;List Maybe a&quot;,	&quot;(List [(Maybe [&apos;a])])&quot;, 13).x
	assert_parses(p, &quot;List Maybe a b&quot;,	&quot;(List [(Maybe [&apos;a, &apos;b])])&quot;, 15).x
	assert_parses(p, &quot;List (Maybe a) b&quot;,&quot;(List [(Maybe [&apos;a]), &apos;b])&quot;, 17).x
	
	refute_parses(p, &quot;-&gt;a&quot;).x
	&apos;refute_parses(p, &quot;a-&gt;&quot;).x

	&apos; skips over trailing whitespace:
	assert_parses(p, &quot;Bool   &quot;, 				&quot;Bool&quot;, 8).x
	assert_parses(p, &quot;Int    &quot;,	 				&quot;Int&quot;,  8).x
	assert_parses(p, &quot;Int -&gt; Int            &quot;,	&quot;(-&gt; Int Int)&quot;, 23).x
	assert_parses(p, &quot;Int  -&gt; Str -&gt;   Bool &quot;,	&quot;(-&gt; Int (-&gt; Str Bool))&quot;, 23).x

	&apos; skips over leading whitespace:
	assert_parses(p, &quot; Bool  &quot;, 				&quot;Bool&quot;, 8).x
	assert_parses(p, &quot; Int   &quot;,	 				&quot;Int&quot;,  8).x
	assert_parses(p, &quot; Int -&gt; Int           &quot;,	&quot;(-&gt; Int Int)&quot;, 23).x
	assert_parses(p, &quot; Int  -&gt; Str -&gt;  Bool &quot;,	&quot;(-&gt; Int (-&gt; Str Bool))&quot;, 23).x

	assert_parses(p, getFnTypeStr(Fn.isNil), &quot;(-&gt; (List [&apos;a]) Bool)&quot;, 15).x
	assert_parses(p, getFnTypeStr(Fn.flatten), &quot;(-&gt; (List [(List [&apos;a])]) (List [&apos;a]))&quot;, 22).x

	Dim fns As Object, f As Object, fName As String, typStr As String
	fns = fnObjs
	While Not(isNil(fns))
		f = car(fns)
		typStr = getFnTypeStr(f)
		If typStr &lt;&gt; &quot;&quot; Then
			fName = getFnName(f)
&apos;			assert_parses(p, typStr, fName &amp; &quot; :: asdf&quot;, Len(typStr) + 1).x
		End If
		fns = cdr(fns)
	Wend
End Function

Function test_Parser_binDigit()
	Dim p As Parser
	p = pBinDigit

	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;sadf&quot;).x
	assert_parses(p, &quot;0sadf&quot;,	0, 2).x
	assert_parses(p, &quot;1sadf&quot;,	1, 2).x
	refute_parses(p, &quot;2sadf&quot;).x
	refute_parses(p, &quot;3sadf&quot;).x
	refute_parses(p, &quot;4sadf&quot;).x
	refute_parses(p, &quot;5sadf&quot;).x
	refute_parses(p, &quot;6sadf&quot;).x
	refute_parses(p, &quot;7sadf&quot;).x
	refute_parses(p, &quot;8sadf&quot;).x
	refute_parses(p, &quot;9sadf&quot;).x
	refute_parses(p, &quot;Asadf&quot;).x
	refute_parses(p, &quot;asadf&quot;).x
	refute_parses(p, &quot;Bsadf&quot;).x
	refute_parses(p, &quot;bsadf&quot;).x
	refute_parses(p, &quot;Csadf&quot;).x
	refute_parses(p, &quot;csadf&quot;).x
	refute_parses(p, &quot;Dsadf&quot;).x
	refute_parses(p, &quot;dsadf&quot;).x
	refute_parses(p, &quot;Esadf&quot;).x
	refute_parses(p, &quot;esadf&quot;).x
	refute_parses(p, &quot;Fsadf&quot;).x
	refute_parses(p, &quot;fsadf&quot;).x
	refute_parses(p, &quot;Gsadf&quot;).x
	refute_parses(p, &quot;gsadf&quot;).x
End Function

Function test_Parser_decDigit()
	Dim p As Parser
	p = pDecDigit

	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;sadf&quot;).x
	assert_parses(p, &quot;0sadf&quot;,	0, 2).x
	assert_parses(p, &quot;1sadf&quot;,	1, 2).x
	assert_parses(p, &quot;2sadf&quot;,	2, 2).x
	assert_parses(p, &quot;3sadf&quot;,	3, 2).x
	assert_parses(p, &quot;4sadf&quot;,	4, 2).x
	assert_parses(p, &quot;5sadf&quot;,	5, 2).x
	assert_parses(p, &quot;6sadf&quot;,	6, 2).x
	assert_parses(p, &quot;7sadf&quot;,	7, 2).x
	assert_parses(p, &quot;8sadf&quot;,	8, 2).x
	assert_parses(p, &quot;9sadf&quot;,	9, 2).x
	refute_parses(p, &quot;Asadf&quot;).x
	refute_parses(p, &quot;asadf&quot;).x
	refute_parses(p, &quot;Bsadf&quot;).x
	refute_parses(p, &quot;bsadf&quot;).x
	refute_parses(p, &quot;Csadf&quot;).x
	refute_parses(p, &quot;csadf&quot;).x
	refute_parses(p, &quot;Dsadf&quot;).x
	refute_parses(p, &quot;dsadf&quot;).x
	refute_parses(p, &quot;Esadf&quot;).x
	refute_parses(p, &quot;esadf&quot;).x
	refute_parses(p, &quot;Fsadf&quot;).x
	refute_parses(p, &quot;fsadf&quot;).x
	refute_parses(p, &quot;Gsadf&quot;).x
	refute_parses(p, &quot;gsadf&quot;).x
End Function

Function test_Parser_hexDigit()
	Dim p As Parser
	p = pHexDigit

	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	refute_parses(p, &quot;sadf&quot;).x
	assert_parses(p, &quot;0sadf&quot;,	 0, 2).x
	assert_parses(p, &quot;1sadf&quot;,	 1, 2).x
	assert_parses(p, &quot;2sadf&quot;,	 2, 2).x
	assert_parses(p, &quot;3sadf&quot;,	 3, 2).x
	assert_parses(p, &quot;4sadf&quot;,	 4, 2).x
	assert_parses(p, &quot;5sadf&quot;,	 5, 2).x
	assert_parses(p, &quot;6sadf&quot;,	 6, 2).x
	assert_parses(p, &quot;7sadf&quot;,	 7, 2).x
	assert_parses(p, &quot;8sadf&quot;,	 8, 2).x
	assert_parses(p, &quot;9sadf&quot;,	 9, 2).x
	assert_parses(p, &quot;Asadf&quot;,	10, 2).x
	assert_parses(p, &quot;asadf&quot;,	10, 2).x
	assert_parses(p, &quot;Bsadf&quot;,	11, 2).x
	assert_parses(p, &quot;bsadf&quot;,	11, 2).x
	assert_parses(p, &quot;Csadf&quot;,	12, 2).x
	assert_parses(p, &quot;csadf&quot;,	12, 2).x
	assert_parses(p, &quot;Dsadf&quot;,	13, 2).x
	assert_parses(p, &quot;dsadf&quot;,	13, 2).x
	assert_parses(p, &quot;Esadf&quot;,	14, 2).x
	assert_parses(p, &quot;esadf&quot;,	14, 2).x
	assert_parses(p, &quot;Fsadf&quot;,	15, 2).x
	assert_parses(p, &quot;fsadf&quot;,	15, 2).x
	refute_parses(p, &quot;Gsadf&quot;).x
	refute_parses(p, &quot;gsadf&quot;).x
End Function

Function test_Parser_many()
	Dim p As Parser
	Dim data As Variant
	Dim zeroMatches As Variant
	zeroMatches = nil
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	p = pMany(pFail)
	assert_parses(p, data, zeroMatches, 1).x
	
	&apos;p = pMany(pReturn(3)) - yields infite sequence of 3s, even on empty string
	
	p = pMany(pItem)
	assert_parses(p, &quot;&quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; chr(13),	List(&quot; &quot;, &quot;\n&quot;), 3).x
	assert_parses(p, &quot;asdf&quot;,		List(&quot;a&quot;, &quot;s&quot;, &quot;d&quot;, &quot;f&quot;), 5).x
	
	p = pMany(pStr(&quot; &quot;))
	assert_parses(p, &quot;&quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; chr(13),	List(&quot; &quot;), 2).x
	assert_parses(p, &quot;asdf&quot;,		zeroMatches, 1).x
	assert_parses(p, &quot;  &quot;,			List(&quot; &quot;, &quot; &quot;), 3).x
	assert_parses(p, &quot;   &quot;,			List(&quot; &quot;, &quot; &quot;, &quot; &quot;), 4).x
	assert_parses(p, &quot; x &quot;,			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; x  &quot;,		List(&quot; &quot;), 2).x
	assert_parses(p, &quot;  x &quot;,		List(&quot; &quot;, &quot; &quot;), 3).x
	
	p = pMany(pDecDigit)
	assert_parses(p, &quot;&quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot; &quot;, 			zeroMatches, 1).x
	assert_parses(p, &quot;1&quot;, 			List(1), 2).x
	assert_parses(p, &quot;10 &quot;, 		List(1, 0), 3).x
	assert_parses(p, &quot;102345&quot;, 		List(1, 0, 2, 3, 4, 5), 7).x
End Function

Function test_Parser_many1()
	Dim p As Parser
	Dim data As Variant
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	p = pMany1(pFail)
	refute_parses(p, data).x
	
	&apos;p = pMany1(pReturn(3)) - yields infite sequence of 3s, except on empty string
	
	p = pMany1(pItem)
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; chr(13),	List(&quot; &quot;, &quot;\n&quot;), 3).x
	assert_parses(p, &quot;asdf&quot;,		List(&quot;a&quot;, &quot;s&quot;, &quot;d&quot;, &quot;f&quot;), 5).x
	
	p = pMany1(pStr(&quot; &quot;))
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot; &quot;, 			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; &quot; &amp; chr(13),	List(&quot; &quot;), 2).x
	refute_parses(p, &quot;asdf&quot;).x
	assert_parses(p, &quot;  &quot;,			List(&quot; &quot;, &quot; &quot;), 3).x
	assert_parses(p, &quot;   &quot;,			List(&quot; &quot;, &quot; &quot;, &quot; &quot;), 4).x
	assert_parses(p, &quot; x &quot;,			List(&quot; &quot;), 2).x
	assert_parses(p, &quot; x  &quot;,		List(&quot; &quot;), 2).x
	assert_parses(p, &quot;  x &quot;,		List(&quot; &quot;, &quot; &quot;), 3).x
	
	p = pMany1(pDecDigit)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot; &quot;).x
	assert_parses(p, &quot;1&quot;, 			List(1), 2).x
	assert_parses(p, &quot;10 &quot;, 		List(1, 0), 3).x
	assert_parses(p, &quot;102345&quot;, 		List(1, 0, 2, 3, 4, 5), 7).x
End Function

Function test_Parser_seq()
	Dim p As Parser, f As Variant
	Dim data As Variant
	
	data = Array(&quot;&quot;, &quot; &quot;, &quot; &quot; &amp; chr(13), &quot;asdf&quot;, &quot; bar&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bar&quot;, &quot;barb&quot;,_
		&quot;barba&quot;, &quot;barbar&quot;, chr(13), chr(13) &amp; &quot;bar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	f = Fn.asc
	p = pSeq(Array(pFail), f)
	refute_parses(p, data).x
	
	f = Fn.asc
	p = pSeq(Array(pItem), f)
	refute_parses(p, &quot;&quot;).x
	assert_parses(p, &quot;0&quot;, 	asc(&quot;0&quot;), 2).x
	assert_parses(p, &quot;1&quot;, 	asc(&quot;1&quot;), 2).x
	assert_parses(p, &quot;A&quot;, 	asc(&quot;A&quot;), 2).x
	assert_parses(p, &quot;B&quot;, 	asc(&quot;B&quot;), 2).x
	assert_parses(p, &quot;AB&quot;,	asc(&quot;A&quot;), 2).x
	assert_parses(p, &quot;BA&quot;,	asc(&quot;B&quot;), 2).x
	
	f = &quot;concat&quot;
	p = pSeq(Array(pItem, pItem), f)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;A&quot;).x
	refute_parses(p, &quot;B&quot;).x
	assert_parses(p, &quot;AB&quot;,	&quot;AB&quot;, 3).x
	assert_parses(p, &quot;BA&quot;,	&quot;BA&quot;, 3).x
	
	p = pSeq(Array(pDecDigit, pDecDigit), f)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;A&quot;).x
	refute_parses(p, &quot;B&quot;).x
	refute_parses(p, &quot;AB&quot;).x
	refute_parses(p, &quot;BA&quot;).x
	refute_parses(p, &quot;0B&quot;).x		&apos; *ALL* in sequence must succeed!
	refute_parses(p, &quot;1A&quot;).x		&apos; *ALL* in sequence must succeed!
	assert_parses(p, &quot;01&quot;,	&quot;01&quot;, 3).x
	assert_parses(p, &quot;10&quot;,	&quot;10&quot;, 3).x
	
	f = Fn.asc
	p = pSeq(Array(pDecDigit), f)
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;A&quot;).x
	refute_parses(p, &quot;B&quot;).x
	refute_parses(p, &quot;AB&quot;).x
	refute_parses(p, &quot;BA&quot;).x
	assert_parses(p, &quot;0&quot;, 			48, 2).x
	assert_parses(p, &quot;1&quot;, 			49, 2).x
	assert_parses(p, &quot;123456789&quot;,	49, 2).x
	
	p = pMany1(pSeq(Array(pDecDigit), f))
	refute_parses(p, &quot;&quot;).x
	refute_parses(p, &quot;A&quot;).x
	refute_parses(p, &quot;B&quot;).x
	refute_parses(p, &quot;AB&quot;).x
	refute_parses(p, &quot;BA&quot;).x
	assert_parses(p, &quot;0&quot;, 			List(48), 2).x
	assert_parses(p, &quot;1&quot;, 			List(49), 2).x
	assert_parses(p, &quot;123456789&quot;,	List(49, 50, 51, 52, 53, 54, 55, 56, 57), 10).x
	assert_parses(p, &quot;123456789 0&quot;,	List(49, 50, 51, 52, 53, 54, 55, 56, 57), 10).x
End Function

Function assert_toStr(p As Object, expected As String)
	Dim testResult As Variant
	testResult = assertEqual(TParser_toString(p), expected)
	If testResult.isFail Then
		assert_toStr = testResult
		Exit Function
	End If
	&apos; try polymorphic dispatch:
	testResult = assertEqual(toString(p), expected)
	assert_toStr = testResult
End Function

Function test_Parser_toString()
	Dim f As Object
	f = TParser_toString
	assertEqual(isFn(f), True).x
	assertEqual(arity(f),   1).x
	
	assert_toStr(pFail, 							&quot;fail&quot;).x
	assert_toStr(pReturn(7), 						&quot;(return 7)&quot;).x
	assert_toStr(pReturn(&quot;seven&quot;),					&quot;(return &apos;seven&apos;)&quot;).x
	assert_toStr(pStr(&quot;a&quot;),							&quot;(str &apos;a&apos;)&quot;).x
	assert_toStr(pChoice(pStr(&quot;a&quot;), pStr(&quot;b&quot;)),		&quot;((str &apos;a&apos;) +++ (str &apos;b&apos;))&quot;).x
	assert_toStr(pChoice(pStr(&quot;b&quot;), pStr(&quot;a&quot;)),		&quot;((str &apos;b&apos;) +++ (str &apos;a&apos;))&quot;).x
	assert_toStr(pZeroOrOne(pStr(&quot;a&quot;)),				&quot;(str &apos;a&apos;)?&quot;).x
	&apos; double p?? is the same as p?:
	assert_toStr(pZeroOrOne(pZeroOrOne(pStr(&quot;a&quot;))),	&quot;(str &apos;a&apos;)?&quot;).x
End Function

Function test_Parser_hexNum()
	Dim p As Parser
	Dim data As Variant
	p = pHexNum

	refute_parses(p, &quot;&quot;).x
		
	data = Array(&quot; &quot;, &quot; &quot; &amp; chr(13), &quot;qasdf&quot;, &quot; bar&quot;, &quot;qb&quot;, &quot;qba&quot;, &quot;qbar&quot;, &quot;qbarb&quot;,_
		&quot;qbarba&quot;, &quot;qbarbar&quot;, chr(13), chr(13) &amp; &quot;qbar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;_
	)
	refute_parses(p, data).x

	assert_parses(p, &quot;0&quot;,	 0, 2).x
	assert_parses(p, &quot;1&quot;,	 1, 2).x
	assert_parses(p, &quot;2&quot;,	 2, 2).x
	assert_parses(p, &quot;3&quot;,	 3, 2).x
	assert_parses(p, &quot;4&quot;,	 4, 2).x
	assert_parses(p, &quot;5&quot;,	 5, 2).x
	assert_parses(p, &quot;6&quot;,	 6, 2).x
	assert_parses(p, &quot;7&quot;,	 7, 2).x
	assert_parses(p, &quot;8&quot;,	 8, 2).x
	assert_parses(p, &quot;9&quot;,	 9, 2).x

	assert_parses(p, &quot;a&quot;,	10, 2).x
	assert_parses(p, &quot;b&quot;, 	11, 2).x
	assert_parses(p, &quot;c&quot;, 	12, 2).x
	assert_parses(p, &quot;d&quot;, 	13, 2).x
	assert_parses(p, &quot;e&quot;, 	14, 2).x
	assert_parses(p, &quot;f&quot;, 	15, 2).x
	assert_parses(p, &quot;A&quot;, 	10, 2).x
	assert_parses(p, &quot;B&quot;, 	11, 2).x
	assert_parses(p, &quot;C&quot;, 	12, 2).x
	assert_parses(p, &quot;D&quot;, 	13, 2).x
	assert_parses(p, &quot;E&quot;, 	14, 2).x
	assert_parses(p, &quot;F&quot;, 	15, 2).x

	assert_parses(p, &quot;FF&quot;, 		readHex(&quot;FF&quot;), 	3).x
	assert_parses(p, &quot;123&quot;, 	readHex(&quot;123&quot;), 4).x

	assert_parses(p, &quot;0FF&quot;, 	readHex(&quot;FF&quot;), 	4).x	&apos; leading 0s don&apos;t matter
	assert_parses(p, &quot;0123&quot;, 	readHex(&quot;123&quot;), 5).x	&apos; leading 0s don&apos;t matter

	assert_parses(p, &quot;00FF&quot;, 	readHex(&quot;FF&quot;), 	5).x	&apos; leading 0s don&apos;t matter
	assert_parses(p, &quot;00123&quot;, 	readHex(&quot;123&quot;), 6).x	&apos; leading 0s don&apos;t matter

	&apos; 31 bit
	assert_parses(p, &quot;CAFEBAB&quot;, readHex(&quot;CAFEBAB&quot;), 	8).x
	assert_parses(p, &quot;DEADBEE&quot;, readHex(&quot;DEADBEE&quot;), 	8).x
	assert_parses(p, &quot;CAFEBAB&quot;, readHex(&quot;cafebab&quot;), 	8).x	&apos; case doesn&apos;t matter
	assert_parses(p, &quot;dEaDbEe&quot;, readHex(&quot;DeAdBeE&quot;), 	8).x	&apos; case doesn&apos;t matter

&apos;	&apos; 32 bit
&apos;	assert_parses(p, &quot;CAFEBABE&quot;, readHex(&quot;CAFEBABE&quot;), 	9).x
&apos;	assert_parses(p, &quot;DEADBEEF&quot;, readHex(&quot;DEADBEEF&quot;), 	9).x
&apos;	assert_parses(p, &quot;CAFEBABE&quot;, readHex(&quot;cafebabe&quot;), 	9).x	&apos; case doesn&apos;t matter
&apos;	assert_parses(p, &quot;dEaDbEeF&quot;, readHex(&quot;DeAdBeEf&quot;), 	9).x	&apos; case doesn&apos;t matter
End Function

Function test_Parser_hexLit()
	Dim p As Parser
	Dim data As Variant
	p = pHexLit

	refute_parses(p, &quot;&quot;).x
		
	data = Array(&quot; &quot;, &quot; &quot; &amp; chr(13), &quot;qasdf&quot;, &quot; bar&quot;, &quot;qb&quot;, &quot;qba&quot;, &quot;qbar&quot;, &quot;qbarb&quot;,_
		&quot;qbarba&quot;, &quot;qbarbar&quot;, chr(13), chr(13) &amp; &quot;qbar&quot;, chr(13) &amp; chr(13),_
		chr(13) &amp; chr(13) &amp; &quot;bar&quot;,_
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;,_
		&quot;a&quot;, &quot;A&quot;, &quot;b&quot;, &quot;B&quot;, &quot;c&quot;, &quot;C&quot;, &quot;d&quot;, &quot;D&quot;, &quot;e&quot;, &quot;E&quot;, &quot;f&quot;, &quot;F&quot;,_
		&quot;0x&quot;_
	)
	refute_parses(p, data).x

	assert_parses(p, &quot;0x0&quot;, 	 0, 4).x
	assert_parses(p, &quot;0x1&quot;, 	 1, 4).x
	assert_parses(p, &quot;0x2&quot;, 	 2, 4).x
	assert_parses(p, &quot;0x3&quot;, 	 3, 4).x
	assert_parses(p, &quot;0x4&quot;, 	 4, 4).x
	assert_parses(p, &quot;0x5&quot;, 	 5, 4).x
	assert_parses(p, &quot;0x6&quot;, 	 6, 4).x
	assert_parses(p, &quot;0x7&quot;, 	 7, 4).x
	assert_parses(p, &quot;0x8&quot;, 	 8, 4).x
	assert_parses(p, &quot;0x9&quot;,		 9, 4).x

	assert_parses(p, &quot;0xa&quot;,		10, 4).x
	assert_parses(p, &quot;0xb&quot;,		11, 4).x
	assert_parses(p, &quot;0xc&quot;, 	12, 4).x
	assert_parses(p, &quot;0xd&quot;, 	13, 4).x
	assert_parses(p, &quot;0xe&quot;, 	14, 4).x
	assert_parses(p, &quot;0xf&quot;, 	15, 4).x
	assert_parses(p, &quot;0xA&quot;, 	10, 4).x
	assert_parses(p, &quot;0xB&quot;, 	11, 4).x
	assert_parses(p, &quot;0xC&quot;, 	12, 4).x
	assert_parses(p, &quot;0xD&quot;, 	13, 4).x
	assert_parses(p, &quot;0xE&quot;, 	14, 4).x
	assert_parses(p, &quot;0xF&quot;, 	15, 4).x

	assert_parses(p, &quot;0xFF&quot;, 	readHex(&quot;FF&quot;), 	5).x
	assert_parses(p, &quot;0x123&quot;, 	readHex(&quot;123&quot;), 6).x

	assert_parses(p, &quot;0x0FF&quot;, 	readHex(&quot;FF&quot;), 	6).x	&apos; leading 0s don&apos;t matter
	assert_parses(p, &quot;0x0123&quot;, 	readHex(&quot;123&quot;), 7).x	&apos; leading 0s don&apos;t matter

	assert_parses(p, &quot;0x00FF&quot;, 	readHex(&quot;FF&quot;), 	7).x	&apos; leading 0s don&apos;t matter
	assert_parses(p, &quot;0x00123&quot;, readHex(&quot;123&quot;), 8).x	&apos; leading 0s don&apos;t matter

	&apos; 31 bit
	assert_parses(p, &quot;0xCAFEBAB&quot;, readHex(&quot;CAFEBAB&quot;), 	10).x
	assert_parses(p, &quot;0xDEADBEE&quot;, readHex(&quot;DEADBEE&quot;), 	10).x
	assert_parses(p, &quot;0xCAFEBAB&quot;, readHex(&quot;cafebab&quot;), 	10).x	&apos; case doesn&apos;t matter
	assert_parses(p, &quot;0xdEaDbEe&quot;, readHex(&quot;DeAdBeE&quot;), 	10).x	&apos; case doesn&apos;t matter

&apos;	&apos; 32 bit
&apos;	assert_parses(p, &quot;0xCAFEBABE&quot;, readHex(&quot;CAFEBABE&quot;), 	11).x
&apos;	assert_parses(p, &quot;0xDEADBEEF&quot;, readHex(&quot;DEADBEEF&quot;), 	11).x
&apos;	assert_parses(p, &quot;0xCAFEBABE&quot;, readHex(&quot;cafebabe&quot;), 	11).x	&apos; case doesn&apos;t matter
&apos;	assert_parses(p, &quot;0xdEaDbEeF&quot;, readHex(&quot;DeAdBeEf&quot;), 	11).x	&apos; case doesn&apos;t matter
End Function

</script:module>