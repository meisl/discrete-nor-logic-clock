<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M12_Type" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit
		
Type DataValue
	id		As Long
	str		As String	&apos; debugger shows that in inspector
	ctor	As Object
	fields	As Variant Array
	x		As Variant
End Type

Type Tp
	TDataTypeCtor	As Object
	DataTypeCtor	As Object
	
	TDataCtor		As Object
	DataCtor		As Object
	
	List			As Object
	List_Nil		As Object
	List_Cons		As Object
	
	TNative			As Object
	Native			As Object
	
	TType			As Object
	TType_Param		As Object
	TType_App		As Object
	
	Native_Boolean	As Object
	Native_Byte		As Object
	Native_Integer	As Object
	Native_Long		As Object
	Native_Single	As Object
	Native_Double	As Object
	Native_String	As Object
	
	Native_Empty	As Object
	Native_Object	As Object
	Native_Date		As Object
	Native_Array	As Object
	Native_Variant	As Object
End Type


Const DataCtor_name     = 0
Const DataCtor_argTypes = 1
Const DataCtor_typeCtor = 2

Const DataTypeCtor_name  	 = 0
Const DataTypeCtor_arity 	 = 1
Const DataTypeCtor_dataCtors = 2

Const Ntv_shortName = 0
Const Ntv_typeName  = 1
Const Ntv_varType   = 2

Sub Main
	Tp()
	[test_Type======================================]()
End Sub


Function _newDataValue(ctor As DataValue, ByRef args As Array)
	Static instanceCount As Long
	Dim out As New DataValue
	out.ctor   = ctor
	out.fields = args
	out.id	   = instanceCount
	instanceCount = instanceCount + 1
	_newDataValue = out
End Function

Function Tp() &apos; bootstrap TType and data types
	Static out As Object
	If isNull(out) Then
		out = New Tp
		
		Dim vNil, tcList, cNil
		vNil = _newDataValue(Nothing, emptyArray)
		tcList = _newDataValue(Nothing, Array(&quot;List&quot;, 1, vNil))
		out.List = tcList
		
		cNil = _newDataValue(Nothing, Array(&quot;Nil&quot;, vNil, tcList))
		cNil.x = vNil
		vNil.ctor = cNil
		out.List_Nil = cNil
		
		
		Dim tcDataCtor, cDataCtor
		tcDataCtor = _newDataValue(Nothing, Array( _
			&quot;TDataCtor&quot;, 0, vNil _
		)
		out.TDataCtor = tcDataCtor
		
		cDataCtor = _newDataValue(Nothing, Array( _
			&quot;DataCtor&quot;, vNil, tcDataCtor _
		))
		cDataCtor.ctor	= cDataCtor
		cNil.ctor		= cDataCtor
		out.DataCtor = cDataCtor
		
		Dim cCons
		cCons = _newDataValue(cDataCtor, Array( _
			&quot;Cons&quot;, vNil, tcList _
		))
		out.List_Cons = cCons
		

		out.List.str			= &quot;List&quot;
		out.List_Nil.str		= &quot;Nil :: List a0&quot;	&apos; singleton data ctor
		out.List_Nil.x.str		= &quot;[]&quot;	&apos; singleton value
		out.List_Cons.str		= &quot;Cons :: a0 -&gt; (List a0) -&gt; (List a0)&quot;


		
		Dim tcDataTypeCtor
		tcDataTypeCtor = _mkDataTypeCtor(&quot;TDataTypeCtor&quot;, 0)
		out.TDataTypeCtor = tcDataTypeCtor
		
		Dim cDataTypeCtor
		cDataTypeCtor = _mkDataCtor(tcDataTypeCtor, &quot;DataTypeCtor&quot;, vNil)
		tcDataTypeCtor.ctor = cDataTypeCtor
		tcDataCtor.ctor 	= cDataTypeCtor
		tcList.ctor			= cDataTypeCtor
		out.DataTypeCtor = cDataTypeCtor
		
		&apos; Now we need types to fix up the argTypes fields
		
		Dim tcNative
		tcNative =  _mkDataTypeCtor(&quot;TNative&quot;, 0)
		out.TNative = tcNative
		
		Dim cNtv &apos; data ctor of TNative for native types
				 &apos; later: its argTypes = [Native Str, Native Str, Native Int]
		cNtv = _mkDataCtor(tcNative, &quot;Native&quot;, vNil)
		out.Native = cNtv
		
		&apos; make Native instances:
		
		Dim nStr
		nStr = _newDataValue(cNtv, Array( _
			&quot;Str&quot;, TypeName(CStr(&quot;&quot;)), VarType(CStr(&quot;&quot;)) _
		)
		
		Dim nInt
		nInt = _newDataValue(cNtv, Array( _
			&quot;Int&quot;, TypeName(CInt(0)), VarType(CInt(0)) _
		)
		
		&apos; With nStr and nInt we can fix argTypes of cNtv:
		
		cNtv.fields(DataCtor_argTypes) = _
			_newDataValue(cCons, Array(nStr, _
			_newDataValue(cCons, Array(nStr, _
			_newDataValue(cCons, Array(nInt, _
								 vNil _
		))))))
		&apos; TODO: cNtv.x
		
		
		
		Dim tcType
		tcType = _mkDataTypeCtor(&quot;Type&quot;, 0)
		out.TType = tcType
				
		Dim cParam
		cParam = _mkDataCtor(tcType, &quot;Param&quot;, _
			_newDataValue(cCons, Array(nInt, _
								 vNil _
		)))
		out.TType_Param = cParam
		
		Dim cApp
		cApp = _mkDataCtor(tcType, &quot;App&quot;, _
			_newDataValue(cCons, Array(tcType, _
			_newDataValue(cCons, Array(tcType, _
								 vNil _
		)))))
		out.TType_App = cApp
		
		
		&apos; With cApp we can fix argTypes of cons so we can use list fns
		&apos; (can use convenience fns already)
		Dim vParam, vApp
		&apos;vParam = _newDataValue(cParam, Array(0))	&apos;	
		&apos;vApp   = _newDataValue(cApp, Array(tcList, vParam))	&apos;	
		
		cCons.fields(DataCtor_argTypes) =		_
			_newDataValue( cCons, Array(TypeParam(0),	_
			_newDataValue( cCons, Array(TList(TypeParam(0)), _
			vNil _
		))))
		
		&apos; argTypes of DataTypeCtor
		vApp = TList(tcDataTypeCtor)
		&apos;vApp = applyDC(cApp, tcList, tcDataTypeCtor)
		&apos;vApp.str = &quot;[TDataTypeCtor]&quot;
		cDataTypeCtor.fields(DataCtor_argTypes) = _
			List(nStr, nInt, vApp)
		
		&apos; argTypes of DataCtor
		vApp = TList(tcType)	&apos;	vApp = applyDC(cApp, tcList, tcType)	&apos;	
		cDataCtor.fields(DataCtor_argTypes) = _
			List(nStr, vApp, tcDataTypeCtor)
		
		&apos; set dataCtors fields
		tcDataCtor.fields(DataTypeCtor_dataCtors) =	List(cDataCtor)
		tcList.fields(DataTypeCtor_dataCtors) =	_
			List(cNil, cCons)
		
		&apos;tcDataTypeCtor.fields(DataTypeCtor_dataCtors) =	List(cDataTypeCtor)
		&apos;tcType.fields(DataTypeCtor_dataCtors) =	_
		&apos;	List(cNtv, cParam, cApp)

		out.TDataTypeCtor.str	= &quot;TDataTypeCtor&quot;
		out.DataTypeCtor.str	= &quot;DataTypeCtor :: Str -&gt; Int -&gt; (List TDataCtor) -&gt; TDataTypeCtor&quot;
		
		out.TDataCtor.str		= &quot;TDataCtor&quot;
		out.DataCtor.str		= &quot;DataCtor :: Str -&gt; (List Type) -&gt; TDataTypeCtor -&gt; TDataCtor&quot;

		out.TNative.str			= &quot;TNative&quot;
		out.Native.str			= &quot;Native&quot;

		out.TType.str			= &quot;Type&quot;
		&apos;out.TType_Ntv.str		= &quot;Native&quot;
		out.TType_Param.str		= &quot;Param :: Int -&gt; Type&quot;
		out.TType_App.str		= &quot;App :: Type -&gt; Type -&gt; Type&quot;
		
		nStr.str 				= cNtv.str &amp; &quot;_Str&quot;
		nInt.str 				= cNtv.str &amp; &quot;_Int&quot;
		
		&apos; -- more BASIC types:
		out.Native_Boolean	= applyDC(cNtv, &quot;Bool&quot;,	 TypeName(CBool(0)), VarType(CBool(0))	)
		out.Native_Boolean.str = &quot;Bool&quot;
		out.Native_Byte 	= applyDC(cNtv, &quot;Byte&quot;,	 TypeName(CByte(0)), VarType(CByte(0))	)
		out.Native_Integer	= nInt		
		out.Native_Long 	= applyDC(cNtv, &quot;Long&quot;,	 TypeName(CLng(0)),  VarType(CLng(0))	)
		out.Native_Single	= applyDC(cNtv, &quot;Sng&quot;, 	 TypeName(CSng(0)),  VarType(CSng(0))	)
		out.Native_Double	= applyDC(cNtv, &quot;Dbl&quot;,	 TypeName(CDbl(0)),  VarType(CDbl(0))	)
		out.Native_String 	= nStr
		out.Native_Object	= applyDC(cNtv, &quot;Obj&quot;,	 TypeName(Nothing),  VarType(Nothing)	)
		out.Native_Empty	= applyDC(cNtv, &quot;Empty&quot;, TypeName(Empty),	 VarType(Empty)		)
		out.Native_Array	= applyDC(cNtv, &quot;Array&quot;, TypeName(Array()),  VarType(Array())	)
		out.Native_Date		= applyDC(cNtv, &quot;Date&quot;,	 TypeName(Date),  	 VarType(Date)		)
		Dim aVariant As Variant
		out.Native_Variant	= applyDC(cNtv, &quot;Variant&quot;, TypeName(aVariant), VarType(aVariant))
						
	End If
	Tp = out
End Function


&apos; duck-type like test:
&apos; - does it have member .ctor of (BASIC) type Object?
&apos; - does it have member .fields of (BASIC) type Array?
Function isDataValue(x As Variant)
	Dim out
	out = False
	&apos; TODO: isDataValue: check isObject &amp; Not isNull first
	On Local Error Goto isDataValue_end
	If isObject(_ctor(x)) And isArray(_fields(x)) Then
		out = True
	End If
isDataValue_end:
	isDataValue = out
End Function


Function _ctor(o As Object)
	_ctor = o.ctor
End Function

Function _fields(o As Object)
	_fields = o.fields
End Function

Function field(idx As Integer, v As DataValue)
	field = v.fields(idx)
End Function

Function fieldCount(v As DataValue)
	fieldCount = CInt(UBound(v.fields) + 1)
End Function


Function DataValue_same(a As DataValue, b As DataValue)
	DataValue_same = (a.id = b.id)
End Function


&apos;	assertEqual(VarType(Empty),		0).x
&apos;	&apos;assertEqual(VarType(?),		1).x	&apos; doc says &quot;Null&quot; (?!)
&apos;	assertEqual(VarType(CInt(0)),	2).x
&apos;	assertEqual(VarType(CLng(0)),	3).x
&apos;	assertEqual(VarType(CSng(0)),	4).x
&apos;	assertEqual(VarType(CDbl(0)),	5).x
&apos;	&apos;assertEqual(VarType(?),	6).x
&apos;	assertEqual(VarType(Date),		7).x
&apos;	assertEqual(VarType(&quot;string&quot;),	8).x
&apos;	assertEqual(VarType(Nothing),	9).x
&apos;	assertEqual(VarType(missing),	10).x
&apos;	assertEqual(VarType(True),		11).x
&apos;	&apos;assertEqual(VarType(?),		12).x	&apos; doc says &quot;Variant&quot;...
&apos;	&apos;assertEqual(VarType(Array()),	8204).x	&apos; let&apos;s treat it as random

Function ctorOf(Optional x As Variant)
	Static oFn As Object &apos; init only when needed (Fn() requires List)
	Static cs As Variant
	&apos; ATTENTION: cByte, cInt, cLng, cSng, cDbl, cStr, cDate, cBool
	&apos;            are BASIC *keywords*! 
	Static _Byte, _Int, _Lng, _Sng, _Dbl, _Str, _Bool
	Static _Empty, _Obj, _Date, _Variant, _Array
	If isEmpty(cs) Then
		Dim cs(0 To 17)
		_Empty 	= Tp.Native_Empty	&apos; vt =  0
									&apos; vt =  1 ??? (&quot;Null&quot;)
		_Int 	= Tp.Native_Integer	&apos; vt =  2
		_Lng 	= Tp.Native_Long	&apos; vt =  3
		_Sng 	= Tp.Native_Single	&apos; vt =  4
		_Dbl 	= Tp.Native_Double	&apos; vt =  5
									&apos; vt =  6 ???
		_Date 	= Tp.Native_Date	&apos; vt =  7
		_Str 	= Tp.Native_String	&apos; vt =  8
		_Obj 	= Tp.Native_Object	&apos; vt =  9
									&apos; vt = 10 (isMissing = True)
		_Bool 	= Tp.Native_Boolean	&apos; vt = 11
		_Variant= Tp.Native_Variant	&apos; vt = 12 ??? (&quot;Variant&quot;)
		_Array 	= Tp.Native_Array	&apos; vt = &amp;H2000 + VarType(elem)
		_Byte	= Tp.Native_Byte	&apos; vt = 17
		
		cs( 0) = _Empty
		cs( 2) = _Int
		cs( 3) = _Lng
		cs( 4) = _Sng
		cs( 5) = _Dbl
		cs( 7) = _Date
		cs( 8) = _Str
		cs( 9) = _Obj
		cs(11) = _Bool
		cs(12) = _Variant
		cs(17) = _Byte
	End If
		
	Dim out As Variant, vt As Integer
	vt = VarType(x)
		
	On vt Goto _vtXX, _vtNN, _vtNN, _vtNN, _vtNN, _
			   _vtXX, _vtNN, _vtNN, _vt09, _vt10, _
			   _vtNN, _vtNN, _vtXX, _vtXX, _vtXX, _
			   _vtXX, _vtNN
	&apos; when we get here then vt = 0 or &gt;17
	Goto _ctorOf_EmptyOrArrrayOrByte
_vt10: &apos; isMissing(x) = True
	If isNull(oFn) Then
		oFn = Fn.ctorOf
	End If
	out = oFn
	Goto _ctorOf_end
_vtNN:
	out = cs(vt)
	Goto _ctorOf_end
_vt09: &apos; isObject(x) = True
	out = _Obj
	On Local Error Goto _ctorOf_end
	out = _ctor(x) &apos; DONT access fields in here!
	If Not(isDataValue(out)) Then
		Goto _ctorOf_error
	End If
_ctorOf_end:
	ctorOf = out
	Exit Function
_ctorOf_EmptyOrArrrayOrByte:
	If vt = 0 Then
		out = _Empty
		Goto _ctorOf_end
	ElseIf isArray(x) Then
		out = _Array
		Goto _ctorOf_end
	End If
_vtXX: &apos; vt =1, =6, &gt;17 and not Array
	croak(&quot;ctorOf: unsupported VarType = &quot; &amp; vt _
		&amp; NL &amp; &quot;TypeName: &apos;&quot; &amp; TypeName(x) &amp; &quot;&apos;&quot; _
	)
_ctorOf_error:
	On Local Error Goto 0 &apos; disable error handler
	croak(&quot;ctorOf: object with invalid .ctor :: &quot; _
	    &amp; typeOf(out) &amp; NL &amp; toString(out))
End Function

Function isCtorOf(c As Object, v As Variant)
	Dim actC As Variant
	actC = ctorOf(v)
	isCtorOf = DataValue_same(actC, c)
End Function

Function ctorName(v As DataValue)
	Dim out
	out = v.ctor.fields(DataCtor_name)
	ctorName = out
End Function

Function typeCtorOf(c)
	&apos;require(hasType, c, TDataCtor)
	typeCtorOf = c.fields(DataCtor_typeCtor)
End Function

Function typeCtorName(c)
	&apos;require(hasType, c, TDataCtor)
	typeCtorName = field(DataTypeCtor_name, typeCtorOf(c))
End Function









Function DataValue_genericToString(v As DataValue)
	Dim seen As String : seen = &quot;&quot;
	DataValue_genericToString = _DataValue_genericToString(v, 0, seen)
End Function

Function _DataValue_genericToString( _
	ByVal v 	 As DataValue, _
	ByVal indent As Integer, _
	ByRef seen 	 As String _
)
	Dim out
	Dim ctor   As Variant : ctor   = v.ctor
	Dim fields As Variant : fields = v.fields
	Dim cStr   As String
	Dim fStr   As String
	
	If inStr(seen, &quot; &quot; &amp; v.id) &lt;&gt; 0 Then
		out = &quot;{ id: &quot; &amp; v.id &amp; &quot; }&quot;
	Else
		seen = v.id &amp; &quot; &quot; &amp; seen 
		If isDataValue(ctor) Then
			cStr = _DataValue_genericToString(ctor, indent + 2, seen)
		Else
			cStr = toString(ctor)
		End If
		If isArray(fields) Then
			fStr = _DataValue_genericToString_Array(fields, indent, seen)
		Else
			fStr = toString(fields)
		End If
		out = &quot;{ id: &quot; &amp; v.id &amp; &quot;,&quot;			&amp; NL &amp; space(indent) _
			&amp; &quot;  ctor: &quot; &amp; cStr &amp; &quot;,&quot; 		&amp; NL &amp; space(indent) _
			&amp; &quot;  fields: &quot; &amp; fStr 			&amp; NL &amp; space(indent) _
			&amp; &quot;}&quot;
	End If
	_DataValue_genericToString = out
End Function

Function _DataValue_genericToString_Array( _
	ByVal a 	 As Array, _
	ByVal indent As Integer, _
	ByRef seen 	 As String _
)
	Dim out
	out = &quot;Array(&quot;
	If UBound(a) &lt; 0 Then
		out = out &amp; &quot;)&quot;
	Else
		out = out &amp; NL &amp; space(indent + 4)
		Dim i As Integer, w As Variant
		For i = 0 To UBound(a)
			If i &gt; 0 Then
				out = out &amp; &quot;,&quot; &amp; NL &amp; space(indent + 4)
			End If
			w = a(i)
			If isArray(w) Then
				out = out &amp; _
				_DataValue_genericToString_Array(w, indent + 2, seen)
			ElseIf isDataValue(w) Then
				out = out &amp; _
				_DataValue_genericToString(w, indent + 4, seen)
			Else
				out = out &amp; toString(w)
			End If
		Next i
		out = out &amp; NL &amp; space(indent + 2) &amp; &quot;)&quot;
	End If	
	_DataValue_genericToString_Array = out
End Function

Function _mkValueFrom_lax(ctor As DataValue, args As Array)
	Dim x As Integer, a As Integer
	a = LBound(args)
	If a &lt;&gt; 0 Then
		croak(&quot;_mkValueFrom_lax &quot; &amp; ctor.fields(DataCtor_name) &amp; &quot;:&quot; _
			&amp; NL &amp; &quot;invalid &quot; &amp; a &amp; &quot;-based args Array&quot; _
			&amp; NL &amp; &quot;expected 0-based Array&quot;)
	Else
		x = UBound(ctor.fields(DataCtor_argTypes))
		a = UBound(args)
		If a &lt;&gt; x Then
			a = a + 1 : x = x + 1
			croak(&quot;_mkValueFrom_lax &quot; &amp; ctor.fields(DataCtor_name) _
				&amp; &quot;:&quot; _
				&amp; NL &amp; &quot;expected &quot; &amp; x &amp; &quot; arg&quot; &amp; IIf(x = 1, &quot;&quot;, &quot;s&quot;) _
				&amp; &quot; but got &quot; &amp; a _
				&amp; NL &amp; toString(args))
		End If
	End If
	_mkValueFrom_lax = _newDataValue(ctor, args)
End Function

Sub _setTypeCtor(dataCtor As DataValue, dataTypeCtor As DataValue)
	&apos; TODO: check that dataCtor really is a DataCtor
	&apos; TODO: check that dataTypeCtor really is a DatatypeCtor
	dataCtor.fields(DataCtor_typeCtor) = dataTypeCtor
End Sub


&apos; --------------------------------------------------------------

Function TDataTypeCtor()
	Static out As Object : If isNull(out) Then : out = Tp.TDataTypeCtor : End If
	TDataTypeCtor = out
End Function

Function TDataCtor()
	Static out As Object : If isNull(out) Then : out = Tp.TDataCtor : End If
	TDataCtor = out
End Function

Function TList(Optional typeArg)
	Static tc As Object : If isNull(tc) Then : tc = Tp.List : End If
	Dim out
	If isMissing(typeArg) Then
		out = tc
	Else
		out = TypeApp(tc, typeArg)
	End If
	TList = out
End Function

Function TType()
	Static out As Object : If isNull(out) Then : out = Tp.TType : End If
	TType = out
End Function

&apos; Str -&gt; [Type] -&gt; TDataTypeCtor -&gt; TDataCtor
Function DataCtor( _
	Optional _name As String, _
	Optional argTypes As Object, _
	Optional typeCtor As Object _
)
	Static c As Object : If isNull(c) Then : c = Tp.DataCtor : End If
	Dim out
	If isMissing(_name) Then
		out = c
	Else
		out = applyDC(c, _name, argTypes, typeCtor)
	End If
	DataCtor = c
End Function

&apos; String -&gt; Integer -&gt; [TDataCtor] -&gt; TDataTypeCtor
Function DataTypeCtor( _
	Optional _name As String, _
	Optional arity As Integer, _
	Optional dataCtors As Object _
)
	Static c As Object : If isNull(c) Then : c = Tp.DataTypeCtor : End If
	Dim out
	If isMissing(_name) Then
		out = c
	Else
		out = applyDC(c, _name, arity, dataCtors)
	End If
	DataTypeCtor = out
End Function

Function nil()
	Static out As Object : If isNull(out) Then : out = Tp.List_Nil.x : End If
	nil = out
End Function

Function isNil(Optional xs)
	Static oFn As Object, vNil As Object
	If isNull(oFn) Then 
		oFn = Fn.isNil
		vNil = nil
	End If
	If isMissing(xs) Then
		isNil = oFn
	ElseIf isList(xs) Then
		isNil = DataValue_same(xs, nil)
	Else
		croak(&quot;isNil: expected a List but got &quot; &amp; NL &amp; toString(xs)
	End If
End Function

Function List_cons(Optional x As Variant, Optional xs As Variant)
	Static oFn As Object : Static c As Object
	If isNull(oFn) Then
		oFn = Fn.cons
		c = Tp.List_Cons
	End If
	Dim out
	If isMissing(x) Then
		out = c
	ElseIf isMissing(xs) Then
		croak(&quot;List_cons/NYI: partial application&quot;)
	Else
		&apos; TODO: require xs to be of type List a and x of type a
		&apos;out = _newDataValue(c, Array(x, xs))
		out = applyDC(c, x, xs)
	End If
	List_cons = out
End Function


Function cons(Optional x, Optional xs)
	Static oFn As Object : Static c As Object
	Dim out As Variant
	If isNull(oFn) Then
		oFn = Fn.cons
		c = Tp.List_Cons
	End If
	If isMissing(xs) Then
		out = _apply(oFn, x, xs)
	Else
		If isList(xs) Then
			out = applyDC(c, x, xs)
		Else
			croak(&quot;cons: invalid tail - expected a List but got a &quot; &amp; typeOf(xs) &amp; &quot;:&quot; &amp; NL &amp; toString(xs))
		End If
	End If
	cons = out
End Function


Function List_car(xs As Variant)
	List_car = field(0, xs)
End Function

Function List_cdr(xs As Variant)
	List_cdr = field(1, xs)
End Function

Function List_cadr(xs As Variant)
	List_cadr = List_car(List_cdr(xs))
End Function

Function List_cddr(xs As Variant)
	List_cddr = List_cdr(List_cdr(xs))
End Function

Function List_caddr(xs As Variant)
	List_caddr = List_car(List_cdr(List_cdr(xs)))
End Function

Function List_cdddr(xs As Variant)
	List_cdddr = List_cdr(List_cdr(List_cdr(xs)))
End Function

Function List_nth(ByVal n As Integer, ByVal xs As Variant)
	Do Until (n = 0)
		xs = List_cdr(xs)
		n = n - 1
	Loop
	List_nth = List_car(xs)
End Function

Function List_length(ByVal xs As Variant)
	Dim out As Integer
	Do Until isNil(xs)
		out = out + 1
		xs = List_cdr(xs)
	Loop
	List_length = out
End Function

Function TString()
	Static out As Object : If isNull(out) Then : out = Tp.TType_Str.x : End If
	TString = out
End Function

Function TInteger()
	Static out As Object : If isNull(out) Then : out = Tp.TType_Int.x : End If
	TInteger = out
End Function

Function TypeParam(Optional i As Integer)
	Static c As Object : If isNull(c) Then : c = Tp.TType_Param : End If
	Dim out
	If isMissing(i) Then
		out = c
	Else
		&apos;out = applyDC(c, i)
		out = _newDataValue(c, Array(i))
		out.str = &quot;a&quot; &amp; i
	End If
	TypeParam = out
End Function



Function TypeApp(Optional tc As Object, Optional ta As Object)
	Static cApp As Object : If isNull(cApp) Then : cApp = Tp.TType_App : End If
	Dim out
	If isMissing(tc) Then
		out = cApp
	Else
		&apos;out = applyDC(cApp, tc, ta)
		out = _newDataValue(cApp, Array(tc, ta))
		
		&apos; tc must be an &quot;applicable&quot; type,
		&apos; ie: a DataTypeCtor with arity &gt; 0
		&apos;     or a TypeApp with at least 1 unbound TypeParam
		Dim tcCtor As Object, r As Integer, tcStr As String
		tcCtor = ctorOf(tc)
		If isEmpty(tcCtor) Then
			Goto TypeApp_invalid_1st_arg
		ElseIf DataValue_same(typeCtorOf(tcCtor), TDataTypeCtor) Then
			&apos; has it arity &gt; 0 ?
			r = field(DataTypeCtor_arity, tc)
			If r &lt; 1 Then
				Goto TypeApp_invalid_1st_arg
			End If
			tcStr = field(DataTypeCtor_name, tc)
		ElseIf DataValue_same(tcCtor, cApp) Then
			&apos; TODO: TypeApp.str/typeCtor - has it arity &gt; 1 ?
			tcStr = tc.str
		End If
		
		&apos; ta must be a &quot;complete&quot; type,
		&apos; ie: a DataTypeCtor with arity &gt; 0
		&apos;  or a TypeApp with no unbound TypeParam s
		&apos;  or a TypeParam
		&apos;  or a native type (Str, Int, ...)
		Dim taCtor As Object, taStr As String
		taCtor = ctorOf(ta)
		If isEmpty(taCtor) Then
			Goto TypeApp_invalid_2nd_arg
		ElseIf DataValue_same(typeCtorOf(taCtor), TDataTypeCtor) Then
			&apos; has it arity = 0 ?
			r = field(DataTypeCtor_arity, ta)
			If r &gt; 0 Then
				Goto TypeApp_invalid_2nd_arg
			End If
			taStr = field(DataTypeCtor_name, ta)
		ElseIf DataValue_same(taCtor, cApp) Then
			&apos; TODO: TypeApp.str/typeArg - has it arity = 0 ?
			taStr = ta.str
			If Not(startsWith(taStr, &quot;[&quot;)) Then
				taStr = &quot;(&quot; &amp; taStr &amp; &quot;)&quot;
			End If
		Else
			taStr = ta.str
		End If
		
		If DataValue_same(tc, TList) Then
			out.str = &quot;[&quot; &amp; taStr &amp; &quot;]&quot;
		Else
			out.str = tcStr &amp; &quot; &quot; &amp; taStr
		End If
		
	End If
	TypeApp = out
	Exit Function
TypeApp_invalid_1st_arg:
	croak(&quot;TypeApp: cannot apply &quot; &amp; toString(tc))	
	Exit Function
TypeApp_invalid_2nd_arg:
	croak(&quot;TypeApp: invalid type arg &quot; &amp; toString(ta))	
End Function

&apos; --------------------------------------------------------------


&apos;Function isSubtypeOf(s As Object, t As Object)
&apos;	Dim out
&apos;	out = DataValue_same(s, t)
&apos;	If Not(out) Then
&apos;		If DataValue_same(t, TType) Then
&apos;			out = CBool(DataValue_same(s, TDataTypeCtor) _
&apos;					Or DataValue_same(s, TString) _
&apos;					Or DataValue_same(s, TInteger) _
&apos;			)
&apos;		End If
&apos;	End If
&apos;	isSubtypeOf = out
&apos;End Function

Function hasType(Optional v As Variant, Optional t As Object)
	Static oFn As Object
	Dim out As Variant
	If isMissing(t) Then
		If isNull(oFn) Then : oFn = Fn.hasType : End If
		If isMissing(v) Then	: out = oFn
		Else					: out = apply1(oFn, v)
		End If
	Else
		out = False
		Dim tOk As Boolean
		tOk = False
		Dim ct As Object, tc As Object, cv As Object
		ct = ctorOf(t)
		If DataValue_same(ct, Tp.DataTypeCtor) Then
			&apos; fine: t is a data type
			tOk = True
		ElseIf DataValue_same(ct, DataCtor) Then
			tc = field(DataCtor_typeCtor, cv)
			If DataValue_same(tc, Tp.TType) Then
				&apos; fine: t is either a Type.Ntv, a Type.Param or a Type.App
				tOk = True
			End If
		End If
		If Not(tOk) Then
			Goto hasType_invalidType
		End If
		
		
	End If	
		
	hasType = out
	Exit Function
hasType_invalidType:
	croak(&quot;hasType: not a type: &quot; &amp; toString(t))	
End Function

&apos;Function requireType(t As Object, v As Variant)
&apos;	Dim out
&apos;	If hasType(v, t) Then
&apos;		out = mkPass
&apos;	Else
&apos;		out = mkFail(v, t, &quot;need &quot; &amp; DataValue_toString(t) &amp; &quot; - got&quot; &amp; NL &amp; toString(v))
&apos;	End If
&apos;	requireType = out
&apos;End Function

Function applyDC(c, _
	Optional a0, _
	Optional a1, _
	Optional a2, _
	Optional a3, _
	Optional a4 _
)
	If Not(isCtorOf(Tp.DataCtor, c)) Then
		croak(&quot;applyDC: not a data ctor: &quot; &amp; NL &amp; toString(c))
	End If
	Dim out As Object
	Dim cName As String : cName = field(DataCtor_name, c)
	Dim ats As Object	: ats = field(DataCtor_argTypes, c)
	Dim r As Integer	: r = length(ats)
	Dim n As Integer, i As Integer
	Dim a As Variant, t As Object
	
	If     isMissing(a0) Then :	n = 0
	ElseIf isMissing(a1) Then
		n = 1 : If r &lt; n Then : Goto applyDC_too_many_args : End If
		&apos;a = a0 : i = 0 : t = List_nth(i, ats)
		&apos;If Not(hasType(a, t)) Then : Goto applyDC_typeError : End If
	ElseIf isMissing(a2) Then
		n = 2 : If r &lt; n Then : Goto applyDC_too_many_args : End If
		&apos;a = a0 : i = 0 : t = List_nth(i, ats)
		&apos;If Not(hasType(a, t)) Then : Goto applyDC_typeError : End If
		&apos;a = a1 : i = 1 : t = List_nth(i, ats)
		&apos;If Not(hasType(a, t)) Then : Goto applyDC_typeError : End If
	ElseIf isMissing(a3) Then
		n = 3 : If r &lt; n Then : Goto applyDC_too_many_args : End If
	ElseIf isMissing(a4) Then
		n = 4 : If r &lt; n Then : Goto applyDC_too_many_args : End If
	Else
		croak(&quot;applyDC &quot; &amp; cName &amp; &quot;: &quot; _
			&amp; &quot; only up to 4 args supported - got 5&quot; _
		)
	End If
	
	If n &lt; r Then
		Dim typeStr As String
		For i = n To r - 1
			t = List_nth(i, ats)
			&apos;If (t.str &lt;&gt; &quot;&quot;) Then
			&apos;	typeStr = typeStr &amp; t.str &amp; &quot; -&gt; &quot;
			&apos;Else
				typeStr = typeStr &amp; _DataValue_toString_Type(t, &quot;&quot;) &amp; &quot; -&gt; &quot;
			&apos;End If
		Next i
		typeStr = typeStr &amp; typeCtorName(c)
		Dim oFn As Object
		oFn = _newFn(&quot;applyDC&quot;, r + 1, typeStr)
		Select Case n
			Case 0:	out = apply(oFn, c)
			Case 1:	out = apply(oFn, c, a0)
			Case 2:	out = apply(oFn, c, a0, a1)
			Case 3:	out = apply(oFn, c, a0, a1, a2)
			Case 4:	out = apply(oFn, c, a0, a1, a2, a3)
		End Select
	ElseIf n = r Then
		If n = 0 Then
			out = c.x
			If isEmpty(out) Then
				croak(&quot;applyDC &quot; &amp; cName &amp; &quot;: singleton ctor &quot; _
					&amp; &quot; empty with .x&quot; _
				)
			End If
		Else
			Dim fields
			Select Case n
				Case 1:	fields = Array(a0)
				Case 2:	fields = Array(a0, a1)
				Case 3:	fields = Array(a0, a1, a2)
				Case 4:	fields = Array(a0, a1, a2, a3)
			End Select
			out = _newDataValue(c, fields)
		End If
	Else
applyDC_too_many_args:
		croak(&quot;applyDC &quot; &amp; cName &amp; &quot;: &quot; _
			&amp; &quot; cannot apply &quot; &amp; r &amp; &quot;-arg ctor to &quot; &amp; n &amp; &quot; args&quot; _
		)
	End If
	applyDC = out
	Exit Function
applyDC_typeError:
		croak(&quot;applyDC &quot; &amp; cName &amp; &quot;: type error: expected &quot; _
			&amp; _DataValue_toString_Type(t) _
			&amp; NL &amp; &quot;but got&quot; _
			&amp; NL &amp; toString(a) _
		)
End Function


&apos; --------------------------------------------------------------

Function DataValue_toString(v As DataValue)
	Dim seen As String
	seen = &quot;&quot;
	DataValue_toString = _DataValue_toString(v, seen)
End Function

Function _DataValue_toString(v As DataValue, ByRef seen As String)
	Dim out As String
	Dim typeStr As String, ctorStr As String
	Dim ctor As DataValue, fields As Variant
	If inStr(seen, &quot; &quot; &amp; v.id) &lt;&gt; 0 Then
		out = &quot;{ id: &quot; &amp; v.id &amp; &quot; }&quot;
	Else
		seen = seen &amp; &quot; &quot; &amp; v.id
		ctor   = v.ctor
		fields = v.fields
		typeStr = field(DataTypeCtor_name, field(DataCtor_typeCtor, ctor))
		ctorStr = field(DataCtor_name, ctor)
		out = typeStr &amp; &quot;.&quot; &amp; ctorStr
		If UBound(fields) &gt;= 0 Then
			Dim argsStr As String, i As Integer, first As Boolean
			Dim tc As DataValue
					
			If typeStr = &quot;TDataTypeCtor&quot; Then
				argsStr = toString(field(DataTypeCtor_name, v)) &amp; &quot; &quot; &amp; field(DataTypeCtor_arity, v) &amp; &quot; &quot; 
				Dim dataCtors As Variant, dc As DataValue
				dataCtors = field(DataTypeCtor_dataCtors, v)
				If isArray(dataCtors) Then
					argsStr = argsStr &amp; &quot;Array(&quot;
					For i = 0 To UBound(dataCtors)
						If i &gt; 0 Then : argsStr = argsStr &amp; &quot;, &quot; : End If
						dc = dataCtors(i)
						argsStr = argsStr &amp; field(DataCtor_name, dc)
					Next i
					argsStr = argsStr &amp; &quot;)&quot;
				ElseIf isDataValue(dataCtors) Then
					ctor = ctorOf(dataCtors)
					tc = field(DataCtor_typeCtor, ctor)
					If field(DataTypeCtor_name, tc) = &quot;List&quot; Then
						argsStr = argsStr &amp; &quot;[&quot;
						first = True
						Do Until ctorName(dataCtors) = &quot;Nil&quot;
							If first Then
								first = False
							Else
								argsStr = argsStr &amp; &quot;, &quot;
							End If
							dc = field(0, dataCtors) &apos; &quot;car&quot;
							argsStr = argsStr &amp; field(DataCtor_name, dc)
							dataCtors = field(1, dataCtors) &apos; &quot;cdr&quot;
						Loop
						argsStr = argsStr &amp; &quot;]&quot; 
					Else
						argsStr = argsStr &amp; _DataValue_toString(dataCtors, seen)
					End If
				Else
					croak(&quot;DataValue_toString/non-array, non-dataValue dataCtors: NYI&quot;)
				End If
			ElseIf typeStr = &quot;TDataCtor&quot; Then
				argsStr = toString(field(DataTypeCtor_name, v)) &amp; &quot; &quot; 
				Dim argTypes As Variant, at As Variant
				argTypes = field(DataCtor_argTypes, v)
				If isArray(argTypes) Then
					argsStr = argsStr &amp; &quot;Array(&quot;
					For i = 0 To UBound(argTypes)
						If i &gt; 0 Then : argsStr = argsStr &amp; &quot;, &quot; : End If
						at = argTypes(i)
						If isDataValue(at) Then
							argsStr = argStr &amp; _DataValue_toString_Type(at, seen)	&apos; &lt;------ type-to-string here
						Else
							argsStr = argsStr &amp; toString(at)
						End If
					Next i
					argsStr = argsStr &amp; &quot;)&quot;
				ElseIf isDataValue(argTypes) Then
					ctor = ctorOf(argTypes)
					tc = field(DataCtor_typeCtor, ctor)
					If field(DataTypeCtor_name, tc) = &quot;List&quot; Then
						argsStr = argsStr &amp; &quot;[&quot;
						first = True
						Do Until ctorName(argTypes) = &quot;Nil&quot;
							If first Then
								first = False
							Else
								argsStr = argsStr &amp; &quot;, &quot;
							End If
							at = field(0, argTypes) &apos; &quot;car&quot;
							argsStr = argsStr &amp; _DataValue_toString(at, seen)	&apos; &lt;------ type-to-string here
							argTypes = field(1, argTypes) &apos; &quot;cdr&quot;
						Loop
						argsStr = argsStr &amp; &quot;]&quot; 
					Else
						argsStr = argsStr &amp; _DataValue_toString(argTypes, seen)
					End If
				Else
					argsStr = argsStr &amp; toString(argTypes, seen)
					&apos;croak(&quot;DataValue_toString/non-array, non-dataValue argTypes: NYI&quot; &amp; NL &amp; NL &amp; toString(argTypes))
				End If
				argsStr = argsStr &amp; &quot; &quot; &amp; field(DataTypeCtor_name, field(DataCtor_typeCtor, v))
			ElseIf typeStr = &quot;Type&quot; Then
				out = _DataValue_toString_Type(v, seen)
			Else
				argsStr = _DataValue_toString_Array(fields, seen)
			End If
			out = &quot;(&quot; &amp; out &amp; &quot; &quot; &amp; argsStr &amp; &quot;)&quot;
		End If
	End If
	_DataValue_toString = out
End Function

Function _DataValue_toString_Array(a As Array, ByRef seen As String)
	Dim out As String, i As Integer, x As Variant
	out = &quot;&quot;
	For i = 0 To UBound(a)
		If i &gt; 0 Then : out = out &amp; &quot; &quot; : End If
		x = a(i)
		If isDataValue(x) Then
			out = out &amp; _DataValue_toString(x, seen)
		ElseIf isArray(x) Then
			out = out &amp; &quot;Array(&quot; &amp; _DataValue_toString_Array(x, seen) &amp; &quot;)&quot;
		Else
			out = out &amp; toString(x)
		End If
	Next i
	
	_DataValue_toString_Array = out
End Function


Function _DataValue_toString_Type(v As DataValue, ByRef seen As String)
	Dim out As String : out = &quot;&quot;
	If isDataTypeCtor(v) Then
		out = field(DataTypeCtor_name, v)
	Else
		Dim c As DataValue : c = ctorOf(v)
		If ctorName(c) = &quot;DataCtor&quot; Then
			Dim t As DataValue : t = field(DataCtor_typeCtor, c)
			If field(DataTypeCtor_name, t) = &quot;Type&quot; Then
				Dim cName As String
				cName = ctorName(v)
				out = cName
				Dim args   As Variant, a As Variant
				Dim i As Integer, n As Integer
				args = _fields(v)
				n = UBound(args)
				If n &gt;= 0 Then
					out = out &amp; &quot; &quot;
					Select Case cName
						Case &quot;Ntv&quot; &apos; Ntv Str Str Int
							out = out &amp; &quot;&apos;&quot; &amp; args(0) &amp; &quot;&apos; ...&quot;
						Case &quot;Param&quot; &apos; Param Int
							out = out &amp; args(0)
						Case &quot;App&quot;	&apos; App Type Type
							out = out &amp; field(DataTypeCtor_name, args(0)) _
								&amp; &quot; &quot; &amp; _DataValue_toString_Type(args(1), seen)
						Case Else
							croak(&quot;_DataValue_toString_Type/NYI: Type instance &quot; &amp; cName &amp; &quot; ...&quot;)
					End Select
					out = &quot;(&quot; &amp; out &amp; &quot;)&quot;
				End If
			End If
		End If
		If out = &quot;&quot; Then
			croak(&quot;_DataValue_toString_Type: invalid Type instance &quot; &amp; DataValue_toString(v))
		End If
	End If
	_DataValue_toString_Type = out
End Function


Function isDataTypeCtor(tc As DataValue)
	Dim out
	out = False
	Dim c As DataValue
	c = tc.ctor
	Dim cName As String
	cName = c.fields(DataCtor_name)
	If cName = &quot;DataTypeCtor&quot; Then
		Dim tcName As String
		tcName = c.fields(DataCtor_typeCtor).fields(DataTypeCtor_name) 
		If tcName = &quot;TDataTypeCtor&quot; Then
			out = True
		End If
	End If
	isDataTypeCtor = out
End Function

Function _mkDataCtor( _
	typeCtor As Object, _
	cName 	 As String, _
	argTypes As Object _
)
	Dim dc As Object : dc = Tp.DataCtor
	Dim nl As Object : nl = Tp.List_Nil.x
	Dim out
	out = _newDataValue(dc, Array(cName, argTypes, typeCtor))
	Dim dcs As Object
	dcs = typeCtor.fields(DataTypeCtor_dataCtors, typeCtor)
	Dim isFirst As Boolean, isSingle As Boolean
	isFirst  = DataValue_same(nl, dcs)
	isSingle = DataValue_same(nl, argTypes) &apos; singleton data ctor?
	typeCtor.fields(DataTypeCtor_dataCtors, typeCtor) _
		= _newDataValue(Tp.List_Cons, Array(out, dcs))
	Dim tcName As String
	tcName = field(DataTypeCtor_name, typeCtor)
	If Not(isFirst) Then
		typeCtor.str = typeCtor.str &amp; &quot; | &quot;
	End If
	If isSingle Then
		out.x = _newDataValue(out, emptyArray)
		out.x.str = cName
		out.str = tcName &amp; &quot;.&quot; &amp; cName
		typeCtor.str = typeCtor.str &amp; cName
	Else
		out.str = tcName &amp; &quot;.&quot; &amp; cName &amp; &quot; ...&quot;
		typeCtor.str = typeCtor.str &amp; cName &amp; &quot; ...&quot;
	End If
	_mkDataCtor = out	
End Function

Function mkDataCtor( _
	typeCtor As Object, _
	cName 	 As String, _
	argTypes As Array _
)
	If Not(isCtorOf(Tp.DataTypeCtor, typeCtor)) Then
		croak(&quot;mkDataCtor: type error - expected TDataTypeCtor&quot; _
			&amp; NL &amp; &quot;got: &quot; &amp; toString(typeCtor))
	End If
	Dim n As Integer  : n = UBound(argTypes) + 1
	Dim ats As Object : ats = toList(argTypes)
	Dim out
	out = _mkDataCtor(typeCtor, cName, ats)
	If n &gt; 0 Then
		&apos;out.str = field(DataTypeCtor_name, typeCtor) &amp; &quot;.&quot; &amp; cName
	End If
	mkDataCtor = out
End Function

Function _mkDataTypeCtor( _
	ByVal tcName As String, _
	ByVal arity As Integer _
)
	Dim dtc As Object : dtc = Tp.DataTypeCtor
	Dim nl	As Object : nl  = Tp.List_Nil.x
	Dim out As Object
	out = _newDataValue(dtc, Array(tcName, arity, nl))
	out.str = tcName
	Dim i As Integer, p As Object
	For i = 0 To arity - 1
		p = applyDC(Tp.TType_Param, i)
		out.str = out.str &amp; &quot; &quot; &amp; p.str
	Next i
	out.str = out.str &amp; &quot; = &quot;
	_mkDataTypeCtor = out
End Function

Function isDataType(x As Variant)
	Dim out
	out = False
	On Local Error Goto isDataType_end
	out = _isDataType(x) &apos; DON&apos;T .-access x here!! (simpler this way anyhow)
isDataType_end:
	isDataType = out
End Function

&apos; provokes an error if x isn&apos;t a DataType
Function _isDataType(x As DataType) As Boolean
	_isDataType = Not(isNull(x.typeCtor)) And isArray(x.typeArgs)
End Function

Function isType(t As Variant)
	isType = isDataType(t) Or False
End Function

Function isArrowType(x As Variant)
	Dim out
	out = False
	&apos; TODO: implent isArrowType
	isArrowType = out
End Function

&apos; that&apos;s how to make a DataType: apply a typeCtor to some types
Function applyTC(tc As TypeCtor, typeArgs As Array) As DataType
	Dim out, n As Integer, k As Integer
	k = LBound(typeArgs)
	n = UBound(typeArgs) - k + 1
	If (n &lt;&gt; tc.arity) Then
		croak(&quot;applyTC &quot; &amp; tc._name &amp; &quot;: expected &quot; &amp; tc.arity _
			&amp; &quot; type arg&quot; &amp; IIf(tc.arity = 1, &quot;&quot;, &quot;s&quot;) &amp; &quot; but got &quot; &amp; n _
			&amp; &quot;: &quot; &amp; NL &amp; toString(typeArgs) _
		)
	End If
	out = New DataType
	out.typeCtor = tc
	Dim str As String
	str = tc._name
	If n = 0 Then
		out.typeArgs = Array()
	Else
		Dim tas(0 To n - 1)
		Dim a
		Dim i As Integer
		For i = 0 To n - 1
			a = typeArgs(k)
			If isType(a) Then
				If isDataType(a) Then
					If a.typeCtor.arity = 0 Then
						str = str &amp; &quot; &quot; &amp; a.str
					Else
						str = str &amp; &quot; (&quot; &amp; a.str &amp; &quot;)&quot;
					End If
				&apos;ElseIf isBaseType(a) Or isTypeVar(a) Then
				&apos;	str = str &amp; &quot; &quot; a._name
				End If
			Else
				croak(&quot;applyTc: invalid type arg &quot; _
					&amp; &quot;- expected a Type, not &quot; &amp; typeOf(a) _
					&amp; &quot;: &quot; &amp; NL &amp; toString(a) _
				)
			End If
			tas(i) = a
			k = k + 1
		Next i
		out.typeArgs = tas
	End If
	out.str = str
	applyTC = out
End Function

&apos; --- equ ---

Function TypeCtor_equ(a As TypeCtor, b As TypeCtor)
	Dim out
	out = (a._name = b._name)
	TypeCtor_equ = out
End Function

Function DataType_equ(a As DataType, b As DataType)
	Dim out
	out = False
	If TypeCtor_equ(a.typeCtor, b.typeCtor) Then
		Dim aArgs : aArgs = a.typeArgs
		Dim bArgs : bArgs = b.typeArgs
		Dim i As Integer
		For i = 0 To UBound(aArgs)
			If Not(Type_equ(aArgs(i), bArgs(i))) Then
				Goto DataType_equ_end
			End If
		Next i
		out = True
	End If
DataType_equ_end:
	DataType_equ = out
End Function

Function DataCtor_equ(a As DataCtor, b As DataCtor)
	Dim out
	out = False
	Dim aStr
	If a._name = b._name Then
		out = TypeCtor_equ(a.typeCtor, b.typeCtor)
	End If
	DataCtor_equ = out
End Function

Function Type_equ(a As Object, b As Object)
	Dim out
	out = False
	If isType(a) And isType(b) Then
		If isDataType(a) And isDataType(b) Then
			out = DataType_equ(a, b)
		&apos;ElseIf ... &apos;TODO: Type_equ for other Types
		End If
	Else
		croak(&quot;Type_equ: cannot compare &quot; &amp; typeOf(a) _
			&amp; &quot; and &quot; &amp; typeOf(b))
	End If
	Type_equ = out
End Function









Function typeOf(x As Variant)
	Dim out As String, c As Object, tc As Object
	c = ctorOf(x)
	If DataValue_same(ctorOf(c), Tp.Native) Then
		&apos; Special case: native values have as &quot;ctors&quot;
		&apos; members of the enum TNative. They are not
		&apos; data ctors, but rather &quot;NativeTypeCtor&quot; s.
		&apos; They cannot be &quot;applied&quot; to construct values.
		&apos; They do however contain x&apos;s TypeName, VarType and short_name.
		If DataValue_same(c, Tp.Native_Object) Then &apos; x is not a DataValue
			out = _typeOf(x)
		Else
			out = field(Ntv_typeName, c)
		End If
	Else &apos; x is normal DataValue
		tc = typeCtorOf(c)
		out = &quot;Data/&quot; &amp; field(DataTypeCtor_name, tc)
	End If
	typeOf = out
End Function

Function _typeOf(o As Object)
	Dim out As String
	out = &quot;Object&quot;
	On Local Error Goto _typeOf_end
	out = out &amp; &quot;/&quot; &amp; _tyname(o)
_typeOf_end:
	_typeOf = out
End Function

Function _tyname(o As Object)
	_tyname = o.tyname
End Function




Function isString(Optional x As Variant)
	If isMissing(x) Then
		isString = Fn.isString
	Else
		isString = (typeOf(x) = typeOf(&quot;&quot;))
	End If
End Function

Function isInteger(Optional x As Variant)
	Dim out As Variant
	If isMissing(x) Then : out = Fn.isInteger
	Else 				 : out = (typeOf(x) = typeOf(0))
	End If
	isInteger = out
End Function


Function [test_Type======================================]
	test_bootstrapTypes()	
	
	test_Type_isDataValue()
	test_Type_DataValue()
	test_Type_ctorOf()
	
	&apos;test_Type_typeOf()
	test_Type_isObject()
	test_Type_isString()
	test_Type_isInteger()
	
	test_Type_hasType()
	
	&apos;test_Type_dot_str()
	
	test_Type_applyDC()
		
	&apos;test_Type_isDataType()
	&apos;test_Type_TypeCtor()
	&apos;test_Type_DataCtor()
End Function

&apos; some dummy (BASIC) Type s used in tests
&apos; ---------------------------------------

Type TTest_NoTyname
End Type

Type TTest_Tyname
	tyname As String
End Type

Type TTest_Foo
	bar As Integer
End Type

Type TTest_Ctor
	ctor As Variant
End Type

&apos; test helpers
&apos; --------------------------------------------------


Function test_same(x As Variant, y As Variant, exp As Boolean)
	Dim out, lvl As Integer, msg As String
	If Not(isDataValue(x)) Or Not(isDataValue(y)) Then
		Goto test_same_invalid_args
	End If
	testLevel = testLevel + 1
	out = assertEqual(DataValue_same(x, y), exp)
	testLevel = testLevel - 1
	If out.isFail Then
		msg = &quot;expected .id &quot; &amp; x.id _
			&amp; IIf(exp, &quot;&quot;, &quot;NOT&quot;) _
			&amp; &quot; to be same as .id &quot; &amp; y.id &amp; &quot;:&quot; _
			&amp; NL &amp; &quot;.id &quot; &amp; x.id &amp; &quot;: &quot; &amp; DataValue_toString(x) _
			&amp; NL _
			&amp; NL &amp; &quot;.id &quot; &amp; y.id &amp; &quot;: &quot; &amp; DataValue_toString(y)
		out = mkFail(x, y, msg)
	End If
	test_same = out
	Exit Function
test_same_invalid_args:
	dim xStr : xStr = toString(x)
	dim yStr : yStr = toString(y)
	msg = IIf(exp, &quot;assert&quot;, &quot;refute&quot;) _
		&amp; &quot;_same: invalid args &quot; &amp; NL &amp; xStr _
		&amp; NL &amp; NL &amp; yStr
	&apos;croak(msg)
	test_same = mkFail(x, y, msg)
End Function

Function assert_same(act As Variant, exp As Variant)
	assert_same = test_same(act, exp, True)
End Function

Function refute_same(act As Variant, exp As Variant)
	refute_same = test_same(act, exp, False)
End Function

Function assert_hasCtor(v As Variant, c As Variant)
	If Not(isDataValue(c)) Or Not(isDataValue(c)) Then
		Goto assert_hasCtor_invalid_args
	End If
	If assert_same(ctorOf(c), DataCtor).isFail Then
		Goto assert_hasCtor_invalid_args
	End If
	assert_hasCtor = assert_same(ctorOf(v), c)
	Exit Function
assert_hasCtor_invalid_args:
	croak(&quot;assert_hasCtor: invalid args &quot; &amp; NL &amp; toString(v) _
		&amp; NL &amp; NL &amp; toString(c)
End Function

Function assert_hasTypeCtor(c As Variant, tc As Variant)
	If Not(isDataValue(c)) Or Not(isDataValue(tc)) Then
		Goto assert_hasTypeCtor_invalid_args
	End If
	If assert_same(ctorOf(c),  DataCtor    ).isFail _
	Or assert_same(ctorOf(tc), DataTypeCtor).isFail Then
		Goto assert_hasTypeCtor_invalid_args
	End If
	assert_hasTypeCtor = assert_same(field(DataCtor_typeCtor, c), tc)
	Exit Function
assert_hasTypeCtor_invalid_args:
		croak(&quot;assert_hasTypeCtor: invalid args &quot; &amp; NL &amp; toString(c) _
			&amp; NL &amp; NL &amp; toString(tc)
End Function

&apos; actual tests
&apos; ----------------------------------------------------

Function test_Type_typeOf()
	assertEqual(typeOf(0), &quot;Integer&quot;).x
	assertEqual(typeOf(1), &quot;Integer&quot;).x
	assertEqual(typeOf(-42), &quot;Integer&quot;).x
	
	assertEqual(typeOf(&quot;&quot;), &quot;String&quot;).x
	assertEqual(typeOf(&quot;1&quot;), &quot;String&quot;).x
	
	assertEqual(typeOf(3.14), &quot;Double&quot;).x

	assertEqual(typeOf(Array()), &quot;Array&quot;).x

	assertEqual(typeOf(Empty), &quot;Empty&quot;).x
	assertEqual(typeOf(Nothing), &quot;Object&quot;).x


	Dim t1 As New TTest_NoTyName
	assertEqual(typeOf(t1), &quot;Object&quot;).x

	Dim t2 As New TTest_TyName
	t2.tyname = &quot;foobar&quot;
	assertEqual(typeOf(t2), &quot;Object/foobar&quot;).x
	
	Dim a
	a = Tp.DataCtor	&apos; the data ctor
	assertEqual(typeOf(a), &quot;Data/TDataCtor&quot;).x
	a = applyDC(DataCtor)	&apos; fn that applies the data ctor
	assertEqual(typeOf(a), &quot;Object/TFn&quot;).x
	a = TDataCtor
	assertEqual(typeOf(a), &quot;Data/TDataTypeCtor&quot;).x
	a = TDataTypeCtor
	assertEqual(typeOf(a), &quot;Data/TDataTypeCtor&quot;).x
	a = Tp.DataTypeCtor	&apos; the data ctor
	assertEqual(typeOf(a), &quot;Data/TDataCtor&quot;).x
	a = applyDC(DataTypeCtor)	&apos; the fn that applies the data ctor
	assertEqual(typeOf(a), &quot;Object/TFn&quot;).x
	
	a = TList	&apos; the data type ctor
	assertEqual(typeOf(a), &quot;Data/TDataTypeCtor&quot;).x
	a = Tp.List	&apos; the data type ctor
	assertEqual(typeOf(a), &quot;Data/TDataTypeCtor&quot;).x
	a = TList	&apos; the data type ctor
	assertEqual(typeOf(a), &quot;Data/TDataTypeCtor&quot;).x
	a = TList(Tp.TType_Int)	&apos; the applied data type ctor
	assertEqual(typeOf(a), &quot;Data/[Int]&quot;).x
	
	a = Tp.List_Nil	&apos; the data ctor
	assertEqual(typeOf(a), &quot;Data/TDataCtor&quot;).x
	a = nil	&apos; returns the singleton *value*
	assertEqual(typeOf(a), &quot;Data/[a0]&quot;).x
	
	a = Tp.List_Cons	&apos; the data ctor
	assertEqual(typeOf(a), &quot;Data/TDataCtor&quot;).x
	a = cons(nil, nil)	&apos; a cons value
	assertEqual(typeOf(a), &quot;Data/[[a0]]&quot;).x
	
End Function


&apos; isObject is a BASIC function:
&apos; make sure we know exactly what it does
Function test_Type_isObject()
	Dim o As Object

	assertEqual(isObject(Nothing),	True).x

	assertEqual(isObject(Empty),	False).x
	assertEqual(isObject(True),		False).x
	assertEqual(isObject(False),	False).x
	assertEqual(isObject(&quot;&quot;),		False).x
	assertEqual(isObject(&quot;foobar&quot;),	False).x
	assertEqual(isObject( 0),		False).x
	assertEqual(isObject( 1),		False).x
	assertEqual(isObject(-1),		False).x
	assertEqual(isObject(3.1415),	False).x
	assertEqual(isObject(Array()),	False).x

	o = New TTest_Foo
	assertEqual(isObject(o), True).x
	o.bar = 4711
	assertEqual(isObject(o), True).x
End Function

&apos; isString: implemented above
Function test_Type_isString()
	assertEqual(isString(&quot;&quot;),                  True).x
	assertEqual(isString(&quot;a&quot;),                 True).x
	assertEqual(isString(&quot;foobar&quot;),            True).x
	assertEqual(isString(Nothing),            False).x
	assertEqual(isString(Empty),              False).x
	assertEqual(isString(True),               False).x
	assertEqual(isString(False),              False).x
	assertEqual(isString(0),                  False).x
	assertEqual(isString(1),                  False).x
	assertEqual(isString(3.14),               False).x
	assertEqual(isString(Array()),            False).x
	assertEqual(isString(Array(42)),          False).x
	assertEqual(isString(Array(42)),          False).x
	
	assertEqual(arity(Fn.isString),	1).x &apos; from Fn object
	assertEqual(arity(isString),	1).x &apos; from 0-arg call
	
	assertEqual(apply(isString, &quot;&quot;),         True).x
	assertEqual(apply(isString, &quot;a&quot;),        True).x
	assertEqual(apply(isString, &quot;foobar&quot;),   True).x
	assertEqual(apply(isString, Nothing),   False).x
	assertEqual(apply(isString, Empty),     False).x
	assertEqual(apply(isString, True),      False).x
	assertEqual(apply(isString, False),     False).x
	assertEqual(apply(isString, 0),         False).x
	assertEqual(apply(isString, 1),         False).x
	assertEqual(apply(isString, 3.14),      False).x
	assertEqual(apply(isString, Array()),   False).x
	assertEqual(apply(isString, Array(42)), False).x
	assertEqual(apply(isString, Array(42)), False).x
End Function

&apos; isInteger: implemented above
Function test_Type_isInteger()
	assertEqual(isInteger(&quot;&quot;),                 False).x
	assertEqual(isInteger(&quot;a&quot;),                False).x
	assertEqual(isInteger(&quot;foobar&quot;),           False).x
	assertEqual(isInteger(Nothing),            False).x
	assertEqual(isInteger(Empty),              False).x
	assertEqual(isInteger(True),               False).x
	assertEqual(isInteger(False),              False).x
	assertEqual(isInteger( 0),                  True).x
	assertEqual(isInteger( 1),                  True).x
	assertEqual(isInteger(-1),                  True).x
	assertEqual(isInteger( 32766),              True).x &apos;0x7FFE
	assertEqual(isInteger( 32767),              True).x &apos;0x7FFF
	assertEqual(isInteger( 32768),             False).x &apos;0x8000 (!)
	assertEqual(isInteger( 65534),             False).x &apos;0xFFFE
	assertEqual(isInteger( 65535),             False).x &apos;0xFFFF
	assertEqual(isInteger( 65536),             False).x &apos;0x80000
	assertEqual(isInteger(-32766),              True).x &apos;0x8002
	assertEqual(isInteger(-32767),              True).x &apos;0x8001
	assertEqual(isInteger(-32768),              True).x &apos;0x8000
	assertEqual(isInteger(-32769),             False).x &apos;0x17FFF (!)
	assertEqual(isInteger(-65534),             False).x &apos;0xFFFE
	assertEqual(isInteger(-65535),             False).x &apos;0xFFFF
	assertEqual(isInteger(-65536),             False).x &apos;0x80000
	assertEqual(isInteger(3.14),               False).x
	assertEqual(isInteger(Array()),            False).x
	assertEqual(isInteger(Array(42)),          False).x
	assertEqual(isInteger(Array(42)),          False).x
End Function

Function test_Type_isDataValue()
	&apos; positive tests below
	assertEqual(isDataValue(&quot;&quot;),                 False).x
	assertEqual(isDataValue(&quot;a&quot;),                False).x
	assertEqual(isDataValue(&quot;foobar&quot;),           False).x
	assertEqual(isDataValue(Nothing),            False).x
	assertEqual(isDataValue(Empty),              False).x
	assertEqual(isDataValue(True),               False).x
	assertEqual(isDataValue(False),              False).x
	assertEqual(isDataValue( 0),                 False).x
	assertEqual(isDataValue( 1),                 False).x
	assertEqual(isDataValue(-1),                 False).x
	assertEqual(isDataValue( 32766),             False).x &apos;0x7FFE
	assertEqual(isDataValue( 32767),             False).x &apos;0x7FFF
	assertEqual(isDataValue( 32768),             False).x &apos;0x8000 (!)
	assertEqual(isDataValue( 65534),             False).x &apos;0xFFFE
	assertEqual(isDataValue( 65535),             False).x &apos;0xFFFF
	assertEqual(isDataValue( 65536),             False).x &apos;0x80000
	assertEqual(isDataValue(-32766),             False).x &apos;0x8002
	assertEqual(isDataValue(-32767),             False).x &apos;0x8001
	assertEqual(isDataValue(-32768),             False).x &apos;0x8000
	assertEqual(isDataValue(-32769),             False).x &apos;0x17FFF (!)
	assertEqual(isDataValue(-65534),             False).x &apos;0xFFFE
	assertEqual(isDataValue(-65535),             False).x &apos;0xFFFF
	assertEqual(isDataValue(-65536),             False).x &apos;0x80000
	assertEqual(isDataValue(3.14),               False).x
	assertEqual(isDataValue(Array()),            False).x
	assertEqual(isDataValue(Array(42)),          False).x
	assertEqual(isDataValue(Array(42)),          False).x
End Function

Function test_Type_DataValue()
	Dim v, c
	v = _newDataValue(Nothing, emptyArray)
	assertEqual(v.ctor, Nothing)
	assertEqual(LBound(v.fields),  0).x
	assertEqual(UBound(v.fields), -1).x
	assertEqual(isDataValue(v), True).x

	v = _newDataValue(Nothing, Array(42))
	assertEqual(v.ctor, Nothing)
	assertEqual(UBound(v.fields), 0).x
	assertEqual(v.fields(0), 42).x 
	assertEqual(isDataValue(v), True).x

	v = _newDataValue(Nothing, Array(&quot;foo&quot;, 4711))
	assertEqual(v.ctor, Nothing)
	assertEqual(UBound(v.fields), 1).x
	assertEqual(v.fields(0), &quot;foo&quot;).x 
	assertEqual(v.fields(1), 4711).x 
	assertEqual(isDataValue(v), True).x
End Function

	
Function test_Type_ctorOf(Optional missing)
	If Not isMissing(missing) Then
		croak(&quot;test_Type_ctorOf: must NOT pass argument!&quot;)
	End If
	
	&apos; VarType returns an Integer:
	assertEqual(VarType(VarType(Empty)), VarType(CInt(0))).x
	
	assertEqual(VarType(Empty),		0).x
	&apos;assertEqual(VarType(?),		1).x	&apos; doc says &quot;Null&quot; (?!)
	assertEqual(VarType(CInt(0)),	2).x
	assertEqual(VarType(CLng(0)),	3).x
	assertEqual(VarType(CSng(0)),	4).x
	assertEqual(VarType(CDbl(0)),	5).x
	&apos;assertEqual(VarType(?),	6).x		&apos; left empty in doc
	assertEqual(VarType(Date),		7).x
	assertEqual(VarType(&quot;string&quot;),	8).x
	assertEqual(VarType(Nothing),	9).x
	assertEqual(VarType(missing),	10).x
	assertEqual(VarType(True),		11).x
	&apos;assertEqual(VarType(?),		12).x	&apos; doc says &quot;Variant&quot;...
	assertEqual(VarType(CByte(0)),	17).x	&apos; not mentioned in doc
	
	Const vtArr = &amp;H2000
	Dim variantArray(0 To 3) As Variant
	assertEqual(VarType(variantArray),	vtArr + 12).x
	assertEqual(VarType(Array(1, 2)),	vtArr + 12).x
	Dim byteArray(0 To 3) As Byte
	assertEqual(VarType(byteArray),		vtArr + 17).x
	Dim intArray(0 To 3) As Integer
	assertEqual(VarType(intArray),		vtArr +  2).x
	Dim lngArray(0 To 3) As Long
	assertEqual(VarType(lngArray),		vtArr +  3).x
	Dim sngArray(0 To 3) As Single
	assertEqual(VarType(sngArray),		vtArr +  4).x
	Dim dblArray(0 To 3) As Double
	assertEqual(VarType(dblArray),		vtArr +  5).x
	Dim dateArray(0 To 3) As Date
	assertEqual(VarType(dateArray),		vtArr +  7).x
	Dim strArray(0 To 3) As String
	assertEqual(VarType(strArray),		vtArr +  8).x
	Dim objArray(0 To 3) As Object
	assertEqual(VarType(objArray),		vtArr +  9).x
	Dim boolArray(0 To 3) As Boolean
	assertEqual(VarType(boolArray),		vtArr + 11).x
	
	&apos; ATTENTION cByte, cInt, ... are BASIC *keywords*!
	Dim _Byte	 : _Byte	= Tp.Native_Byte
	Dim _Int	 : _Int		= Tp.Native_Integer
	Dim _Lng	 : _Lng		= Tp.Native_Long
	Dim _Sng	 : _Sng		= Tp.Native_Single
	Dim _Dbl	 : _Dbl		= Tp.Native_Double
	Dim _Str	 : _Str		= Tp.Native_String
	Dim _Bool	 : _Bool	= Tp.Native_Boolean
	Dim _Obj 	 : _Obj		= Tp.Native_Object
	Dim _Empty	 : _Empty	= Tp.Native_Empty
	Dim _Date	 : _Date	= Tp.Native_Date
	Dim _Array	 : _Array	= Tp.Native_Array
	Dim _Variant : _Variant	= Tp.Native_Variant
	
	assert_same(ctorOf(Nothing),		_Obj).x
	assert_same(ctorOf(Empty),			_Empty).x
	assert_same(ctorOf(True),			_Bool).x
	assert_same(ctorOf(False),			_Bool).x
	assert_same(ctorOf(&quot;&quot;),				_Str).x
	assert_same(ctorOf(&quot;blah&quot;),			_Str).x
	assert_same(ctorOf(CByte(0)),		_Byte).x
	assert_same(ctorOf( 0),				_Int).x
	assert_same(ctorOf( 1),				_Int).x
	assert_same(ctorOf(-1),				_Int).x
	assert_same(ctorOf(CLng(0)),		_Lng).x
	assert_same(ctorOf(CSng(0)),		_Sng).x
	assert_same(ctorOf(3.1415),			_Dbl).x
	assert_same(ctorOf(CDbl(0)),		_Dbl).x
	assert_same(ctorOf(Date),			_Date).x
	assert_same(ctorOf(Array()),		_Array).x

	Dim o As Object, act As Variant
	
	&apos; an object without member .ctor:
	o = New TTest_TyName
	assert_same(ctorOf(o), _Obj).x
	o.tyname = &quot;foo&quot;
	assert_same(ctorOf(o), _Obj).x

	&apos; an object with a member .ctor: ~&gt; &quot;invalid .ctor&quot;
	o = New TTest_Ctor
	o.ctor = Empty		: assertThrows(ctorOf, Array(o)).x
	o.ctor = Nothing	: assertThrows(ctorOf, Array(o)).x
	o.ctor = True		: assertThrows(ctorOf, Array(o)).x
	o.ctor = False		: assertThrows(ctorOf, Array(o)).x
	o.ctor = &quot;&quot;			: assertThrows(ctorOf, Array(o)).x
	o.ctor = &quot;foo&quot;		: assertThrows(ctorOf, Array(o)).x
	o.ctor =  0			: assertThrows(ctorOf, Array(o)).x
	o.ctor =  1			: assertThrows(ctorOf, Array(o)).x
	o.ctor = -1			: assertThrows(ctorOf, Array(o)).x
	o.ctor = 3.1415		: assertThrows(ctorOf, Array(o)).x
	o.ctor = Array()	: assertThrows(ctorOf, Array(o)).x
	&apos; even a fn object:
	o.ctor = ctorOf		: assertThrows(ctorOf, Array(o)).x
	
	&apos; data values:
	assert_same(ctorOf(Tp.DataTypeCtor),	Tp.DataCtor).x
	assert_same(ctorOf(Tp.TDataTypeCtor),	Tp.DataTypeCtor).x

	assert_same(ctorOf(Tp.DataCtor),		Tp.DataCtor).x
	assert_same(ctorOf(Tp.TDataCtor),		Tp.DataTypeCtor).x
	
	assert_same(ctorOf(Tp.TType),		Tp.DataTypeCtor).x
	assert_same(ctorOf(Tp.TType_App),	Tp.DataCtor).x
	assert_same(ctorOf(Tp.TType_Param),	Tp.DataCtor).x
	assert_same(ctorOf(_Byte),			Tp.DataCtor).x
	assert_same(ctorOf(_Int),			Tp.DataCtor).x
	assert_same(ctorOf(_Lng),			Tp.DataCtor).x
	assert_same(ctorOf(_Sng),			Tp.DataCtor).x
	assert_same(ctorOf(_Dbl),			Tp.DataCtor).x
	assert_same(ctorOf(_Str),			Tp.DataCtor).x
	assert_same(ctorOf(_Bool),			Tp.DataCtor).x
	assert_same(ctorOf(_Empty),			Tp.DataCtor).x
	assert_same(ctorOf(_Obj),			Tp.DataCtor).x
	assert_same(ctorOf(_Date),			Tp.DataCtor).x
	assert_same(ctorOf(_Array),			Tp.DataCtor).x
	assert_same(ctorOf(_Variant),		Tp.DataCtor).x
	
	Dim _Nil  : _Nil  = Tp.List_Nil
	Dim _Cons : _Cons = Tp.List_Cons
	
	assert_same(ctorOf(Tp.List),	Tp.DataTypeCtor).x
	assert_same(ctorOf(_Nil),		Tp.DataCtor).x
	assert_same(ctorOf(_Cons),		Tp.DataCtor).x

	Dim vNil : vNil = field(DataCtor_argTypes, _Nil)
	assert_same(ctorOf(vNil),	_Nil).x
	Dim vCons : vCons = field(DataCtor_argTypes, _Cons)
	assert_same(ctorOf(vCons),	_Cons).x

	assert_same(ctorOf(applyDC(_Str)),	_Cons).x
	
End Function

Function bootstrapTypes()
	Dim vNil
	&apos; The most simple DataValue is one without any fields.
	&apos; Since we don&apos;t have data ctors yet we&apos;ll leave the
	&apos; .ctor member empty.
	vNil = _newDataValue(Nothing, emptyArray)
	&apos; The function DataValue_genericToString provides a way to
	&apos; see what&apos;s inside a DataValue:
	Dim vNilStr As String
	vNilStr = DataValue_genericToString(vNil)
	assertEqual( _
		vNilStr, _
		&quot;{ id: &quot; &amp; vNil.id &amp; &quot;,&quot;	&amp; NL &amp; _
		&quot;  ctor: Nothing,&quot;			&amp; NL &amp; _
		&quot;  fields: Array()&quot;			&amp; NL &amp; _
		&quot;}&quot;							       _
	).x
	&apos; We can see that there&apos;s another member: .id, which is unique
	&apos; to the particular DataValue instance. This gives rise to a 
	&apos; notion of sameness. The function `DataValue_same` provides a
	&apos; means of testing for sameness:
	assertEqual(DataValue_same(vNil, vNil), True).x
	&apos; Even if we provide the very same values, we&apos;ll get a
	&apos; different instance:
	Dim x
	x = _newDataValue(Nothing, emptyArray)
	assertEqual(DataValue_same(x, vNil), False).x
	&apos; To make the tests more readable we&apos;ll abbreviate that to
	refute_same(x, vNil).x
	&apos; and for a positive test:
	assert_same(x,    x).x
	assert_same(vNil, vNil).x
	&apos; ...which simply means that &quot;sameness&quot; is of course
	&apos; reflexive, ie for all x, y: if x = y then x same y.
	&apos; It is - again of course - 
	&apos; symmetric, ie forall x, y: x same y iff y same x.
	assertEqual(_
		DataValue_same(vNil, x), _
		DataValue_same(x, vNil) _
	).x
	
	&apos; Now we have to fill in the .ctor member of vNil, which should
	&apos; point to vNil&apos;s data ctor.
	&apos; A data ctor has
	&apos;   - a name (a String)
	&apos;   - a list of argument types (tbd)
	&apos;   - a pointer to its datatype ctor (tbd)
	&apos; ...and we&apos;ll consider DataValue s with a .ctor member pointing
	&apos; to it as having been &quot;created&quot; from that data ctor.
	&apos; We already can provide a name, and for the particular data ctor
	&apos; of vNil - which has no fields whatsoever - we can also provide
	&apos; the list of argument types: it&apos;s just the empty list, represented
	&apos; by vNil.
	&apos; If we want to represent data ctors as DataValue as well,
	&apos; then they in turn need a .ctor member. For now we&apos;ll leave it
	&apos; empty.
	Dim cNil
	cNil = _newDataValue(Nothing, Array( _
		&quot;Nil&quot;, _
		vNil, _
		Nothing _
	)
	assertEqual(isDataValue(cNil), True).x
	&apos; The data ctor is different from the value, even if the data ctor
	&apos; takes no arguments:
	refute_same(cNil, vNil).x
	&apos; Let&apos;s make sure that cNil has an empty argument list.
	&apos; We&apos;ll use the fn `field` and constants to index into a
	&apos; DataValue&apos;s fields:
	assert_same(field(DataCtor_argTypes, cNil), vNil).x
	&apos; Fill in cNil as vNil&apos;s .ctor and see what it looks like then:
	vNil.ctor = cNil
	vNilStr = DataValue_genericToString(vNil)
	assertEqual( vNilStr, _
		&quot;{ id: &quot; &amp; vNil.id &amp; &quot;,&quot;			&amp; NL &amp; _
		&quot;  ctor: { id: &quot; &amp; cNil.id &amp; &quot;,&quot;	&amp; NL &amp; _
		&quot;    ctor: Nothing,&quot;				&amp; NL &amp; _
		&quot;    fields: Array(&quot;				&amp; NL &amp; _
		&quot;      &apos;Nil&apos;,&quot;						&amp; NL &amp; _ 
		&quot;      { id: &quot; &amp; vNil.id &amp; &quot; },&quot;	&amp; NL &amp; _ 
		&quot;      Nothing&quot;						&amp; NL &amp; _
		&quot;    )&quot;								&amp; NL &amp; _
		&quot;  },&quot;								&amp; NL &amp; _
		&quot;  fields: Array()&quot;					&amp; NL &amp; _
		&quot;}&quot;										   _
	).x
	&apos; We&apos;ve just created a circular structure:
	&apos; vNil refers to cNil via .ctor and cNil refers to vNil
	&apos; via field argTypes. DataValue_genericToString resolves
	&apos; the problem by showing only the .id member of previously
	&apos; encountered DataValue s.
	&apos; Looking at cNil (first):
	Dim cNilStr
	cNilStr = DataValue_genericToString(cNil)
	assertEqual(cNilStr, _
		&quot;{ id: &quot; &amp; cNil.id &amp; &quot;,&quot;				&amp; NL &amp; _
		&quot;  ctor: Nothing,&quot;						&amp; NL &amp; _
		&quot;  fields: Array(&quot;						&amp; NL &amp; _
		&quot;    &apos;Nil&apos;,&quot;							&amp; NL &amp; _ 
		&quot;    { id: &quot; &amp; vNil.id &amp; &quot;,&quot;			&amp; NL &amp; _ 
		&quot;      ctor: { id: &quot; &amp; cNil.id &amp; &quot; },&quot;	&amp; NL &amp; _
		&quot;      fields: Array()&quot;					&amp; NL &amp; _
		&quot;    },&quot;								&amp; NL &amp; _
		&quot;    Nothing&quot;							&amp; NL &amp; _
		&quot;  )&quot;									&amp; NL &amp; _
		&quot;}&quot;											   _
	).x

	&apos; access ctor fields:
	&apos; TODO: why not .fields ?
	Dim c
	c = ctorOf(vNil)
	assertEqual(field(DataCtor_name,     c), &quot;Nil&quot;).x
	assert_same(field(DataCtor_argTypes, c), vNil).x
	assertEqual(field(DataCtor_typeCtor, c), Nothing).x
	
	
	
	
	
	
	
	&apos; Since the ctor is itself a DataValue - what&apos;s the ctor of that ctor?
	Dim cDataCtor As DataValue
	&apos; it&apos;ll be a DataValue again, and it&apos;ll be a data ctor with
	&apos; - name: &quot;DataCtor&quot;
	&apos; - argTypes: a list of argument types
	&apos; - and as the third field typeCtor: a DataTypeCtor
	&apos; The typeCtor field will be left empty for now, but we must mention
	&apos; it in the definition of DataCtor. Therefore there are not only
	&apos; two entries in argTypes - &quot;String&quot; and &quot;List_of_TypeExpr&quot; - but three: the
	&apos; third must be &quot;TDataTypeCtor&quot;.
	Dim cName As String, argTypes As Variant
	cName    = &quot;DataCtor&quot;
	&apos; The argTypes should be types (type expressions), which we don&apos;t
	&apos; have yet.
	&apos; But types (type expressions) may also be type variables. Let&apos;s
	&apos; just use plain strings and pretend they&apos;re type vars.
	&apos; Similarly, since we don&apos;t have the List data type yet, we&apos;ll
	&apos; use a native Array instead for argTypes and pretend it were a
	&apos; List.
	argTypes = Array(&quot;String&quot;, &quot;List_of_TypeExpr&quot;, &quot;TDataTypeCtor&quot;)
	cDataCtor = _newDataValue(Nothing, Array(cName, argTypes, Nothing))
	c = cDataCtor
	assertEqual(           field(DataCtor_name,     c), cName).x
	assert_toString_equals(field(DataCtor_argTypes, c), argTypes).x
	assertEqual(           field(DataCtor_typeCtor, c), Nothing).x

	&apos; What does it look like?
	Dim cDataCtorStr As String
	cDataCtorStr = DataValue_genericToString(cDataCtor)
	&apos;msgbox(cDataCtorStr)
	assertEqual( _
		cDataCtorStr, _
		&quot;{ id: &quot; &amp; cDataCtor.id &amp; &quot;,&quot;	&amp; NL &amp; _
		&quot;  ctor: Nothing,&quot;				&amp; NL &amp; _
		&quot;  fields: Array(&quot;				&amp; NL &amp; _
		&quot;    &apos;DataCtor&apos;,&quot;				&amp; NL &amp; _ 
		&quot;    Array(&quot;					&amp; NL &amp; _
		&quot;      &apos;String&apos;,&quot;				&amp; NL &amp; _
		&quot;      &apos;List_of_TypeExpr&apos;,&quot;		&amp; NL &amp; _
		&quot;      &apos;TDataTypeCtor&apos;&quot;			&amp; NL &amp; _
		&quot;    ),&quot;						&amp; NL &amp; _
		&quot;    Nothing&quot;					&amp; NL &amp; _
		&quot;  )&quot;							&amp; NL &amp; _
		&quot;}&quot;							           _
	).x

	&apos; Let&apos;s put this in as cNil&apos;s .ctor:
	cNil.ctor = cDataCtor
	&apos; Now cNil looks like this:
	cNilStr = DataValue_genericToString(cNil)
	assertEqual( _
		cNilStr, _
		&quot;{ id: &quot; &amp; cNil.id &amp; &quot;,&quot;				&amp; NL &amp; _
		&quot;  ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot;,&quot;	&amp; NL &amp; _
		&quot;    ctor: Nothing,&quot;					&amp; NL &amp; _
		&quot;    fields: Array(&quot;					&amp; NL &amp; _
		&quot;      &apos;DataCtor&apos;,&quot;						&amp; NL &amp; _ 
		&quot;      Array(&quot;							&amp; NL &amp; _ 
		&quot;        &apos;String&apos;,&quot;						&amp; NL &amp; _ 
		&quot;        &apos;List_of_TypeExpr&apos;,&quot;			&amp; NL &amp; _ 
		&quot;        &apos;TDataTypeCtor&apos;&quot;				&amp; NL &amp; _ 
		&quot;      ),&quot;								&amp; NL &amp; _
		&quot;      Nothing&quot;							&amp; NL &amp; _
		&quot;    )&quot;									&amp; NL &amp; _
		&quot;  },&quot;									&amp; NL &amp; _
		&quot;  fields: Array(&quot;						&amp; NL &amp; _
		&quot;    &apos;Nil&apos;,&quot;							&amp; NL &amp; _
		&quot;    { id: &quot; &amp; vNil.id &amp; &quot;,&quot;			&amp; NL &amp; _
		&quot;      ctor: { id: &quot; &amp; cNil.id &amp; &quot; },&quot;	&amp; NL &amp; _
		&quot;      fields: Array()&quot;					&amp; NL &amp; _
		&quot;    },&quot;								&amp; NL &amp; _
		&quot;    Nothing&quot;							&amp; NL &amp; _
		&quot;  )&quot;									&amp; NL &amp; _
		&quot;}&quot; _
	).x
	
	
	&apos; What&apos;s the ctor of cDataCtor?
	&apos; Since again, cDataCtor is just a DataValue, it&apos;s constructor
	&apos; must be a data ctor as we have just described, ie have fields:
	&apos; - 1st a String for the name - which we don&apos;t care about
	&apos; - 2nd a three-elem list with types &quot;String&quot;, &quot;List_of_Type_Expr&quot;
	&apos;       and &quot;TDataTypeCtor&quot;
	&apos; - 3rd a a value of type &quot;TDataTypeCtor&quot; (still left empty)
	&apos; But that&apos;s just cDataCtor itself!
	cDataCtor.ctor = cDataCtor
	&apos; Also: once we worked out the typeCtor field (left empty but we
	&apos; already &quot;know&quot; it must be a value of type &quot;TDataTypeCtor&quot;)
	&apos; - it&apos;ll work just fine as the typeCtor for both cDataCtor, and
	&apos; its constructor. Proof: if it works for cDataCtor then it will
	&apos; work for cDataCtor :)
	
	&apos; But we&apos;ve created a problem with traversing the structure
	&apos; in order to create a string representation. 
	&apos; TODO: infinite regression in toString(cDataCtor) via .ctor
	&apos; In the special case at hand, DataCtor, it&apos;s enough to not
	&apos; go down the .ctor member if it&apos;s the same as the current
	&apos; instance. This is indicated by &quot;-&gt;self&quot;:
	cDataCtorStr = DataValue_genericToString(cDataCtor)
	assertEqual( _
		cDataCtorStr, _
		&quot;{ id: &quot; &amp; cDataCtor.id &amp; &quot;,&quot;			&amp; NL &amp; _
		&quot;  ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot; },&quot;	&amp; NL &amp; _
		&quot;  fields: Array(&quot;						&amp; NL &amp; _
		&quot;    &apos;DataCtor&apos;,&quot;						&amp; NL &amp; _
		&quot;    Array(&quot;							&amp; NL &amp; _
		&quot;      &apos;String&apos;,&quot;						&amp; NL &amp; _
		&quot;      &apos;List_of_TypeExpr&apos;,&quot;				&amp; NL &amp; _
		&quot;      &apos;TDataTypeCtor&apos;&quot;					&amp; NL &amp; _
		&quot;    ),&quot;								&amp; NL &amp; _
		&quot;    Nothing&quot;							&amp; NL &amp; _
		&quot;  )&quot;									&amp; NL &amp; _
		&quot;}&quot; _
	).x
	
	
	&apos; So what&apos;s the type of cDataCtor, ie what should we put in its 
	&apos; typeCtor field?
	&apos; It&apos;s the very simple data type
	&apos;   TDataCtor = DataCtor Str (List TypeExpr)
	&apos; The &quot;DataCtor&quot; on the rhs is just a data ctor as we have defined,
	&apos; and its name is &quot;DataCtor&quot;.
	&apos; On the lhs, however, it&apos;s a DataTypeCtor and there&apos;s &quot;T&quot; as a name
	&apos; prefix. We *could* have given it just the same name, but the &quot;T&quot; may
	&apos; help to reduce confusion (a little bit...).
	&apos; Now, a DataTypeCtor has
	&apos; - a name (a String)
	&apos; - an arity (an Integer), which is the nr of it&apos;s type parameters
	&apos; - zero or more DataCtors
	&apos; We can describe that by defining another data ctor - which itself,
	&apos; as we saw, has DataCtor as it&apos;s (data) constructor:
	Dim cDataTypeCtor As DataValue, arity As Integer
	cDataTypeCtor = _newDataValue(cDataCtor, Array( _
		&quot;DataTypeCtor&quot;, _
		Array(&quot;String&quot;, &quot;Integer&quot;, &quot;List_of_DataCtor&quot;), _
		Nothing _
	))
	&apos; Except for the typeCtor field - again left empty -
	&apos; what we&apos;ve just done will be bread-and-butter: create a value
	&apos; from a data ctor where the value&apos;s fields are filled with the
	&apos; argument values - provided they comply with the data ctor&apos;s
	&apos; argTypes.
	&apos; However, we cannot factor this pattern out until we&apos;ve completed
	&apos; the bootstrap.
	cDataTypeCtor = _newDataValue(cDataCtor, Array( _
		&quot;DataTypeCtor&quot;, _
		Array(&quot;String&quot;, &quot;Integer&quot;, &quot;List_of_DataCtor&quot;), _
		Nothing _
	))
	assertEqual(DataValue_same(ctorOf(cDataTypeCtor), cDataCtor), True).x

	&apos;TODO: Another repeated pattern is that of making DataValues that serve
	&apos; serve as DataCtor s:
	&apos;cTypeCtor = _mkDataCtor(&quot;DataTypeCtor&quot;, Nothing)
	&apos; This will stick in the repeated cDataCtor as .ctor member and
	&apos; Array(&quot;String&quot;, &quot;Integer&quot;, &quot;List_of_DataCtor&quot;) as argType field
	
	&apos; Let&apos;s inspect cDataTypeCtor.
	Dim cDataTypeCtorStr As String
	cDataTypeCtorStr = DataValue_genericToString(cDataTypeCtor)
	assertEqual( _
		cDataTypeCtorStr, _
		&quot;{ id: &quot; &amp; cDataTypeCtor.id &amp; &quot;,&quot;			&amp; NL &amp; _
		&quot;  ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot;,&quot;		&amp; NL &amp; _
		&quot;    ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot; },&quot;	&amp; NL &amp; _
		&quot;    fields: Array(&quot;						&amp; NL &amp; _
		&quot;      &apos;DataCtor&apos;,&quot;							&amp; NL &amp; _
		&quot;      Array(&quot;								&amp; NL &amp; _
		&quot;        &apos;String&apos;,&quot;							&amp; NL &amp; _
		&quot;        &apos;List_of_TypeExpr&apos;,&quot;				&amp; NL &amp; _
		&quot;        &apos;TDataTypeCtor&apos;&quot;					&amp; NL &amp; _
		&quot;      ),&quot;									&amp; NL &amp; _
		&quot;      Nothing&quot;								&amp; NL &amp; _
		&quot;    )&quot;										&amp; NL &amp; _
		&quot;  },&quot;										&amp; NL &amp; _
		&quot;  fields: Array(&quot;							&amp; NL &amp; _
		&quot;    &apos;DataTypeCtor&apos;,&quot;						&amp; NL &amp; _
		&quot;    Array(&quot;								&amp; NL &amp; _
		&quot;      &apos;String&apos;,&quot;							&amp; NL &amp; _
		&quot;      &apos;Integer&apos;,&quot;							&amp; NL &amp; _
		&quot;      &apos;List_of_DataCtor&apos;&quot;					&amp; NL &amp; _
		&quot;    ),&quot;									&amp; NL &amp; _
		&quot;    Nothing&quot;								&amp; NL &amp; _
		&quot;  )&quot;										&amp; NL &amp; _
		&quot;}&quot; _
	).x
	
	
	&apos; Now we&apos;ll make a value from that cDataTypeCtor, and that value
	&apos; will serve as the typeCtor for DataCtor:
	Dim tcDataCtor As DataValue
	tcDataCtor = _newDataValue(cDataTypeCtor, Array( _
		&quot;TDataCtor&quot;, _
		0, _
		Array(cDataCtor) _
	)
	&apos; Since cDataCtor is a (the only) data ctor of tcDataCtor, cDataCtor&apos;s
	&apos; &quot;typeCtor&quot; field points back to tcDataCtor. We could do this by indexing
	&apos; into the .fields member and writing it there, like so:
	&apos; cDataCtor.fields(DataCtor_typeCtor) = tcDataCtor
	&apos; But again, this pointer-fixing will occur everytime we create a new
	&apos; data type (and its constructors), so:
 	assertEqual(field(DataCtor_typeCtor, cDataCtor), Nothing).x
	&apos; was empty, now set it:
	_setTypeCtor(cDataCtor, tcDataCtor)
	&apos; now it&apos;s set:
	Dim it
	it = field(DataCtor_typeCtor, cDataCtor)
	assertEqual(DataValue_same(it, tcDataCtor), True).x
	&apos; we also have constants for accessing a DataTypeCtor&apos;s fields:	
	assertEqual( _
		field(DataTypeCtor_name, it), _
		field(DataTypeCtor_name, tcDataCtor) ).x
	assertEqual( _
		field(DataTypeCtor_arity, it), _
		field(DataTypeCtor_arity, tcDataCtor) ).x
	
	it = field(DataTypeCtor_dataCtors, tcDataCtor)
	assertEqual(isArray(it), True).x
	assertEqual(DataValue_same(it(0), cDataCtor), True).x
	
	Dim tcDatStr As String
	tcDatStr = DataValue_genericToString(tcDataCtor)
	
	&apos;msgbox(tcDatStr &amp; NL &amp; NL &amp; _
	assertEqual(tcDatStr, _
		&quot;{ id: &quot; &amp; tcDataCtor.id &amp; &quot;,&quot;				&amp; NL &amp; _
		&quot;  ctor: { id: &quot; &amp; cDataTypeCtor.id &amp; &quot;,&quot;	&amp; NL &amp; _
		&quot;    ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot;,&quot;		&amp; NL &amp; _
		&quot;      ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot; },&quot;	&amp; NL &amp; _
		&quot;      fields: Array(&quot;						&amp; NL &amp; _
		&quot;        &apos;DataCtor&apos;,&quot;						&amp; NL &amp; _
		&quot;        Array(&quot;							&amp; NL &amp; _
		&quot;          &apos;String&apos;,&quot;						&amp; NL &amp; _
		&quot;          &apos;List_of_TypeExpr&apos;,&quot;				&amp; NL &amp; _
		&quot;          &apos;TDataTypeCtor&apos;&quot;					&amp; NL &amp; _
		&quot;        ),&quot;								&amp; NL &amp; _
		&quot;        { id: &quot; &amp; tcDataCtor.id &amp; &quot; }&quot;		&amp; NL &amp; _
		&quot;      )&quot;									&amp; NL &amp; _
		&quot;    },&quot;									&amp; NL &amp; _
		&quot;    fields: Array(&quot;						&amp; NL &amp; _
		&quot;      &apos;DataTypeCtor&apos;,&quot;						&amp; NL &amp; _
		&quot;      Array(&quot;								&amp; NL &amp; _
		&quot;        &apos;String&apos;,&quot;							&amp; NL &amp; _
		&quot;        &apos;Integer&apos;,&quot;						&amp; NL &amp; _
		&quot;        &apos;List_of_DataCtor&apos;&quot;				&amp; NL &amp; _
		&quot;      ),&quot;									&amp; NL &amp; _
		&quot;      Nothing&quot;								&amp; NL &amp; _
		&quot;    )&quot;										&amp; NL &amp; _
		&quot;  },&quot;										&amp; NL &amp; _
		&quot;  fields: Array(&quot;							&amp; NL &amp; _
		&quot;    &apos;TDataCtor&apos;,&quot;							&amp; NL &amp; _
		&quot;    0,&quot;									&amp; NL &amp; _
		&quot;    Array(&quot;								&amp; NL &amp; _
		&quot;      { id: &quot; &amp; cDataCtor.id &amp; &quot; }&quot;		&amp; NL &amp; _
		&quot;    )&quot;										&amp; NL &amp; _
		&quot;  )&quot;										&amp; NL &amp; _
		&quot;}&quot; _
	).x
	
	&apos; What&apos;s still missing is a typeCtor for cDataTypeCtor. We already
	&apos; have a ctor to construct DataTypeCtor s: cDataTypeCtor. It&apos;ll
	&apos; be quite simple again, with only one data ctor (cDataTypeCtor),
	&apos; and name &quot;TDataTypeCtor&quot;:
	&apos; TDataTypeCtor = DataTypeCtor String Int (List DataCtor)
	Dim tcDataTypeCtor As DataValue
	tcDataTypeCtor = _newDataValue(cDataTypeCtor, Array( _
		&quot;TDataTypeCtor&quot;, _
		0, _
		Array(cDataTypeCtor) _
	))
	&apos; and fill in the back-pointer:
	_setTypeCtor(cDataTypeCtor, tcDataTypeCtor)
	assertEqual(DataValue_same( _
		field(DataCtor_typeCtor, cDataTypeCtor), _
		tcDataTypeCtor), True).x
	
	Dim tcDataTypeCtorStr As String
	tcDataTypeCtorStr = DataValue_genericToString(tcDataTypeCtor)
	
	&apos;msgbox(tcDataTypeCtorStr &amp; NL &amp; NL &amp; _
	assertEqual(tcDataTypeCtorStr, _
		&quot;{ id: &quot; &amp; tcDataTypeCtor.id &amp; &quot;,&quot;					&amp; NL &amp; _
		&quot;  ctor: { id: &quot; &amp; cDataTypeCtor.id &amp; &quot;,&quot;			&amp; NL &amp; _
		&quot;    ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot;,&quot;				&amp; NL &amp; _
		&quot;      ctor: { id: &quot; &amp; cDataCtor.id &amp; &quot; },&quot;			&amp; NL &amp; _
		&quot;      fields: Array(&quot;								&amp; NL &amp; _
		&quot;        &apos;DataCtor&apos;,&quot;								&amp; NL &amp; _
		&quot;        Array(&quot;									&amp; NL &amp; _
		&quot;          &apos;String&apos;,&quot;								&amp; NL &amp; _
		&quot;          &apos;List_of_TypeExpr&apos;,&quot;						&amp; NL &amp; _
		&quot;          &apos;TDataTypeCtor&apos;&quot;							&amp; NL &amp; _
		&quot;        ),&quot;										&amp; NL &amp; _
		&quot;        { id: &quot; &amp; tcDataCtor.id &amp; &quot;,&quot;				&amp; NL &amp; _
		&quot;          ctor: { id: &quot; &amp; cDataTypeCtor.id &amp; &quot; },&quot;	&amp; NL &amp; _
		&quot;          fields: Array(&quot;							&amp; NL &amp; _
		&quot;            &apos;TDataCtor&apos;,&quot;							&amp; NL &amp; _
		&quot;            0,&quot;									&amp; NL &amp; _
		&quot;            Array(&quot;								&amp; NL &amp; _
		&quot;              { id: &quot; &amp; cDataCtor.id &amp; &quot; }&quot;		&amp; NL &amp; _
		&quot;            )&quot;										&amp; NL &amp; _
		&quot;          )&quot;										&amp; NL &amp; _
		&quot;        }&quot;											&amp; NL &amp; _
		&quot;      )&quot;											&amp; NL &amp; _
		&quot;    },&quot;											&amp; NL &amp; _
		&quot;    fields: Array(&quot;								&amp; NL &amp; _
		&quot;      &apos;DataTypeCtor&apos;,&quot;								&amp; NL &amp; _
		&quot;      Array(&quot;										&amp; NL &amp; _
		&quot;        &apos;String&apos;,&quot;									&amp; NL &amp; _
		&quot;        &apos;Integer&apos;,&quot;								&amp; NL &amp; _
		&quot;        &apos;List_of_DataCtor&apos;&quot;						&amp; NL &amp; _
		&quot;      ),&quot;											&amp; NL &amp; _
		&quot;      { id: &quot; &amp; tcDataTypeCtor.id &amp; &quot; }&quot;			&amp; NL &amp; _
		&quot;    )&quot;												&amp; NL &amp; _
		&quot;  },&quot;												&amp; NL &amp; _
		&quot;  fields: Array(&quot;									&amp; NL &amp; _
		&quot;    &apos;TDataTypeCtor&apos;,&quot;								&amp; NL &amp; _
		&quot;    0,&quot;											&amp; NL &amp; _
		&quot;    Array(&quot;										&amp; NL &amp; _
		&quot;      { id: &quot; &amp; cDataTypeCtor.id &amp; &quot; }&quot;			&amp; NL &amp; _
		&quot;    )&quot;												&amp; NL &amp; _
		&quot;  )&quot;												&amp; NL &amp; _
		&quot;}&quot; _
	).x
	
	&apos; We have now established a structure of DataValue s where every
	&apos; DataValue has a
	&apos;   - a .ctor member which was made by &quot;applying&quot; cDataCtor to some arguments 
	&apos;   - a type ctor associated to it, and that is the .ctor&apos;s typeCtor field
	&apos; With that we can make more concise String representations of DataValue s.
	assertEqual(DataValue_toString(tcDataTypeCtor), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;TDataTypeCtor&apos; 0 Array(DataTypeCtor))&quot;).x
	assertEqual(DataValue_toString(tcDataCtor), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;TDataCtor&apos; 0 Array(DataCtor))&quot;).x
	assertEqual(DataValue_toString(cDataTypeCtor), _
		&quot;(TDataCtor.DataCtor &apos;DataTypeCtor&apos; Array(&apos;String&apos;, &apos;Integer&apos;, &apos;List_of_DataCtor&apos;) TDataTypeCtor)&quot;).x
	assertEqual(DataValue_toString(cDataCtor), _
		&quot;(TDataCtor.DataCtor &apos;DataCtor&apos; Array(&apos;String&apos;, &apos;List_of_TypeExpr&apos;, &apos;TDataTypeCtor&apos;) TDataCtor)&quot;).x
	
	&apos; The List data type
	&apos; ------------------
	
	&apos; Let&apos;s go back to old data ctor cNil. It itself has got a proper
	&apos; constructor (cDataCtor) but no DataTypeCtor in field typeCtor:
	assertEqual(field(DataCtor_typeCtor, cNil), Nothing).x
	
	&apos; So let&apos;s make one:
	Dim tcList As DataValue
	tcList = _newDataValue(cDataTypeCtor, Array( _
		&quot;List&quot;, 1, Nothing _
	))
	_setTypeCtor(cNil, tcList)
	&apos; There are two things that are different from what we did before:
	&apos;   - the arity field is set to 1, rather than 0
	&apos;   - the dataCtors field is left empty
	&apos; The former is to say that List will have a type parameter,
	&apos; and the latter is because we will be using *a List* again
	&apos; for this field - and once we have it do the same to the other
	&apos; TDataTypeCtor s we have.
	&apos; But before we can do so we need another data ctor for List:
	Dim cCons As DataValue
	cCons = _newDataValue(cDataCtor, Array( _
		&quot;Cons&quot;, vNil, tcList _
	))
	&apos; There we have left empty the argTypes field, again because we
	&apos; a List itself there. But we already filled in the type ctor:
	assert_same(field(DataCtor_typeCtor, cCons), tcList).x
	
	&apos; With those two data ctors we can now make List values.
	&apos; We already made one from cNil : vNil. It represents the 
	&apos; empty List. But that is exactly the argTypes list that 
	&apos; we want for the 0-arity data ctor cNil.
	cNil.fields(DataCtor_argTypes) = vNil
	&apos; A singleton list that contains just the data ctor cCons is this:
	x = _newDataValue(cCons, Array(cCons, vNil))
	&apos; ...and the two-elem list that contains both data ctors, cNil and
	&apos; and cCons - which we want for tcList&apos;s dataCtors field:
	tcList.fields(DataTypeCtor_dataCtors) = _newDataValue( _
		cCons, Array(cNil, x) _
	)

	assertEqual(DataValue_toString(tcList), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;List&apos; 1 [Nil, Cons])&quot;).x
	assertEqual(DataValue_toString(cCons), _
		&quot;(TDataCtor.DataCtor &apos;Cons&apos; [] List)&quot;).x
	assertEqual(DataValue_toString(cNil), _
		&quot;(TDataCtor.DataCtor &apos;Nil&apos; [] List)&quot;).x
	
	
	&apos; Now, we had given cCons an empty argTypes list, which needs to be fixed.
	&apos; We will express Types as yet another data type:
	Dim tcType As DataValue
	tcType = _newDataValue(cDataTypeCtor, Array(&quot;Type&quot;, 0, vNil))
	Dim cStr As DataValue, vStr As DataValue
	cStr = _newDataValue(cDataCtor, Array(&quot;String&quot;, vNil, tcType))
	&apos; add to dataCtors
	tcType.fields(DataTypeCtor_dataCtors) = _newDataValue(cCons, Array( _
		cStr, _
		field(DataTypeCtor_dataCtors, tcType) _
	))
	assertEqual(DataValue_toString(tcType), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;Type&apos; 0 [String])&quot;).x
	assertEqual(DataValue_toString(cStr), _
		&quot;(TDataCtor.DataCtor &apos;String&apos; [] Type)&quot;).x
	vStr = _newDataValue(cStr, Array())
	assertEqual(DataValue_toString(vStr), _
		&quot;Type.String&quot;).x
	
	
	Dim cInt As DataValue, vInt As DataValue
	cInt = _newDataValue(cDataCtor, Array(&quot;Integer&quot;, vNil, tcType))
	&apos; add to dataCtors
	tcType.fields(DataTypeCtor_dataCtors) = _newDataValue(cCons, Array( _
		cInt, _
		field(DataTypeCtor_dataCtors, tcType) _
	))
	assertEqual(DataValue_toString(tcType), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;Type&apos; 0 [Integer, String])&quot;).x
	assertEqual(DataValue_toString(cInt), _
		&quot;(TDataCtor.DataCtor &apos;Integer&apos; [] Type)&quot;).x
	vInt = _newDataValue(cInt, Array())
	assertEqual(DataValue_toString(vInt), _
		&quot;Type.Integer&quot;).x
	
	
	Dim cParam As DataValue
	cParam = _newDataValue(cDataCtor, Array( _
		&quot;TypeParam&quot;, _
		_newDataValue(cCons, Array(vInt, vNil)), _
		tcType _
	))
	&apos; add to dataCtors
	tcType.fields(DataTypeCtor_dataCtors) = _newDataValue(cCons, Array( _
		cParam, _
		field(DataTypeCtor_dataCtors, tcType) _
	))
	assertEqual(DataValue_toString(tcType), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;Type&apos; 0 [TypeParam, Integer, String])&quot;).x
	Dim vParam As DataValue
	vParam = _newDataValue(cParam, Array(0))
	assertEqual(DataValue_toString(vParam), _
		&quot;(Type.TypeParam 0)&quot;).x
	vParam.str = &quot;a0&quot;
	
	Dim cApp As DataValue
	cApp = _newDataValue(cDataCtor, Array( _
		&quot;TypeApp&quot;, _
		_newDataValue(cCons, Array(tcDataTypeCtor, _newDataValue(cCons, Array(tcType, vNil)))), _
		tcType _
	))
	&apos; add to dataCtors
	tcType.fields(DataTypeCtor_dataCtors) = _newDataValue(cCons, Array( _
		cApp, _
		field(DataTypeCtor_dataCtors, tcType) _
	))
	assertEqual(DataValue_toString(tcType), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;Type&apos; 0 [TypeApp, TypeParam, Integer, String])&quot;).x
	assertEqual(DataValue_toString(cApp), _
		&quot;(TDataCtor.DataCtor &apos;TypeApp&apos; [TDataTypeCtor, Type] Type)&quot;).x
	Dim vApp As DataValue
	vApp = _newDataValue(cApp, Array(tcList, vParam))
	assertEqual(DataValue_toString(vApp), _
		&quot;(Type.TypeApp (TDataTypeCtor.DataTypeCtor &apos;List&apos; 1 [Nil, Cons]) (Type.TypeParam 0))&quot;).x
	vApp.str = &quot;List &quot; &amp; vParam.str
	
	&apos; With vParam and vApp we can fix the argTypes List of cCons:
	argTypes = _
		_newDataValue(cCons, Array(vParam, _
		_newDataValue(cCons, Array(vApp, _
		vNil))))
	cCons.fields(DataCtor_argTypes) = argTypes
	assertEqual(DataValue_toString(cCons), _
		&quot;(TDataCtor.DataCtor &apos;Cons&apos; [(TypeParam 0), (TypeApp List (TypeParam 0))] List)&quot;).x
	
	
	&apos; fix the rest
	vApp = _newDataValue(cApp, Array(tcList, tcType))
	argTypes = vNil
	argTypes = _newDataValue(cCons, Array(tcDataTypeCtor, argTypes))
	argTypes = _newDataValue(cCons, Array(vApp,  argTypes))
	argTypes = _newDataValue(cCons, Array(vStr,  argTypes))
	cDataCtor.fields(DataCtor_argTypes) = argTypes
	assertEqual(DataValue_toString(cDataCtor), _
		&quot;(TDataCtor.DataCtor &apos;DataCtor&apos; [String, (TypeApp List Type), TDataTypeCtor] TDataCtor)&quot;).x
	
	
	tcDataCtor.fields(DataTypeCtor_dataCtors) = _newDataValue( _
		cCons, Array(cDataCtor , vNil))
	assertEqual(DataValue_toString(tcDataCtor), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;TDataCtor&apos; 0 [DataCtor])&quot;).x


	vApp = _newDataValue(cApp, Array(tcList, tcDataCtor))
	argTypes = vNil
	argTypes = _newDataValue(cCons, Array(vApp, argTypes))
	argTypes = _newDataValue(cCons, Array(vInt,  argTypes))
	argTypes = _newDataValue(cCons, Array(vStr,  argTypes))
	cDataTypeCtor.fields(DataCtor_argTypes) = argTypes
	assertEqual(DataValue_toString(cDataTypeCtor), _
		&quot;(TDataCtor.DataCtor &apos;DataTypeCtor&apos; [String, Integer, (TypeApp List TDataCtor)] TDataTypeCtor)&quot;).x
	
	
	tcDataTypeCtor.fields(DataTypeCtor_dataCtors) = _newDataValue( _
		cCons, Array(cDataTypeCtor , vNil))
	assertEqual(DataValue_toString(tcDataTypeCtor), _
		&quot;(TDataTypeCtor.DataTypeCtor &apos;TDataTypeCtor&apos; 0 [DataTypeCtor])&quot;).x
	
	&apos; from that we can reach everything in the object graph:
	bootstrapTypes = tcType
End Function	


Function test_bootstrapTypes()
	Dim tcType As Variant
	tcType = Tp.TType
	assertEqual(isDataValue(tcType), True).x
	assertEqual(fieldCount( tcType), 3).x
	assertEqual(field(DataTypeCtor_name,  tcType), &quot;Type&quot;).x
	assertEqual(field(DataTypeCtor_arity, tcType), 0).x
	&apos; field dataCtors later

	Dim cDataTypeCtor As Variant
	cDataTypeCtor = Tp.DataTypeCtor
	assertEqual(isDataValue(cDataTypeCtor), True).x
	assertEqual(fieldCount( cDataTypeCtor), 3).x
	assertEqual(field(DataTypeCtor_name, cDataTypeCtor), &quot;DataTypeCtor&quot;).x
	&apos; field argTypes later
	assert_hasCtor(tcType, cDataTypeCtor).x
	&apos; different from anything else so far:
	refute_same(cDataTypeCtor, tcType).x

	Dim tcDataTypeCtor As Variant
	tcDataTypeCtor = Tp.TDataTypeCtor
	assertEqual(isDataValue(tcDataTypeCtor), True).x
	assertEqual(fieldCount( tcDataTypeCtor), 3).x
	assertEqual(field(DataTypeCtor_name, tcDataTypeCtor), &quot;TDataTypeCtor&quot;).x
	assertEqual(field(DataTypeCtor_arity, tcDataTypeCtor), 0).x
	&apos; field dataCtors later
	assert_hasCtor(    tcDataTypeCtor,	cDataTypeCtor).x
	assert_hasTypeCtor(cDataTypeCtor,	tcDataTypeCtor).x
	&apos; TODO: confirm that tcDataTypeCtor dataCtors(0) = cDataTypeCtor
	&apos; different from anything else so far:
	refute_same(tcDataTypeCtor, tcType).x
	refute_same(tcDataTypeCtor, cDataTypeCtor).x

	Dim cDataCtor As Variant
	cDataCtor = Tp.DataCtor
	assertEqual(isDataValue(cDataCtor), True).x
	assertEqual(fieldCount( cDataCtor), 3).x
	assertEqual(field(DataCtor_name, cDataCtor), &quot;DataCtor&quot;).x
	&apos; field argTypes later
	assert_hasCtor(cDataCtor, 	cDataCtor).x
	assert_hasCtor(cDataTypeCtor,	cDataCtor).x
	&apos; different from anything else so far:
	refute_same(cDataCtor, tcType).x
	refute_same(cDataCtor, cDataTypeCtor).x
	refute_same(cDataCtor, tcDataTypeCtor).x
	
	Dim tcDataCtor As Variant
	tcDataCtor = Tp.TDataCtor
	assertEqual(isDataValue(tcDataCtor), True).x
	assertEqual(fieldCount( tcDataCtor), 3).x
	assertEqual(field(DataTypeCtor_name,  tcDataCtor), &quot;TDataCtor&quot;).x
	assertEqual(field(DataTypeCtor_arity, tcDataCtor), 0).x
	&apos; field dataCtors later
	assert_hasCtor(tcDataCtor, 		cDataTypeCtor).x
	assert_hasCtor(cDataTypeCtor, 	cDataCtor).x
	assert_hasTypeCtor(cDataCtor, 	tcDataCtor).x
	&apos; TODO: confirm that tcDataCtor dataCtors(0) = cDataCtor
	&apos; different from anything else so far:
	refute_same(tcDataCtor, tcType).x
	refute_same(tcDataCtor, cDataTypeCtor).x
	refute_same(tcDataCtor, tcDataTypeCtor).x
	refute_same(tcDataCtor, cDataCtor).x
	
	Dim tcList As Variant
	tcList = Tp.List
	assertEqual(isDataValue(tcList), True).x
	assertEqual(fieldCount(tcList), 3).x
	assertEqual(field(DataTypeCtor_name,  tcList), &quot;List&quot;).x
	assertEqual(field(DataTypeCtor_arity, tcList), 1).x
	&apos; its dataCtors field is a List instance:
	assert_hasTypeCtor(ctorOf(field(DataTypeCtor_dataCtors, tcList)), tcList).x
	assert_hasCtor(    tcList, cDataTypeCtor).x
	&apos; different from anything else so far:
	refute_same(tcList, tcType).x
	refute_same(tcList, cDataTypeCtor).x
	refute_same(tcList, tcDataTypeCtor).x
	refute_same(tcList, cDataCtor).x
	refute_same(tcList, tcDataCtor).x

	&apos; dataCtors fields of the other type ctors so far:
	assert_hasTypeCtor(ctorOf(field(DataTypeCtor_dataCtors, tcType)), 			tcList).x
	assert_hasTypeCtor(ctorOf(field(DataTypeCtor_dataCtors, tcDataTypeCtor)), 	tcList).x
	assert_hasTypeCtor(ctorOf(field(DataTypeCtor_dataCtors, tcDataCtor)), 		tcList).x

	&apos; argTypes fields of the data ctors so far:
	assert_hasTypeCtor(ctorOf(field(DataCtor_argTypes, cDataTypeCtor)),			tcList).x
	assert_hasTypeCtor(ctorOf(field(DataCtor_argTypes, cDataCtor)),				tcList).x
	

	&apos;---- data ctors of TList
	
	Dim vNil As Variant, cNil As Variant
	cNil = Tp.List_Nil
	assertEqual(isDataValue(cNil), True).x
	assertEqual(fieldCount(cNil),  3).x
	assert_hasCtor(    cNil, cDataCtor	).x
	assert_hasTypeCtor(cNil, tcList		).x
	
	vNil = applyDC(cNil)
	assertEqual(isDataValue(vNil), True).x
	assertEqual(fieldCount(vNil),  0).x
	&apos; applying cNil again yields the same instance:
	assert_same(applyDC(cNil), vNil).x
	assert_hasCtor(vNil, cNil).x

	&apos; Let&apos;s not test cNil&apos;s name, rather confirm that cNil is a
	&apos; singleton data ctor: its argTypes field is the same as vNil!
	assert_same(field(DataCtor_argTypes, cNil), vNil).x
	
	
	&apos; nil returns the same instance again
	assertEqual(DataValue_same(nil, vNil), True).x
	cNil = ctorOf(vNil)

	&apos; TList&apos;s dataCtors field is non-nil:
	Dim ListCtors
	ListCtors = field(DataTypeCtor_dataCtors, tcList)
	refute_same(ListCtors, vNil).x

	&apos; vNil is different from anything else so far:
	refute_same(vNil, tcType).x
	refute_same(vNil, cDataTypeCtor).x
	refute_same(vNil, tcDataTypeCtor).x
	refute_same(vNil, cDataCtor).x
	refute_same(vNil, tcDataCtor).x
	refute_same(vNil, tcList).x
	&apos; cNil is different from anything else so far:
	refute_same(cNil, vNil).x
	refute_same(cNil, tcType).x
	refute_same(cNil, cDataTypeCtor).x
	refute_same(cNil, tcDataTypeCtor).x
	refute_same(cNil, cDataCtor).x
	refute_same(cNil, tcDataCtor).x
	refute_same(cNil, tcList).x
	
	Dim cCons As Variant
	cCons = Tp.List_Cons
	assertEqual(isDataValue(cCons), True).x
	assert_hasCtor(    cCons, cDataCtor	).x
	assert_hasTypeCtor(cCons, tcList	).x
	&apos; Let&apos;s not test the name, rather confirm that it has 
	&apos; a non-nil argTypes field and is itself the data ctor of that!
	refute_same(field(DataCtor_argTypes, cCons), vNil).x
	assert_hasCtor(field(DataCtor_argTypes, cCons), cCons).x
	&apos; TList&apos;s dataCtors field is a cons value:
	assert_hasCtor(ListCtors, cCons).x

	&apos; cCons is different from anything else so far:
	refute_same(cCons, tcType).x
	refute_same(cCons, cDataTypeCtor).x
	refute_same(cCons, tcDataTypeCtor).x
	refute_same(cCons, cDataCtor).x
	refute_same(cCons, tcDataCtor).x
	refute_same(cCons, tcList).x
	refute_same(cCons, vNil).x
	refute_same(cCons, cNil).x
	
	&apos;--- apply cons, test isNil
	Dim xs As Variant, ys As Variant
	xs = vNil
	assertEqual(isNil(xs), True).x
	
	xs = cons(vNil, vNil)
	assertEqual(isDataValue(xs), True).x
	assert_hasCtor(xs, cCons).x
	assertEqual(isNil(xs), False).x
	ys = cons(vNil, xs)
	assertEqual(isDataValue(ys), True).x
	assert_hasCtor(ys, cCons).x
	assertEqual(isNil(ys), False).x
	
	assertThrows(isNil, Array(Empty)).x
	assertThrows(isNil, Array(Nothing)).x
	assertThrows(isNil, Array(0)).x
	assertThrows(isNil, Array(&quot;&quot;)).x
	assertThrows(isNil, Array(cNil)).x &apos; ctor != value
	
	&apos;--- List_car, List_cdr, List_nth
	xs = cons(vNil, cons(vNil, vNil))
	ys = cons(vNil, xs)
	assert_same(List_car(ys), vNil).x
	assert_same(List_cdr(ys), xs).x
	assert_same(List_car(xs), vNil).x
	xs = cons(2, cons(3, vNil))
	ys = cons(1, xs)
	assertEqual(                             List_car(ys),		1).x
	assert_same(              				 List_cdr(ys),	   xs).x
	assertEqual(                             List_car(xs),		2).x	
	assertEqual(                    List_car(List_cdr(ys)),		2).x	
	assertEqual(                    List_car(List_cdr(xs)),		3).x	
	assertEqual(           List_car(List_cdr(List_cdr(ys))),	3).x	
	assertEqual(	isNil(List_cdr(List_cdr(List_cdr(ys)))), 	True).x	

	assertEqual(            List_cadr(ys),	2).x	
	assertEqual(            List_cadr(xs),	3).x	
	assertEqual(	isNil( List_cddr(xs)),	True).x	
	assertEqual(           List_caddr(ys),	3).x	
	assertEqual(	isNil(List_cdddr(ys)),	True).x	

	assertEqual(List_nth(0, xs), 2).x
	assertEqual(List_nth(1, xs), 3).x
	assertEqual(List_nth(0, ys), 1).x
	assertEqual(List_nth(1, ys), 2).x
	assertEqual(List_nth(2, ys), 3).x

	&apos;--- List_length
	assertEqual(List_length(				  vNil), 	0).x
	assertEqual(List_length(		 cons(0, vNil)), 	1).x
	assertEqual(List_length(cons(0, cons(0, vNil))), 	2).x

	&apos;assertEqual(isFn(Fn.length), 	True).x	&apos; from Fn object
	&apos;assertEqual(isFn(List_length), 	True).x	&apos; from 0-arg call
	&apos;assertEqual(arity(List_length), 1).x
	
	&apos;assertEqual(apply(List_length,						  vNil), 	0).x
	&apos;assertEqual(apply(List_length,			 cons(0, vNil)), 	1).x
	&apos;assertEqual(apply(List_length,	cons(0, cons(0, vNil))), 2).x

	
	&apos;--- with List_length and List_nth, 
	&apos;    check dataCtors fields of data type ctors so far (TType later)
	Dim dataCtors
	dataCtors = field(DataTypeCtor_dataCtors,         tcDataTypeCtor)
	assertEqual(List_length(dataCtors), 1).x
	assert_same(List_nth(0, dataCtors), cDataTypeCtor).x
	
	dataCtors = field(DataTypeCtor_dataCtors,         tcDataCtor)
	assertEqual(List_length(dataCtors), 1).x
	assert_same(List_nth(0, dataCtors), cDataCtor).x
	
	dataCtors = field(DataTypeCtor_dataCtors,         tcList)
	assertEqual(List_length(dataCtors), 2).x
	assert_same(List_nth(0, dataCtors), cNil).x
	assert_same(List_nth(1, dataCtors), cCons).x
	
	
	&apos;--- data ctors of TType

	dataCtors = field(DataTypeCtor_dataCtors, tcType)
	assertEqual(List_length(dataCtors), 2).x
	Dim cParam	: cParam = Tp.TType_Param
	Dim cApp	: cApp	 = Tp.TType_App
	assert_same(List_nth(0, dataCtors), cApp).x
	assert_same(List_nth(1, dataCtors), cParam).x
	
	assert_hasTypeCtor(cParam, 	tcType).x
	assert_hasTypeCtor(cApp, 	tcType).x

	&apos;--- native types
	Dim nStr : nStr = Tp.Native_String
	Dim nInt : nInt = Tp.Native_Integer
	
	refute_same(nStr, nInt).x

	&apos;--- fix argument order for DataTypeCtor
	Dim argTypes, at
	argTypes = field(DataCtor_argTypes, cDataTypeCtor)
	assertEqual(List_length(argTypes), 3).x
	
	assert_same(List_nth(DataTypeCtor_name,			argTypes), nStr).x
	assert_same(List_nth(DataTypeCtor_arity, 		argTypes), nInt).x
	&apos; third argType should be (App TList TDataCtor) - later

	
	&apos;--- TType data ctor: Param (Ntv Int)
	assertEqual(isDataValue(cParam), True		).x
	assertEqual( fieldCount(cParam), 3			).x
	assert_hasTypeCtor(     cParam,  tcType		).x
	assert_hasCtor(			cParam,  cDataCtor	).x
	assertEqual(field(DataCtor_name,     cParam),  &quot;Param&quot;).x
	argTypes =  field(DataCtor_argTypes, cParam)
	assertEqual(List_length(argTypes), 1).x
	assert_same(List_nth(0, argTypes), nInt).x

	&apos;--- apply data ctor Param
	Dim vParam As Variant
	vParam = TypeParam(42)
	assertEqual(isDataValue(vParam),	True	).x
	assertEqual( fieldCount(vParam),	1		).x
	assert_hasCtor(         vParam,		cParam	).x
	assertEqual(field(0,	vParam),	42).x

	&apos;--- TType data ctor: App Type Type
	assertEqual(isDataValue(cApp), True		).x
	assertEqual( fieldCount(cApp), 3			).x
	assert_hasTypeCtor(     cApp,  tcType		).x
	assert_hasCtor(			cApp,  cDataCtor	).x
	assertEqual(field(DataCtor_name,     cApp),  &quot;App&quot;).x
	argTypes =  field(DataCtor_argTypes, cApp)
	assertEqual(List_length(argTypes), 2).x
	assert_same(List_nth(1, argTypes), tcType).x
	&apos; TODO: really only TDataTypeCtor? - it means only 1 type param ever!
	assert_same(List_nth(0, argTypes), tcType).x

	&apos;--- apply data ctor App
	Dim vApp As Variant
	vApp = TypeApp(tcList, nInt)
	assertEqual(isDataValue(vApp),	True	).x
	assertEqual( fieldCount(vApp),	2		).x
	assert_hasCtor(         vApp,	cApp	).x	

	assert_same(field(0,	vApp),	tcList).x
	assert_same(field(1,	vApp),	nInt).x
	
	&apos; TODO: make convenience fn TypeApp return a TFn on 0 args
	&apos;assertThrows(TypeApp, Array(vInt, tcList))
	
	
	&apos;--- apply data ctor DataTypeCtor
	Dim tcUnit

End Function

Function test_Type_hasType
	assertEqual(hasType(DataTypeCtor,	TDataCtor), 	True).x
	assertEqual(hasType(DataCtor,		TDataCtor), 	True).x
	assertEqual(hasType(TDataCtor,		TDataTypeCtor), True).x
	assertEqual(hasType(TDataTypeCtor,	TDataTypeCtor), True).x
	assertEqual(hasType(TType, 			TDataTypeCtor), True).x
	assertEqual(hasType(TList, 			TDataTypeCtor), True).x
	
	assertEqual(hasType(DataCtor,		TDataTypeCtor), False).x
	assertEqual(hasType(DataTypeCtor,	TDataTypeCtor), False).x

	assertThrows(hasType, Array(TDataCtor, DataCtor)).x
	
	assertEqual(hasType(nil,			TList),		True).x
	assertEqual(hasType(List(1),		TList),		True).x
	assertEqual(hasType(Tp.List_Cons,	TList),		False).x
	assertEqual(hasType(Tp.List_Cons,	TDataCtor),	True).x
		
	assertEqual(hasType(TString,						TType), True).x
	assertEqual(hasType(TInteger,						TType), True).x
	assertEqual(hasType(TypeParam(0),					TType), True).x
	assertEqual(hasType(TypeApp(TList, TypeParam(0)),	TType), True).x

	&apos; NYI
	&apos;assertEqual(hasType(3, TypeParam(0)), True).x
	&apos; NYI
	&apos;assertEqual(hasType(3, TypeApp(TList TString)), True).x
	
	assertEqual(hasType(&quot;&quot;,				TString),	 True).x
	assertEqual(hasType(&quot;a&quot;,			TString),	 True).x
	assertEqual(hasType(&quot;foobar&quot;,		TString),	 True).x
	assertEqual(hasType(Nothing,		TString),	False).x
	assertEqual(hasType(Empty,			TString),	False).x
	assertEqual(hasType(True,			TString),	False).x
	assertEqual(hasType(False,			TString),	False).x
	assertEqual(hasType(0,				TString),	False).x
	assertEqual(hasType(1,				TString),	False).x
	assertEqual(hasType(3.14,			TString),	False).x
	assertEqual(hasType(Array(),		TString),	False).x
	assertEqual(hasType(Array(42),		TString),	False).x
	assertEqual(hasType(Array(42),		TString),	False).x
	assertEqual(hasType(TList,			TString),	False).x
	assertEqual(hasType(Tp.List_Nil,	TString),	False).x
	assertEqual(hasType(Tp.List_Cons,	TString),	False).x
	assertEqual(hasType(nil,			TString),	False).x
	assertEqual(hasType(List(),			TString),	False).x
	assertEqual(hasType(List(1),		TString),	False).x
	assertEqual(hasType(List(1, 2),		TString),	False).x

	assertEqual(hasType(&quot;&quot;,				TInteger),	False).x
	assertEqual(hasType(&quot;a&quot;,			TInteger),	False).x
	assertEqual(hasType(&quot;foobar&quot;,		TInteger),	False).x
	assertEqual(hasType(Nothing,		TInteger),	False).x
	assertEqual(hasType(Empty,			TInteger),	False).x
	assertEqual(hasType(True,			TInteger),	False).x
	assertEqual(hasType(False,			TInteger),	False).x
	assertEqual(hasType( 0,				TInteger),	 True).x
	assertEqual(hasType( 1,				TInteger),	 True).x
	assertEqual(hasType(-1,				TInteger),	 True).x
	assertEqual(hasType( 32766,			TInteger),	 True).x &apos;0x7FFE
	assertEqual(hasType( 32767,			TInteger),	 True).x &apos;0x7FFF
	assertEqual(hasType( 32768,			TInteger),	False).x &apos;0x8000 (!)
	assertEqual(hasType( 65534,			TInteger),	False).x &apos;0xFFFE
	assertEqual(hasType( 65535,			TInteger),	False).x &apos;0xFFFF
	assertEqual(hasType( 65536,			TInteger),	False).x &apos;0x80000
	assertEqual(hasType(-32766,			TInteger),	 True).x &apos;0x8002
	assertEqual(hasType(-32767,			TInteger),	 True).x &apos;0x8001
	assertEqual(hasType(-32768,			TInteger),	 True).x &apos;0x8000
	assertEqual(hasType(-32769,			TInteger),	False).x &apos;0x17FFF (!)
	assertEqual(hasType(-65534,			TInteger),	False).x &apos;0xFFFE
	assertEqual(hasType(-65535,			TInteger),	False).x &apos;0xFFFF
	assertEqual(hasType(-65536,			TInteger),	False).x &apos;0x80000
	assertEqual(hasType(3.14,			TInteger),	False).x
	assertEqual(hasType(Array(),		TInteger),	False).x
	assertEqual(hasType(Array(42),		TInteger),	False).x
	assertEqual(hasType(Array(42),		TInteger),	False).x
	assertEqual(hasType(TList,			TInteger),	False).x
	assertEqual(hasType(Tp.List_Nil,	TInteger),	False).x
	assertEqual(hasType(Tp.List_Cons,	TInteger),	False).x
	assertEqual(hasType(nil,			TInteger),	False).x
	assertEqual(hasType(List(),			TInteger),	False).x
	assertEqual(hasType(List(1),		TInteger),	False).x
	assertEqual(hasType(List(1, 2),		TInteger),	False).x

	&apos; depending on isSubtypeOf
	
	&apos;assertEqual(hasType(TDataCtor,		TType), True).x
	&apos;assertEqual(hasType(TDataTypeCtor,	TType), True).x
	&apos;assertEqual(hasType(TList,			TType), True).x
	&apos;assertEqual(hasType(TType,			TType), True).x

	&apos;assertEqual(isSubTypeOf(TDataCtor,		TType), False).x
	&apos;assertEqual(isSubTypeOf(TDataTypeCtor,	TType), True).x
	&apos;assertEqual(isSubTypeOf(TList,			TType), False).x
	&apos;assertEqual(isSubTypeOf(TString,		TType), True).x
	&apos;assertEqual(isSubTypeOf(TInteger,		TType), True).x

	assertEqual(hasType(DataCtor,				TType), False).x
	&apos;assertEqual(hasType(DataTypeCtor,			TType), False).x
	
	assertEqual(hasType(TList,			TType),	False).x
	assertEqual(hasType(Tp.List_Nil,	TType),	False).x
	assertEqual(hasType(Tp.List_Cons,	TType),	False).x
	assertEqual(hasType(nil,			TType),	False).x
	assertEqual(hasType(List(),			TType),	False).x
	assertEqual(hasType(List(1),		TType),	False).x
	assertEqual(hasType(List(1, 2),		TType),	False).x
	
End Function

Function test_Type_dot_str()
	assertEqual(TDataTypeCtor.str,	&quot;TDataTypeCtor&quot;).x
	assertEqual(TDataCtor.str,		&quot;TDataCtor&quot;).x
	assertEqual(TType.str, 			&quot;Type&quot;).x
	assertEqual(TList.str,			&quot;List&quot;).x


	&apos;assertEqual(DataTypeCtor.str,	&quot;TDataTypeCtor.DataTypeCtor&quot;).x
	assertEqual(DataTypeCtor.str,	&quot;DataTypeCtor :: Str -&gt; Int -&gt; (List TDataCtor) -&gt; TDataTypeCtor&quot;).x
	
	&apos;assertEqual(DataCtor.str,		&quot;TDataCtor.DataCtor&quot;).x
	assertEqual(DataCtor.str,		&quot;DataCtor :: Str -&gt; (List Type) -&gt; TDataTypeCtor -&gt; TDataCtor&quot;).x
	
	Dim vNil, cNil, cCons
	vNil = nil
	cNil = ctorOf(vNil)
	cCons = Tp.List_Cons
	assertEqual(vNil.str,		&quot;[]&quot;).x
	&apos;assertEqual(cNil.str,		&quot;List.Nil&quot;).x
	assertEqual(cNil.str,		&quot;Nil :: List a0&quot;).x
	&apos;assertEqualcCons.str,	&quot;List.Cons&quot;).x
	assertEqual(cCons.str,	&quot;Cons :: a0 -&gt; (List a0) -&gt; (List a0)&quot;).x
	
	Dim vStr, vInt
	Dim cStr, cInt
	vStr = TString  : cStr = ctorOf(vStr)
	vInt = TInteger : cInt = ctorOf(vInt)
	assertEqual(vStr.str,	&quot;Str&quot;).x
	assertEqual(vInt.str,	&quot;Int&quot;).x
	assertEqual(cStr.str,	&quot;Type.String&quot;).x
	assertEqual(cInt.str,	&quot;Type.Integer&quot;).x
	
	assertEqual(TypeParam.str,		&quot;Type.TypeParam&quot;).x
	assertEqual(TypeParam(0).str,	&quot;a0&quot;).x
	assertEqual(TypeParam(1).str,	&quot;a1&quot;).x
	assertEqual(TypeParam(2).str,	&quot;a2&quot;).x
	
	assertEqual(TypeApp.str,						&quot;Type.TypeApp&quot;).x
	assertEqual(TypeApp(TList, TypeParam(0)).str,	&quot;List a0&quot;).x
	assertEqual(TypeApp(TList, TString).str,		&quot;List Str&quot;).x
	assertEqual(TypeApp(TList, TInteger).str,		&quot;List Int&quot;).x
	assertEqual(TypeApp(TList, TType).str,			&quot;List Type&quot;).x

	Dim t : t = TypeApp(TList, TypeApp(TList, TString))
	assertEqual(t.str,	&quot;List (List Str)&quot;).x
	
End Function

Function test_Type_applyDC()
	Dim a, c

	c = Tp.TType_Param
	a = applyDC(c, 0)
	assert_hasCtor(a, c).x
	
	a = applyDC(c)
	assertEqual(isFn(a), True).x
	
	a = apply(applyDC(c), 0)
	assert_hasCtor(a, c).x
	
	c = Tp.TType_App
	a = applyDC(c, TList)
	assertEqual(isFn(a), True).x
	a = apply(a, TypeParam(0))
	assert_hasCtor(a, c).x
	
	c = Tp.List_Cons
	a = applyDC(c, 42)
	assertEqual(isFn(a), True).x
	a = apply(a, nil)
	assert_hasCtor(a, c).x
	assertEqual(TList_equ(c, List(42)), True).x
	
	a = applyDC(c, 42, nil)
	assert_hasCtor(a, c).x
	assertEqual(TList_equ(c, List(42)), True).x
		
	a = applyDC(c)
	assertEqual(isFn(a), True).x
	a = apply(a, 4711)
	assertEqual(isFn(a), True).x
	a = apply(a, nil)
	assert_hasCtor(a, c).x
	assertEqual(TList_equ(a, List(4711)), True).x
	
	
	Dim tc, cFoo, cBar
	tc = applyDC(DataTypeCtor, &quot;TFoo&quot;, 0, nil)
	cFoo = mkDataCtor(tc, &quot;Foo&quot;, emptyArray)
	cBar = mkDataCtor(tc, &quot;Bar&quot;, emptyArray)
	&apos;show(cBar.str, DataValue_toString(cBar))
	a = applyDC(cFoo)
	&apos;show(a.str, DataValue_toString(a))
	
	assert_same(applyDC(cFoo), a).x
	refute_same(applyDC(cBar), a).x
	a = applyDC(cBar)
	assert_same(applyDC(cBar), a).x
	
End Function

&apos; ##############################################


Function asdf
	&apos; But before we go on to make one, let&apos;s make things a bit more 
	&apos; interesting. Why not give him a brother:
	Dim cBar As DataValue
	cBar = _mkValueFrom_lax(cDataCtor, Array( _
		&quot;Bar&quot;, _
		emptyArray, _
		Nothing _
	)
	&apos; Bar just looks like his twin Foo, only the names are different.
	&apos; Of course they have the same &quot;parent&quot;:
	Dim tcFooOrBar As DataValue
	tcFooOrBar = _mkValueFrom_lax(cDataTypeCtor, Array( _
		&quot;FooOrBar&quot;, _
		0, _
		Array(cFoo, cBar) _
	)
	_setTypeCtor(cFoo, tcFooOrBar)
	_setTypeCtor(cBar, tcFooOrBar)
	&apos; FooOrBar = Foo | Bar
	&apos; We can now make values of type FooOrBar
	Dim y, z
	x = _mkValueFrom_lax(cFoo, Array())
	y = _mkValueFrom_lax(cBar, Array())
	z = _mkValueFrom_lax(cFoo, Array())
	&apos; the function istypeOf takes a type and a value, and tests
	&apos; whether the value has the given type:
	assertEqual(istypeOf(tcFooOrBar, x), True).x
	assertEqual(istypeOf(tcFooOrBar, y), True).x
	assertEqual(istypeOf(tcFooOrBar, z), True).x
	&apos; But of course, FooOrBar itself is NOT a FooOrBar
	assertEqual(istypeOf(tcFooOrBar, tcFooOrBar), False).x
	&apos; Rather it is a TDataTypeCtor
	assertEqual(istypeOf(tcDataTypeCtor, tcFooOrBar), True).x
	&apos; Similarly, neither cFoo nor cBar are FooBar s:
	assertEqual(istypeOf(tcFooOrBar, cFoo), False).x
	assertEqual(istypeOf(tcFooOrBar, cBar), False).x
	&apos; They&apos;re data constructors:
	assertEqual(istypeOf(tcDataCtor, cFoo), True).x
	assertEqual(istypeOf(tcDataCtor, cBar), True).x
	
	&apos; We can also dispatch on the values&apos; ctors (names).
	&apos; Since extracting the ctor&apos;s name will be common, we&apos;ll
	&apos; extract that into another helper function:
	assertEqual(ctorName(x), field(DataCtor_name, cFoo)).x
	assertEqual(ctorName(y), field(DataCtor_name, cBar)).x
	assertEqual(ctorName(z), field(DataCtor_name, cFoo)).x
	&apos; With that in place:
	Dim what As String, i As Integer, vs As Variant
	what = &quot;&quot;
	vs = Array(x, y, z)
	For i = 0 To 2
		Select Case ctorName(vs(i))
			Case &quot;Foo&quot;: what = what &amp; &quot;aFoo &quot;
			Case &quot;Bar&quot;: what = what &amp; &quot;aBar &quot;
		End Select
	Next i
	assertEqual(what, &quot;aFoo aBar aFoo &quot;).x

		
End Function

Function test_Type_TypeCtor()
	Dim tc0, tc1
	tc0 = _newTypeCtor(&quot;TC0&quot;, 0, Array())
	assertEqual(isDataType(tc0),           False).x
	assertEqual(tc0._name, &quot;TC0&quot;).x
	assertEqual(tc0.arity, 	  0 ).x
	assertEqual(TypeCtor_equ(tc0, tc0), 	True).x
	
	tc1 = _newTypeCtor(&quot;TC1&quot;, 1, Array())
	assertEqual(tc1._name, &quot;TC1&quot;).x
	assertEqual(tc1.arity, 	  1 ).x
	assertEqual(TypeCtor_equ(tc1, tc1), 	True).x

	assertEqual(TypeCtor_equ(tc0, tc1), 	False).x
	assertEqual(TypeCtor_equ(tc1, tc0), 	False).x
	
	Dim dt0, args
	args = Array()
	dt0 = applyTC(tc0, args)
	assertEqual(isDataType(dt0), True).x
	assertEqual(LBound(dt0.typeArgs),  0).x
	assertEqual(UBound(dt0.typeArgs), -1).x
	assertEqual(TypeCtor_equ(tc0, dt0.typeCtor), True).x
	
	Redim args(0 To 1)
	assertEqual(UBound(dt0.typeArgs), -1).x

	Dim dt1
	&apos;assertThrows(Fn.applyTC, Array(tc1, Array(tc1)) ).x
	args = Array(dt0)
	dt1 = applyTC(tc1, args)
	assertEqual(LBound(dt1.typeArgs),  0).x
	assertEqual(UBound(dt1.typeArgs),  0).x
	assertEqual(TypeCtor_equ(tc1, dt1.typeCtor), True).x
	assertEqual(DataType_equ(dt1.typeArgs(0), dt0), True).x

	&apos; the typeArgs array cannot be changed via ByRef var:
	args(0) = dt1
	assertEqual(DataType_equ(dt1.typeArgs(0), dt0), True).x

	Dim dt1b
	args = Array(dt0)
	dt1b = applyTC(tc1, args)
	assertEqual(DataType_equ(dt1b, dt1), True).x
	
	args = Array(dt1) &apos; TC1 (TC1 TC0) is also a proper DataType
	dt1b = applyTC(tc1, args) &apos; but different from TC1 TC0:
	assertEqual(DataType_equ(dt1b, dt1), False).x
End Function

Function test_Type_DataCtor()
	Dim tc
	Dim c1, c2
	Dim dtUnit, dtBool, dtMaybeUnit, dtMaybeBool
	
	&apos; no type args, only 1 zero-arg data ctor ~ Unit
	tc = _newTypeCtor(&quot;TC_Unit&quot;, 0, _
		Array( _
			&quot;_Unit&quot;, Array() _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_Unit&quot;).x
	assertEqual(c1.arity,       0).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	dtUnit = applyTC(tc, Array())
	
	&apos; no type args, 2 zero-arg data ctors ~ Bool
	tc = _newTypeCtor(&quot;TC_Bool&quot;, 0, _
		Array( _
			&quot;_False&quot;, Array(), _
			&quot;_True&quot;,  Array() _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_False&quot;).x
	assertEqual(c1.arity,        0).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	c2 = tc.dataCtors(1)
	assertEqual(c2._name, &quot;_True&quot;).x
	assertEqual(c2.arity,       0).x
	assertEqual(TypeCtor_equ(c2.typeCtor, tc), True).x
	dtBool = applyTC(tc, Array())
	
	&apos; one type args, 2 data ctors ~ Maybe
	tc = _newTypeCtor(&quot;TC_Maybe&quot;, 1, _
		Array( _
			&quot;_None&quot;, Array(), _
			&quot;_Some&quot;, Array(0) _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_None&quot;).x
	assertEqual(c1.arity,      0).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	c2 = tc.dataCtors(1)
	assertEqual(c2._name, &quot;_Some&quot;).x
	assertEqual(c2.arity,       1).x
	assertEqual(TypeCtor_equ(c2.typeCtor, tc), True).x

	&apos;show(c1.str, c2.str)

	dtMaybeUnit = applyTC(tc, Array(dtUnit))
	dtMaybeBool = applyTC(tc, Array(dtBool))
	
	&apos;show(dtMaybeUnit.str)

	&apos; dataCtors may only refer to typeVars with index &lt; typeCtor.arity:
	&apos;assertThrows(_newTypeCtor(&quot;TC_Foo&quot;, 0, Array(&quot;_Bar&quot;, Array(0)))).x
	&apos;assertThrows(_newTypeCtor(&quot;TC_Foo&quot;, 1, Array(&quot;_Bar&quot;, Array(1)))).x
		
	&apos; two type args, one 2-arg data ctors ~ Pair
	tc = _newTypeCtor(&quot;TC_Pair&quot;, 2, _
		Array( _
			&quot;_Pair&quot;, Array(0, 1) _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_Pair&quot;).x
	assertEqual(c1.arity,       2).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x

	&apos; two type args, two 1-arg data ctors ~ Either
	tc = _newTypeCtor(&quot;TC_Either&quot;, 2, _
		Array( _
			&quot;_Left&quot;,  Array(0), _
			&quot;_Right&quot;, Array(1) _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_Left&quot;).x
	assertEqual(c1.arity,       1).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	c2 = tc.dataCtors(1)
	assertEqual(c2._name, &quot;_Right&quot;).x
	assertEqual(c2.arity,       1).x
	assertEqual(TypeCtor_equ(c2.typeCtor, tc), True).x
	
	
	&apos;-- data ctors with non-var argument types:

	&apos; one type arg, 1 data ctors ~ package together something and a Bool
	tc = _newTypeCtor(&quot;TC_Foo&quot;, 1, _
		Array( _
			&quot;_Bar&quot;, Array(0, dtMaybeBool) _
		) _
	)
	c1 = tc.dataCtors(0)
	assertEqual(c1._name, &quot;_Bar&quot;).x
	assertEqual(c1.arity,      2).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	
	&apos;show(c1.str)
	
	&apos; List a b = Nil
	&apos;          | Cons a List b a

	&apos; Now for *recursive* dataTypes, such as List a
	tc = _newTypeCtor(&quot;TC_List&quot;, 1, _
		Array( _
			&quot;_Nil&quot;,  Array(), _
			&quot;_Cons&quot;, Array(0, tc), _
		) _
	)
	c1 = tc.dataCtors(0)
	c2 = tc.dataCtors(1)
	show(c2.str)
	&apos; close the loop:
	c2.argTypes(1) = tc
	show(c2.str)
	
	assertEqual(c1._name, &quot;_Nil&quot;).x
	assertEqual(c1.arity,      0).x
	assertEqual(TypeCtor_equ(c1.typeCtor, tc), True).x
	assertEqual(c2._name, &quot;_Cons&quot;).x
	assertEqual(c2.arity,       2).x
	assertEqual(TypeCtor_equ(c2.typeCtor, tc), True).x
	
	show(applyTC(tc, Array(dtBool)).str)
End Function



</script:module>