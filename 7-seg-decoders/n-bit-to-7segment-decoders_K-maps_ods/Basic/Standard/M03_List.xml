<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M03_List" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit

Type TList
	tyname As String
	len As Integer
	head As Variant
	tail As TList
End Type

Sub Main
	test_List()
End Sub


Function TList_toString(xs As TList)
&apos;	concat &quot;[&quot; (concat (foldl1 (\acc.(concat acc) Â° (concat &quot;, &quot;))) &quot;[&quot; (map toString xs)) &quot;]&quot;
	Dim result As String
	result = &quot;[&quot; &amp; Join(toArray(map(Fn.toString, xs)), &quot;, &quot;) &amp; &quot;]&quot;
	TList_toString = result
End Function

Function TList_equ(xs As TList, ys As TList) As Boolean
	Dim result As Boolean
	If xs.len &lt;&gt; ys.len Then
		result = False
	ElseIf (isNil(xs) And isNil(ys)) Then
		result = True
	Else
		On Local Error Goto IncompatibleCars
		If equ(car(xs), car(ys)) Then
			result = TList_equ(cdr(xs), cdr(ys))
			TList_equ = result
			Exit Function
		End If
IncompatibleCars:
		result = False	
	End If
	TList_equ = result
End Function

Function nil() As TList
	Static result As Object
	If isNull(result) Then
		Set result = New TList
		result.tyname = &quot;TList&quot;
	End If
	nil = result
End Function

Function isList(Optional x As Variant)
	If isMissing(x) Then
		isList = Fn.isList
	Else
		isList = (typeOf(x) = typeOf(nil))
	End If
End Function

Function isNil(Optional xs As TList)
	If isMissing(xs) Then : isNil = Fn.isNil : Else
		isNil = (xs.len = 0)
	End If
End Function

Function length(Optional xs As TList)
	If isMissing(xs) Then : length = Fn.length : Else
		length = xs.len
	End If
End Function

Function cons(Optional x, Optional xs As TList)
	If isMissing(xs) Then : cons = _apply(Fn.cons, x) : Else
		Dim result As New TList
		result.tyname = nil.tyname
		result.head = x
		result.tail = xs
		result.len = xs.len + 1&apos; do not dot-access xs directly!
		cons = result
	End If
End Function

Function car(Optional xs As TList) As Variant
	If isMissing(xs) Then : car = Fn.car : Exit Function : End If
	If isNil(xs) Then
		croak(&quot;car: nil&quot;)
	Else
		car = xs.head
	End If
End Function

Function cdr(Optional xs As TList) As TList
	If isMissing(xs) Then : cdr = Fn.cdr : Exit Function : End If
	If isNil(xs) Then
		croak(&quot;cdr: nil&quot;)
	Else
		cdr = xs.tail
	End If
End Function

Function cadr(xs As TList)
	cadr = car(cdr(xs))
End Function

Function caddr(xs As TList)
	caddr = cadr(cdr(xs))
End Function

Function map(Optional f As Variant, Optional xs As Object)
	Dim result As Variant
	If isMissing(f) Then
		result = Fn.map
	ElseIf isMissing(xs) Then
		result = apply(Fn.map, f)
	Else
		If isArray(xs) Then
			result = toArray(map(f, toList(xs)))
		ElseIf isNil(xs) Then
			result = nil
		Else
			result = cons(apply(f, xs.head), map(f, xs.tail))
		End If
	End If
	map = result
End Function

Function filter(fn As Variant, ByVal xs As TList)
	Dim result As TList
	If IsArray(xs) Then
		result = filter(fn, toList(xs))
	Else
		Dim x As Variant
		result = nil
		While Not(isNil(xs))
			x = car(xs)
			If (apply(fn, x)) Then
				result = cons(x, result)
			End If
			xs = cdr(xs)
		Wend
	End If
	filter = result
End Function

Function foldl(Optional f As Object, Optional acc, Optional ByVal xs As TList)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.foldl : End If
	If isMissing(xs) Then
		If isMissing(acc) Then
			If isMissing(f) Then
				foldl = oFn
			Else
				foldl = apply(oFn, f)
			End If
		Else
			foldl = apply(oFn, f, acc)
		End If
	Else
		If IsArray(xs) Then
			foldl = foldl(f, acc, toList(xs))
		Else
			Dim result As Variant
			result = acc
			While Not(isNil(xs))
				result = apply(f, result, car(xs))
				xs = cdr(xs)
			Wend
			foldl = result
		End If
	End If
End Function

Function foldl1(Optional f As Object, Optional xs As TList)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.foldl1 : End If
	If isMissing(f) Then
		foldl1 = oFn
	ElseIf isMissing(xs) Then
		foldl1 = apply(oFn, f)
	Else
		If isNil(xs) Then
			croak(&quot;foldl1 on nil&quot;)
		End If
		foldl1 = foldl(f, car(xs), cdr(xs))
	End If
End Function

Function foldr(Optional f As Object, Optional acc As Variant, Optional xs As TList)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.foldr : End If
	If isMissing(xs) Then
		If isMissing(acc) Then
			If isMissing(f) Then
				foldr = oFn
			Else
				foldr = apply(oFn, f)
			End If
		Else
			foldr = apply(oFn, f, acc)
		End If
	Else
		Dim result As Variant
		If IsNil(xs) Then
			result = acc
		ElseIf IsArray(xs) Then
			result = foldr(f, acc, toList(xs))
		Else
			result = apply(f, car(xs), foldr(f, acc, cdr(xs)))
		End If
		foldr = result
	End If
End Function

&apos; Cannot name this function &quot;append&quot;, seems to be a BASIC keyword(?)
Function adjoin(Optional xs As TList, Optional ys As TList)
	Static oFn As Object : If isNull(oFn) Then : oFn = Fn.adjoin : End If
	If isMissing(ys) Then 
		If isMissing(xs) Then
			adjoin = oFn
		Else
			adjoin = apply(oFn, xs)
		End If
	Else
		adjoin = foldr(cons, ys, xs)
	End If
End Function

&apos; Normally this is called &quot;concat&quot; but we already have that for Strings
Function flatten(Optional xs As TList)
	If isMissing(xs) Then
		flatten = foldl(adjoin, nil)
	Else
		flatten = foldl(adjoin, nil, xs)
	End If
End Function

Function reverse(Optional xs As TList)
	If isMissing(xs) Then : reverse = Fn.reverse : Exit Function : End If
	Dim result As Object
	If xs.len &lt;= 1 Then
		result = xs
	Else
		&apos;result = foldl(swap(cons), nil, xs)
		Dim ts As Object
		ts = xs
		result = nil
		While (ts.len &gt; 0)
			result = cons(ts.head, result)
			ts = ts.tail
		Wend
	End If
	reverse = result
End Function

Function toArray(xs As TList)
	If isNil(xs) Then
		toArray = Array()
	Else
		Dim result(0 To xs.len - 1)
		Dim t As TList
		Set t = xs
		Dim i As Integer
		For i = 0 To xs.len - 1
			result(i) = t.head
			Set t = t.tail
		Next i
		toArray = result
	End If
End Function

Function List(Optional a0, Optional a1, Optional a2, Optional a3, Optional a4, Optional a5, Optional a6, Optional a7, Optional a8, Optional a9, Optional a10)
	If Not(IsMissing(a10)) Then
		croak(&quot;List(...): cannot handle more than 10 args&quot;)
	End If
	Dim result As TList
	If isMissing(a0) Then
		result = nil
	Else
		result = cons(a0, List(a1, a2, a3, a4, a5, a6, a7, a8, a9))
	End If
	List = result
End Function

Function toList(a As Array)
	Dim result As TList
	Set result = nil
	Dim i As Integer, k As Integer
	Select Case getDim(a)
		Case 1
			For i = UBound(a) To LBound(a) Step -1
				result = cons(a(i), result)
			Next i
		Case 2
			For i = UBound(a, 1) To LBound(a, 1) Step -1
				Dim inner As TList
				Set inner = nil
				For k = UBound(a, 2) To LBound(a, 2) Step -1
					inner = cons(a(i, k), inner)
				Next k
				result = cons(inner, result)
			Next i
		Case Else
			croak(&quot;cannot handle &quot; &amp; getDim(a) &amp; &quot;-dimensional arrays&quot;)
	End Select
	toList = result
End Function
				
&apos;= tests ============================================================

Function test_List()
	test_List_isList()
	test_List_isNil_and_cons()
	test_List_length()
	test_List_fnApp()
	test_List_typeOfAndToString()
	test_List_List()
	test_List_car()
	test_List_cdr()
	test_List_map()
	test_List_filter()
	test_List_foldl()
	test_List_foldl1()
	test_List_foldr()
	test_List_adjoin()
	test_List_flatten()
	test_List_reverse()
	test_List_equ()
End Function

Function test_List_isList()
	assertEqual(isList(Empty), 			False).x
	assertEqual(isList(Nothing), 		False).x
	assertEqual(isList(False),			False).x
	assertEqual(isList(True),			False).x
	assertEqual(isList(&quot;&quot;), 			False).x
	assertEqual(isList(&quot;foobar&quot;), 		False).x
	assertEqual(isList(0),				False).x
	assertEqual(isList(1),				False).x
	assertEqual(isList(-1),				False).x
	assertEqual(isList(3.1415),			False).x
	assertEqual(isList(Array()),		False).x
	assertEqual(isList(Array(1)),		False).x
	assertEqual(isList(Array(1, &quot;x&quot;)),	False).x
	assertEqual(isList(Fn.id),			False).x

	assertEqual(isList(nil),			True).x
	assertEqual(isList(cons(nil, nil)),	True).x
End Function

Function test_List_isNil_and_cons()
	assertEqual(isNil(nil), True).x
&apos;	assertThrows(isNil, Array()).x		&apos; assertThrows can&apos;t test call with 0 args
	assertThrows(isNil, Array(Empty)).x
	assertThrows(isNil, Array(Nothing)).x

	assertEqual(isNil(cons(nil, nil)), False).x
	assertEqual(isNil(cons(0, nil)), False).x
	assertEqual(isNil(cons(&quot;&quot;, nil)), False).x
	
	assertEqual(isFn(Fn.isNil), True).x	&apos; from Fn object
	assertEqual(isFn(isNil), 	True).x	&apos; from 0-arg call
	assertEqual(arity(isNil),	1).x

	assertEqual(isFn(Fn.cons),	True).x	&apos; from Fn object
	assertEqual(isFn(cons),		True).x	&apos; from 0-arg call
	assertEqual(arity(cons),	2).x

	assertEqual(apply(isNil, nil), True).x
		
	&apos;assertEqual(toString(isNil(Empty)), &quot;[&apos;isNil&apos;, True, 1]&quot;).x
	&apos;assertEqual(apply(isNil, Nothing), True).x
End Function

Function test_List_length()
	assertEqual(length(					nil), 	0).x
	assertEqual(length(			cons(0, nil)), 	1).x
	assertEqual(length(cons(0, 	cons(0, nil))), 2).x

	assertEqual(isFn(Fn.length), 	True).x	&apos; from Fn object
	assertEqual(isFn(length), 		True).x	&apos; from 0-arg call
	assertEqual(arity(length), 		   1).x
	
	assertEqual(apply(length,						nil), 	0).x
	assertEqual(apply(length,				cons(0, nil)), 	1).x
	assertEqual(apply(length,	cons(0, 	cons(0, nil))), 2).x
End Function

Function test_List_fnApp()
	assertEqual(arityF(&quot;TList_toString&quot;), 1).x

End Function

Function test_List_typeOfAndToString()
	assertEqual(typeOf(nil), &quot;Object/TList&quot;).x
	assertEqual(toString(nil), &quot;[]&quot;).x
	
	Dim lst As TList
	Set lst = cons(5, nil)
	assertEqual(typeOf(lst), &quot;Object/TList&quot;).x
	assertEqual(toString(lst), &quot;[5]&quot;).x

	Dim a As Variant
	a = Array(7)
	assertEqual(Join(a, &quot;, &quot;), &quot;7&quot;)

	a = Array(7, 5)
	assertEqual(Join(a, &quot;, &quot;), &quot;7, 5&quot;)

	Set lst = cons(7, lst)
	assertEqual(toString(lst), &quot;[7, 5]&quot;).x
	Set lst = cons(&quot;a&quot;, lst)
	assertEqual(toString(lst), &quot;[&apos;a&apos;, 7, 5]&quot;).x
	Set lst = cons(&quot;xxx&quot;, nil)
	assertEqual(toString(lst), &quot;[&apos;xxx&apos;]&quot;).x

	Set lst = cons(nil, nil)
	assertEqual(toString(lst), &quot;[[]]&quot;).x
	Set lst = cons(&quot;b&quot;, lst)
	assertEqual(toString(lst), &quot;[&apos;b&apos;, []]&quot;).x
	Set lst = cons(cons(&quot;a&quot;, nil), lst)
	assertEqual(toString(lst), &quot;[[&apos;a&apos;], &apos;b&apos;, []]&quot;).x
End Function

Function test_List_foo(Optional a0, Optional a1)
	test_List_foo = List(a0, a1)
End Function

Function test_List_List()
	assertEqual(toString(List()), &quot;[]&quot;).x
	assertEqual(toString(List(0)), &quot;[0]&quot;).x
	assertEqual(toString(List(0, 1)), &quot;[0, 1]&quot;).x
	assertEqual(toString(List(0, 1, 2)), &quot;[0, 1, 2]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3)), &quot;[0, 1, 2, 3]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3, 4)), &quot;[0, 1, 2, 3, 4]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3, 4, 5)), &quot;[0, 1, 2, 3, 4, 5]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3, 4, 5, 6)), &quot;[0, 1, 2, 3, 4, 5, 6]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3, 4, 5, 6, 7)), &quot;[0, 1, 2, 3, 4, 5, 6, 7]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3, 4, 5, 6, 7, 8)), &quot;[0, 1, 2, 3, 4, 5, 6, 7, 8]&quot;).x
	assertEqual(toString(List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)), &quot;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&quot;).x

	&apos;&apos; assertThrows requires the function to be recognized by module &quot;List&quot;
	&apos;assertThrows(&quot;List&quot;, Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)).x
	
	assertEqual(toString(test_List_foo(5)), &quot;[5]&quot;).x
	assertEqual(toString(test_List_foo(5, 7)), &quot;[5, 7]&quot;).x
End Function

Function test_List_car()
	assertThrows(&quot;car&quot;, Array(nil)).x
	assertEqual(car(List(1   	)), 1).x
	assertEqual(car(List(2, 1	)), 2).x
	assertEqual(car(List(3, 2, 1)), 3).x

	assertEqual(isFn(Fn.car), 	True).x	&apos; from Fn object
	assertEqual(isFn(car), 		True).x	&apos; from 0-arg call
	assertEqual(arity(car), 	   1).x

	assertEqual(apply(car, List(1   	)), 1).x
	assertEqual(apply(car, List(2, 1	)), 2).x
	assertEqual(apply(car, List(3, 2, 1	)), 3).x
End Function

Function test_List_cdr()
	assertThrows(&quot;cdr&quot;, Array(nil)).x
	assertEqual(toString(cdr(List(1   	 ))), &quot;[]&quot;).x
	assertEqual(toString(cdr(List(2, 1	 ))), &quot;[1]&quot;).x
	assertEqual(toString(cdr(List(3, 2, 1))), &quot;[2, 1]&quot;).x

	assertEqual(isFn(Fn.cdr), 	True).x	&apos; from Fn object
	assertEqual(isFn(cdr), 		True).x	&apos; from 0-arg call
	assertEqual(arity(cdr), 	   1).x

	assertEqual(toString(apply(cdr, List(1   	))), &quot;[]&quot;).x
	assertEqual(toString(apply(cdr, List(2, 1	))), &quot;[1]&quot;).x
	assertEqual(toString(apply(cdr, List(3, 2, 1))), &quot;[2, 1]&quot;).x
End Function

Function test_List_map()
	assertEqual(toString(map(&quot;toString&quot;, nil)), &quot;[]&quot;).x
	assertEqual(toString(map(&quot;toString&quot;, List(1))), &quot;[&apos;1&apos;]&quot;).x
	assertEqual(toString(map(&quot;toString&quot;, List(&quot;a&quot;))), &quot;[&apos;&apos;a&apos;&apos;]&quot;).x
	assertEqual(toString(map(&quot;toString&quot;, List(&quot;a&quot;, 42))), &quot;[&apos;&apos;a&apos;&apos;, &apos;42&apos;]&quot;).x
	assertEqual(toString(map(&quot;toString&quot;, List(nil, &quot;a&quot;, 42))), &quot;[&apos;[]&apos;, &apos;&apos;a&apos;&apos;, &apos;42&apos;]&quot;).x
	
	assertEqual(arityF(&quot;map&quot;), 2).x
	assertEqual(toString(apply(&quot;map&quot;, &quot;toString&quot;, nil)), &quot;[]&quot;).x
	assertEqual(toString(apply(&quot;map&quot;, &quot;toString&quot;, List(1))), &quot;[&apos;1&apos;]&quot;).x
	assertEqual(toString(apply(&quot;map&quot;, &quot;toString&quot;, List(&quot;a&quot;))), &quot;[&apos;&apos;a&apos;&apos;]&quot;).x
	assertEqual(toString(apply(&quot;map&quot;, &quot;toString&quot;, List(&quot;a&quot;, 42))), &quot;[&apos;&apos;a&apos;&apos;, &apos;42&apos;]&quot;).x
	assertEqual(toString(apply(&quot;map&quot;, &quot;toString&quot;, List(nil, &quot;a&quot;, 42))), &quot;[&apos;[]&apos;, &apos;&apos;a&apos;&apos;, &apos;42&apos;]&quot;).x
End Function

Function test_List_filter()
	assertEqual(toString(filter(  &quot;isNil&quot;, nil  )), &quot;[]&quot;).x
	assertEqual(toString(filter(  &quot;isNil&quot;, List(nil)  )), &quot;[[]]&quot;).x
	assertEqual(toString(filter(  &quot;isNil&quot;, List(nil, nil)  )), &quot;[[], []]&quot;).x
	assertEqual(toString(filter(  &quot;isNil&quot;, List(List(1), List(1, 0), List(nil))  )), &quot;[]&quot;).x
	assertEqual(toString(filter(  &quot;isNil&quot;, List(nil, List(1), nil, List(1, 0), List(nil))  )), &quot;[[], []]&quot;).x
	Dim equ1 As Variant
	equ1 = apply(&quot;equ&quot;, 1)
	assertEqual(toString(filter(  equ1, List(0, 1, 1, 0, 1, 0)  )), &quot;[1, 1, 1]&quot;).x
	
	assertEqual(arityF(&quot;filter&quot;), 2).x
	assertEqual(toString(apply(&quot;filter&quot;,  &quot;isNil&quot;, nil  )), &quot;[]&quot;).x
	assertEqual(toString(apply(&quot;filter&quot;,  &quot;isNil&quot;, List(nil)  )), &quot;[[]]&quot;).x
	assertEqual(toString(apply(&quot;filter&quot;,  &quot;isNil&quot;, List(nil, nil)  )), &quot;[[], []]&quot;).x
	assertEqual(toString(apply(&quot;filter&quot;,  &quot;isNil&quot;, List(List(1), List(1, 0), List(nil))  )), &quot;[]&quot;).x
	assertEqual(toString(apply(&quot;filter&quot;,  &quot;isNil&quot;, List(nil, List(1), nil, List(1, 0), List(nil))  )), &quot;[[], []]&quot;).x

	assertEqual(toString(apply(&quot;filter&quot;,  equ1, List(0, 1, 1, 0, 1, 0)  )), &quot;[1, 1, 1]&quot;).x
End Function

Function test_List_foldl() &apos;TODO: check order of args as they come in
	Dim f As Object
	f = Fn.foldl
	assertEqual(isFn(f), True).x
	assertEqual(arity(f),   3).x
	
	f = foldl(concat)
	assertEqual(isFn(f), True).x
	assertEqual(arity(f),   2).x
	
	f = foldl(concat, &quot;xxx&quot;)
	assertEqual(isFn(f), True).x
	assertEqual(arity(f),   1).x
	
	assertEqual(apply(f, nil),                      &quot;xxx&quot;).x
	assertEqual(apply(f, List(&quot;a&quot;)),			 	&quot;xxxa&quot;).x
	assertEqual(apply(f, List(&quot;a&quot;, &quot;b&quot;)),		 	&quot;xxxab&quot;).x
	assertEqual(apply(f, List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)),	 	&quot;xxxabc&quot;).x
	assertEqual(apply(f, List(&quot;d&quot;, &quot;a&quot;, &quot;c&quot;, &quot;b&quot;)),	&quot;xxxdacb&quot;).x

	assertEqual(apply(foldl, add, 1, List(4, 1, 3, 2)), 11).x
End Function

Function test_List_foldl1() &apos;TODO: check order of args as they come in
	Dim f As Object
	f = Fn.foldl1
	assertEqual(isFn(f), True).x
	assertEqual(arity(f),   2).x
	
	f = foldl1(concat)
	assertEqual(isFn(f), True).x
	assertEqual(arity(f),   1).x
	assertThrows(f, Array(nil)).x
	assertEqual(apply(f, List(&quot;a&quot;)),			 	&quot;a&quot;).x
	assertEqual(apply(f, List(&quot;a&quot;, &quot;b&quot;)),		 	&quot;ab&quot;).x
	assertEqual(apply(f, List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)),	 	&quot;abc&quot;).x
	assertEqual(apply(f, List(&quot;d&quot;, &quot;a&quot;, &quot;c&quot;, &quot;b&quot;)),	&quot;dacb&quot;).x

	assertEqual(apply(foldl1, add, List(4, 1, 3, 2)), 10).x
End Function

Function test_List_foldr() &apos;TODO: check order of args as they come in
	Dim f As Object, i As Integer, a As Variant
	f = Fn.foldr
	assertEqual(isFn(f), True).x
	assertEqual(arity(f),   3).x
	
	f = foldr(concat)
	assertEqual(isFn(f), True).x
	assertEqual(arity(f),   2).x
	
	a = Array(foldr(concat, &quot;xxx&quot;), apply(Fn.foldr, concat, &quot;xxx&quot;))
	For i = LBound(a) To UBound(a)
		f = a(i)
		assertEqual(isFn(f), True).x
		assertEqual(arity(f),   1).x
		
		assertEqual(apply(f, nil),                      &quot;xxx&quot;).x
		assertEqual(apply(f, List(&quot;a&quot;)),			 	&quot;axxx&quot;).x
		assertEqual(apply(f, List(&quot;a&quot;, &quot;b&quot;)),		 	&quot;abxxx&quot;).x
		assertEqual(apply(f, List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)),	 	&quot;abcxxx&quot;).x
		assertEqual(apply(f, List(&quot;d&quot;, &quot;a&quot;, &quot;c&quot;, &quot;b&quot;)),	&quot;dacbxxx&quot;).x
	Next i
	
	assertEqual(apply(foldr, add, 1, List(4, 1, 3, 2)), 11).x
End Function

Function test_List_adjoin()
	assertEqual(toString(adjoin(nil, nil)), &quot;[]&quot;).x
	Dim lst As TList
	Set lst = cons(1, nil)
	assertEqual(toString(adjoin(lst, nil)), &quot;[1]&quot;).x
	assertEqual(toString(adjoin(nil, lst)), &quot;[1]&quot;).x

	assertEqual(toString(adjoin(lst, lst)), &quot;[1, 1]&quot;).x
	Dim lst2 As TList
	Set lst2 = cons(2, nil)
	assertEqual(toString(adjoin(lst, lst2)), &quot;[1, 2]&quot;).x
	assertEqual(toString(adjoin(lst2, lst)), &quot;[2, 1]&quot;).x
	Set lst2 = cons(3, lst2)
	assertEqual(toString(adjoin(lst, lst2)), &quot;[1, 3, 2]&quot;).x
	assertEqual(toString(adjoin(lst2, lst)), &quot;[3, 2, 1]&quot;).x
	Set lst = cons(0, lst)
	assertEqual(toString(adjoin(lst, lst2)), &quot;[0, 1, 3, 2]&quot;).x
	assertEqual(toString(adjoin(lst2, lst)), &quot;[3, 2, 0, 1]&quot;).x
End Function

Function test_List_flatten()
	assertEqual(toString(flatten(nil)), &quot;[]&quot;).x
	Dim lst As TList
	Set lst = cons(1, nil)
	assertThrows(&quot;flatten&quot;, Array(lst)).x
	Set lst = cons(lst, nil)	&apos; [[1]]
	assertEqual(toString(flatten(lst)), &quot;[1]&quot;).x
	Set lst = cons(nil, lst)	&apos; [[], [1]]
	assertEqual(toString(flatten(lst)), &quot;[1]&quot;).x
	Dim lst2 As TList
	Set lst2 = cons(&quot;a&quot;, cons(&quot;b&quot;, nil))
	Set lst = cons(lst2, lst)	&apos; [[&apos;a&apos;, &apos;b&apos;], [], [1]]
	assertEqual(toString(flatten(lst)), &quot;[&apos;a&apos;, &apos;b&apos;, 1]&quot;).x
	Set lst2 = cons(lst2, nil)
	Set lst = cons(lst2, lst)	&apos; [[[&apos;a&apos;, &apos;b&apos;]], [&apos;a&apos;, &apos;b&apos;], [], [1]]
	assertEqual(toString(flatten(lst)), &quot;[[&apos;a&apos;, &apos;b&apos;], &apos;a&apos;, &apos;b&apos;, 1]&quot;).x
End Function

Function test_List_reverse()
	assertEqual(toString(reverse(nil)), toString(nil)).x
	Dim lst As TList
	Set lst = cons(1, nil)
	assertEqual(toString(reverse(lst)), toString(lst)).x
	Set lst = cons(2, lst)
	assertEqual(toString(reverse(lst)), &quot;[1, 2]&quot;).x
	Set lst = cons(3, lst)
	assertEqual(toString(reverse(lst)), &quot;[1, 2, 3]&quot;).x
	
	assertEqual(isFn(Fn.reverse), True).x &apos; from Fn object
	assertEqual(isFn(reverse), 	  True).x &apos; from 0-arg call
End Function

Function test_List_equ()
	assertEqual(arityF(&quot;TList_equ&quot;), 2).x
	
	assertThrows(&quot;equ&quot;, Array(nil, Empty)).x	&apos; incompatible types Object/TList and Empty
	assertThrows(&quot;equ&quot;, Array(Empty, nil)).x	&apos; incompatible types Empty and Object/TList

	assertEqual(equ(nil,		Nothing),		False).x
	assertEqual(equ(Nothing,	nil),			False).x

	assertEqual(equ(nil,		nil),			True).x
	
	assertEqual(equ(List(1), 	nil),			False).x
	assertEqual(equ(nil, 		List(1)),		False).x
	
	assertEqual(equ(List(1), 	List(1)),		True).x
	assertEqual(equ(List(2), 	List(1)),		False).x
	assertEqual(equ(List(1), 	List(2)),		False).x
	
&apos;	assertEqual(equ(List(&quot;1&quot;), 	List(1)),		False).x
	assertEqual(equ(List(1, 2), List(1)),		False).x
	assertEqual(equ(List(1), 	List(1, 2)),	False).x
	assertEqual(equ(List(1, 2), List(1, 2)),	True).x
	assertEqual(equ(List(2, 2), List(1, 2)),	False).x
	assertEqual(equ(List(2, 1), List(1, 2)),	False).x

End Function

</script:module>