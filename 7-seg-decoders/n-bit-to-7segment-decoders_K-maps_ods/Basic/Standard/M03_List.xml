<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M03_List" script:language="StarBasic">REM  *****  BASIC  *****


Type TList
	tyname As String
	head As Variant
	tail As TList
	len As Integer
End Type

Sub Main
	test_List()
End Sub


Function nil()
	Static result As New TList	&apos; uninitialized instance at first
	result.tyname = &quot;TList&quot;
	nil = result
End Function

Function isNil(xs As TList)
	isNil = (xs.len = 0)
End Function

Function cons(x As Variant, xs As TList)
	Dim result As New TList
	result.tyname = xs.tyname
	result.head = x
	result.tail = xs
	result.len = xs.len + 1
	cons = result
End Function

Function snoc(xs As TList, x As Variant)
	snoc = cons(x, xs)
End Function

Function length(xs As TList)
	length = xs.len
End Function

Function car(xs As TList) As Variant
	If isNil(xs) Then
		croak(&quot;car: nil&quot;)
	Else
		car = xs.head
	End If
End Function

Function cdr(xs As TList) As TList
	If isNil(xs) Then
		croak(&quot;cdr: nil&quot;)
	Else
		cdr = xs.tail
	End If
End Function

Function toList(a As Array)
	Dim result As TList
	Set result = nil
	Dim i As Integer, k As Integer
	Select Case getDim(a)
		Case 1
			For i = UBound(a) To LBound(a) Step -1
				result = cons(a(i), result)
			Next i
		Case 2
			For i = UBound(a, 1) To LBound(a, 1) Step -1
				Dim inner As TList
				Set inner = nil
				For k = UBound(a, 2) To LBound(a, 2) Step -1
					inner = cons(a(i, k), inner)
				Next k
				result = cons(inner, result)
			Next i
		Case Else
			croak(&quot;cannot handle &quot; &amp; getDim(a) &amp; &quot;-dimensional arrays&quot;)
	End Select
	toList = result
End Function

Function map(fn As String, xs As Variant)
	Dim result As TList
	If isNil(xs) Then
		result = nil
	ElseIf isArray(xs) Then
		result = map(fn, toList(xs))
	Else
		result = cons(applyF(fn, Array(xs.head)), map(fn, xs.tail))
	End If
	map = result
End Function

Function toArray(xs As TList)
	Dim result(0 To xs.len - 1)
	Dim t As TList
	Set t = xs
	For i = 0 To xs.len - 1
		result(i) = t.head
		Set t = t.tail
	Next i
	toArray = result
End Function

Function foldl(fn As String, acc As Variant, xs As Variant)
	Dim result As Variant
	If isNil(xs) Then
		result = acc
	ElseIf IsArray(xs) Then
		result = foldl(fn, acc, toList(xs))
	Else
		result = foldl(fn, applyF(fn, Array(acc, xs.head)), xs.tail)
	End If
	foldl = result
End Function

Function foldr(fn As String, acc As Variant, xs As Variant)
	Dim result As Variant
	If IsNil(xs) Then
		result = acc
	ElseIf IsArray(xs) Then
		result = foldr(fn, acc, toList(xs))
	Else
		result = applyF(fn, Array(xs.head, foldr(fn, acc, xs.tail)))
	End If
	foldr = result
End Function

Function reverse(xs As TList)
	Dim result As TList
	If xs.len &lt;= 1 Then
		result = xs
	Else
		result = foldl(&quot;snoc&quot;, nil, xs)
	End If
	reverse = result
End Function


&apos;= tests ============================================================

Function test_List()
	test_List_fnApp()
	test_List_typeOfAndToString()
	test_List_reverse()
End Function

Function test_List_fnApp()
	assertEqual(arityF(&quot;cons&quot;), 2).x
	assertEqual(arityF(&quot;snoc&quot;), 2).x
	assertEqual(arityF(&quot;reverse&quot;), 1).x
End Function

Function test_List_typeOfAndToString()
	assertEqual(typeOf(nil), &quot;Object/TList&quot;).x
	assertEqual(toString(nil), &quot;[]&quot;).x
	
	Dim lst As TList
	Set lst = cons(5, nil)
	assertEqual(typeOf(lst), &quot;Object/TList&quot;).x
	assertEqual(toString(lst), &quot;[5]&quot;).x

	Dim a As Variant
	a = Array(7)
	assertEqual(Join(a, &quot;, &quot;), &quot;7&quot;)

	a = Array(7, 5)
	assertEqual(Join(a, &quot;, &quot;), &quot;7, 5&quot;)

	Set lst = cons(7, lst)
	assertEqual(toString(lst), &quot;[7, 5]&quot;).x
	Set lst = cons(&quot;a&quot;, lst)
	assertEqual(toString(lst), &quot;[&apos;a&apos;, 7, 5]&quot;).x
	Set lst = cons(&quot;xxx&quot;, nil)
	assertEqual(toString(lst), &quot;[&apos;xxx&apos;]&quot;).x

	Set lst = cons(nil, nil)
	assertEqual(toString(lst), &quot;[[]]&quot;).x
	Set lst = cons(&quot;b&quot;, lst)
	assertEqual(toString(lst), &quot;[&apos;b&apos;, []]&quot;).x
	Set lst = cons(cons(&quot;a&quot;, nil), lst)
	assertEqual(toString(lst), &quot;[[&apos;a&apos;], &apos;b&apos;, []]&quot;).x
End Function


Function test_List_reverse()
	assertEqual(toString(reverse(nil)), toString(nil)).x
	Dim lst As TList
	Set lst = cons(1, nil)
	assertEqual(toString(reverse(lst)), toString(lst)).x
	Set lst = cons(2, lst)
	assertEqual(toString(reverse(lst)), &quot;[1, 2]&quot;).x
	Set lst = cons(3, lst)
	assertEqual(toString(reverse(lst)), &quot;[1, 2, 3]&quot;).x
End Function

</script:module>