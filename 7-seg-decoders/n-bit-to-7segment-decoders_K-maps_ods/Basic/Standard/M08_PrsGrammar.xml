<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M08_PrsGrammar" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit

Sub Main
	[test_PrsGrammar======================================]()
End Sub

Function derivationTree_prsGrammar( _
	s As String, _
	Optional ByVal options As Integer _
)
	Dim p As Object
	Dim result As Variant, parseResult As Variant
	p = toDerivationP(pGrmGrammar, options)
	parseResult = applyP(p, s)
	If isParseFailure(parseResult) Then
		result = &quot;!ParseFailure!&quot;
	Else
		result = toString(parseResult(0))
	End If
	MsgBox(parserStats)	
	derivationTree_prsGrammar = result
End Function


Function pGrmLinebreak()
	Static result As Object
	If isNull(result) Then
		result = pChoice( _
			pSeq(Array( _
				pStr(CR), _
				pZeroOrOne2(&quot;&quot;, pStr(LF)) _
			), concat), _
			pSeq(Array( _
				pStr(LF), _
				pZeroOrOne2(&quot;&quot;, pStr(CR)) _
			), concat) _
		)
		result = fixIndirection(pInd(&quot;nl&quot;), result)
	End If
	pGrmLinebreak = result	
End Function

Function pGrmIdent()
	Static result As Object
	If isNull(result) Then
		Dim pAlpha As Object, pAlphaNumDash As Object
		
		pAlpha = foldl1(pChoice, List( _
			pStr(&quot;_&quot;), _
			pRange(&quot;A&quot;, &quot;Z&quot;), _
			pRange(&quot;a&quot;, &quot;z&quot;) _
		))
		&apos;pAlpha = fixIndirection(pInd(&quot;pAlpha&quot;), pAlpha)

		pAlphaNumDash = foldl1(pChoice, List( _
			pAlpha, _
			pStr(&quot;-&quot;), _
			pRange(&quot;0&quot;, &quot;9&quot;) _
		))
		&apos;pAlphaNumDash = fixIndirection(pInd(&quot;pAlphaNumDash&quot;), pAlphaNumDash)

		result = pSeq(Array( _
						pAlpha, _
						pMany(pAlphaNumDash), _
					), foldl(concat))
		result = fixIndirection(pInd(&quot;Ident&quot;), result)
	End If
	pGrmIdent = result
End Function

Function pGrmEscQ()
	Static result As Object
	If isNull(result) Then
		result = pSeq(Array( _
					pSkip(pStr(&quot;\&quot;)), _
					foldl1(pChoice, List( _
						pBind(pStr(&quot;r&quot;), fstArg(pReturn(CR))), _
						pBind(pStr(&quot;n&quot;), fstArg(pReturn(LF))), _
						pBind(pStr(&quot;t&quot;), fstArg(pReturn(TAB))), _
						pCClass(List(&quot;\&quot;, DQ)) _
					) ) _
				 ), id)
		result = fixIndirection(pInd(&quot;escQ&quot;), result)
	End If
	pGrmEscQ = result
End Function

Function pGrmEscC()
	Static result As Object
	If isNull(result) Then
		result = pSeq(Array( _
					pSkip(pStr(&quot;\&quot;)), _
					foldl1(pChoice, List( _
						pBind(pStr(&quot;r&quot;), fstArg(pReturn(CR))), _
						pBind(pStr(&quot;n&quot;), fstArg(pReturn(LF))), _
						pBind(pStr(&quot;t&quot;), fstArg(pReturn(TAB))), _
						pCClass(List(&quot;\&quot;, DQ, &quot;[&quot;, &quot;-&quot;, &quot;]&quot;)) _
					) ) _
				 ), id)
		result = fixIndirection(pInd(&quot;escC&quot;), result)
	End If
	pGrmEscC = result
End Function

Function pGrmGrammar()
	Static out As Object
	If isNull(out) Then
		out = pSeq(Array( _
				pSkip(pMany(pWhite)), _
				pGrmRule, _
				pSkip(pMany(pWhite)), _
				pMany( _
					pSeq(Array( _
						pSkip(pMany1(pGrmLinebreak)), _
						pGrmRule _
					), id) _
				) _
			 ), cons)
		out = fixIndirection(pInd(&quot;Grammar&quot;), out)
	End If
	pGrmGrammar = out	
End Function

Function pGrmRule()
	Static result As Object
	If isNull(result) Then
		result = pSeqL(Array( _
					pSkip(pMany(pWhite)), _
					pGrmRuleName, _
					pSkip(pMany(pWhite)), _
					pSkip(pStr(&quot;::=&quot;)), _
					pGrmAlt, _
				 ), id)
		
		result = fixIndirection(pInd(&quot;Rule&quot;), result)
	End If
	pGrmRule = result
End Function

Function pGrmRuleName()
	Static result As Object
	If isNull(result) Then
		result = pGrmIdent
		result = fixIndirection(pInd(&quot;RuleName&quot;), result)
	End If
	pGrmRuleName = result
End Function

Function pGrmAlt()
	Static result As Object
	If isNull(result) Then
		result = pSeq(Array( _
			pGrmCon, _
			pMany( _
				pSeq(Array( _
					pSkip(pZeroOrOne(pGrmLinebreak)), _
					pSkip(pMany(pWhite)), _
					pSkip(pStr(&quot;|&quot;)), _
					pGrmCon _
				), id) _
			) _
		), cons)
		result = fixIndirection(pInd(&quot;Alt&quot;), result)
	End If
	pGrmAlt = result
End Function

Function pGrmCon()
	Static result As Object
	If isNull(result) Then
		Dim pCon As Object
		pCon = pInd(&quot;Con&quot;)
		result = pMany1( _
			pSeq(Array( _
				pSkip(pMany(pWhite)), _
				pGrmAtom, _
				pSkip(pMany(pWhite)) _
			), id) _
		)
		result = fixIndirection(pCon, result)
	End If
	pGrmCon = result
End Function

Function pGrmAtom()
	Static result As Object
	If isNull(result) Then
		result = pInd(&quot;Atom&quot;)
		Dim pAtom As Object
		&apos; building up the implementation will call pGrmAtom again
		&apos; (via pGramAlt), but that&apos;s fine since we have already set
		&apos; result to the (yet uninitialized indirection).
		pAtom = foldl1(pChoice, List( _
			pSeq(Array( _
				pSkip(pStr(&quot;(&quot;)), _
				pGrmAlt, _
				pSkip(pStr(&quot;)&quot;)) _
			), id), _
			pGrmNonterminal, _
			pGrmTerminal, _
			pGrmCClass _
		))
		result = fixIndirection(result, pAtom)
	End If
	pGrmAtom = result
End Function

Function pGrmNonterminal()
	Static result As Object
	If isNull(result) Then
		result = pGrmIdent
		result = fixIndirection(pInd(&quot;Nonterminal&quot;), result)
	End If
	pGrmNonterminal = result
End Function

Function pGrmTerminal()
	Static result As Object
	If isNull(result) Then
		Dim nonEscQ As Object
		nonEscQ = pSat( _
					ite(equ(DQ), _
						fstArg(False), _
						ite(equ(&quot;\&quot;), _
							fstArg(False), _
							ite(equ(CR), _
								fstArg(False), _
								neq(LF) _
							) _
						) _
					) _
				)
		nonEscQ.str = &quot;[-&quot; &amp; DQ &amp; &quot;\r\n\t\\]&quot;
		result = pSeq(Array( _
					pSkip(pStr(DQ)), _
					pMany1( _
						pChoice( _
							pGrmEscQ, _
							nonEscQ _
						) _
					), _
					pSkip(pStr(DQ)) _
				 ), foldl1(concat))
		result = fixIndirection(pInd(&quot;Terminal&quot;), result)
	End If
	pGrmTerminal = result
End Function

Function pGrmCClass()
	Static result As Object
	If isNull(result) Then
		result = pChoice( _
			pBind(pStr(&quot;.&quot;), fstArg(pReturn(pItem))), _
			pSeq(Array( _
				pSkip(pStr(&quot;[&quot;)), _
				pChoice( _
					pGrmNCList, _
					pGrmPCList _
				), _
				pSkip(pStr(&quot;]&quot;)), _
			), id) _
		)
		result = fixIndirection(pInd(&quot;CClass&quot;), result)
	End If
	pGrmCClass = result
End Function

Function pGrmNCList()
	Static result As Object
	If isNull(result) Then
		result = pSeq(Array( _
					pSkip(pStr(&quot;-&quot;)), _
					pGrmPCList _
				), id)
		result = fixIndirection(pInd(&quot;NCList&quot;), result)
	End If
	pGrmNCList = result
End Function

Function pGrmPCList()
	Static result As Object
	If isNull(result) Then
		result = pMany1( _
					pChoice( _
						pGrmCCRange, _
						pGrmCCItem _
					) _
				)
		result = fixIndirection(pInd(&quot;PCList&quot;), result)
	End If
	pGrmPCList = result
End Function

Function pGrmCCRange()
	Static result As Object
	If isNull(result) Then
		result = pSeqL(Array( _
					pGrmCCItem, _
					pSkip(pStr(&quot;-&quot;)), _
					pGrmCCItem, _
				), id)
		result = fixIndirection(pInd(&quot;CCRange&quot;), result)
	End If
	pGrmCCRange = result
End Function

Function pGrmCCItem()
	Static result As Object
	If isNull(result) Then
		Dim nonEscC As Object, cs As Object, ds As Object
		Dim kTrue As Object, kFalse As Object
		kTrue  = fstArg(True)
		kFalse = fstArg(False)
		cs = List(CR, LF, TAB, &quot;[&quot;, &quot;-&quot;, &quot;]&quot;, &quot;\&quot;)
		ds = map(neq, cs)
		ds = cons( _
			car(ds), _
			map(ite, cdr(ds)) _
		)
		&apos;cs = cons(apply(car(cs), kTrue, kFalse), cdr(cs))
		&apos;show(cs)
		Dim f As Object, g As Object
		&apos; f = \x.[x, K False]
		f = swap(cons, List(kFalse))
		&apos; g = \x h.(applyToList h (f x)
		g = compose(swap(Fn.applyToList), f)
		nonEscC = pSat( foldl1(g, ds) )
		&apos; nonEscC = pSat ite (neq LF)
		&apos;                    (ite (neq TAB)
		&apos;                         ...
		&apos;                              (ite (neq &quot;\&quot;)
		&apos;                                   (neq CR)
		&apos;                                   (K False) )
		&apos;                         ...
		&apos;                         (K False) )
		&apos;                     (K False) )
		Dim s As String, c As String
		s = &quot;[-&quot;
		While Not(isNil(cs))
			c = toString(car(cs))
			c = Mid(c, 2, Len(c) - 2) &apos; remove surrounding quotes
			If (c = &quot;[&quot;) Or (c = &quot;-&quot;) Or (c = &quot;]&quot;) Then
				c = &quot;\&quot; &amp; c
			End If
			s = s &amp; c
			cs = cdr(cs)
		Wend
		nonEscC.str = s &amp; &quot;]&quot;
		&apos;show(nonEscC)
		result = pChoice( _
					pGrmEscC, _
					nonEscC _
				)
		result = fixIndirection(pInd(&quot;CCItem&quot;), result)
	End If
	pGrmCCItem = result
End Function


Function pGrmMult()
	Static result As Object
	If isNull(result) Then
		result = foldl1(pChoice, List( _
			pBind(pStr(&quot;*&quot;), fstArg(pReturn(pMany))), _
			pBind(pStr(&quot;+&quot;), fstArg(pReturn(pMany1))), _
			pBind(pStr(&quot;?&quot;), fstArg(pReturn(pZeroOrOne))) _
		))
	End If
	pGrmMult = result
End Function


&apos;= tests ======================================================================

Function [test_PrsGrammar======================================]()
	test_PrsGrammar_linebreak()
	test_PrsGrammar_escQ()
	test_PrsGrammar_escC()
	test_PrsGrammar_pclist()
	test_PrsGrammar_terminal()
	test_PrsGrammar_cclass()
	test_PrsGrammar_pGrmMult()

	&apos; pGrmIdent, pGrmRuleName and pGrmNonterminal are essentially the same
	test_PrsGrammar_ident(pGrmIdent)
	test_PrsGrammar_ident(pGrmRuleName) 	&apos;    RuleName ::= ident
	test_PrsGrammar_ident(pGrmNonterminal)	&apos; Nonterminal ::= ident
End Function


Function test_PrsGrammar_linebreak()
	Dim p As Object, x As Object
	p = pGrmLinebreak
	
	refute_parses(p, Array( _
		&quot;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;=&quot;, &quot;:&quot;, &quot;.&quot;, &quot;|&quot;, &quot;-&quot;, &quot;_&quot;, &quot;\&quot;, &quot;/&quot;, _
		&quot;(&quot;, &quot;)&quot;, &quot;[&quot;, &quot;]&quot;, &quot;{&quot;, &quot;}&quot;, DQ, _
		&quot; &quot;,           TAB, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, _
		&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,   &quot;q&quot;,        &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, _
		&quot;A&quot;, &quot;B&quot;, &quot;C&quot;,        &quot;R&quot;,   &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot; _
	)).x
	Dim CRLF As String,  LFCR As String
	CRLF = CR &amp; LF
	LFCR = LF &amp; CR
	
	assert_parses(p, CR,		CR, 2).x
	assert_parses(p, LF, 		LF, 2).x
	assert_parses(p, CR &amp; &quot; &quot;,	CR, 2).x
	assert_parses(p, LF &amp; &quot; &quot;,	LF, 2).x
	assert_parses(p, CR &amp; CR,	CR, 2).x &apos; consumes only one!
	assert_parses(p, LF &amp; LF,	LF, 2).x

	assert_parses(p, CRLF, 			CRLF, 3).x &apos; consumes both!
	assert_parses(p, LFCR, 			LFCR, 3).x
	assert_parses(p, CRLF &amp; &quot; &quot;,	CRLF, 3).x
	assert_parses(p, LFCR &amp; &quot; &quot;,	LFCR, 3).x
	
	assert_parses(p, CRLF &amp; CR, CRLF, 3).x &apos; consumes only first two!
	assert_parses(p, CRLF &amp; LF, CRLF, 3).x
	assert_parses(p, LFCR &amp; CR, LFCR, 3).x
	assert_parses(p, LFCR &amp; LF, LFCR, 3).x
	
	p = pMany(pGrmLinebreak)
	&apos; all the following yield exactly two strings:
	assert_parses(p, CR &amp; CR,			List(CR, CR),		3).x
	assert_parses(p, LF &amp; LF,			List(LF, LF),		3).x
	assert_parses(p, CR &amp; CRLF,			List(CR, CRLF),		4).x
	assert_parses(p, LF &amp; LFCR,			List(LF, LFCR),		4).x
	assert_parses(p, CRLF &amp; CR,			List(CRLF, CR),		4).x
	assert_parses(p, CRLF &amp; LF,			List(CRLF, LF),		4).x
	assert_parses(p, LFCR &amp; CR,			List(LFCR, CR),		4).x
	assert_parses(p, LFCR &amp; LF,			List(LFCR, LF),		4).x
	assert_parses(p, CRLF &amp; CRLF,		List(CRLF, CRLF),	5).x
	assert_parses(p, CRLF &amp; LFCR,		List(CRLF, LFCR),	5).x
	assert_parses(p, LFCR &amp; CRLF,		List(LFCR, CRLF),	5).x
	assert_parses(p, LFCR &amp; LFCR,		List(LFCR, LFCR),	5).x
	&apos; again with an additional non-CR, non-LF character suffix:
	assert_parses(p, CR &amp; CR &amp; &quot; &quot;,		List(CR, CR),		3).x
	assert_parses(p, LF &amp; LF &amp; &quot; &quot;,		List(LF, LF),		3).x
	assert_parses(p, CR &amp; CRLF &amp; &quot; &quot;,	List(CR, CRLF),		4).x
	assert_parses(p, LF &amp; LFCR &amp; &quot; &quot;,	List(LF, LFCR),		4).x
	assert_parses(p, CRLF &amp; CR &amp; &quot; &quot;,	List(CRLF, CR),		4).x
	assert_parses(p, CRLF &amp; LF &amp; &quot; &quot;,	List(CRLF, LF),		4).x
	assert_parses(p, LFCR &amp; CR &amp; &quot; &quot;,	List(LFCR, CR),		4).x
	assert_parses(p, LFCR &amp; LF &amp; &quot; &quot;,	List(LFCR, LF),		4).x
	assert_parses(p, CRLF &amp; CRLF &amp; &quot; &quot;,	List(CRLF, CRLF),	5).x
	assert_parses(p, CRLF &amp; LFCR &amp; &quot; &quot;,	List(CRLF, LFCR),	5).x
	assert_parses(p, LFCR &amp; CRLF &amp; &quot; &quot;,	List(LFCR, CRLF),	5).x
	assert_parses(p, LFCR &amp; LFCR &amp; &quot; &quot;,	List(LFCR, LFCR),	5).x
End Function

Function test_PrsGrammar_escQ()
	Dim p As Object, x As Object
	p = pGrmEscQ
		
	refute_parses(p, Array( _
		&quot;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;=&quot;, &quot;:&quot;, &quot;.&quot;, &quot;|&quot;, &quot;-&quot;, &quot;_&quot;,     &quot;/&quot;, _
		&quot;(&quot;, &quot;)&quot;, &quot;[&quot;, &quot;]&quot;, &quot;{&quot;, &quot;}&quot;, DQ, _
		&quot; &quot;, CR, LF, TAB, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, _
		&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,   &quot;q&quot;,        &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, _
		&quot;A&quot;, &quot;B&quot;, &quot;C&quot;,        &quot;R&quot;,   &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot; _
	)).x
	
	assert_parses(p, &quot;\\&quot;, 		&quot;\&quot;, 3).x
	assert_parses(p, &quot;\r&quot;, 		CR,  3).x
	assert_parses(p, &quot;\n&quot;, 		LF,  3).x
	assert_parses(p, &quot;\t&quot;, 		TAB, 3).x
	assert_parses(p, &quot;\&quot; &amp; DQ, 	DQ, 3).x
End Function

Function test_PrsGrammar_escC()
	Dim p As Object, x As Object
	p = pGrmEscC
		
	refute_parses(p, Array( _
		&quot;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;=&quot;, &quot;:&quot;, &quot;.&quot;, &quot;|&quot;, &quot;-&quot;, &quot;_&quot;,     &quot;/&quot;, _
		&quot;(&quot;, &quot;)&quot;, &quot;[&quot;, &quot;]&quot;, &quot;{&quot;, &quot;}&quot;, DQ, _
		&quot; &quot;, CR, LF, TAB, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, _
		&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,   &quot;q&quot;,        &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, _
		&quot;A&quot;, &quot;B&quot;, &quot;C&quot;,        &quot;R&quot;,   &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot; _
	)).x
	
	assert_parses(p, &quot;\\&quot;, 		&quot;\&quot;, 3).x
	assert_parses(p, &quot;\r&quot;, 		CR,  3).x
	assert_parses(p, &quot;\n&quot;, 		LF,  3).x
	assert_parses(p, &quot;\t&quot;, 		TAB, 3).x
	assert_parses(p, &quot;\&quot; &amp; DQ, 	DQ,  3).x
	assert_parses(p, &quot;\[&quot;,		&quot;[&quot;, 3).x
	assert_parses(p, &quot;\-&quot;,		&quot;-&quot;, 3).x
	assert_parses(p, &quot;\]&quot;,		&quot;]&quot;, 3).x
End Function

Function test_PrsGrammar_pclist()
	Dim p As Object, x As Object
	p = pGrmPCList
	
	assert_parses(p, &quot;\\&quot;, 		List(&quot;\&quot;), 3).x
	assert_parses(p, &quot;\r&quot;, 		List(CR),  3).x
	assert_parses(p, &quot;\n&quot;, 		List(LF),  3).x
	assert_parses(p, &quot;\t&quot;, 		List(TAB), 3).x
	assert_parses(p, &quot;\[&quot;,		List(&quot;[&quot;), 3).x
	assert_parses(p, &quot;\-&quot;,		List(&quot;-&quot;), 3).x
	assert_parses(p, &quot;\]&quot;,		List(&quot;]&quot;), 3).x	

	&apos; can escape DQ
	assert_parses(p, &quot;\&quot; &amp; DQ, 	List(DQ),  3).x
	&apos; but don&apos;t need to:
	assert_parses(p, DQ, 	List(DQ),  2).x

	assert_parses(p, &quot;\\\r&quot;, 	List(&quot;\&quot;, CR), 		 5).x
	assert_parses(p, &quot;\t\-\r&quot;, 	List(TAB, &quot;-&quot;, CR),  7).x
	assert_parses(p, &quot;\t-\r&quot;, 	List(List(TAB, CR)), 6).x

	assert_parses(p, &quot; \t&quot;, 	List(&quot; &quot;, TAB),		 4).x
	assert_parses(p, &quot;\r\n\t\[\-\]\\&quot;, _
					 List(CR, LF, TAB, &quot;[&quot;, &quot;-&quot;, &quot;]&quot;, &quot;\&quot;),	15).x
	assert_parses(p, &quot;abc.DEF&quot;, List( _
					 	&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;.&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot; _
					 ), 8).x
	assert_parses(p, &quot;a-zA-Z_&quot;, List( _
					 	List(&quot;a&quot;, &quot;z&quot;), _
					 	List(&quot;A&quot;, &quot;Z&quot;), _
					 	&quot;_&quot; _
					 ), 8).x
	assert_parses(p, &quot;a-zA-Z_0-9&quot;, List( _
					 	List(&quot;a&quot;, &quot;z&quot;), _
					 	List(&quot;A&quot;, &quot;Z&quot;), _
					 	&quot;_&quot;, _
					 	List(&quot;0&quot;, &quot;9&quot;) _
					 ), 11).x

End Function

Function _dq(s As String) : _dq = DQ &amp; s &amp; DQ : End Function

Function test_PrsGrammar_terminal()
	Dim p As Object, x As Object
	p = pGrmTerminal
	
	refute_parses(p, Array( _
		&quot;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;=&quot;, &quot;:&quot;, &quot;.&quot;, &quot;|&quot;, &quot;-&quot;, &quot;_&quot;, &quot;\&quot;, &quot;/&quot;, _
		&quot;(&quot;, &quot;)&quot;, &quot;[&quot;, &quot;]&quot;, &quot;{&quot;, &quot;}&quot;, DQ, _
		_dq(&quot;&quot;), _
		&quot; &quot;, CR, LF, TAB, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, _
		&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,   &quot;q&quot;,        &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, _
		&quot;A&quot;, &quot;B&quot;, &quot;C&quot;,        &quot;R&quot;,   &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, _
		_dq(&quot;\&quot;), _dq(&quot;\-&quot;), _dq(&quot;\[&quot;), _dq(&quot;\]&quot;), _
		_dq(CR), _dq(LF) _
	)).x
	assert_parses(p, _dq(&quot;\\&quot;),     &quot;\&quot;,   5).x
	assert_parses(p, _dq(&quot;\&quot; &amp; DQ), DQ,    5).x

	assert_parses(p, _dq(&quot;\t&quot;),		TAB,   5).x
	assert_parses(p, _dq(&quot;\r&quot;),		CR,    5).x
	assert_parses(p, _dq(&quot;\n&quot;),		LF,    5).x
	assert_parses(p, _dq(&quot;\r\n&quot;),	CR &amp; LF, 7).x
	assert_parses(p, _dq(&quot;\n\r&quot;),	LF &amp; CR, 7).x
	assert_parses(p, _dq(TAB), TAB, 4).x
		
	assert_parses(p, _dq(&quot; &quot;), &quot; &quot;, 4).x
	assert_parses(p, _dq(&quot;a&quot;), &quot;a&quot;, 4).x
	assert_parses(p, _dq(&quot;b&quot;), &quot;b&quot;, 4).x
	assert_parses(p, _dq(&quot;c&quot;), &quot;c&quot;, 4).x
	assert_parses(p, _dq(&quot;z&quot;), &quot;z&quot;, 4).x
End Function

Function test_PrsGrammar_cclass()
	Dim p As Object
	p = pGrmCClass
	
	refute_parses(p, Array( _
		&quot;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;=&quot;,    , &quot;|&quot;, &quot;-&quot;, &quot;_&quot;, &quot;\&quot;, &quot;/&quot;, _
		&quot;(&quot;, &quot;)&quot;, &quot;[&quot;, &quot;]&quot;, &quot;{&quot;, &quot;}&quot;, DQ, _
		&quot; &quot;, CR, LF, TAB, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, _
		&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,   &quot;q&quot;,        &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, _
		&quot;A&quot;, &quot;B&quot;, &quot;C&quot;,        &quot;R&quot;,   &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, _
		_dq(&quot;\&quot;), _dq(&quot;\-&quot;), _dq(&quot;\[&quot;), _dq(&quot;\]&quot;), _
		_dq(CR), _dq(LF) _
	)).x
	
	assert_parses(p, &quot;.&quot;, 		pItem, 2).x
	assert_parses(p, &quot;[.]&quot;, 	List(&quot;.&quot;), 4).x
	assert_parses(p, &quot;[\r]&quot;, 	List(CR),  5).x
	assert_parses(p, &quot;[\n]&quot;, 	List(LF),  5).x
	assert_parses(p, &quot;[\t]&quot;, 	List(TAB), 5).x
	assert_parses(p, &quot;[\[]&quot;, 	List(&quot;[&quot;), 5).x
	assert_parses(p, &quot;[\-]&quot;, 	List(&quot;-&quot;), 5).x
	assert_parses(p, &quot;[\]]&quot;, 	List(&quot;]&quot;), 5).x
	assert_parses(p, &quot;[\\]&quot;, 	List(&quot;\&quot;), 5).x

	assert_parses(p, &quot;[.\r]&quot;, 	List(&quot;.&quot;, CR), 6).x

	&apos; we may escape the double quote &quot;
	assert_parses(p, &quot;[\&quot; &amp; DQ &amp; &quot;]&quot;, 	List(DQ), 5).x
	&apos; but we don&apos;t need to:
	assert_parses(p, &quot;[&quot; &amp; DQ &amp; &quot;]&quot;, 	List(DQ), 4).x

	&apos;assert_parses(p, &quot;[-.]&quot;, 	&quot;.&quot;, 5).x
End Function

Function test_PrsGrammar_ident(p As Object)
	Dim x As Object
	refute_parses(p, Array( _
		&quot;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;=&quot;, &quot;.&quot;, &quot;|&quot;, &quot;-&quot;,      &quot;\&quot;, &quot;/&quot;, _
		&quot;(&quot;, &quot;)&quot;, &quot;[&quot;, &quot;]&quot;, &quot;{&quot;, &quot;}&quot;, DQ, _
		&quot; &quot;, CR, LF, TAB, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot; _
	)).x
	
	&apos;msgbox(toString(p))
	
	assert_parses(p, &quot;_&quot;, &quot;_&quot;, 2).x
	assert_parses(p, &quot;A&quot;, &quot;A&quot;, 2).x
	assert_parses(p, &quot;B&quot;, &quot;B&quot;, 2).x
	assert_parses(p, &quot;Z&quot;, &quot;Z&quot;, 2).x
	assert_parses(p, &quot;a&quot;, &quot;a&quot;, 2).x
	assert_parses(p, &quot;b&quot;, &quot;b&quot;, 2).x
	assert_parses(p, &quot;z&quot;, &quot;z&quot;, 2).x
	
	assert_parses(p, &quot;__&quot;, &quot;__&quot;, 3).x
	assert_parses(p, &quot;AB&quot;, &quot;AB&quot;, 3).x
	assert_parses(p, &quot;CB&quot;, &quot;CB&quot;, 3).x
	assert_parses(p, &quot;Z_&quot;, &quot;Z_&quot;, 3).x
	assert_parses(p, &quot;aB&quot;, &quot;aB&quot;, 3).x
	assert_parses(p, &quot;by&quot;, &quot;by&quot;, 3).x
	assert_parses(p, &quot;zz&quot;, &quot;zz&quot;, 3).x
	
	assert_parses(p, &quot;__0&quot;, &quot;__0&quot;, 	4).x
	assert_parses(p, &quot;A1B|&quot;, &quot;A1B&quot;, 4).x
	assert_parses(p, &quot;CBZ &quot;, &quot;CBZ&quot;, 4).x
	assert_parses(p, &quot;Z_a*&quot;, &quot;Z_a&quot;, 4).x
	assert_parses(p, &quot;aBc+&quot;, &quot;aBc&quot;, 4).x
	assert_parses(p, &quot;b23?&quot;, &quot;b23&quot;, 4).x
	assert_parses(p, &quot;zzx(&quot;, &quot;zzx&quot;, 4).x
End Function

Function test_PrsGrammar_pGrmMult()
	Dim p As Object, x As Object
	p = pGrmMult
	
	refute_parses(p, Array(&quot;&quot;, &quot;abc&quot;, &quot;.&quot;, &quot;:&quot;, &quot;=&quot;, &quot;_&quot;, &quot;(&quot;, &quot;)&quot;, &quot; &quot;, &quot;A&quot;, &quot;Z&quot;)).x
	assert_parses(p, &quot;*&quot;, pMany, 2).x
	assert_parses(p, &quot;+&quot;, pMany1, 2).x
	assert_parses(p, &quot;?&quot;, pZeroOrOne, 2).x
End Function


</script:module>