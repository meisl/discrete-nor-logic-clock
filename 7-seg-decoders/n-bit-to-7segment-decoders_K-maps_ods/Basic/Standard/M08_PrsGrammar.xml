<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="M08_PrsGrammar" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit

Sub Main
	[test_PrsGrammar======================================]
End Sub

Function derivationTree_prsGrammar( _
	s As String, _
	Optional ByVal options As Integer _
)
	Dim p As Object, result As Variant, parseResult As Variant
	p = toDerivationP(pGrmGrammar, options)
	&apos;msgbox(toString(p))
	parseResult = applyP(p, s)
	If isParseFailure(parseResult) Then
		result = &quot;!ParseFailure!&quot;
	Else
		result = toString(parseResult(0))
	End If
			
	derivationTree_prsGrammar = result
End Function


Function pGrmNewline()
	Static result As Object
	If isNull(result) Then
		result = pChoice( _
			pSeq(Array( _
				pStr(CR), _
				pZeroOrOne2(&quot;&quot;, pStr(LF)) _
			), concat), _
			pSeq(Array( _
				pStr(LF), _
				pZeroOrOne2(&quot;&quot;, pStr(CR)) _
			), concat) _
		)
		result = fixIndirection(pInd(&quot;nl&quot;), result)
	End If
	pGrmNewline = result	
End Function

Function pGrmIdent()
	Static result As Object
	If isNull(result) Then
		Dim pAlpha As Object, pAlphaNumDash As Object
		
		pAlpha = foldl1(pChoice, List( _
			pStr(&quot;_&quot;), _
			pRange(&quot;A&quot;, &quot;Z&quot;), _
			pRange(&quot;a&quot;, &quot;z&quot;) _
		))
		&apos;pAlpha = fixIndirection(pInd(&quot;pAlpha&quot;), pAlpha)

		pAlphaNumDash = foldl1(pChoice, List( _
			pAlpha, _
			pStr(&quot;-&quot;), _
			pRange(&quot;0&quot;, &quot;9&quot;) _
		))
		&apos;pAlphaNumDash = fixIndirection(pInd(&quot;pAlphaNumDash&quot;), pAlphaNumDash)

		result = pSeq(Array( _
						pAlpha, _
						pMany(pAlphaNumDash), _
					), foldl(concat))
		&apos;result = fixIndirection(pInd(&quot;Ident&quot;), result)
	End If
	pGrmIdent = result
End Function

Function pGrmEscQ()
	Static result As Object
	If isNull(result) Then
		result = pSeq(Array( _
					pSkip(pStr(&quot;\&quot;)), _
					foldl1(pChoice, List( _
						pBind(pStr(&quot;r&quot;), fstArg(pReturn(CR))), _
						pBind(pStr(&quot;n&quot;), fstArg(pReturn(LF))), _
						pBind(pStr(&quot;t&quot;), fstArg(pReturn(TAB))), _
						pStr(&quot;\&quot;), _
						pStr(DQ) _
					) ) _
				 ), id)
		
		result = pSeq(Array( _
					pSkip(pStr(&quot;\&quot;)), _
					foldl1(pChoice, List( _
						pStr(&quot;r&quot;), _
						pStr(&quot;n&quot;), _
						pStr(&quot;t&quot;), _
						pStr(&quot;\&quot;), _
						pStr(DQ) _
					) ) _
				 ), id)
		result = fixIndirection(pInd(&quot;escQ&quot;), result)
	End If
	pGrmEscQ = result
End Function

Function pGrmGrammar()
	Static result As Object
	If isNull(result) Then
		result = pSeq(Array( _
					pSkip(pMany(pWhite)), _
					pGrmRule, _
					pSkip(pMany(pWhite)), _
					pMany( _
						pSeq(Array( _
							pSkip(pMany1(pGrmNewline)), _
							pGrmRule _
						), id) _
					) _
				 ), cons)
		result = fixIndirection(pInd(&quot;Grammar&quot;), result)
	End If
	pGrmGrammar = result	
End Function

Function pGrmRule()
	Static result As Object
	If isNull(result) Then
		result = pSeqL(Array( _
					pSkip(pMany(pWhite)), _
					pGrmRuleName, _
					pSkip(pMany(pWhite)), _
					pSkip(pStr(&quot;::=&quot;)), _
					pGrmAlt, _
				 ), id)
		
		result = fixIndirection(pInd(&quot;Rule&quot;), result)
	End If
	pGrmRule = result
End Function

Function pGrmRuleName()
	Static result As Object
	If isNull(result) Then
		result = pGrmIdent
		result = fixIndirection(pInd(&quot;RuleName&quot;), result)
	End If
	pGrmRuleName = result
End Function

Function pGrmAlt()
	Static result As Object
	If isNull(result) Then
		result = pSeq(Array( _
			pGrmCon, _
			pMany( _
				pSeq(Array( _
					pSkip(pZeroOrOne(pGrmNewline)), _
					pSkip(pMany(pWhite)), _
					pSkip(pStr(&quot;|&quot;)), _
					pGrmCon _
				), id) _
			) _
		), cons)
		result = fixIndirection(pInd(&quot;Alt&quot;), result)
	End If
	pGrmAlt = result
End Function

Function pGrmCon()
	Static result As Object
	If isNull(result) Then
		Dim pCon As Object
		pCon = pInd(&quot;Con&quot;)
		result = pMany1( _
			pSeq(Array( _
				pSkip(pMany(pWhite)), _
				pGrmAtom, _
				pSkip(pMany(pWhite)) _
			), id) _
		)
		result = fixIndirection(pCon, result)
	End If
	pGrmCon = result
End Function

Function pGrmAtom()
	Static result As Object
	If isNull(result) Then
		result = pInd(&quot;Atom&quot;)
		Dim pAtom As Object
		&apos; building up the implementation will call pGrmAtom again
		&apos; (via pGramAlt), but that&apos;s fine since we have already set
		&apos; result to the (yet uninitialized indirection).
		pAtom = foldl1(pChoice, List( _
			pSeq(Array( _
				pSkip(pStr(&quot;(&quot;)), _
				pGrmAlt, _
				pSkip(pStr(&quot;)&quot;)) _
			), id), _
			pGrmNonterminal, _
			pGrmTerminal _
		))
		result = fixIndirection(result, pAtom)
	End If
	pGrmAtom = result
End Function

Function pGrmNonterminal()
	Static result As Object
	If isNull(result) Then
		result = pGrmIdent
		result = fixIndirection(pInd(&quot;Nonterminal&quot;), result)
	End If
	pGrmNonterminal = result
End Function

Function pGrmTerminal()
	Static result As Object
	If isNull(result) Then
		Dim badQ As Object
		badQ = pSat( _
					ite(equ(DQ), _
						fstArg(False), _
						ite(equ(&quot;\&quot;), _
							fstArg(False), _
							ite(equ(CR), _
								fstArg(False), _
								neq(LF) _
							) _
						) _
					) _
				)
		badQ.str = &quot;[-&quot; &amp; DQ &amp; &quot;\r\n\t\\]&quot;
		result = pSeq(Array( _
					pSkip(pStr(DQ)), _
					pBind(pMany1( _
						pChoice( _
							pGrmEscQ, _
							badQ _
						) _
					), compose(pReturn, foldl1(concat))), _
					pSkip(pStr(DQ)) _
				 ), id)
		result = fixIndirection(pInd(&quot;Terminal&quot;), result)
	End If
	pGrmTerminal = result
End Function

Function pGrmMult()
	Static result As Object
	If isNull(result) Then
		result = foldl1(pChoice, List( _
			pBind(pStr(&quot;*&quot;), fstArg(pReturn(pMany))), _
			pBind(pStr(&quot;+&quot;), fstArg(pReturn(pMany1))), _
			pBind(pStr(&quot;?&quot;), fstArg(pReturn(pZeroOrOne))) _
		))
	End If
	pGrmMult = result
End Function


&apos;= tests ======================================================================

Function [test_PrsGrammar======================================]()
	test_PrsGrammar_newline()
	test_PrsGrammar_terminal()
	test_PrsGrammar_pGrmMult()

	&apos; pGrmIdent, pGrmRuleName and pGrmNonterminal are essentially the same
	test_PrsGrammar_ident(pGrmIdent)
	test_PrsGrammar_ident(pGrmRuleName) 	&apos;    RuleName ::= ident
	test_PrsGrammar_ident(pGrmNonterminal)	&apos; Nonterminal ::= ident
End Function


Function test_PrsGrammar_newline()
	Dim p As Object, x As Object
	p = pGrmNewline
	
	refute_parses(p, Array( _
		&quot;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;=&quot;, &quot;:&quot;, &quot;.&quot;, &quot;|&quot;, &quot;-&quot;, &quot;_&quot;, &quot;\&quot;, &quot;/&quot;, _
		&quot;(&quot;, &quot;)&quot;, &quot;[&quot;, &quot;]&quot;, &quot;{&quot;, &quot;}&quot;, DQ, _
		&quot; &quot;,           TAB, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, _
		&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,   &quot;q&quot;,        &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, _
		&quot;A&quot;, &quot;B&quot;, &quot;C&quot;,        &quot;R&quot;,   &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot; _
	)).x
	Dim CRLF As String,  LFCR As String
	CRLF = CR &amp; LF
	LFCR = LF &amp; CR
	
	assert_parses(p, CR,		CR, 2).x
	assert_parses(p, LF, 		LF, 2).x
	assert_parses(p, CR &amp; &quot; &quot;,	CR, 2).x
	assert_parses(p, LF &amp; &quot; &quot;,	LF, 2).x
	assert_parses(p, CR &amp; CR,	CR, 2).x &apos; consumes only one!
	assert_parses(p, LF &amp; LF,	LF, 2).x

	assert_parses(p, CRLF, 			CRLF, 3).x &apos; consumes both!
	assert_parses(p, LFCR, 			LFCR, 3).x
	assert_parses(p, CRLF &amp; &quot; &quot;,	CRLF, 3).x
	assert_parses(p, LFCR &amp; &quot; &quot;,	LFCR, 3).x
	
	assert_parses(p, CRLF &amp; CR, CRLF, 3).x &apos; consumes only first two!
	assert_parses(p, CRLF &amp; LF, CRLF, 3).x
	assert_parses(p, LFCR &amp; CR, LFCR, 3).x
	assert_parses(p, LFCR &amp; LF, LFCR, 3).x
	
	p = pMany(p)
	&apos; all the following yield exactly two strings:
	assert_parses(p, CR &amp; CR,			List(CR, CR),		3).x
	assert_parses(p, LF &amp; LF,			List(LF, LF),		3).x
	assert_parses(p, CR &amp; CRLF,			List(CR, CRLF),		4).x
	assert_parses(p, LF &amp; LFCR,			List(LF, LFCR),		4).x
	assert_parses(p, CRLF &amp; CR,			List(CRLF, CR),		4).x
	assert_parses(p, CRLF &amp; LF,			List(CRLF, LF),		4).x
	assert_parses(p, LFCR &amp; CR,			List(LFCR, CR),		4).x
	assert_parses(p, LFCR &amp; LF,			List(LFCR, LF),		4).x
	assert_parses(p, CRLF &amp; CRLF,		List(CRLF, CRLF),	5).x
	assert_parses(p, CRLF &amp; LFCR,		List(CRLF, LFCR),	5).x
	assert_parses(p, LFCR &amp; CRLF,		List(LFCR, CRLF),	5).x
	assert_parses(p, LFCR &amp; LFCR,		List(LFCR, LFCR),	5).x
	&apos; again with an additional non-CR, non-LF character suffix:
	assert_parses(p, CR &amp; CR &amp; &quot; &quot;,		List(CR, CR),		3).x
	assert_parses(p, LF &amp; LF &amp; &quot; &quot;,		List(LF, LF),		3).x
	assert_parses(p, CR &amp; CRLF &amp; &quot; &quot;,	List(CR, CRLF),		4).x
	assert_parses(p, LF &amp; LFCR &amp; &quot; &quot;,	List(LF, LFCR),		4).x
	assert_parses(p, CRLF &amp; CR &amp; &quot; &quot;,	List(CRLF, CR),		4).x
	assert_parses(p, CRLF &amp; LF &amp; &quot; &quot;,	List(CRLF, LF),		4).x
	assert_parses(p, LFCR &amp; CR &amp; &quot; &quot;,	List(LFCR, CR),		4).x
	assert_parses(p, LFCR &amp; LF &amp; &quot; &quot;,	List(LFCR, LF),		4).x
	assert_parses(p, CRLF &amp; CRLF &amp; &quot; &quot;,	List(CRLF, CRLF),	5).x
	assert_parses(p, CRLF &amp; LFCR &amp; &quot; &quot;,	List(CRLF, LFCR),	5).x
	assert_parses(p, LFCR &amp; CRLF &amp; &quot; &quot;,	List(LFCR, CRLF),	5).x
	assert_parses(p, LFCR &amp; LFCR &amp; &quot; &quot;,	List(LFCR, LFCR),	5).x
End Function

Function _dq(s As String) : _dq = DQ &amp; s &amp; DQ : End Function

Function test_PrsGrammar_terminal()
	Dim p As Object, x As Object
	p = pGrmTerminal
	
	refute_parses(p, Array( _
		&quot;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;=&quot;, &quot;:&quot;, &quot;.&quot;, &quot;|&quot;, &quot;-&quot;, &quot;_&quot;, &quot;\&quot;, &quot;/&quot;, _
		&quot;(&quot;, &quot;)&quot;, &quot;[&quot;, &quot;]&quot;, &quot;{&quot;, &quot;}&quot;, DQ, _
		_dq(&quot;&quot;), _
		&quot; &quot;, CR, LF, TAB, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, _
		&quot;a&quot;, &quot;b&quot;, &quot;c&quot;,   &quot;q&quot;,        &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, _
		&quot;A&quot;, &quot;B&quot;, &quot;C&quot;,        &quot;R&quot;,   &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, _
		_dq(&quot;\&quot;), _dq(&quot;\-&quot;), _dq(&quot;\[&quot;), _dq(&quot;\]&quot;), _
		_dq(CR), _dq(LF) _
	)).x
	assert_parses(p, _dq(&quot;\\&quot;),     &quot;\&quot;,   5).x
	assert_parses(p, _dq(&quot;\&quot; &amp; DQ), DQ,    5).x

	&apos;assert_parses(p, _dq(&quot;\t&quot;),		TAB,   5).x
	&apos;assert_parses(p, _dq(&quot;\r&quot;),		CR,    5).x
	&apos;assert_parses(p, _dq(&quot;\n&quot;),		LF,    5).x
	&apos;assert_parses(p, _dq(&quot;\r\n&quot;),	CR &amp; LF, 7).x
	&apos;assert_parses(p, _dq(&quot;\n\r&quot;),	LF &amp; CR, 7).x
	assert_parses(p, _dq(TAB), TAB, 4).x
		
	assert_parses(p, _dq(&quot; &quot;), &quot; &quot;, 4).x
	assert_parses(p, _dq(&quot;a&quot;), &quot;a&quot;, 4).x
	assert_parses(p, _dq(&quot;b&quot;), &quot;b&quot;, 4).x
	assert_parses(p, _dq(&quot;c&quot;), &quot;c&quot;, 4).x
	assert_parses(p, _dq(&quot;z&quot;), &quot;z&quot;, 4).x

End Function

Function test_PrsGrammar_ident(p As Object)
	Dim x As Object
	refute_parses(p, Array( _
		&quot;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;=&quot;, &quot;.&quot;, &quot;|&quot;, &quot;-&quot;,      &quot;\&quot;, &quot;/&quot;, _
		&quot;(&quot;, &quot;)&quot;, &quot;[&quot;, &quot;]&quot;, &quot;{&quot;, &quot;}&quot;, DQ, _
		&quot; &quot;, CR, LF, TAB, _
		&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot; _
	)).x
	
	&apos;msgbox(toString(p))
	
	assert_parses(p, &quot;_&quot;, &quot;_&quot;, 2).x
	assert_parses(p, &quot;A&quot;, &quot;A&quot;, 2).x
	assert_parses(p, &quot;B&quot;, &quot;B&quot;, 2).x
	assert_parses(p, &quot;Z&quot;, &quot;Z&quot;, 2).x
	assert_parses(p, &quot;a&quot;, &quot;a&quot;, 2).x
	assert_parses(p, &quot;b&quot;, &quot;b&quot;, 2).x
	assert_parses(p, &quot;z&quot;, &quot;z&quot;, 2).x
	
	assert_parses(p, &quot;__&quot;, &quot;__&quot;, 3).x
	assert_parses(p, &quot;AB&quot;, &quot;AB&quot;, 3).x
	assert_parses(p, &quot;CB&quot;, &quot;CB&quot;, 3).x
	assert_parses(p, &quot;Z_&quot;, &quot;Z_&quot;, 3).x
	assert_parses(p, &quot;aB&quot;, &quot;aB&quot;, 3).x
	assert_parses(p, &quot;by&quot;, &quot;by&quot;, 3).x
	assert_parses(p, &quot;zz&quot;, &quot;zz&quot;, 3).x
	
	assert_parses(p, &quot;__0&quot;, &quot;__0&quot;, 	4).x
	assert_parses(p, &quot;A1B|&quot;, &quot;A1B&quot;, 4).x
	assert_parses(p, &quot;CBZ &quot;, &quot;CBZ&quot;, 4).x
	assert_parses(p, &quot;Z_a*&quot;, &quot;Z_a&quot;, 4).x
	assert_parses(p, &quot;aBc+&quot;, &quot;aBc&quot;, 4).x
	assert_parses(p, &quot;b23?&quot;, &quot;b23&quot;, 4).x
	assert_parses(p, &quot;zzx(&quot;, &quot;zzx&quot;, 4).x
End Function

Function test_PrsGrammar_pGrmMult()
	Dim p As Object, x As Object
	p = pGrmMult
	
	refute_parses(p, Array(&quot;&quot;, &quot;abc&quot;, &quot;.&quot;, &quot;:&quot;, &quot;=&quot;, &quot;_&quot;, &quot;(&quot;, &quot;)&quot;, &quot; &quot;, &quot;A&quot;, &quot;Z&quot;)).x
	assert_parses(p, &quot;*&quot;, pMany, 2).x
	assert_parses(p, &quot;+&quot;, pMany1, 2).x
	assert_parses(p, &quot;?&quot;, pZeroOrOne, 2).x
End Function


</script:module>